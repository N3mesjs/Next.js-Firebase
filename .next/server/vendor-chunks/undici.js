/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(ssr)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\")\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(ssr)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\")\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent\nmodule.exports.RetryAgent = RetryAgent\nmodule.exports.RetryHandler = RetryHandler\n\nmodule.exports.DecoratorHandler = DecoratorHandler\nmodule.exports.RedirectHandler = RedirectHandler\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor\nmodule.exports.interceptors = {\n  redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect.js\"),\n  retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(ssr)/./node_modules/undici/lib/interceptor/retry.js\"),\n  dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(ssr)/./node_modules/undici/lib/interceptor/dump.js\")\n}\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\nmodule.exports.util = {\n  parseHeaders: util.parseHeaders,\n  headerNameToString: util.headerNameToString\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      let path = opts.path\n      if (!opts.path.startsWith('/')) {\n        path = `/${path}`\n      }\n\n      url = new URL(util.parseOrigin(url).origin + path)\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\").fetch)\nmodule.exports.fetch = async function fetch (init, options = undefined) {\n  try {\n    return await fetchImpl(init, options)\n  } catch (err) {\n    if (err && typeof err === 'object') {\n      Error.captureStackTrace(err)\n    }\n\n    throw err\n  }\n}\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\").Headers\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\").Response\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\").Request\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData\nmodule.exports.File = globalThis.File ?? (__webpack_require__(/*! node:buffer */ \"node:buffer\").File)\nmodule.exports.FileReader = __webpack_require__(/*! ./lib/web/fileapi/filereader */ \"(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\").FileReader\n\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\")\n\nmodule.exports.setGlobalOrigin = setGlobalOrigin\nmodule.exports.getGlobalOrigin = getGlobalOrigin\n\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\")\nconst { kConstruct } = __webpack_require__(/*! ./lib/web/cache/symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\")\n\n// Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n// in an older version of Node, it doesn't have any use without fetch.\nmodule.exports.caches = new CacheStorage(kConstruct)\n\nconst { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(ssr)/./node_modules/undici/lib/web/cookies/index.js\")\n\nmodule.exports.deleteCookie = deleteCookie\nmodule.exports.getCookies = getCookies\nmodule.exports.getSetCookies = getSetCookies\nmodule.exports.setCookie = setCookie\n\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\nmodule.exports.parseMIMEType = parseMIMEType\nmodule.exports.serializeAMimeType = serializeAMimeType\n\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\")\nmodule.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\").WebSocket\nmodule.exports.CloseEvent = CloseEvent\nmodule.exports.ErrorEvent = ErrorEvent\nmodule.exports.MessageEvent = MessageEvent\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\")\n\nmodule.exports.EventSource = EventSource\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRXhCLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyx1RkFBMEI7O0FBRWhGLDRCQUE0QjtBQUM1QixpQ0FBaUM7O0FBRWpDLFFBQVEsdUNBQXVDLEVBQUUsbUJBQU8sQ0FBQywyRkFBNEI7QUFDckYsMkpBQTZFO0FBQzdFLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsMkJBQTJCOztBQUUzQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qix5QkFBeUI7O0FBRXpCLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMseUdBQW1DOztBQUVuRSwwQkFBMEIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvY2xpZW50JylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcG9vbCcpXG5jb25zdCBCYWxhbmNlZFBvb2wgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2FnZW50JylcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50JylcbmNvbnN0IEVudkh0dHBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9lbnYtaHR0cC1wcm94eS1hZ2VudCcpXG5jb25zdCBSZXRyeUFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9yZXRyeS1hZ2VudCcpXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9saWIvY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IGVycm9yc1xuY29uc3QgYXBpID0gcmVxdWlyZSgnLi9saWIvYXBpJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9saWIvY29yZS9jb25uZWN0JylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tBZ2VudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1hZ2VudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1wb29sJylcbmNvbnN0IG1vY2tFcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stZXJyb3JzJylcbmNvbnN0IFJldHJ5SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvcmV0cnktaGFuZGxlcicpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIsIHNldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vbGliL2dsb2JhbCcpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9kZWNvcmF0b3ItaGFuZGxlcicpXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXInKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0LWludGVyY2VwdG9yJylcblxuT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKVxuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Qb29sID0gUG9vbFxubW9kdWxlLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sXG5tb2R1bGUuZXhwb3J0cy5BZ2VudCA9IEFnZW50XG5tb2R1bGUuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuRW52SHR0cFByb3h5QWdlbnQgPSBFbnZIdHRwUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlBZ2VudCA9IFJldHJ5QWdlbnRcbm1vZHVsZS5leHBvcnRzLlJldHJ5SGFuZGxlciA9IFJldHJ5SGFuZGxlclxuXG5tb2R1bGUuZXhwb3J0cy5EZWNvcmF0b3JIYW5kbGVyID0gRGVjb3JhdG9ySGFuZGxlclxubW9kdWxlLmV4cG9ydHMuUmVkaXJlY3RIYW5kbGVyID0gUmVkaXJlY3RIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxubW9kdWxlLmV4cG9ydHMuaW50ZXJjZXB0b3JzID0ge1xuICByZWRpcmVjdDogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QnKSxcbiAgcmV0cnk6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JldHJ5JyksXG4gIGR1bXA6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL2R1bXAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5idWlsZENvbm5lY3RvciA9IGJ1aWxkQ29ubmVjdG9yXG5tb2R1bGUuZXhwb3J0cy5lcnJvcnMgPSBlcnJvcnNcbm1vZHVsZS5leHBvcnRzLnV0aWwgPSB7XG4gIHBhcnNlSGVhZGVyczogdXRpbC5wYXJzZUhlYWRlcnMsXG4gIGhlYWRlck5hbWVUb1N0cmluZzogdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmdcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIgKGZuKSB7XG4gIHJldHVybiAodXJsLCBvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyID0gb3B0c1xuICAgICAgb3B0cyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzLnBhdGgnKVxuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IG9wdHMucGF0aFxuICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgICB9XG5cbiAgICAgIHVybCA9IG5ldyBVUkwodXRpbC5wYXJzZU9yaWdpbih1cmwpLm9yaWdpbiArIHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyB1cmwgOiB7fVxuICAgICAgfVxuXG4gICAgICB1cmwgPSB1dGlsLnBhcnNlVVJMKHVybClcbiAgICB9XG5cbiAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzXG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgb3B0cy5hZ2VudC4gRGlkIHlvdSBtZWFuIG9wdHMuY2xpZW50PycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IChvcHRzLmJvZHkgPyAnUFVUJyA6ICdHRVQnKVxuICAgIH0sIGhhbmRsZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyXG5cbmNvbnN0IGZldGNoSW1wbCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaCcpLmZldGNoXG5tb2R1bGUuZXhwb3J0cy5mZXRjaCA9IGFzeW5jIGZ1bmN0aW9uIGZldGNoIChpbml0LCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoSW1wbChpbml0LCBvcHRpb25zKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLkhlYWRlcnMgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvaGVhZGVycycpLkhlYWRlcnNcbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL3Jlc3BvbnNlJykuUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdCcpLlJlcXVlc3Rcbm1vZHVsZS5leHBvcnRzLkZvcm1EYXRhID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2Zvcm1kYXRhJykuRm9ybURhdGFcbm1vZHVsZS5leHBvcnRzLkZpbGUgPSBnbG9iYWxUaGlzLkZpbGUgPz8gcmVxdWlyZSgnbm9kZTpidWZmZXInKS5GaWxlXG5tb2R1bGUuZXhwb3J0cy5GaWxlUmVhZGVyID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZpbGVhcGkvZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJcblxuY29uc3QgeyBzZXRHbG9iYWxPcmlnaW4sIGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2dsb2JhbCcpXG5cbm1vZHVsZS5leHBvcnRzLnNldEdsb2JhbE9yaWdpbiA9IHNldEdsb2JhbE9yaWdpblxubW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsT3JpZ2luID0gZ2V0R2xvYmFsT3JpZ2luXG5cbmNvbnN0IHsgQ2FjaGVTdG9yYWdlIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2NhY2hlL3N5bWJvbHMnKVxuXG4vLyBDYWNoZSAmIENhY2hlU3RvcmFnZSBhcmUgdGlnaHRseSBjb3VwbGVkIHdpdGggZmV0Y2guIEV2ZW4gaWYgaXQgbWF5IHJ1blxuLy8gaW4gYW4gb2xkZXIgdmVyc2lvbiBvZiBOb2RlLCBpdCBkb2Vzbid0IGhhdmUgYW55IHVzZSB3aXRob3V0IGZldGNoLlxubW9kdWxlLmV4cG9ydHMuY2FjaGVzID0gbmV3IENhY2hlU3RvcmFnZShrQ29uc3RydWN0KVxuXG5jb25zdCB7IGRlbGV0ZUNvb2tpZSwgZ2V0Q29va2llcywgZ2V0U2V0Q29va2llcywgc2V0Q29va2llIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY29va2llcycpXG5cbm1vZHVsZS5leHBvcnRzLmRlbGV0ZUNvb2tpZSA9IGRlbGV0ZUNvb2tpZVxubW9kdWxlLmV4cG9ydHMuZ2V0Q29va2llcyA9IGdldENvb2tpZXNcbm1vZHVsZS5leHBvcnRzLmdldFNldENvb2tpZXMgPSBnZXRTZXRDb29raWVzXG5tb2R1bGUuZXhwb3J0cy5zZXRDb29raWUgPSBzZXRDb29raWVcblxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9kYXRhLXVybCcpXG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlTUlNRVR5cGUgPSBwYXJzZU1JTUVUeXBlXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVBTWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGVcblxuY29uc3QgeyBDbG9zZUV2ZW50LCBFcnJvckV2ZW50LCBNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvZXZlbnRzJylcbm1vZHVsZS5leHBvcnRzLldlYlNvY2tldCA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0JykuV2ViU29ja2V0XG5tb2R1bGUuZXhwb3J0cy5DbG9zZUV2ZW50ID0gQ2xvc2VFdmVudFxubW9kdWxlLmV4cG9ydHMuRXJyb3JFdmVudCA9IEVycm9yRXZlbnRcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VFdmVudCA9IE1lc3NhZ2VFdmVudFxuXG5tb2R1bGUuZXhwb3J0cy5yZXF1ZXN0ID0gbWFrZURpc3BhdGNoZXIoYXBpLnJlcXVlc3QpXG5tb2R1bGUuZXhwb3J0cy5zdHJlYW0gPSBtYWtlRGlzcGF0Y2hlcihhcGkuc3RyZWFtKVxubW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSBtYWtlRGlzcGF0Y2hlcihhcGkucGlwZWxpbmUpXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gbWFrZURpc3BhdGNoZXIoYXBpLmNvbm5lY3QpXG5tb2R1bGUuZXhwb3J0cy51cGdyYWRlID0gbWFrZURpc3BhdGNoZXIoYXBpLnVwZ3JhZGUpXG5cbm1vZHVsZS5leHBvcnRzLk1vY2tDbGllbnQgPSBNb2NrQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Nb2NrUG9vbCA9IE1vY2tQb29sXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQWdlbnQgPSBNb2NrQWdlbnRcbm1vZHVsZS5leHBvcnRzLm1vY2tFcnJvcnMgPSBtb2NrRXJyb3JzXG5cbmNvbnN0IHsgRXZlbnRTb3VyY2UgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9ldmVudHNvdXJjZS9ldmVudHNvdXJjZScpXG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50U291cmNlID0gRXZlbnRTb3VyY2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort(self[kSignal]?.reason)\n  } else {\n    self.reason = self[kSignal]?.reason ?? new RequestAbortedError()\n  }\n  removeSignal(self)\n}\n\nfunction addSignal (self, signal) {\n  self.reason = null\n\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYWJvcnQtc2lnbmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgYWRkQWJvcnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG5jb25zdCBrTGlzdGVuZXIgPSBTeW1ib2woJ2tMaXN0ZW5lcicpXG5jb25zdCBrU2lnbmFsID0gU3ltYm9sKCdrU2lnbmFsJylcblxuZnVuY3Rpb24gYWJvcnQgKHNlbGYpIHtcbiAgaWYgKHNlbGYuYWJvcnQpIHtcbiAgICBzZWxmLmFib3J0KHNlbGZba1NpZ25hbF0/LnJlYXNvbilcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnJlYXNvbiA9IHNlbGZba1NpZ25hbF0/LnJlYXNvbiA/PyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gIH1cbiAgcmVtb3ZlU2lnbmFsKHNlbGYpXG59XG5cbmZ1bmN0aW9uIGFkZFNpZ25hbCAoc2VsZiwgc2lnbmFsKSB7XG4gIHNlbGYucmVhc29uID0gbnVsbFxuXG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcblxuICBpZiAoIXNpZ25hbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgYWJvcnQoc2VsZilcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBzaWduYWxcbiAgc2VsZltrTGlzdGVuZXJdID0gKCkgPT4ge1xuICAgIGFib3J0KHNlbGYpXG4gIH1cblxuICBhZGRBYm9ydExpc3RlbmVyKHNlbGZba1NpZ25hbF0sIHNlbGZba0xpc3RlbmVyXSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2lnbmFsIChzZWxmKSB7XG4gIGlmICghc2VsZltrU2lnbmFsXSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBzZWxmW2tTaWduYWxdKSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmW2tTaWduYWxdLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIHNlbGZba0xpc3RlbmVyXSlcbiAgfVxuXG4gIHNlbGZba1NpZ25hbF0gPSBudWxsXG4gIHNlbGZba0xpc3RlbmVyXSA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZFNpZ25hbCxcbiAgcmVtb3ZlU2lnbmFsXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEJBQTRCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFwaS1jb25uZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBDb25uZWN0SGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX0NPTk5FQ1QnKVxuXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKCkge1xuICAgIHRocm93IG5ldyBTb2NrZXRFcnJvcignYmFkIGNvbm5lY3QnLCBudWxsKVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcblxuICAgIGxldCBoZWFkZXJzID0gcmF3SGVhZGVyc1xuICAgIC8vIEluZGljYXRlcyBpcyBhbiBIVFRQMlNlc3Npb25cbiAgICBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIH1cblxuICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNvY2tldCxcbiAgICAgIG9wYXF1ZSxcbiAgICAgIGNvbnRleHRcbiAgICB9KVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbm5lY3QuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSBuZXcgQ29ubmVjdEhhbmRsZXIob3B0cywgY2FsbGJhY2spXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIG1ldGhvZDogJ0NPTk5FQ1QnIH0sIGNvbm5lY3RIYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n    assert(!ret.destroyed)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjtBQUM1RCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrREFBa0Q7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLDZCQUE2Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwyQkFBMkI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFwaS1waXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBSZWFkYWJsZSxcbiAgRHVwbGV4LFxuICBQYXNzVGhyb3VnaFxufSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCBrUmVzdW1lID0gU3ltYm9sKCdyZXN1bWUnKVxuXG5jbGFzcyBQaXBlbGluZVJlcXVlc3QgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIGNvbnN0IHsgW2tSZXN1bWVdOiByZXN1bWUgfSA9IHRoaXNcblxuICAgIGlmIChyZXN1bWUpIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0gPSBudWxsXG4gICAgICByZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVhZCgpXG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVSZXNwb25zZSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKHJlc3VtZSkge1xuICAgIHN1cGVyKHsgYXV0b0Rlc3Ryb3k6IHRydWUgfSlcbiAgICB0aGlzW2tSZXN1bWVdID0gcmVzdW1lXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgdGhpc1trUmVzdW1lXSgpXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnIpXG4gIH1cbn1cblxuY2xhc3MgUGlwZWxpbmVIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhhbmRsZXInKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSW5mbyBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9QSVBFTElORScpXG5cbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG5cbiAgICB0aGlzLnJlcSA9IG5ldyBQaXBlbGluZVJlcXVlc3QoKS5vbignZXJyb3InLCB1dGlsLm5vcClcblxuICAgIHRoaXMucmV0ID0gbmV3IER1cGxleCh7XG4gICAgICByZWFkYWJsZU9iamVjdE1vZGU6IG9wdHMub2JqZWN0TW9kZSxcbiAgICAgIGF1dG9EZXN0cm95OiB0cnVlLFxuICAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoYm9keT8ucmVzdW1lKSB7XG4gICAgICAgICAgYm9keS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKHJlcS5wdXNoKGNodW5rLCBlbmNvZGluZykgfHwgcmVxLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXFba1Jlc3VtZV0gPSBjYWxsYmFja1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogKGVyciwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5LCByZXEsIHJlcywgcmV0LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghZXJyICYmICFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhYm9ydCAmJiBlcnIpIHtcbiAgICAgICAgICBhYm9ydCgpXG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVxLCBlcnIpXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcblxuICAgICAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSkub24oJ3ByZWZpbmlzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVxIH0gPSB0aGlzXG5cbiAgICAgIC8vIE5vZGUgPCAxNSBkb2VzIG5vdCBjYWxsIF9maW5hbCBpbiBzYW1lIHRpY2suXG4gICAgICByZXEucHVzaChudWxsKVxuICAgIH0pXG5cbiAgICB0aGlzLnJlcyA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyByZXQsIHJlcyB9ID0gdGhpc1xuXG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCghcmVzLCAncGlwZWxpbmUgY2Fubm90IGJlIHJldHJpZWQnKVxuICAgIGFzc2VydCghcmV0LmRlc3Ryb3llZClcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lKSB7XG4gICAgY29uc3QgeyBvcGFxdWUsIGhhbmRsZXIsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnJlcyA9IG5ldyBQaXBlbGluZVJlc3BvbnNlKHJlc3VtZSlcblxuICAgIGxldCBib2R5XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICBib2R5ID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoaGFuZGxlciwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGJvZHk6IHRoaXMucmVzLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5yZXMub24oJ2Vycm9yJywgdXRpbC5ub3ApXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkub24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcignZXhwZWN0ZWQgUmVhZGFibGUnKVxuICAgIH1cblxuICAgIGJvZHlcbiAgICAgIC5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCwgYm9keSB9ID0gdGhpc1xuXG4gICAgICAgIGlmICghcmV0LnB1c2goY2h1bmspICYmIGJvZHkucGF1c2UpIHtcbiAgICAgICAgICBib2R5LnBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgdXRpbC5kZXN0cm95KHJldCwgZXJyKVxuICAgICAgfSlcbiAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHJldC5wdXNoKG51bGwpXG4gICAgICB9KVxuICAgICAgLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXQsIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcbiAgICByZXR1cm4gcmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG4gICAgdGhpcy5oYW5kbGVyID0gbnVsbFxuICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZSAob3B0cywgaGFuZGxlcikge1xuICB0cnkge1xuICAgIGNvbnN0IHBpcGVsaW5lSGFuZGxlciA9IG5ldyBQaXBlbGluZUhhbmRsZXIob3B0cywgaGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoKHsgLi4ub3B0cywgYm9keTogcGlwZWxpbmVIYW5kbGVyLnJlcSB9LCBwaXBlbGluZUhhbmRsZXIpXG4gICAgcmV0dXJuIHBpcGVsaW5lSGFuZGxlci5yZXRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n    this.signal = signal\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    if (this.signal) {\n      if (this.signal.aborted) {\n        this.reason = this.signal.reason ?? new RequestAbortedError()\n      } else {\n        this.removeAbortListener = util.addAbortListener(this.signal, () => {\n          this.reason = this.signal.reason ?? new RequestAbortedError()\n          if (this.res) {\n            util.destroy(this.res, this.reason)\n          } else if (this.abort) {\n            this.abort(this.reason)\n          }\n\n          if (this.removeAbortListener) {\n            this.res?.off('close', this.removeAbortListener)\n            this.removeAbortListener()\n            this.removeAbortListener = null\n          }\n        })\n      }\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body: res, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n\n    if (this.removeAbortListener) {\n      res?.off('close', this.removeAbortListener)\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUVBQVk7QUFDekMsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM5RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLDJEQUFRO0FBQ3hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxxRkFBcUY7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1FQUFtRTs7QUFFL0U7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcYXBpLXJlcXVlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5cbmNsYXNzIFJlcXVlc3RIYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCB0aHJvd09uRXJyb3IsIGhpZ2hXYXRlck1hcmsgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChoaWdoV2F0ZXJNYXJrICYmICh0eXBlb2YgaGlnaFdhdGVyTWFyayAhPT0gJ251bWJlcicgfHwgaGlnaFdhdGVyTWFyayA8IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoaWdoV2F0ZXJNYXJrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1JFUVVFU1QnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgdXRpbC5ub3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5yZXMgPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmJvZHkgPSBib2R5XG4gICAgdGhpcy50cmFpbGVycyA9IHt9XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvclxuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcmtcbiAgICB0aGlzLnNpZ25hbCA9IHNpZ25hbFxuICAgIHRoaXMucmVhc29uID0gbnVsbFxuICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2lnbmFsKSB7XG4gICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHRoaXMuc2lnbmFsLnJlYXNvbiA/PyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSB1dGlsLmFkZEFib3J0TGlzdGVuZXIodGhpcy5zaWduYWwsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYXNvbiA9IHRoaXMuc2lnbmFsLnJlYXNvbiA/PyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICAgICAgaWYgKHRoaXMucmVzKSB7XG4gICAgICAgICAgICB1dGlsLmRlc3Ryb3kodGhpcy5yZXMsIHRoaXMucmVhc29uKVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcz8ub2ZmKCdjbG9zZScsIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcigpXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSwgYWJvcnQsIGNvbnRleHQsIHJlc3BvbnNlSGVhZGVycywgaGlnaFdhdGVyTWFyayB9ID0gdGhpc1xuXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICBjb25zdCByZXMgPSBuZXcgUmVhZGFibGUoe1xuICAgICAgcmVzdW1lLFxuICAgICAgYWJvcnQsXG4gICAgICBjb250ZW50VHlwZSxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aFxuICAgICAgICA/IE51bWJlcihjb250ZW50TGVuZ3RoKVxuICAgICAgICA6IG51bGwsXG4gICAgICBoaWdoV2F0ZXJNYXJrXG4gICAgfSlcblxuICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgIHJlcy5vbignY2xvc2UnLCB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpXG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICB0aGlzLnJlcyA9IHJlc1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudGhyb3dPbkVycm9yICYmIHN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjaywgbnVsbCxcbiAgICAgICAgICB7IGNhbGxiYWNrLCBib2R5OiByZXMsIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgdHJhaWxlcnM6IHRoaXMudHJhaWxlcnMsXG4gICAgICAgICAgb3BhcXVlLFxuICAgICAgICAgIGJvZHk6IHJlcyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIHJldHVybiB0aGlzLnJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycywgdGhpcy50cmFpbGVycylcbiAgICB0aGlzLnJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIGJvZHksIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBEb2VzIHRoaXMgbmVlZCBxdWV1ZU1pY3JvdGFzaz9cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMucmVzID0gbnVsbFxuICAgICAgLy8gRW5zdXJlIGFsbCBxdWV1ZWQgaGFuZGxlcnMgYXJlIGludm9rZWQgYmVmb3JlIGRlc3Ryb3lpbmcgcmVzLlxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgIHJlcz8ub2ZmKCdjbG9zZScsIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcilcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcigpXG4gICAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVlc3QuY2FsbCh0aGlzLCBvcHRzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBuZXcgUmVxdWVzdEhhbmRsZXIob3B0cywgY2FsbGJhY2spKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Rcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3RIYW5kbGVyID0gUmVxdWVzdEhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { finished, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError || false\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, callback, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    let res\n\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n      const contentType = parsedHeaders['content-type']\n      res = new PassThrough()\n\n      this.callback = null\n      this.runInAsyncScope(getResolveErrorBodyCallback, null,\n        { callback, body: res, contentType, statusCode, statusMessage, headers }\n      )\n    } else {\n      if (factory === null) {\n        return\n      }\n\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      })\n\n      if (\n        !res ||\n        typeof res.write !== 'function' ||\n        typeof res.end !== 'function' ||\n        typeof res.on !== 'function'\n      ) {\n        throw new InvalidReturnValueError('expected Writable')\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, { readable: false }, (err) => {\n        const { callback, res, opaque, trailers, abort } = this\n\n        this.res = null\n        if (err || !res.readable) {\n          util.destroy(res, err)\n        }\n\n        this.callback = null\n        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n        if (err) {\n          abort()\n        }\n      })\n    }\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3ZELFFBQVEsZ0RBQWdELEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDbEYsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsOEJBQThCLEVBQUUsbUJBQU8sQ0FBQywyREFBUTtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxzRUFBc0U7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNEQUFzRDs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLGdCQUFnQix5Q0FBeUM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGtCQUFrQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOEJBQThCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFwaS1zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZmluaXNoZWQsIFBhc3NUaHJvdWdoIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB7IGFkZFNpZ25hbCwgcmVtb3ZlU2lnbmFsIH0gPSByZXF1aXJlKCcuL2Fib3J0LXNpZ25hbCcpXG5cbmNsYXNzIFN0cmVhbUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGZhY3RvcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHsgc2lnbmFsLCBtZXRob2QsIG9wYXF1ZSwgYm9keSwgb25JbmZvLCByZXNwb25zZUhlYWRlcnMsIHRocm93T25FcnJvciB9ID0gb3B0c1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBmYWN0b3J5JylcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsLm9uICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uSW5mbyAmJiB0eXBlb2Ygb25JbmZvICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBzdXBlcignVU5ESUNJX1NUUkVBTScpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgICB1dGlsLmRlc3Ryb3koYm9keS5vbignZXJyb3InLCB1dGlsLm5vcCksIGVycilcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeVxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudHJhaWxlcnMgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMub25JbmZvID0gb25JbmZvIHx8IG51bGxcbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciB8fCBmYWxzZVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIGJvZHkub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBmYWN0b3J5LCBvcGFxdWUsIGNvbnRleHQsIGNhbGxiYWNrLCByZXNwb25zZUhlYWRlcnMgfSA9IHRoaXNcblxuICAgIGNvbnN0IGhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmICh0aGlzLm9uSW5mbykge1xuICAgICAgICB0aGlzLm9uSW5mbyh7IHN0YXR1c0NvZGUsIGhlYWRlcnMgfSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmFjdG9yeSA9IG51bGxcblxuICAgIGxldCByZXNcblxuICAgIGlmICh0aGlzLnRocm93T25FcnJvciAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgY29uc3QgcGFyc2VkSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSA6IGhlYWRlcnNcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICAgIHJlcyA9IG5ldyBQYXNzVGhyb3VnaCgpXG5cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssIG51bGwsXG4gICAgICAgIHsgY2FsbGJhY2ssIGJvZHk6IHJlcywgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFjdG9yeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVzID0gdGhpcy5ydW5JbkFzeW5jU2NvcGUoZmFjdG9yeSwgbnVsbCwge1xuICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBvcGFxdWUsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChcbiAgICAgICAgIXJlcyB8fFxuICAgICAgICB0eXBlb2YgcmVzLndyaXRlICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMuZW5kICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiByZXMub24gIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFdyaXRhYmxlJylcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogQXZvaWQgZmluaXNoZWQuIEl0IHJlZ2lzdGVycyBhbiB1bm5lY2Vzc2FyeSBhbW91bnQgb2YgbGlzdGVuZXJzLlxuICAgICAgZmluaXNoZWQocmVzLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIHJlcywgb3BhcXVlLCB0cmFpbGVycywgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgICAgaWYgKGVyciB8fCAhcmVzLnJlYWRhYmxlKSB7XG4gICAgICAgICAgdXRpbC5kZXN0cm95KHJlcywgZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciB8fCBudWxsLCB7IG9wYXF1ZSwgdHJhaWxlcnMgfSlcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJlcy5vbignZHJhaW4nLCByZXN1bWUpXG5cbiAgICB0aGlzLnJlcyA9IHJlc1xuXG4gICAgY29uc3QgbmVlZERyYWluID0gcmVzLndyaXRhYmxlTmVlZERyYWluICE9PSB1bmRlZmluZWRcbiAgICAgID8gcmVzLndyaXRhYmxlTmVlZERyYWluXG4gICAgICA6IHJlcy5fd3JpdGFibGVTdGF0ZT8ubmVlZERyYWluXG5cbiAgICByZXR1cm4gbmVlZERyYWluICE9PSB0cnVlXG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJldHVybiByZXMgPyByZXMud3JpdGUoY2h1bmspIDogdHJ1ZVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy50cmFpbGVycyA9IHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzKVxuXG4gICAgcmVzLmVuZCgpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJlcywgY2FsbGJhY2ssIG9wYXF1ZSwgYm9keSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBpZiAocmVzKSB7XG4gICAgICB0aGlzLnJlcyA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyZWFtIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdHJlYW0uY2FsbCh0aGlzLCBvcHRzLCBmYWN0b3J5LCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGhpcy5kaXNwYXRjaChvcHRzLCBuZXcgU3RyZWFtSGFuZGxlcihvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyZWFtXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(ssr)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsMkVBQWdCO0FBQzVELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFwaS11cGdyYWRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBTb2NrZXRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jbGFzcyBVcGdyYWRlSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgb3BhcXVlLCByZXNwb25zZUhlYWRlcnMgfSA9IG9wdHNcblxuICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0JylcbiAgICB9XG5cbiAgICBzdXBlcignVU5ESUNJX1VQR1JBREUnKVxuXG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgfHwgbnVsbFxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwoc3RhdHVzQ29kZSwgMTAxKVxuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIG51bGwsIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGdyYWRlIChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGdyYWRlLmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVwZ3JhZGVIYW5kbGVyID0gbmV3IFVwZ3JhZGVIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG1ldGhvZDogb3B0cy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICB1cGdyYWRlOiBvcHRzLnByb3RvY29sIHx8ICdXZWJzb2NrZXQnXG4gICAgfSwgdXBncmFkZUhhbmRsZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXBncmFkZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(ssr)/./node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(ssr)/./node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(ssr)/./node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(ssr)/./node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(ssr)/./node_modules/undici/lib/api/api-connect.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUhBQWlEO0FBQ2pELG9IQUErQztBQUMvQywwSEFBbUQ7QUFDbkQsdUhBQWlEO0FBQ2pELHVIQUFpRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLnJlcXVlc3QgPSByZXF1aXJlKCcuL2FwaS1yZXF1ZXN0Jylcbm1vZHVsZS5leHBvcnRzLnN0cmVhbSA9IHJlcXVpcmUoJy4vYXBpLXN0cmVhbScpXG5tb2R1bGUuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vYXBpLXBpcGVsaW5lJylcbm1vZHVsZS5leHBvcnRzLnVwZ3JhZGUgPSByZXF1aXJlKCcuL2FwaS11cGdyYWRlJylcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSByZXF1aXJlKCcuL2FwaS1jb25uZWN0JylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\n\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\n\nconst noop = () => {}\n\nclass BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n    this[kContentLength] = contentLength\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  _destroy (err, callback) {\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing a 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kReading]) {\n      setImmediate(() => {\n        callback(err)\n      })\n    } else {\n      callback(err)\n    }\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal')\n    }\n\n    signal?.throwIfAborted()\n\n    if (this._readableState.closeEmitted) {\n      return null\n    }\n\n    return await new Promise((resolve, reject) => {\n      if (this[kContentLength] > limit) {\n        this.destroy(new AbortError())\n      }\n\n      const onAbort = () => {\n        this.destroy(signal.reason ?? new AbortError())\n      }\n      signal?.addEventListener('abort', onAbort)\n\n      this\n        .on('close', function () {\n          signal?.removeEventListener('abort', onAbort)\n          if (signal?.aborted) {\n            reject(signal.reason ?? new AbortError())\n          } else {\n            resolve(null)\n          }\n        })\n        .on('error', noop)\n        .on('data', function (chunk) {\n          limit -= chunk.length\n          if (limit <= 0) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', err => {\n            reject(err)\n          })\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */\nfunction chunksDecode (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  return buffer.utf8Slice(start, bufferLength)\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst.buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = { Readable: BodyReadable, chunksDecode }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM3RyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3QkFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsc0NBQXNDOztBQUVoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTiwrQkFBK0IsNEJBQTRCO0FBQzNEOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxyZWFkYWJsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzkwN1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBSZXF1ZXN0QWJvcnRlZEVycm9yLCBOb3RTdXBwb3J0ZWRFcnJvciwgSW52YWxpZEFyZ3VtZW50RXJyb3IsIEFib3J0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBSZWFkYWJsZVN0cmVhbUZyb20gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmNvbnN0IGtDb25zdW1lID0gU3ltYm9sKCdrQ29uc3VtZScpXG5jb25zdCBrUmVhZGluZyA9IFN5bWJvbCgna1JlYWRpbmcnKVxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2tCb2R5JylcbmNvbnN0IGtBYm9ydCA9IFN5bWJvbCgna0Fib3J0JylcbmNvbnN0IGtDb250ZW50VHlwZSA9IFN5bWJvbCgna0NvbnRlbnRUeXBlJylcbmNvbnN0IGtDb250ZW50TGVuZ3RoID0gU3ltYm9sKCdrQ29udGVudExlbmd0aCcpXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jbGFzcyBCb2R5UmVhZGFibGUgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgcmVzdW1lLFxuICAgIGFib3J0LFxuICAgIGNvbnRlbnRUeXBlID0gJycsXG4gICAgY29udGVudExlbmd0aCxcbiAgICBoaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0IC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6IHJlc3VtZSxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZCA9IGZhbHNlXG5cbiAgICB0aGlzW2tBYm9ydF0gPSBhYm9ydFxuICAgIHRoaXNba0NvbnN1bWVdID0gbnVsbFxuICAgIHRoaXNba0JvZHldID0gbnVsbFxuICAgIHRoaXNba0NvbnRlbnRUeXBlXSA9IGNvbnRlbnRUeXBlXG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBjb250ZW50TGVuZ3RoXG5cbiAgICAvLyBJcyBzdHJlYW0gYmVpbmcgY29uc3VtZWQgdGhyb3VnaCBSZWFkYWJsZSBBUEk/XG4gICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gdGhhdCB3ZSBhdm9pZCBjaGVja2luZ1xuICAgIC8vIGZvciAnZGF0YScgYW5kICdyZWFkYWJsZScgbGlzdGVuZXJzIGluIHRoZSBob3QgcGF0aFxuICAgIC8vIGluc2lkZSBwdXNoKCkuXG4gICAgdGhpc1trUmVhZGluZ10gPSBmYWxzZVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgaWYgKCFlcnIgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgZXJyID0gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgIH1cblxuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXNba0Fib3J0XSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBOb2RlIFwiYnVnXCIuIElmIHRoZSBzdHJlYW0gaXMgZGVzdHJveWVkIGluIHNhbWVcbiAgICAvLyB0aWNrIGFzIGl0IGlzIGNyZWF0ZWQsIHRoZW4gYSB1c2VyIHdobyBpcyB3YWl0aW5nIGZvciBhXG4gICAgLy8gcHJvbWlzZSAoaS5lIG1pY3JvIHRpY2spIGZvciBpbnN0YWxsaW5nIGEgJ2Vycm9yJyBsaXN0ZW5lciB3aWxsXG4gICAgLy8gbmV2ZXIgZ2V0IGEgY2hhbmNlIGFuZCB3aWxsIGFsd2F5cyBlbmNvdW50ZXIgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICBpZiAoIXRoaXNba1JlYWRpbmddKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfVxuICB9XG5cbiAgb24gKGV2LCAuLi5hcmdzKSB7XG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIub24oZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBhZGRMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgLi4uYXJncylcbiAgfVxuXG4gIG9mZiAoZXYsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIC4uLmFyZ3MpXG4gICAgaWYgKGV2ID09PSAnZGF0YScgfHwgZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgIHRoaXNba1JlYWRpbmddID0gKFxuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDAgfHxcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lciAoZXYsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBwdXNoIChjaHVuaykge1xuICAgIGlmICh0aGlzW2tDb25zdW1lXSAmJiBjaHVuayAhPT0gbnVsbCkge1xuICAgICAgY29uc3VtZVB1c2godGhpc1trQ29uc3VtZV0sIGNodW5rKVxuICAgICAgcmV0dXJuIHRoaXNba1JlYWRpbmddID8gc3VwZXIucHVzaChjaHVuaykgOiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LXRleHRcbiAgYXN5bmMgdGV4dCAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ3RleHQnKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWpzb25cbiAgYXN5bmMganNvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2pzb24nKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJsb2JcbiAgYXN5bmMgYmxvYiAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2Jsb2InKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWFycmF5YnVmZmVyXG4gIGFzeW5jIGFycmF5QnVmZmVyICgpIHtcbiAgICByZXR1cm4gY29uc3VtZSh0aGlzLCAnYXJyYXlCdWZmZXInKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWZvcm1kYXRhXG4gIGFzeW5jIGZvcm1EYXRhICgpIHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQuXG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKClcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ib2R5dXNlZFxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHRoaXMpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keVxuICBnZXQgYm9keSAoKSB7XG4gICAgaWYgKCF0aGlzW2tCb2R5XSkge1xuICAgICAgdGhpc1trQm9keV0gPSBSZWFkYWJsZVN0cmVhbUZyb20odGhpcylcbiAgICAgIGlmICh0aGlzW2tDb25zdW1lXSkge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIHRoZSBiZXN0IHdheSB0byBmb3JjZSBhIGxvY2s/XG4gICAgICAgIHRoaXNba0JvZHldLmdldFJlYWRlcigpIC8vIEVuc3VyZSBzdHJlYW0gaXMgbG9ja2VkLlxuICAgICAgICBhc3NlcnQodGhpc1trQm9keV0ubG9ja2VkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trQm9keV1cbiAgfVxuXG4gIGFzeW5jIGR1bXAgKG9wdHMpIHtcbiAgICBsZXQgbGltaXQgPSBOdW1iZXIuaXNGaW5pdGUob3B0cz8ubGltaXQpID8gb3B0cy5saW1pdCA6IDEyOCAqIDEwMjRcbiAgICBjb25zdCBzaWduYWwgPSBvcHRzPy5zaWduYWxcblxuICAgIGlmIChzaWduYWwgIT0gbnVsbCAmJiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lnbmFsIG11c3QgYmUgYW4gQWJvcnRTaWduYWwnKVxuICAgIH1cblxuICAgIHNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKVxuXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuY2xvc2VFbWl0dGVkKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpc1trQ29udGVudExlbmd0aF0gPiBsaW1pdCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kobmV3IEFib3J0RXJyb3IoKSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgIH1cbiAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KVxuXG4gICAgICB0aGlzXG4gICAgICAgIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpXG4gICAgICAgICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24gPz8gbmV3IEFib3J0RXJyb3IoKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIG5vb3ApXG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICAgIGxpbWl0IC09IGNodW5rLmxlbmd0aFxuICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbS1sb2NrZWRcbmZ1bmN0aW9uIGlzTG9ja2VkIChzZWxmKSB7XG4gIC8vIENvbnN1bWUgaXMgYW4gaW1wbGljaXQgbG9jay5cbiAgcmV0dXJuIChzZWxmW2tCb2R5XSAmJiBzZWxmW2tCb2R5XS5sb2NrZWQgPT09IHRydWUpIHx8IHNlbGZba0NvbnN1bWVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LXVudXNhYmxlXG5mdW5jdGlvbiBpc1VudXNhYmxlIChzZWxmKSB7XG4gIHJldHVybiB1dGlsLmlzRGlzdHVyYmVkKHNlbGYpIHx8IGlzTG9ja2VkKHNlbGYpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWUgKHN0cmVhbSwgdHlwZSkge1xuICBhc3NlcnQoIXN0cmVhbVtrQ29uc3VtZV0pXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoaXNVbnVzYWJsZShzdHJlYW0pKSB7XG4gICAgICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChyU3RhdGUuZGVzdHJveWVkICYmIHJTdGF0ZS5jbG9zZUVtaXR0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcigndW51c2FibGUnKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KHJTdGF0ZS5lcnJvcmVkID8/IG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgc3RyZWFtW2tDb25zdW1lXSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgYm9keTogW11cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbVxuICAgICAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdW1lRmluaXNoKHRoaXNba0NvbnN1bWVdLCBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNba0NvbnN1bWVdLmJvZHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN1bWVTdGFydChzdHJlYW1ba0NvbnN1bWVdKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVTdGFydCAoY29uc3VtZSkge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7IF9yZWFkYWJsZVN0YXRlOiBzdGF0ZSB9ID0gY29uc3VtZS5zdHJlYW1cblxuICBpZiAoc3RhdGUuYnVmZmVySW5kZXgpIHtcbiAgICBjb25zdCBzdGFydCA9IHN0YXRlLmJ1ZmZlckluZGV4XG4gICAgY29uc3QgZW5kID0gc3RhdGUuYnVmZmVyLmxlbmd0aFxuICAgIGZvciAobGV0IG4gPSBzdGFydDsgbiA8IGVuZDsgbisrKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBzdGF0ZS5idWZmZXJbbl0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2Ygc3RhdGUuYnVmZmVyKSB7XG4gICAgICBjb25zdW1lUHVzaChjb25zdW1lLCBjaHVuaylcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gIH0gZWxzZSB7XG4gICAgY29uc3VtZS5zdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN1bWVFbmQodGhpc1trQ29uc3VtZV0pXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN1bWUuc3RyZWFtLnJlc3VtZSgpXG5cbiAgd2hpbGUgKGNvbnN1bWUuc3RyZWFtLnJlYWQoKSAhPSBudWxsKSB7XG4gICAgLy8gTG9vcFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gY2h1bmtzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNodW5rc0RlY29kZSAoY2h1bmtzLCBsZW5ndGgpIHtcbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgfHwgbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgY29uc3QgYnVmZmVyID0gY2h1bmtzLmxlbmd0aCA9PT0gMSA/IGNodW5rc1swXSA6IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBsZW5ndGgpXG4gIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlci5sZW5ndGhcblxuICAvLyBTa2lwIEJPTS5cbiAgY29uc3Qgc3RhcnQgPVxuICAgIGJ1ZmZlckxlbmd0aCA+IDIgJiZcbiAgICBidWZmZXJbMF0gPT09IDB4ZWYgJiZcbiAgICBidWZmZXJbMV0gPT09IDB4YmIgJiZcbiAgICBidWZmZXJbMl0gPT09IDB4YmZcbiAgICAgID8gM1xuICAgICAgOiAwXG4gIHJldHVybiBidWZmZXIudXRmOFNsaWNlKHN0YXJ0LCBidWZmZXJMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVFbmQgKGNvbnN1bWUpIHtcbiAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW0sIGxlbmd0aCB9ID0gY29uc3VtZVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzb2x2ZShjaHVua3NEZWNvZGUoYm9keSwgbGVuZ3RoKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKGNodW5rc0RlY29kZShib2R5LCBsZW5ndGgpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgIGNvbnN0IGRzdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcblxuICAgICAgbGV0IHBvcyA9IDBcbiAgICAgIGZvciAoY29uc3QgYnVmIG9mIGJvZHkpIHtcbiAgICAgICAgZHN0LnNldChidWYsIHBvcylcbiAgICAgICAgcG9zICs9IGJ1Zi5ieXRlTGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoZHN0LmJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdibG9iJykge1xuICAgICAgcmVzb2x2ZShuZXcgQmxvYihib2R5LCB7IHR5cGU6IHN0cmVhbVtrQ29udGVudFR5cGVdIH0pKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICBjb25zdW1lLnR5cGUgPSBudWxsXG4gIGNvbnN1bWUuc3RyZWFtID0gbnVsbFxuICBjb25zdW1lLnJlc29sdmUgPSBudWxsXG4gIGNvbnN1bWUucmVqZWN0ID0gbnVsbFxuICBjb25zdW1lLmxlbmd0aCA9IDBcbiAgY29uc3VtZS5ib2R5ID0gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUmVhZGFibGU6IEJvZHlSZWFkYWJsZSwgY2h1bmtzRGVjb2RlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  ResponseStatusCodeError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nconst { chunksDecode } = __webpack_require__(/*! ./readable */ \"(ssr)/./node_modules/undici/lib/api/readable.js\")\nconst CHUNK_LIMIT = 128 * 1024\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let length = 0\n\n  try {\n    for await (const chunk of body) {\n      chunks.push(chunk)\n      length += chunk.length\n      if (length > CHUNK_LIMIT) {\n        chunks = []\n        length = 0\n        break\n      }\n    }\n  } catch {\n    chunks = []\n    length = 0\n    // Do nothing....\n  }\n\n  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`\n\n  if (statusCode === 204 || !contentType || !length) {\n    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)))\n    return\n  }\n\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  let payload\n\n  try {\n    if (isContentTypeApplicationJson(contentType)) {\n      payload = JSON.parse(chunksDecode(chunks, length))\n    } else if (isContentTypeText(contentType)) {\n      payload = chunksDecode(chunks, length)\n    }\n  } catch {\n    // process in a callback to avoid throwing in the microtask queue\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n  queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)))\n}\n\nconst isContentTypeApplicationJson = (contentType) => {\n  return (\n    contentType.length > 15 &&\n    contentType[11] === '/' &&\n    contentType[0] === 'a' &&\n    contentType[1] === 'p' &&\n    contentType[2] === 'p' &&\n    contentType[3] === 'l' &&\n    contentType[4] === 'i' &&\n    contentType[5] === 'c' &&\n    contentType[6] === 'a' &&\n    contentType[7] === 't' &&\n    contentType[8] === 'i' &&\n    contentType[9] === 'o' &&\n    contentType[10] === 'n' &&\n    contentType[12] === 'j' &&\n    contentType[13] === 's' &&\n    contentType[14] === 'o' &&\n    contentType[15] === 'n'\n  )\n}\n\nconst isContentTypeText = (contentType) => {\n  return (\n    contentType.length > 4 &&\n    contentType[4] === '/' &&\n    contentType[0] === 't' &&\n    contentType[1] === 'e' &&\n    contentType[2] === 'x' &&\n    contentType[3] === 't'\n  )\n}\n\nmodule.exports = {\n  getResolveErrorBodyCallback,\n  isContentTypeApplicationJson,\n  isContentTypeText\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEM7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFNUIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxtRUFBWTtBQUM3Qzs7QUFFQSw4Q0FBOEMsaUVBQWlFO0FBQy9HOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFdBQVcsRUFBRSxxQkFBcUIsY0FBYyxPQUFPOztBQUVqRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3Qge1xuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3QgeyBjaHVua3NEZWNvZGUgfSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3QgQ0hVTktfTElNSVQgPSAxMjggKiAxMDI0XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayAoeyBjYWxsYmFjaywgYm9keSwgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfSkge1xuICBhc3NlcnQoYm9keSlcblxuICBsZXQgY2h1bmtzID0gW11cbiAgbGV0IGxlbmd0aCA9IDBcblxuICB0cnkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspXG4gICAgICBsZW5ndGggKz0gY2h1bmsubGVuZ3RoXG4gICAgICBpZiAobGVuZ3RoID4gQ0hVTktfTElNSVQpIHtcbiAgICAgICAgY2h1bmtzID0gW11cbiAgICAgICAgbGVuZ3RoID0gMFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgY2h1bmtzID0gW11cbiAgICBsZW5ndGggPSAwXG4gICAgLy8gRG8gbm90aGluZy4uLi5cbiAgfVxuXG4gIGNvbnN0IG1lc3NhZ2UgPSBgUmVzcG9uc2Ugc3RhdHVzIGNvZGUgJHtzdGF0dXNDb2RlfSR7c3RhdHVzTWVzc2FnZSA/IGA6ICR7c3RhdHVzTWVzc2FnZX1gIDogJyd9YFxuXG4gIGlmIChzdGF0dXNDb2RlID09PSAyMDQgfHwgIWNvbnRlbnRUeXBlIHx8ICFsZW5ndGgpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhuZXcgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycykpKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3RhY2tUcmFjZUxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0XG4gIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDBcbiAgbGV0IHBheWxvYWRcblxuICB0cnkge1xuICAgIGlmIChpc0NvbnRlbnRUeXBlQXBwbGljYXRpb25Kc29uKGNvbnRlbnRUeXBlKSkge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmtzRGVjb2RlKGNodW5rcywgbGVuZ3RoKSlcbiAgICB9IGVsc2UgaWYgKGlzQ29udGVudFR5cGVUZXh0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgcGF5bG9hZCA9IGNodW5rc0RlY29kZShjaHVua3MsIGxlbmd0aClcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIHByb2Nlc3MgaW4gYSBjYWxsYmFjayB0byBhdm9pZCB0aHJvd2luZyBpbiB0aGUgbWljcm90YXNrIHF1ZXVlXG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0XG4gIH1cbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMsIHBheWxvYWQpKSlcbn1cblxuY29uc3QgaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbiA9IChjb250ZW50VHlwZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIGNvbnRlbnRUeXBlLmxlbmd0aCA+IDE1ICYmXG4gICAgY29udGVudFR5cGVbMTFdID09PSAnLycgJiZcbiAgICBjb250ZW50VHlwZVswXSA9PT0gJ2EnICYmXG4gICAgY29udGVudFR5cGVbMV0gPT09ICdwJyAmJlxuICAgIGNvbnRlbnRUeXBlWzJdID09PSAncCcgJiZcbiAgICBjb250ZW50VHlwZVszXSA9PT0gJ2wnICYmXG4gICAgY29udGVudFR5cGVbNF0gPT09ICdpJyAmJlxuICAgIGNvbnRlbnRUeXBlWzVdID09PSAnYycgJiZcbiAgICBjb250ZW50VHlwZVs2XSA9PT0gJ2EnICYmXG4gICAgY29udGVudFR5cGVbN10gPT09ICd0JyAmJlxuICAgIGNvbnRlbnRUeXBlWzhdID09PSAnaScgJiZcbiAgICBjb250ZW50VHlwZVs5XSA9PT0gJ28nICYmXG4gICAgY29udGVudFR5cGVbMTBdID09PSAnbicgJiZcbiAgICBjb250ZW50VHlwZVsxMl0gPT09ICdqJyAmJlxuICAgIGNvbnRlbnRUeXBlWzEzXSA9PT0gJ3MnICYmXG4gICAgY29udGVudFR5cGVbMTRdID09PSAnbycgJiZcbiAgICBjb250ZW50VHlwZVsxNV0gPT09ICduJ1xuICApXG59XG5cbmNvbnN0IGlzQ29udGVudFR5cGVUZXh0ID0gKGNvbnRlbnRUeXBlKSA9PiB7XG4gIHJldHVybiAoXG4gICAgY29udGVudFR5cGUubGVuZ3RoID4gNCAmJlxuICAgIGNvbnRlbnRUeXBlWzRdID09PSAnLycgJiZcbiAgICBjb250ZW50VHlwZVswXSA9PT0gJ3QnICYmXG4gICAgY29udGVudFR5cGVbMV0gPT09ICdlJyAmJlxuICAgIGNvbnRlbnRUeXBlWzJdID09PSAneCcgJiZcbiAgICBjb250ZW50VHlwZVszXSA9PT0gJ3QnXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlc29sdmVFcnJvckJvZHlDYWxsYmFjayxcbiAgaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbixcbiAgaXNDb250ZW50VHlwZVRleHRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = __webpack_require__(/*! node:tls */ \"node:tls\")\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we prioritize socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')})`\n  }\n  util.destroy(socket, new ConnectTimeoutError(message))\n}\n\nmodule.exports = buildConnector\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLGdFQUFVOztBQUV4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0ZBQWtGO0FBQzdHO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFzRTtBQUNuRztBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsMEJBQVU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFEQUFxRDtBQUM5RjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxjb25uZWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIENvbm5lY3RUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxubGV0IHRscyAvLyBpbmNsdWRlIHRscyBjb25kaXRpb25hbGx5IHNpbmNlIGl0IGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlXG5cbi8vIFRPRE86IHNlc3Npb24gcmUtdXNlIGRvZXMgbm90IHdhaXQgZm9yIHRoZSBmaXJzdFxuLy8gY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBzZXNzaW9uIGFuZCBtaWdodCB0aGVyZWZvcmVcbi8vIHJlc29sdmUgdGhlIHNhbWUgc2VydmVybmFtZSBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW5cbi8vIHJlLXVzZSBpcyBlbmFibGVkLlxuXG5sZXQgU2Vzc2lvbkNhY2hlXG4vLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbmlmIChnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgIShwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFIHx8IHByb2Nlc3MuZW52LlVORElDSV9OT19GRykpIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeSA9IG5ldyBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPCB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChrZXkpXG4gICAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkucmVnaXN0ZXIoc2Vzc2lvbiwgc2Vzc2lvbktleSlcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFNpbXBsZVNlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG9sZGVzdEtleSB9ID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmtleXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIHNlc3Npb246IGN1c3RvbVNlc3Npb24sIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCdub2RlOnRscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBjdXN0b21TZXNzaW9uIHx8IHNlc3Npb25DYWNoZS5nZXQoc2Vzc2lvbktleSkgfHwgbnVsbFxuXG4gICAgICBhc3NlcnQoc2Vzc2lvbktleSlcblxuICAgICAgc29ja2V0ID0gdGxzLmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiAxNjM4NCwgLy8gVExTIGluIG5vZGUgY2FuJ3QgaGF2ZSBiaWdnZXIgSFdNIGFueXdheS4uLlxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzZXJ2ZXJuYW1lLFxuICAgICAgICBzZXNzaW9uLFxuICAgICAgICBsb2NhbEFkZHJlc3MsXG4gICAgICAgIC8vIFRPRE8oSFRUUC8yKTogQWRkIHN1cHBvcnQgZm9yIGgyY1xuICAgICAgICBBTFBOUHJvdG9jb2xzOiBhbGxvd0gyID8gWydodHRwLzEuMScsICdoMiddIDogWydodHRwLzEuMSddLFxuICAgICAgICBzb2NrZXQ6IGh0dHBTb2NrZXQsIC8vIHVwZ3JhZGUgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgcG9ydDogcG9ydCB8fCA0NDMsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuICAgICAgc29ja2V0ID0gbmV0LmNvbm5lY3Qoe1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiA2NCAqIDEwMjQsIC8vIFNhbWUgYXMgbm9kZWpzIGZzIHN0cmVhbXMuXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGxvY2FsQWRkcmVzcyxcbiAgICAgICAgcG9ydDogcG9ydCB8fCA4MCxcbiAgICAgICAgaG9zdDogaG9zdG5hbWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gU2V0IFRDUCBrZWVwIGFsaXZlIG9wdGlvbnMgb24gdGhlIHNvY2tldCBoZXJlIGluc3RlYWQgb2YgaW4gY29ubmVjdCgpIGZvciB0aGUgY2FzZSBvZiBhc3NpZ25pbmcgdGhlIHNvY2tldFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSA9PSBudWxsIHx8IG9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICBjb25zdCBrZWVwQWxpdmVJbml0aWFsRGVsYXkgPSBvcHRpb25zLmtlZXBBbGl2ZUluaXRpYWxEZWxheSA9PT0gdW5kZWZpbmVkID8gNjBlMyA6IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5XG4gICAgICBzb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIGtlZXBBbGl2ZUluaXRpYWxEZWxheSlcbiAgICB9XG5cbiAgICBjb25zdCBjYW5jZWxUaW1lb3V0ID0gc2V0dXBUaW1lb3V0KCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0KSwgdGltZW91dClcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbmNlbFRpbWVvdXQoKVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICByZXR1cm4gc29ja2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBUaW1lb3V0IChvbkNvbm5lY3RUaW1lb3V0LCB0aW1lb3V0KSB7XG4gIGlmICghdGltZW91dCkge1xuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG5cbiAgbGV0IHMxID0gbnVsbFxuICBsZXQgczIgPSBudWxsXG4gIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIHNldEltbWVkaWF0ZSBpcyBhZGRlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcmlvcml0aXplIHNvY2tldCBlcnJvciBldmVudHMgb3ZlciB0aW1lb3V0c1xuICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIC8vIFdpbmRvd3MgbmVlZHMgYW4gZXh0cmEgc2V0SW1tZWRpYXRlIHByb2JhYmx5IGR1ZSB0byBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcyBpbiB0aGUgc29ja2V0IGxvZ2ljXG4gICAgICAgIHMyID0gc2V0SW1tZWRpYXRlKCgpID0+IG9uQ29ubmVjdFRpbWVvdXQoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIHRpbWVvdXQpXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQpIHtcbiAgbGV0IG1lc3NhZ2UgPSAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICBpZiAoQXJyYXkuaXNBcnJheShzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcykpIHtcbiAgICBtZXNzYWdlICs9IGAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7c29ja2V0LmF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMuam9pbignLCAnKX0pYFxuICB9XG4gIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBDb25uZWN0VGltZW91dEVycm9yKG1lc3NhZ2UpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQ29ubmVjdG9yXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {Record<string, string | undefined>} */\nconst headerNameLowerCasedRecord = {}\n\n// https://developer.mozilla.org/docs/Web/HTTP/Headers\nconst wellknownHeaderNames = [\n  'Accept',\n  'Accept-Encoding',\n  'Accept-Language',\n  'Accept-Ranges',\n  'Access-Control-Allow-Credentials',\n  'Access-Control-Allow-Headers',\n  'Access-Control-Allow-Methods',\n  'Access-Control-Allow-Origin',\n  'Access-Control-Expose-Headers',\n  'Access-Control-Max-Age',\n  'Access-Control-Request-Headers',\n  'Access-Control-Request-Method',\n  'Age',\n  'Allow',\n  'Alt-Svc',\n  'Alt-Used',\n  'Authorization',\n  'Cache-Control',\n  'Clear-Site-Data',\n  'Connection',\n  'Content-Disposition',\n  'Content-Encoding',\n  'Content-Language',\n  'Content-Length',\n  'Content-Location',\n  'Content-Range',\n  'Content-Security-Policy',\n  'Content-Security-Policy-Report-Only',\n  'Content-Type',\n  'Cookie',\n  'Cross-Origin-Embedder-Policy',\n  'Cross-Origin-Opener-Policy',\n  'Cross-Origin-Resource-Policy',\n  'Date',\n  'Device-Memory',\n  'Downlink',\n  'ECT',\n  'ETag',\n  'Expect',\n  'Expect-CT',\n  'Expires',\n  'Forwarded',\n  'From',\n  'Host',\n  'If-Match',\n  'If-Modified-Since',\n  'If-None-Match',\n  'If-Range',\n  'If-Unmodified-Since',\n  'Keep-Alive',\n  'Last-Modified',\n  'Link',\n  'Location',\n  'Max-Forwards',\n  'Origin',\n  'Permissions-Policy',\n  'Pragma',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'RTT',\n  'Range',\n  'Referer',\n  'Referrer-Policy',\n  'Refresh',\n  'Retry-After',\n  'Sec-WebSocket-Accept',\n  'Sec-WebSocket-Extensions',\n  'Sec-WebSocket-Key',\n  'Sec-WebSocket-Protocol',\n  'Sec-WebSocket-Version',\n  'Server',\n  'Server-Timing',\n  'Service-Worker-Allowed',\n  'Service-Worker-Navigation-Preload',\n  'Set-Cookie',\n  'SourceMap',\n  'Strict-Transport-Security',\n  'Supports-Loading-Mode',\n  'TE',\n  'Timing-Allow-Origin',\n  'Trailer',\n  'Transfer-Encoding',\n  'Upgrade',\n  'Upgrade-Insecure-Requests',\n  'User-Agent',\n  'Vary',\n  'Via',\n  'WWW-Authenticate',\n  'X-Content-Type-Options',\n  'X-DNS-Prefetch-Control',\n  'X-Frame-Options',\n  'X-Permitted-Cross-Domain-Policies',\n  'X-Powered-By',\n  'X-Requested-With',\n  'X-XSS-Protection'\n]\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = wellknownHeaderNames[i]\n  const lowerCasedKey = key.toLowerCase()\n  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =\n    lowerCasedKey\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null)\n\nmodule.exports = {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG9DQUFvQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD59ICovXG5jb25zdCBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCA9IHt9XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvSGVhZGVyc1xuY29uc3Qgd2VsbGtub3duSGVhZGVyTmFtZXMgPSBbXG4gICdBY2NlcHQnLFxuICAnQWNjZXB0LUVuY29kaW5nJyxcbiAgJ0FjY2VwdC1MYW5ndWFnZScsXG4gICdBY2NlcHQtUmFuZ2VzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kcycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAnQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtTWF4LUFnZScsXG4gICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnLFxuICAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QnLFxuICAnQWdlJyxcbiAgJ0FsbG93JyxcbiAgJ0FsdC1TdmMnLFxuICAnQWx0LVVzZWQnLFxuICAnQXV0aG9yaXphdGlvbicsXG4gICdDYWNoZS1Db250cm9sJyxcbiAgJ0NsZWFyLVNpdGUtRGF0YScsXG4gICdDb25uZWN0aW9uJyxcbiAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nLFxuICAnQ29udGVudC1FbmNvZGluZycsXG4gICdDb250ZW50LUxhbmd1YWdlJyxcbiAgJ0NvbnRlbnQtTGVuZ3RoJyxcbiAgJ0NvbnRlbnQtTG9jYXRpb24nLFxuICAnQ29udGVudC1SYW5nZScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeScsXG4gICdDb250ZW50LVNlY3VyaXR5LVBvbGljeS1SZXBvcnQtT25seScsXG4gICdDb250ZW50LVR5cGUnLFxuICAnQ29va2llJyxcbiAgJ0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3knLFxuICAnQ3Jvc3MtT3JpZ2luLVJlc291cmNlLVBvbGljeScsXG4gICdEYXRlJyxcbiAgJ0RldmljZS1NZW1vcnknLFxuICAnRG93bmxpbmsnLFxuICAnRUNUJyxcbiAgJ0VUYWcnLFxuICAnRXhwZWN0JyxcbiAgJ0V4cGVjdC1DVCcsXG4gICdFeHBpcmVzJyxcbiAgJ0ZvcndhcmRlZCcsXG4gICdGcm9tJyxcbiAgJ0hvc3QnLFxuICAnSWYtTWF0Y2gnLFxuICAnSWYtTW9kaWZpZWQtU2luY2UnLFxuICAnSWYtTm9uZS1NYXRjaCcsXG4gICdJZi1SYW5nZScsXG4gICdJZi1Vbm1vZGlmaWVkLVNpbmNlJyxcbiAgJ0tlZXAtQWxpdmUnLFxuICAnTGFzdC1Nb2RpZmllZCcsXG4gICdMaW5rJyxcbiAgJ0xvY2F0aW9uJyxcbiAgJ01heC1Gb3J3YXJkcycsXG4gICdPcmlnaW4nLFxuICAnUGVybWlzc2lvbnMtUG9saWN5JyxcbiAgJ1ByYWdtYScsXG4gICdQcm94eS1BdXRoZW50aWNhdGUnLFxuICAnUHJveHktQXV0aG9yaXphdGlvbicsXG4gICdSVFQnLFxuICAnUmFuZ2UnLFxuICAnUmVmZXJlcicsXG4gICdSZWZlcnJlci1Qb2xpY3knLFxuICAnUmVmcmVzaCcsXG4gICdSZXRyeS1BZnRlcicsXG4gICdTZWMtV2ViU29ja2V0LUFjY2VwdCcsXG4gICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnLFxuICAnU2VjLVdlYlNvY2tldC1LZXknLFxuICAnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcsXG4gICdTZWMtV2ViU29ja2V0LVZlcnNpb24nLFxuICAnU2VydmVyJyxcbiAgJ1NlcnZlci1UaW1pbmcnLFxuICAnU2VydmljZS1Xb3JrZXItQWxsb3dlZCcsXG4gICdTZXJ2aWNlLVdvcmtlci1OYXZpZ2F0aW9uLVByZWxvYWQnLFxuICAnU2V0LUNvb2tpZScsXG4gICdTb3VyY2VNYXAnLFxuICAnU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eScsXG4gICdTdXBwb3J0cy1Mb2FkaW5nLU1vZGUnLFxuICAnVEUnLFxuICAnVGltaW5nLUFsbG93LU9yaWdpbicsXG4gICdUcmFpbGVyJyxcbiAgJ1RyYW5zZmVyLUVuY29kaW5nJyxcbiAgJ1VwZ3JhZGUnLFxuICAnVXBncmFkZS1JbnNlY3VyZS1SZXF1ZXN0cycsXG4gICdVc2VyLUFnZW50JyxcbiAgJ1ZhcnknLFxuICAnVmlhJyxcbiAgJ1dXVy1BdXRoZW50aWNhdGUnLFxuICAnWC1Db250ZW50LVR5cGUtT3B0aW9ucycsXG4gICdYLUROUy1QcmVmZXRjaC1Db250cm9sJyxcbiAgJ1gtRnJhbWUtT3B0aW9ucycsXG4gICdYLVBlcm1pdHRlZC1Dcm9zcy1Eb21haW4tUG9saWNpZXMnLFxuICAnWC1Qb3dlcmVkLUJ5JyxcbiAgJ1gtUmVxdWVzdGVkLVdpdGgnLFxuICAnWC1YU1MtUHJvdGVjdGlvbidcbl1cblxuZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWxsa25vd25IZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICBjb25zdCBrZXkgPSB3ZWxsa25vd25IZWFkZXJOYW1lc1tpXVxuICBjb25zdCBsb3dlckNhc2VkS2V5ID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRba2V5XSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2xvd2VyQ2FzZWRLZXldID1cbiAgICBsb3dlckNhc2VkS2V5XG59XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkLCBudWxsKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2VsbGtub3duSGVhZGVyTmFtZXMsXG4gIGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst undiciDebugLog = util.debuglog('undici')\nconst fetchDebuglog = util.debuglog('fetch')\nconst websocketDebuglog = util.debuglog('websocket')\nlet isClientSet = false\nconst channels = {\n  // Client\n  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n  connected: diagnosticsChannel.channel('undici:client:connected'),\n  connectError: diagnosticsChannel.channel('undici:client:connectError'),\n  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n  // Request\n  create: diagnosticsChannel.channel('undici:request:create'),\n  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n  headers: diagnosticsChannel.channel('undici:request:headers'),\n  trailers: diagnosticsChannel.channel('undici:request:trailers'),\n  error: diagnosticsChannel.channel('undici:request:error'),\n  // WebSocket\n  open: diagnosticsChannel.channel('undici:websocket:open'),\n  close: diagnosticsChannel.channel('undici:websocket:close'),\n  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n  ping: diagnosticsChannel.channel('undici:websocket:ping'),\n  pong: diagnosticsChannel.channel('undici:websocket:pong')\n}\n\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n  const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog\n\n  // Track all Client events\n  diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host }\n    } = evt\n    debuglog(\n      'connecting to %s using %s%s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host }\n    } = evt\n    debuglog(\n      'connected to %s using %s%s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host },\n      error\n    } = evt\n    debuglog(\n      'connection to %s using %s%s errored - %s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version,\n      error.message\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {\n    const {\n      request: { method, path, origin }\n    } = evt\n    debuglog('sending request to %s %s/%s', method, origin, path)\n  })\n\n  // Track Request events\n  diagnosticsChannel.channel('undici:request:headers').subscribe(evt => {\n    const {\n      request: { method, path, origin },\n      response: { statusCode }\n    } = evt\n    debuglog(\n      'received response to %s %s/%s - HTTP %d',\n      method,\n      origin,\n      path,\n      statusCode\n    )\n  })\n\n  diagnosticsChannel.channel('undici:request:trailers').subscribe(evt => {\n    const {\n      request: { method, path, origin }\n    } = evt\n    debuglog('trailers received from %s %s/%s', method, origin, path)\n  })\n\n  diagnosticsChannel.channel('undici:request:error').subscribe(evt => {\n    const {\n      request: { method, path, origin },\n      error\n    } = evt\n    debuglog(\n      'request to %s %s/%s errored - %s',\n      method,\n      origin,\n      path,\n      error.message\n    )\n  })\n\n  isClientSet = true\n}\n\nif (websocketDebuglog.enabled) {\n  if (!isClientSet) {\n    const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog\n    diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debuglog(\n        'connecting to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debuglog(\n        'connected to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host },\n        error\n      } = evt\n      debuglog(\n        'connection to %s%s using %s%s errored - %s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version,\n        error.message\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debuglog('sending request to %s %s/%s', method, origin, path)\n    })\n  }\n\n  // Track all WebSocket events\n  diagnosticsChannel.channel('undici:websocket:open').subscribe(evt => {\n    const {\n      address: { address, port }\n    } = evt\n    websocketDebuglog('connection opened %s%s', address, port ? `:${port}` : '')\n  })\n\n  diagnosticsChannel.channel('undici:websocket:close').subscribe(evt => {\n    const { websocket, code, reason } = evt\n    websocketDebuglog(\n      'closed connection to %s - %s %s',\n      websocket.url,\n      code,\n      reason\n    )\n  })\n\n  diagnosticsChannel.channel('undici:websocket:socket_error').subscribe(err => {\n    websocketDebuglog('connection errored - %s', err.message)\n  })\n\n  diagnosticsChannel.channel('undici:websocket:ping').subscribe(evt => {\n    websocketDebuglog('ping received')\n  })\n\n  diagnosticsChannel.channel('undici:websocket:pong').subscribe(evt => {\n    websocketDebuglog('pong received')\n  })\n}\n\nmodule.exports = {\n  channels\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osMkJBQTJCLG1CQUFPLENBQUMsMERBQTBCO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxrQkFBa0I7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLG9FQUFvRSxLQUFLO0FBQ3pFLEdBQUc7O0FBRUg7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcZGlhZ25vc3RpY3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBkaWFnbm9zdGljc0NoYW5uZWwgPSByZXF1aXJlKCdub2RlOmRpYWdub3N0aWNzX2NoYW5uZWwnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmNvbnN0IHVuZGljaURlYnVnTG9nID0gdXRpbC5kZWJ1Z2xvZygndW5kaWNpJylcbmNvbnN0IGZldGNoRGVidWdsb2cgPSB1dGlsLmRlYnVnbG9nKCdmZXRjaCcpXG5jb25zdCB3ZWJzb2NrZXREZWJ1Z2xvZyA9IHV0aWwuZGVidWdsb2coJ3dlYnNvY2tldCcpXG5sZXQgaXNDbGllbnRTZXQgPSBmYWxzZVxuY29uc3QgY2hhbm5lbHMgPSB7XG4gIC8vIENsaWVudFxuICBiZWZvcmVDb25uZWN0OiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0JyksXG4gIGNvbm5lY3RlZDogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdGVkJyksXG4gIGNvbm5lY3RFcnJvcjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6Y29ubmVjdEVycm9yJyksXG4gIHNlbmRIZWFkZXJzOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpLFxuICAvLyBSZXF1ZXN0XG4gIGNyZWF0ZTogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmNyZWF0ZScpLFxuICBib2R5U2VudDogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmJvZHlTZW50JyksXG4gIGhlYWRlcnM6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJyksXG4gIHRyYWlsZXJzOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6dHJhaWxlcnMnKSxcbiAgZXJyb3I6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicpLFxuICAvLyBXZWJTb2NrZXRcbiAgb3BlbjogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6b3BlbicpLFxuICBjbG9zZTogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6Y2xvc2UnKSxcbiAgc29ja2V0RXJyb3I6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnNvY2tldF9lcnJvcicpLFxuICBwaW5nOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwaW5nJyksXG4gIHBvbmc6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBvbmcnKVxufVxuXG5pZiAodW5kaWNpRGVidWdMb2cuZW5hYmxlZCB8fCBmZXRjaERlYnVnbG9nLmVuYWJsZWQpIHtcbiAgY29uc3QgZGVidWdsb2cgPSBmZXRjaERlYnVnbG9nLmVuYWJsZWQgPyBmZXRjaERlYnVnbG9nIDogdW5kaWNpRGVidWdMb2dcblxuICAvLyBUcmFjayBhbGwgQ2xpZW50IGV2ZW50c1xuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0Jykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ2Nvbm5lY3RpbmcgdG8gJXMgdXNpbmcgJXMlcycsXG4gICAgICBgJHtob3N0fSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICB2ZXJzaW9uXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RlZCcpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZyhcbiAgICAgICdjb25uZWN0ZWQgdG8gJXMgdXNpbmcgJXMlcycsXG4gICAgICBgJHtob3N0fSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICB2ZXJzaW9uXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvcicpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfSxcbiAgICAgIGVycm9yXG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ2Nvbm5lY3Rpb24gdG8gJXMgdXNpbmcgJXMlcyBlcnJvcmVkIC0gJXMnLFxuICAgICAgYCR7aG9zdH0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9YCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgdmVyc2lvbixcbiAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coJ3NlbmRpbmcgcmVxdWVzdCB0byAlcyAlcy8lcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICB9KVxuXG4gIC8vIFRyYWNrIFJlcXVlc3QgZXZlbnRzXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9LFxuICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKFxuICAgICAgJ3JlY2VpdmVkIHJlc3BvbnNlIHRvICVzICVzLyVzIC0gSFRUUCAlZCcsXG4gICAgICBtZXRob2QsXG4gICAgICBvcmlnaW4sXG4gICAgICBwYXRoLFxuICAgICAgc3RhdHVzQ29kZVxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6dHJhaWxlcnMnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coJ3RyYWlsZXJzIHJlY2VpdmVkIGZyb20gJXMgJXMvJXMnLCBtZXRob2QsIG9yaWdpbiwgcGF0aClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH0sXG4gICAgICBlcnJvclxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZyhcbiAgICAgICdyZXF1ZXN0IHRvICVzICVzLyVzIGVycm9yZWQgLSAlcycsXG4gICAgICBtZXRob2QsXG4gICAgICBvcmlnaW4sXG4gICAgICBwYXRoLFxuICAgICAgZXJyb3IubWVzc2FnZVxuICAgIClcbiAgfSlcblxuICBpc0NsaWVudFNldCA9IHRydWVcbn1cblxuaWYgKHdlYnNvY2tldERlYnVnbG9nLmVuYWJsZWQpIHtcbiAgaWYgKCFpc0NsaWVudFNldCkge1xuICAgIGNvbnN0IGRlYnVnbG9nID0gdW5kaWNpRGVidWdMb2cuZW5hYmxlZCA/IHVuZGljaURlYnVnTG9nIDogd2Vic29ja2V0RGVidWdsb2dcbiAgICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpiZWZvcmVDb25uZWN0Jykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdsb2coXG4gICAgICAgICdjb25uZWN0aW5nIHRvICVzJXMgdXNpbmcgJXMlcycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQgPyBgOiR7cG9ydH1gIDogJycsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICApXG4gICAgfSlcblxuICAgIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RlZCcpLnN1YnNjcmliZShldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnbG9nKFxuICAgICAgICAnY29ubmVjdGVkIHRvICVzJXMgdXNpbmcgJXMlcycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQgPyBgOiR7cG9ydH1gIDogJycsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICApXG4gICAgfSlcblxuICAgIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvcicpLnN1YnNjcmliZShldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH0sXG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZyhcbiAgICAgICAgJ2Nvbm5lY3Rpb24gdG8gJXMlcyB1c2luZyAlcyVzIGVycm9yZWQgLSAlcycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQgPyBgOiR7cG9ydH1gIDogJycsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBlcnJvci5tZXNzYWdlXG4gICAgICApXG4gICAgfSlcblxuICAgIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfVxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdsb2coJ3NlbmRpbmcgcmVxdWVzdCB0byAlcyAlcy8lcycsIG1ldGhvZCwgb3JpZ2luLCBwYXRoKVxuICAgIH0pXG4gIH1cblxuICAvLyBUcmFjayBhbGwgV2ViU29ja2V0IGV2ZW50c1xuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpvcGVuJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzczogeyBhZGRyZXNzLCBwb3J0IH1cbiAgICB9ID0gZXZ0XG4gICAgd2Vic29ja2V0RGVidWdsb2coJ2Nvbm5lY3Rpb24gb3BlbmVkICVzJXMnLCBhZGRyZXNzLCBwb3J0ID8gYDoke3BvcnR9YCA6ICcnKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3QgeyB3ZWJzb2NrZXQsIGNvZGUsIHJlYXNvbiB9ID0gZXZ0XG4gICAgd2Vic29ja2V0RGVidWdsb2coXG4gICAgICAnY2xvc2VkIGNvbm5lY3Rpb24gdG8gJXMgLSAlcyAlcycsXG4gICAgICB3ZWJzb2NrZXQudXJsLFxuICAgICAgY29kZSxcbiAgICAgIHJlYXNvblxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InKS5zdWJzY3JpYmUoZXJyID0+IHtcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygnY29ubmVjdGlvbiBlcnJvcmVkIC0gJXMnLCBlcnIubWVzc2FnZSlcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwaW5nJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgd2Vic29ja2V0RGVidWdsb2coJ3BpbmcgcmVjZWl2ZWQnKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OnBvbmcnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICB3ZWJzb2NrZXREZWJ1Z2xvZygncG9uZyByZWNlaXZlZCcpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjaGFubmVsc1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass ResponseStatusCodeError extends UndiciError {\n  constructor (message, statusCode, headers, body) {\n    super(message)\n    this.name = 'ResponseStatusCodeError'\n    this.message = message || 'Response Status Code Error'\n    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'\n    this.body = body\n    this.status = statusCode\n    this.statusCode = statusCode\n    this.headers = headers\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass AbortError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'The operation was aborted'\n  }\n}\n\nclass RequestAbortedError extends AbortError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n}\n\nclass RequestRetryError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'RequestRetryError'\n    this.message = message || 'Request retry error'\n    this.code = 'UND_ERR_REQ_RETRY'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n}\n\nclass SecureProxyConnectionError extends UndiciError {\n  constructor (cause, message, options) {\n    super(message, { cause, ...(options ?? {}) })\n    this.name = 'SecureProxyConnectionError'\n    this.message = message || 'Secure Proxy Connection failed'\n    this.code = 'UND_ERR_PRX_TLS'\n    this.cause = cause\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  ResponseStatusCodeError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError,\n  RequestRetryError,\n  SecureProxyConnectionError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgVW5kaWNpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnVW5kaWNpRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlInXG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc092ZXJmbG93RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc092ZXJmbG93RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBPdmVyZmxvdyBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XJ1xuICB9XG59XG5cbmNsYXNzIEJvZHlUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQm9keVRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdCb2R5IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQk9EWV9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlU3RhdHVzQ29kZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFJ1xuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgQXJndW1lbnQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9BUkcnXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cbn1cblxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdEFib3J0ZWRFcnJvciBleHRlbmRzIEFib3J0RXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgSW5mb3JtYXRpb25hbEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0luZm9ybWF0aW9uYWxFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGluZm9ybWF0aW9uJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lORk8nXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50RGVzdHJveWVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBkZXN0cm95ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfREVTVFJPWUVEJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudENsb3NlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudENsb3NlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgY2xvc2VkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NMT1NFRCdcbiAgfVxufVxuXG5jbGFzcyBTb2NrZXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1NvY2tldEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NvY2tldCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9TT0NLRVQnXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdOb3Qgc3VwcG9ydGVkIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX05PVF9TVVBQT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1Vwc3RyZWFtRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm8gdXBzdHJlYW0gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIEJhbGFuY2VkUG9vbCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTSdcbiAgfVxufVxuXG5jbGFzcyBIVFRQUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19FWENFRURFRF9NQVhfU0laRSdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0UmV0cnlFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdFJldHJ5RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCByZXRyeSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfUkVUUlknXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChjYXVzZSwgbWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UsIC4uLihvcHRpb25zID8/IHt9KSB9KVxuICAgIHRoaXMubmFtZSA9ICdTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdTZWN1cmUgUHJveHkgQ29ubmVjdGlvbiBmYWlsZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfUFJYX1RMUydcbiAgICB0aGlzLmNhdXNlID0gY2F1c2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQWJvcnRFcnJvcixcbiAgSFRUUFBhcnNlckVycm9yLFxuICBVbmRpY2lFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQ29ubmVjdFRpbWVvdXRFcnJvcixcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IsXG4gIFJlcXVlc3RSZXRyeUVycm9yLFxuICBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  buildURL,\n  validateHandler,\n  getServerName,\n  normalizedMethodRecords\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\")\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue,\n    servername\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.throwOnError = throwOnError === true\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? buildURL(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    validateHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNERBQVE7QUFDcEIsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDL0MsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhOztBQUU1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMkJBQTJCLG1DQUFtQztBQUMvRjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCxLQUFLO0FBQ3ZELFFBQVE7QUFDUixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixhQUFhLElBQUk7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOENBQThDLFlBQVk7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBOb3RTdXBwb3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1N0cmVhbSxcbiAgZGVzdHJveSxcbiAgaXNCdWZmZXIsXG4gIGlzRm9ybURhdGFMaWtlLFxuICBpc0l0ZXJhYmxlLFxuICBpc0Jsb2JMaWtlLFxuICBidWlsZFVSTCxcbiAgdmFsaWRhdGVIYW5kbGVyLFxuICBnZXRTZXJ2ZXJOYW1lLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1xufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IHsgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gVmVyaWZpZXMgdGhhdCBhIGdpdmVuIHBhdGggaXMgdmFsaWQgZG9lcyBub3QgY29udGFpbiBjb250cm9sIGNoYXJzIFxceDAwIHRvIFxceDIwXG5jb25zdCBpbnZhbGlkUGF0aFJlZ2V4ID0gL1teXFx1MDAyMS1cXHUwMGZmXS9cblxuY29uc3Qga0hhbmRsZXIgPSBTeW1ib2woJ2hhbmRsZXInKVxuXG5jbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeSxcbiAgICBpZGVtcG90ZW50LFxuICAgIGJsb2NraW5nLFxuICAgIHVwZ3JhZGUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgYm9keVRpbWVvdXQsXG4gICAgcmVzZXQsXG4gICAgdGhyb3dPbkVycm9yLFxuICAgIGV4cGVjdENvbnRpbnVlLFxuICAgIHNlcnZlcm5hbWVcbiAgfSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncGF0aCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAhKHBhdGguc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8IHBhdGguc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBhYnNvbHV0ZSBVUkwgb3Igc3RhcnQgd2l0aCBhIHNsYXNoJylcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQYXRoUmVnZXgudGVzdChwYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgcGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF0gPT09IHVuZGVmaW5lZCAmJiAhaXNWYWxpZEhUVFBUb2tlbihtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVxdWVzdCBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlICYmIHR5cGVvZiB1cGdyYWRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1cGdyYWRlIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyc1RpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGJvZHlUaW1lb3V0KSB8fCBib2R5VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgYm9keVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChyZXNldCAhPSBudWxsICYmIHR5cGVvZiByZXNldCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgcmVzZXQnKVxuICAgIH1cblxuICAgIGlmIChleHBlY3RDb250aW51ZSAhPSBudWxsICYmIHR5cGVvZiBleHBlY3RDb250aW51ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZXhwZWN0Q29udGludWUnKVxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyc1RpbWVvdXQgPSBoZWFkZXJzVGltZW91dFxuXG4gICAgdGhpcy5ib2R5VGltZW91dCA9IGJvZHlUaW1lb3V0XG5cbiAgICB0aGlzLnRocm93T25FcnJvciA9IHRocm93T25FcnJvciA9PT0gdHJ1ZVxuXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcblxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJvZHkgPSBudWxsXG4gICAgfSBlbHNlIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuXG4gICAgICBjb25zdCByU3RhdGUgPSB0aGlzLmJvZHkuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmICghclN0YXRlIHx8ICFyU3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbmRIYW5kbGVyID0gZnVuY3Rpb24gYXV0b0Rlc3Ryb3kgKCkge1xuICAgICAgICAgIGRlc3Ryb3kodGhpcylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkub24oJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnIgPT4ge1xuICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ib2R5Lm9uKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAoaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnl0ZUxlbmd0aCA/IGJvZHkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkuYnVmZmVyLmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpIDogbnVsbFxuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5sZW5ndGggPyBCdWZmZXIuZnJvbShib2R5KSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGlzRm9ybURhdGFMaWtlKGJvZHkpIHx8IGlzSXRlcmFibGUoYm9keSkgfHwgaXNCbG9iTGlrZShib2R5KSkge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2JvZHkgbXVzdCBiZSBhIHN0cmluZywgYSBCdWZmZXIsIGEgUmVhZGFibGUgc3RyZWFtLCBhbiBpdGVyYWJsZSwgb3IgYW4gYXN5bmMgaXRlcmFibGUnKVxuICAgIH1cblxuICAgIHRoaXMuY29tcGxldGVkID0gZmFsc2VcblxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnVwZ3JhZGUgPSB1cGdyYWRlIHx8IG51bGxcblxuICAgIHRoaXMucGF0aCA9IHF1ZXJ5ID8gYnVpbGRVUkwocGF0aCwgcXVlcnkpIDogcGF0aFxuXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cblxuICAgIHRoaXMuaWRlbXBvdGVudCA9IGlkZW1wb3RlbnQgPT0gbnVsbFxuICAgICAgPyBtZXRob2QgPT09ICdIRUFEJyB8fCBtZXRob2QgPT09ICdHRVQnXG4gICAgICA6IGlkZW1wb3RlbnRcblxuICAgIHRoaXMuYmxvY2tpbmcgPSBibG9ja2luZyA9PSBudWxsID8gZmFsc2UgOiBibG9ja2luZ1xuXG4gICAgdGhpcy5yZXNldCA9IHJlc2V0ID09IG51bGwgPyBudWxsIDogcmVzZXRcblxuICAgIHRoaXMuaG9zdCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IG51bGxcblxuICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsXG5cbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuXG4gICAgLy8gT25seSBmb3IgSDJcbiAgICB0aGlzLmV4cGVjdENvbnRpbnVlID0gZXhwZWN0Q29udGludWUgIT0gbnVsbCA/IGV4cGVjdENvbnRpbnVlIDogZmFsc2VcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBpZiAoaGVhZGVycy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBhcnJheSBtdXN0IGJlIGV2ZW4nKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGhlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikgfHwgaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgaW4ga2V5LXZhbHVlIHBhaXIgZm9ybWF0JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzc0hlYWRlcih0aGlzLCBoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5c1tpXSwgaGVhZGVyc1trZXlzW2ldXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICAgIH1cblxuICAgIHZhbGlkYXRlSGFuZGxlcihoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpXG5cbiAgICB0aGlzLnNlcnZlcm5hbWUgPSBzZXJ2ZXJuYW1lIHx8IGdldFNlcnZlck5hbWUodGhpcy5ob3N0KVxuXG4gICAgdGhpc1trSGFuZGxlcl0gPSBoYW5kbGVyXG5cbiAgICBpZiAoY2hhbm5lbHMuY3JlYXRlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jcmVhdGUucHVibGlzaCh7IHJlcXVlc3Q6IHRoaXMgfSlcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vbkJvZHlTZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAoY2hhbm5lbHMuYm9keVNlbnQuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmJvZHlTZW50LnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0hhbmRsZXJdLm9uUmVxdWVzdFNlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICBhYm9ydCh0aGlzLmVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkNvbm5lY3QoYWJvcnQpXG4gICAgfVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vblJlc3BvbnNlU3RhcnRlZD8uKClcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIGlmIChjaGFubmVscy5oZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5oZWFkZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCByZXNwb25zZTogeyBzdGF0dXNDb2RlLCBoZWFkZXJzLCBzdGF0dXNUZXh0IH0gfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFib3J0KGVycilcbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG4gICAgYXNzZXJ0KCF0aGlzLmNvbXBsZXRlZClcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25EYXRhKGNodW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgYXNzZXJ0KCF0aGlzLmFib3J0ZWQpXG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWVcbiAgICBpZiAoY2hhbm5lbHMudHJhaWxlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLnRyYWlsZXJzLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCB0cmFpbGVycyB9KVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFRoaXMgbWlnaHQgYmUgYSBiYWQgaWRlYT9cbiAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRmluYWxseSgpXG5cbiAgICBpZiAoY2hhbm5lbHMuZXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzLCBlcnJvciB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlXG5cbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uRmluYWxseSAoKSB7XG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyKSB7XG4gICAgICB0aGlzLmJvZHkub2ZmKCdlcnJvcicsIHRoaXMuZXJyb3JIYW5kbGVyKVxuICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kSGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZW5kJywgdGhpcy5lbmRIYW5kbGVyKVxuICAgICAgdGhpcy5lbmRIYW5kbGVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGFkZEhlYWRlciAoa2V5LCB2YWx1ZSkge1xuICAgIHByb2Nlc3NIZWFkZXIodGhpcywga2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIgKHJlcXVlc3QsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgaGVhZGVyTmFtZSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2tleV1cblxuICBpZiAoaGVhZGVyTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGVhZGVyTmFtZSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2hlYWRlck5hbWVdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4oaGVhZGVyTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoZWFkZXIga2V5JylcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbFtpXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICAgIH1cbiAgICAgICAgYXJyLnB1c2godmFsW2ldKVxuICAgICAgfSBlbHNlIGlmICh2YWxbaV0gPT09IG51bGwpIHtcbiAgICAgICAgYXJyLnB1c2goJycpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWxbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyci5wdXNoKGAke3ZhbFtpXX1gKVxuICAgICAgfVxuICAgIH1cbiAgICB2YWwgPSBhcnJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgdmFsID0gJydcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBgJHt2YWx9YFxuICB9XG5cbiAgaWYgKHJlcXVlc3QuaG9zdCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnaG9zdCcpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBob3N0IGhlYWRlcicpXG4gICAgfVxuICAgIC8vIENvbnN1bWVkIGJ5IENsaWVudFxuICAgIHJlcXVlc3QuaG9zdCA9IHZhbFxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudExlbmd0aCA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC1sZW5ndGgnKSB7XG4gICAgcmVxdWVzdC5jb250ZW50TGVuZ3RoID0gcGFyc2VJbnQodmFsLCAxMClcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXF1ZXN0LmNvbnRlbnRMZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29udGVudC1sZW5ndGggaGVhZGVyJylcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PT0gbnVsbCAmJiBoZWFkZXJOYW1lID09PSAnY29udGVudC10eXBlJykge1xuICAgIHJlcXVlc3QuY29udGVudFR5cGUgPSB2YWxcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAndHJhbnNmZXItZW5jb2RpbmcnIHx8IGhlYWRlck5hbWUgPT09ICdrZWVwLWFsaXZlJyB8fCBoZWFkZXJOYW1lID09PSAndXBncmFkZScpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtoZWFkZXJOYW1lfSBoZWFkZXJgKVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdjb25uZWN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyB2YWwudG9Mb3dlckNhc2UoKSA6IG51bGxcbiAgICBpZiAodmFsdWUgIT09ICdjbG9zZScgJiYgdmFsdWUgIT09ICdrZWVwLWFsaXZlJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbm5lY3Rpb24gaGVhZGVyJylcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICdjbG9zZScpIHtcbiAgICAgIHJlcXVlc3QucmVzZXQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlck5hbWUgPT09ICdleHBlY3QnKSB7XG4gICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdleHBlY3QgaGVhZGVyIG5vdCBzdXBwb3J0ZWQnKVxuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuaGVhZGVycy5wdXNoKGtleSwgdmFsKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("module.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kBody: Symbol('abstracted request body'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kResume: Symbol('resume'),\n  kOnError: Symbol('on error'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kInterceptors: Symbol('dispatch interceptors'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n  kConstruct: Symbol('constructable'),\n  kListeners: Symbol('listeners'),\n  kHTTPContext: Symbol('http context'),\n  kMaxConcurrentStreams: Symbol('max concurrent streams'),\n  kNoProxyAgent: Symbol('no proxy agent'),\n  kHttpProxyAgent: Symbol('http proxy agent'),\n  kHttpsProxyAgent: Symbol('https proxy agent')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFxzeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga0Rlc3Ryb3k6IFN5bWJvbCgnZGVzdHJveScpLFxuICBrRGlzcGF0Y2g6IFN5bWJvbCgnZGlzcGF0Y2gnKSxcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga1dyaXRpbmc6IFN5bWJvbCgnd3JpdGluZycpLFxuICBrUmVzdW1pbmc6IFN5bWJvbCgncmVzdW1pbmcnKSxcbiAga1F1ZXVlOiBTeW1ib2woJ3F1ZXVlJyksXG4gIGtDb25uZWN0OiBTeW1ib2woJ2Nvbm5lY3QnKSxcbiAga0Nvbm5lY3Rpbmc6IFN5bWJvbCgnY29ubmVjdGluZycpLFxuICBrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXQ6IFN5bWJvbCgnZGVmYXVsdCBrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZU1heFRpbWVvdXQ6IFN5bWJvbCgnbWF4IGtlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZDogU3ltYm9sKCdrZWVwIGFsaXZlIHRpbWVvdXQgdGhyZXNob2xkJyksXG4gIGtLZWVwQWxpdmVUaW1lb3V0VmFsdWU6IFN5bWJvbCgna2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmU6IFN5bWJvbCgna2VlcCBhbGl2ZScpLFxuICBrSGVhZGVyc1RpbWVvdXQ6IFN5bWJvbCgnaGVhZGVycyB0aW1lb3V0JyksXG4gIGtCb2R5VGltZW91dDogU3ltYm9sKCdib2R5IHRpbWVvdXQnKSxcbiAga1NlcnZlck5hbWU6IFN5bWJvbCgnc2VydmVyIG5hbWUnKSxcbiAga0xvY2FsQWRkcmVzczogU3ltYm9sKCdsb2NhbCBhZGRyZXNzJyksXG4gIGtIb3N0OiBTeW1ib2woJ2hvc3QnKSxcbiAga05vUmVmOiBTeW1ib2woJ25vIHJlZicpLFxuICBrQm9keVVzZWQ6IFN5bWJvbCgndXNlZCcpLFxuICBrQm9keTogU3ltYm9sKCdhYnN0cmFjdGVkIHJlcXVlc3QgYm9keScpLFxuICBrUnVubmluZzogU3ltYm9sKCdydW5uaW5nJyksXG4gIGtCbG9ja2luZzogU3ltYm9sKCdibG9ja2luZycpLFxuICBrUGVuZGluZzogU3ltYm9sKCdwZW5kaW5nJyksXG4gIGtTaXplOiBTeW1ib2woJ3NpemUnKSxcbiAga0J1c3k6IFN5bWJvbCgnYnVzeScpLFxuICBrUXVldWVkOiBTeW1ib2woJ3F1ZXVlZCcpLFxuICBrRnJlZTogU3ltYm9sKCdmcmVlJyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJyksXG4gIGtDbG9zZWQ6IFN5bWJvbCgnY2xvc2VkJyksXG4gIGtOZWVkRHJhaW46IFN5bWJvbCgnbmVlZCBkcmFpbicpLFxuICBrUmVzZXQ6IFN5bWJvbCgncmVzZXQnKSxcbiAga0Rlc3Ryb3llZDogU3ltYm9sLmZvcignbm9kZWpzLnN0cmVhbS5kZXN0cm95ZWQnKSxcbiAga1Jlc3VtZTogU3ltYm9sKCdyZXN1bWUnKSxcbiAga09uRXJyb3I6IFN5bWJvbCgnb24gZXJyb3InKSxcbiAga01heEhlYWRlcnNTaXplOiBTeW1ib2woJ21heCBoZWFkZXJzIHNpemUnKSxcbiAga1J1bm5pbmdJZHg6IFN5bWJvbCgncnVubmluZyBpbmRleCcpLFxuICBrUGVuZGluZ0lkeDogU3ltYm9sKCdwZW5kaW5nIGluZGV4JyksXG4gIGtFcnJvcjogU3ltYm9sKCdlcnJvcicpLFxuICBrQ2xpZW50czogU3ltYm9sKCdjbGllbnRzJyksXG4gIGtDbGllbnQ6IFN5bWJvbCgnY2xpZW50JyksXG4gIGtQYXJzZXI6IFN5bWJvbCgncGFyc2VyJyksXG4gIGtPbkRlc3Ryb3llZDogU3ltYm9sKCdkZXN0cm95IGNhbGxiYWNrcycpLFxuICBrUGlwZWxpbmluZzogU3ltYm9sKCdwaXBlbGluaW5nJyksXG4gIGtTb2NrZXQ6IFN5bWJvbCgnc29ja2V0JyksXG4gIGtIb3N0SGVhZGVyOiBTeW1ib2woJ2hvc3QgaGVhZGVyJyksXG4gIGtDb25uZWN0b3I6IFN5bWJvbCgnY29ubmVjdG9yJyksXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoOiBTeW1ib2woJ3N0cmljdCBjb250ZW50IGxlbmd0aCcpLFxuICBrTWF4UmVkaXJlY3Rpb25zOiBTeW1ib2woJ21heFJlZGlyZWN0aW9ucycpLFxuICBrTWF4UmVxdWVzdHM6IFN5bWJvbCgnbWF4UmVxdWVzdHNQZXJDbGllbnQnKSxcbiAga1Byb3h5OiBTeW1ib2woJ3Byb3h5IGFnZW50IG9wdGlvbnMnKSxcbiAga0NvdW50ZXI6IFN5bWJvbCgnc29ja2V0IHJlcXVlc3QgY291bnRlcicpLFxuICBrSW50ZXJjZXB0b3JzOiBTeW1ib2woJ2Rpc3BhdGNoIGludGVyY2VwdG9ycycpLFxuICBrTWF4UmVzcG9uc2VTaXplOiBTeW1ib2woJ21heCByZXNwb25zZSBzaXplJyksXG4gIGtIVFRQMlNlc3Npb246IFN5bWJvbCgnaHR0cDJTZXNzaW9uJyksXG4gIGtIVFRQMlNlc3Npb25TdGF0ZTogU3ltYm9sKCdodHRwMlNlc3Npb24gc3RhdGUnKSxcbiAga1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeTogU3ltYm9sKCdyZXRyeSBhZ2VudCBkZWZhdWx0IHJldHJ5JyksXG4gIGtDb25zdHJ1Y3Q6IFN5bWJvbCgnY29uc3RydWN0YWJsZScpLFxuICBrTGlzdGVuZXJzOiBTeW1ib2woJ2xpc3RlbmVycycpLFxuICBrSFRUUENvbnRleHQ6IFN5bWJvbCgnaHR0cCBjb250ZXh0JyksXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtczogU3ltYm9sKCdtYXggY29uY3VycmVudCBzdHJlYW1zJyksXG4gIGtOb1Byb3h5QWdlbnQ6IFN5bWJvbCgnbm8gcHJveHkgYWdlbnQnKSxcbiAga0h0dHBQcm94eUFnZW50OiBTeW1ib2woJ2h0dHAgcHJveHkgYWdlbnQnKSxcbiAga0h0dHBzUHJveHlBZ2VudDogU3ltYm9sKCdodHRwcyBwcm94eSBhZ2VudCcpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\")\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWE7O0FBRXpCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFx0cmVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIHdlbGxrbm93bkhlYWRlck5hbWVzLFxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY2xhc3MgVHN0Tm9kZSB7XG4gIC8qKiBAdHlwZSB7YW55fSAqL1xuICB2YWx1ZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbGVmdCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgbWlkZGxlID0gbnVsbFxuICAvKiogQHR5cGUge251bGwgfCBUc3ROb2RlfSAqL1xuICByaWdodCA9IG51bGxcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGNvZGVcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0ga2V5Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBjb25zdCBjb2RlID0gdGhpcy5jb2RlID0ga2V5LmNoYXJDb2RlQXQoaW5kZXgpXG4gICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleSBtdXN0IGJlIGFzY2lpIHN0cmluZycpXG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoICE9PSArK2luZGV4KSB7XG4gICAgICB0aGlzLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIGFkZCAoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGtleS5sZW5ndGhcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlYWNoYWJsZScpXG4gICAgfVxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbm9kZSA9IHRoaXNcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY29kZSA9IGtleS5jaGFyQ29kZUF0KGluZGV4KVxuICAgICAgLy8gY2hlY2sgY29kZSBpcyBhc2NpaSBzdHJpbmdcbiAgICAgIGlmIChjb2RlID4gMHg3Rikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXkgbXVzdCBiZSBhc2NpaSBzdHJpbmcnKVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY29kZSA9PT0gY29kZSkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSArK2luZGV4KSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm1pZGRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLm1pZGRsZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubWlkZGxlID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNvZGUgPCBjb2RlKSB7XG4gICAgICAgIGlmIChub2RlLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJpZ2h0ID0gbmV3IFRzdE5vZGUoa2V5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5XG4gICAqIEByZXR1cm4ge1RzdE5vZGUgfCBudWxsfVxuICAgKi9cbiAgc2VhcmNoIChrZXkpIHtcbiAgICBjb25zdCBrZXlsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBub2RlID0gdGhpc1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGluZGV4IDwga2V5bGVuZ3RoKSB7XG4gICAgICBsZXQgY29kZSA9IGtleVtpbmRleF1cbiAgICAgIC8vIEEtWlxuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgaXQgaXMgYmlnZ2VyIHRoYW4gMHg1YS5cbiAgICAgIC8vIExvd2VyY2FzZSBsZXR0ZXJzIGhhdmUgaGlnaGVyIGNoYXIgY29kZXMgdGhhbiB1cHBlcmNhc2Ugb25lcy5cbiAgICAgIC8vIEFsc28gd2UgYXNzdW1lIHRoYXQgaGVhZGVycyB3aWxsIG1vc3RseSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLlxuICAgICAgaWYgKGNvZGUgPD0gMHg1YSAmJiBjb2RlID49IDB4NDEpIHtcbiAgICAgICAgLy8gTG93ZXJjYXNlIGZvciB1cHBlcmNhc2UuXG4gICAgICAgIGNvZGUgfD0gMzJcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjb2RlID09PSBub2RlLmNvZGUpIHtcbiAgICAgICAgICBpZiAoa2V5bGVuZ3RoID09PSArK2luZGV4KSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIE5vZGUgc2luY2UgaXQgaXMgdGhlIGxhc3Qga2V5LlxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUubWlkZGxlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5jb2RlIDwgY29kZSA/IG5vZGUubGVmdCA6IG5vZGUucmlnaHRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jbGFzcyBUZXJuYXJ5U2VhcmNoVHJlZSB7XG4gIC8qKiBAdHlwZSB7VHN0Tm9kZSB8IG51bGx9ICovXG4gIG5vZGUgPSBudWxsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqICovXG4gIGluc2VydCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLm5vZGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZS5hZGQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXlcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgbG9va3VwIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlPy5zZWFyY2goa2V5KT8udmFsdWUgPz8gbnVsbFxuICB9XG59XG5cbmNvbnN0IHRyZWUgPSBuZXcgVGVybmFyeVNlYXJjaFRyZWUoKVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IHdlbGxrbm93bkhlYWRlck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gIGNvbnN0IGtleSA9IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW3dlbGxrbm93bkhlYWRlck5hbWVzW2ldXVxuICB0cmVlLmluc2VydChrZXksIGtleSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRlcm5hcnlTZWFyY2hUcmVlLFxuICB0cmVlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\")\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/core/constants.js\")\nconst { tree } = __webpack_require__(/*! ./tree */ \"(ssr)/./node_modules/undici/lib/core/tree.js\")\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v))\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nfunction wrapRequestBody (body) {\n  if (isStream(body)) {\n    // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n    // so that it can be dispatched again?\n    // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n    if (bodyLength(body) === 0) {\n      body\n        .on('data', function () {\n          assert(false)\n        })\n    }\n\n    if (typeof body.readableDidRead !== 'boolean') {\n      body[kBodyUsed] = false\n      EE.prototype.on.call(body, 'data', function () {\n        this[kBodyUsed] = true\n      })\n    }\n\n    return body\n  } else if (body && typeof body.pipeTo === 'function') {\n    // TODO (fix): We can't access ReadableStream internal state\n    // to determine whether or not it has been disturbed. This is just\n    // a workaround.\n    return new BodyAsyncIterable(body)\n  } else if (\n    body &&\n    typeof body !== 'string' &&\n    !ArrayBuffer.isView(body) &&\n    isIterable(body)\n  ) {\n    // TODO: Should we allow re-using iterable if !this.opts.idempotent\n    // or through some other flag?\n    return new BodyAsyncIterable(body)\n  } else {\n    return body\n  }\n}\n\nfunction nop () {}\n\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  if (object === null) {\n    return false\n  } else if (object instanceof Blob) {\n    return true\n  } else if (typeof object !== 'object') {\n    return false\n  } else {\n    const sTag = object[Symbol.toStringTag]\n\n    return (sTag === 'Blob' || sTag === 'File') && (\n      ('stream' in object && typeof object.stream === 'function') ||\n      ('arrayBuffer' in object && typeof object.arrayBuffer === 'function')\n    )\n  }\n}\n\nfunction buildURL (url, queryParams) {\n  if (url.includes('?') || url.includes('#')) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\nfunction isValidPort (port) {\n  const value = parseInt(port, 10)\n  return (\n    value === Number(port) &&\n    value >= 0 &&\n    value <= 65535\n  )\n}\n\nfunction isHttpOrHttpsPrefixed (value) {\n  return (\n    value != null &&\n    value[0] === 'h' &&\n    value[1] === 't' &&\n    value[2] === 't' &&\n    value[3] === 'p' &&\n    (\n      value[4] === ':' ||\n      (\n        value[4] === 's' &&\n        value[5] === ':'\n      )\n    )\n  )\n}\n\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol || ''}//${url.hostname || ''}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin[origin.length - 1] === '/') {\n      origin = origin.slice(0, origin.length - 1)\n    }\n\n    if (path && path[0] !== '/') {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    return new URL(`${origin}${path}`)\n  }\n\n  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  return url\n}\n\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substring(1, idx)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substring(0, idx)\n}\n\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert.strictEqual(typeof host, 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\nfunction isDestroyed (body) {\n  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))\n}\n\nfunction destroy (stream, err) {\n  if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    queueMicrotask(() => {\n      stream.emit('error', err)\n    })\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */\nfunction headerNameToString (value) {\n  return typeof value === 'string'\n    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()\n    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */\nfunction bufferToLowerCasedHeaderName (value) {\n  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */\nfunction parseHeaders (headers, obj) {\n  if (obj === undefined) obj = {}\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headerNameToString(headers[i])\n    let val = obj[key]\n\n    if (val) {\n      if (typeof val === 'string') {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('utf8'))\n    } else {\n      const headersValue = headers[i + 1]\n      if (typeof headersValue === 'string') {\n        obj[key] = headersValue\n      } else {\n        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('utf8')) : headersValue.toString('utf8')\n      }\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if ('content-length' in obj && 'content-disposition' in obj) {\n    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')\n  }\n\n  return obj\n}\n\nfunction parseRawHeaders (headers) {\n  const len = headers.length\n  const ret = new Array(len)\n\n  let hasContentLength = false\n  let contentDispositionIdx = -1\n  let key\n  let val\n  let kLen = 0\n\n  for (let n = 0; n < headers.length; n += 2) {\n    key = headers[n]\n    val = headers[n + 1]\n\n    typeof key !== 'string' && (key = key.toString())\n    typeof val !== 'string' && (val = val.toString('utf8'))\n\n    kLen = key.length\n    if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n      hasContentLength = true\n    } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n      contentDispositionIdx = n + 1\n    }\n    ret[n] = key\n    ret[n + 1] = val\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if (hasContentLength && contentDispositionIdx !== -1) {\n    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')\n  }\n\n  return ret\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction validateHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed (body) {\n  // TODO (fix): Why is body[kBodyUsed] needed?\n  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))\n}\n\nfunction isErrored (body) {\n  return !!(body && stream.isErrored(body))\n}\n\nfunction isReadable (body) {\n  return !!(body && stream.isReadable(body))\n}\n\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\n/** @type {globalThis['ReadableStream']} */\nfunction ReadableStreamFrom (iterable) {\n  // We cannot use ReadableStream.from here because it does not return a byte stream.\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          if (buf.byteLength) {\n            controller.enqueue(new Uint8Array(buf))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    }\n  )\n}\n\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction addAbortListener (signal, listener) {\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.addListener('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\nconst hasToWellFormed = typeof String.prototype.toWellFormed === 'function'\nconst hasIsWellFormed = typeof String.prototype.isWellFormed === 'function'\n\n/**\n * @param {string} val\n */\nfunction toUSVString (val) {\n  return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val)\n}\n\n/**\n * @param {string} val\n */\n// TODO: move this to webidl\nfunction isUSVString (val) {\n  return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n/**\n * @param {string} characters\n */\nfunction isValidHeaderValue (characters) {\n  return !headerCharRegex.test(characters)\n}\n\n// Parsed accordingly to RFC 9110\n// https://www.rfc-editor.org/rfc/rfc9110#field.content-range\nfunction parseRangeHeader (range) {\n  if (range == null || range === '') return { start: 0, end: null, size: null }\n\n  const m = range ? range.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null\n  return m\n    ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n      }\n    : null\n}\n\nfunction addListener (obj, name, listener) {\n  const listeners = (obj[kListeners] ??= [])\n  listeners.push([name, listener])\n  obj.on(name, listener)\n  return obj\n}\n\nfunction removeAllListeners (obj) {\n  for (const [name, listener] of obj[kListeners] ?? []) {\n    obj.removeListener(name, listener)\n  }\n  obj[kListeners] = null\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nconst normalizedMethodRecordsBase = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\nconst normalizedMethodRecords = {\n  ...normalizedMethodRecordsBase,\n  patch: 'patch',\n  PATCH: 'PATCH'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null)\nObject.setPrototypeOf(normalizedMethodRecords, null)\n\nmodule.exports = {\n  kEnumerableProperty,\n  nop,\n  isDisturbed,\n  isErrored,\n  isReadable,\n  toUSVString,\n  isUSVString,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  headerNameToString,\n  bufferToLowerCasedHeaderName,\n  addListener,\n  removeAllListeners,\n  errorRequest,\n  parseRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  validateHandler,\n  getSocketInfo,\n  isFormDataLike,\n  buildURL,\n  addAbortListener,\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isTokenCharCode,\n  parseRangeHeader,\n  normalizedMethodRecordsBase,\n  normalizedMethodRecords,\n  isValidPort,\n  isHttpOrHttpsPrefixed,\n  nodeMajor,\n  nodeMinor,\n  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE'],\n  wrapRequestBody\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUN4RSxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwQkFBVTtBQUM5QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ2hELFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNsRCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDbkQsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhO0FBQzVELFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsNERBQVE7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxjb3JlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGtEZXN0cm95ZWQsIGtCb2R5VXNlZCwga0xpc3RlbmVycywga0JvZHkgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IEluY29taW5nTWVzc2FnZSB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25vZGU6bmV0JylcbmNvbnN0IHsgQmxvYiB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJ25vZGU6cXVlcnlzdHJpbmcnKVxuY29uc3QgeyBFdmVudEVtaXR0ZXI6IEVFIH0gPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCB7IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IHRyZWUgfSA9IHJlcXVpcmUoJy4vdHJlZScpXG5cbmNvbnN0IFtub2RlTWFqb3IsIG5vZGVNaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKS5tYXAodiA9PiBOdW1iZXIodikpXG5cbmNsYXNzIEJvZHlBc3luY0l0ZXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKGJvZHkpIHtcbiAgICB0aGlzW2tCb2R5XSA9IGJvZHlcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZVxuICB9XG5cbiAgYXN5bmMgKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgJ2Rpc3R1cmJlZCcpXG4gICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgIHlpZWxkICogdGhpc1trQm9keV1cbiAgfVxufVxuXG5mdW5jdGlvbiB3cmFwUmVxdWVzdEJvZHkgKGJvZHkpIHtcbiAgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgLy8gVE9ETyAoZml4KTogUHJvdmlkZSBzb21lIHdheSBmb3IgdGhlIHVzZXIgdG8gY2FjaGUgdGhlIGZpbGUgdG8gZS5nLiAvdG1wXG4gICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBhZ2Fpbj9cbiAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgaWYgKGJvZHlMZW5ndGgoYm9keSkgPT09IDApIHtcbiAgICAgIGJvZHlcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJvZHkucmVhZGFibGVEaWRSZWFkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIGJvZHlba0JvZHlVc2VkXSA9IGZhbHNlXG4gICAgICBFRS5wcm90b3R5cGUub24uY2FsbChib2R5LCAnZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keVxuICB9IGVsc2UgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucGlwZVRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGRpc3R1cmJlZC4gVGhpcyBpcyBqdXN0XG4gICAgLy8gYSB3b3JrYXJvdW5kLlxuICAgIHJldHVybiBuZXcgQm9keUFzeW5jSXRlcmFibGUoYm9keSlcbiAgfSBlbHNlIGlmIChcbiAgICBib2R5ICYmXG4gICAgdHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnICYmXG4gICAgIUFycmF5QnVmZmVyLmlzVmlldyhib2R5KSAmJlxuICAgIGlzSXRlcmFibGUoYm9keSlcbiAgKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHdlIGFsbG93IHJlLXVzaW5nIGl0ZXJhYmxlIGlmICF0aGlzLm9wdHMuaWRlbXBvdGVudFxuICAgIC8vIG9yIHRocm91Z2ggc29tZSBvdGhlciBmbGFnP1xuICAgIHJldHVybiBuZXcgQm9keUFzeW5jSXRlcmFibGUoYm9keSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYm9keVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcCAoKSB7fVxuXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbidcbn1cblxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvZmV0Y2gtYmxvYi9ibG9iLzhhYjU4N2QzNDA4MGRlOTQxNDBiNTRmMDcxNjg0NTFlN2QwYjY1NWUvaW5kZXguanMjTDIyOS1MMjQxIChNSVQgTGljZW5zZSlcbmZ1bmN0aW9uIGlzQmxvYkxpa2UgKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzVGFnID0gb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ11cblxuICAgIHJldHVybiAoc1RhZyA9PT0gJ0Jsb2InIHx8IHNUYWcgPT09ICdGaWxlJykgJiYgKFxuICAgICAgKCdzdHJlYW0nIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykgfHxcbiAgICAgICgnYXJyYXlCdWZmZXInIGluIG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFVSTCAodXJsLCBxdWVyeVBhcmFtcykge1xuICBpZiAodXJsLmluY2x1ZGVzKCc/JykgfHwgdXJsLmluY2x1ZGVzKCcjJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IHBhcmFtcyBjYW5ub3QgYmUgcGFzc2VkIHdoZW4gdXJsIGFscmVhZHkgY29udGFpbnMgXCI/XCIgb3IgXCIjXCIuJylcbiAgfVxuXG4gIGNvbnN0IHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zKVxuXG4gIGlmIChzdHJpbmdpZmllZCkge1xuICAgIHVybCArPSAnPycgKyBzdHJpbmdpZmllZFxuICB9XG5cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9ydCAocG9ydCkge1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHBvcnQsIDEwKVxuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSBOdW1iZXIocG9ydCkgJiZcbiAgICB2YWx1ZSA+PSAwICYmXG4gICAgdmFsdWUgPD0gNjU1MzVcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0h0dHBPckh0dHBzUHJlZml4ZWQgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgIHZhbHVlWzBdID09PSAnaCcgJiZcbiAgICB2YWx1ZVsxXSA9PT0gJ3QnICYmXG4gICAgdmFsdWVbMl0gPT09ICd0JyAmJlxuICAgIHZhbHVlWzNdID09PSAncCcgJiZcbiAgICAoXG4gICAgICB2YWx1ZVs0XSA9PT0gJzonIHx8XG4gICAgICAoXG4gICAgICAgIHZhbHVlWzRdID09PSAncycgJiZcbiAgICAgICAgdmFsdWVbNV0gPT09ICc6J1xuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBwYXJzZVVSTCAodXJsKSB7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKVxuXG4gICAgaWYgKCFpc0h0dHBPckh0dHBzUHJlZml4ZWQodXJsLm9yaWdpbiB8fCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxuICB9XG5cbiAgaWYgKCF1cmwgfHwgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMOiBUaGUgVVJMIGFyZ3VtZW50IG11c3QgYmUgYSBub24tbnVsbCBvYmplY3QuJylcbiAgfVxuXG4gIGlmICghKHVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICBpZiAodXJsLnBvcnQgIT0gbnVsbCAmJiB1cmwucG9ydCAhPT0gJycgJiYgaXNWYWxpZFBvcnQodXJsLnBvcnQpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogcG9ydCBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRoICE9IG51bGwgJiYgdHlwZW9mIHVybC5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRoOiB0aGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5wYXRobmFtZSAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHBhdGhuYW1lOiB0aGUgcGF0aG5hbWUgbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwuaG9zdG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLmhvc3RuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBob3N0bmFtZTogdGhlIGhvc3RuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLm9yaWdpbiAhPSBudWxsICYmIHR5cGVvZiB1cmwub3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBvcmlnaW46IHRoZSBvcmlnaW4gbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHBvcnQgPSB1cmwucG9ydCAhPSBudWxsXG4gICAgICA/IHVybC5wb3J0XG4gICAgICA6ICh1cmwucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApXG4gICAgbGV0IG9yaWdpbiA9IHVybC5vcmlnaW4gIT0gbnVsbFxuICAgICAgPyB1cmwub3JpZ2luXG4gICAgICA6IGAke3VybC5wcm90b2NvbCB8fCAnJ30vLyR7dXJsLmhvc3RuYW1lIHx8ICcnfToke3BvcnR9YFxuICAgIGxldCBwYXRoID0gdXJsLnBhdGggIT0gbnVsbFxuICAgICAgPyB1cmwucGF0aFxuICAgICAgOiBgJHt1cmwucGF0aG5hbWUgfHwgJyd9JHt1cmwuc2VhcmNoIHx8ICcnfWBcblxuICAgIGlmIChvcmlnaW5bb3JpZ2luLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICAgIG9yaWdpbiA9IG9yaWdpbi5zbGljZSgwLCBvcmlnaW4ubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICBpZiAocGF0aCAmJiBwYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgfVxuICAgIC8vIG5ldyBVUkwocGF0aCwgb3JpZ2luKSBpcyB1bnNhZmUgd2hlbiBgcGF0aGAgY29udGFpbnMgYW4gYWJzb2x1dGUgVVJMXG4gICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML1VSTDpcbiAgICAvLyBJZiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSByZWxhdGl2ZSBVUkwsIHNlY29uZCBwYXJhbSBpcyByZXF1aXJlZCwgYW5kIHdpbGwgYmUgdXNlZCBhcyB0aGUgYmFzZSBVUkwuXG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGFuIGFic29sdXRlIFVSTCwgYSBnaXZlbiBzZWNvbmQgcGFyYW0gd2lsbCBiZSBpZ25vcmVkLlxuICAgIHJldHVybiBuZXcgVVJMKGAke29yaWdpbn0ke3BhdGh9YClcbiAgfVxuXG4gIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcGFyc2VPcmlnaW4gKHVybCkge1xuICB1cmwgPSBwYXJzZVVSTCh1cmwpXG5cbiAgaWYgKHVybC5wYXRobmFtZSAhPT0gJy8nIHx8IHVybC5zZWFyY2ggfHwgdXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgdXJsJylcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdG5hbWUgKGhvc3QpIHtcbiAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignXScpXG5cbiAgICBhc3NlcnQoaWR4ICE9PSAtMSlcbiAgICByZXR1cm4gaG9zdC5zdWJzdHJpbmcoMSwgaWR4KVxuICB9XG5cbiAgY29uc3QgaWR4ID0gaG9zdC5pbmRleE9mKCc6JylcbiAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBob3N0XG5cbiAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDAsIGlkeClcbn1cblxuLy8gSVAgYWRkcmVzc2VzIGFyZSBub3QgdmFsaWQgc2VydmVyIG5hbWVzIHBlciBSRkM2MDY2XG4vLyA+IEN1cnJlbnRseSwgdGhlIG9ubHkgc2VydmVyIG5hbWVzIHN1cHBvcnRlZCBhcmUgRE5TIGhvc3RuYW1lc1xuZnVuY3Rpb24gZ2V0U2VydmVyTmFtZSAoaG9zdCkge1xuICBpZiAoIWhvc3QpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBob3N0LCAnc3RyaW5nJylcblxuICBjb25zdCBzZXJ2ZXJuYW1lID0gZ2V0SG9zdG5hbWUoaG9zdClcbiAgaWYgKG5ldC5pc0lQKHNlcnZlcm5hbWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICByZXR1cm4gc2VydmVybmFtZVxufVxuXG5mdW5jdGlvbiBkZWVwQ2xvbmUgKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxufVxuXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUgKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiYgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpXG59XG5cbmZ1bmN0aW9uIGlzSXRlcmFibGUgKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykpXG59XG5cbmZ1bmN0aW9uIGJvZHlMZW5ndGggKGJvZHkpIHtcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHJldHVybiAwXG4gIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGJvZHkuX3JlYWRhYmxlU3RhdGVcbiAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUub2JqZWN0TW9kZSA9PT0gZmFsc2UgJiYgc3RhdGUuZW5kZWQgPT09IHRydWUgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXRlLmxlbmd0aClcbiAgICAgID8gc3RhdGUubGVuZ3RoXG4gICAgICA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZSAhPSBudWxsID8gYm9keS5zaXplIDogbnVsbFxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZXN0cm95ZWQgKGJvZHkpIHtcbiAgcmV0dXJuIGJvZHkgJiYgISEoYm9keS5kZXN0cm95ZWQgfHwgYm9keVtrRGVzdHJveWVkXSB8fCAoc3RyZWFtLmlzRGVzdHJveWVkPy4oYm9keSkpKVxufVxuXG5mdW5jdGlvbiBkZXN0cm95IChzdHJlYW0sIGVycikge1xuICBpZiAoc3RyZWFtID09IG51bGwgfHwgIWlzU3RyZWFtKHN0cmVhbSkgfHwgaXNEZXN0cm95ZWQoc3RyZWFtKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RyZWFtKS5jb25zdHJ1Y3RvciA9PT0gSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM4NTA1L2ZpbGVzXG4gICAgICBzdHJlYW0uc29ja2V0ID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkICE9PSB0cnVlKSB7XG4gICAgc3RyZWFtW2tEZXN0cm95ZWRdID0gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX0VYUFIgPSAvdGltZW91dD0oXFxkKykvXG5mdW5jdGlvbiBwYXJzZUtlZXBBbGl2ZVRpbWVvdXQgKHZhbCkge1xuICBjb25zdCBtID0gdmFsLnRvU3RyaW5nKCkubWF0Y2goS0VFUEFMSVZFX1RJTUVPVVRfRVhQUilcbiAgcmV0dXJuIG0gPyBwYXJzZUludChtWzFdLCAxMCkgKiAxMDAwIDogbnVsbFxufVxuXG4vKipcbiAqIFJldHJpZXZlcyBhIGhlYWRlciBuYW1lIGFuZCByZXR1cm5zIGl0cyBsb3dlcmNhc2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IEJ1ZmZlcn0gdmFsdWUgSGVhZGVyIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhlYWRlck5hbWVUb1N0cmluZyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbiAgICA/IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW3ZhbHVlXSA/PyB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgOiB0cmVlLmxvb2t1cCh2YWx1ZSkgPz8gdmFsdWUudG9TdHJpbmcoJ2xhdGluMScpLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBSZWNlaXZlIHRoZSBidWZmZXIgYXMgYSBzdHJpbmcgYW5kIHJldHVybiBpdHMgbG93ZXJjYXNlIHZhbHVlLlxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lICh2YWx1ZSkge1xuICByZXR1cm4gdHJlZS5sb29rdXAodmFsdWUpID8/IHZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKS50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT4gfCAoQnVmZmVyIHwgc3RyaW5nIHwgKEJ1ZmZlciB8IHN0cmluZylbXSlbXX0gaGVhZGVyc1xuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT59IFtvYmpdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fVxuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGhlYWRlcnMsIG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIG9iaiA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IGhlYWRlck5hbWVUb1N0cmluZyhoZWFkZXJzW2ldKVxuICAgIGxldCB2YWwgPSBvYmpba2V5XVxuXG4gICAgaWYgKHZhbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdXG4gICAgICAgIG9ialtrZXldID0gdmFsXG4gICAgICB9XG4gICAgICB2YWwucHVzaChoZWFkZXJzW2kgKyAxXS50b1N0cmluZygndXRmOCcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWFkZXJzVmFsdWUgPSBoZWFkZXJzW2kgKyAxXVxuICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9ialtrZXldID0gaGVhZGVyc1ZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IEFycmF5LmlzQXJyYXkoaGVhZGVyc1ZhbHVlKSA/IGhlYWRlcnNWYWx1ZS5tYXAoeCA9PiB4LnRvU3RyaW5nKCd1dGY4JykpIDogaGVhZGVyc1ZhbHVlLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDY1MjhcbiAgaWYgKCdjb250ZW50LWxlbmd0aCcgaW4gb2JqICYmICdjb250ZW50LWRpc3Bvc2l0aW9uJyBpbiBvYmopIHtcbiAgICBvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSA9IEJ1ZmZlci5mcm9tKG9ialsnY29udGVudC1kaXNwb3NpdGlvbiddKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcGFyc2VSYXdIZWFkZXJzIChoZWFkZXJzKSB7XG4gIGNvbnN0IGxlbiA9IGhlYWRlcnMubGVuZ3RoXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShsZW4pXG5cbiAgbGV0IGhhc0NvbnRlbnRMZW5ndGggPSBmYWxzZVxuICBsZXQgY29udGVudERpc3Bvc2l0aW9uSWR4ID0gLTFcbiAgbGV0IGtleVxuICBsZXQgdmFsXG4gIGxldCBrTGVuID0gMFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVycy5sZW5ndGg7IG4gKz0gMikge1xuICAgIGtleSA9IGhlYWRlcnNbbl1cbiAgICB2YWwgPSBoZWFkZXJzW24gKyAxXVxuXG4gICAgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgJiYgKGtleSA9IGtleS50b1N0cmluZygpKVxuICAgIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnICYmICh2YWwgPSB2YWwudG9TdHJpbmcoJ3V0ZjgnKSlcblxuICAgIGtMZW4gPSBrZXkubGVuZ3RoXG4gICAgaWYgKGtMZW4gPT09IDE0ICYmIGtleVs3XSA9PT0gJy0nICYmIChrZXkgPT09ICdjb250ZW50LWxlbmd0aCcgfHwga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LWxlbmd0aCcpKSB7XG4gICAgICBoYXNDb250ZW50TGVuZ3RoID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoa0xlbiA9PT0gMTkgJiYga2V5WzddID09PSAnLScgJiYgKGtleSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1kaXNwb3NpdGlvbicpKSB7XG4gICAgICBjb250ZW50RGlzcG9zaXRpb25JZHggPSBuICsgMVxuICAgIH1cbiAgICByZXRbbl0gPSBrZXlcbiAgICByZXRbbiArIDFdID0gdmFsXG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDY1MjhcbiAgaWYgKGhhc0NvbnRlbnRMZW5ndGggJiYgY29udGVudERpc3Bvc2l0aW9uSWR4ICE9PSAtMSkge1xuICAgIHJldFtjb250ZW50RGlzcG9zaXRpb25JZHhdID0gQnVmZmVyLmZyb20ocmV0W2NvbnRlbnREaXNwb3NpdGlvbklkeF0pLnRvU3RyaW5nKCdsYXRpbjEnKVxuICB9XG5cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoYnVmZmVyKSB7XG4gIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9wdWxsLzMxOVxuICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUhhbmRsZXIgKGhhbmRsZXIsIG1ldGhvZCwgdXBncmFkZSkge1xuICBpZiAoIWhhbmRsZXIgfHwgdHlwZW9mIGhhbmRsZXIgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5vbkNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Db25uZWN0IG1ldGhvZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkVycm9yIG1ldGhvZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25Cb2R5U2VudCAhPT0gJ2Z1bmN0aW9uJyAmJiBoYW5kbGVyLm9uQm9keVNlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkJvZHlTZW50IG1ldGhvZCcpXG4gIH1cblxuICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vblVwZ3JhZGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvblVwZ3JhZGUgbWV0aG9kJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uSGVhZGVycyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uSGVhZGVycyBtZXRob2QnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkRhdGEgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25Db21wbGV0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQ29tcGxldGUgbWV0aG9kJylcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBib2R5IGlzIGRpc3R1cmJlZCBpZiBpdCBoYXMgYmVlbiByZWFkIGZyb20gYW5kIGl0IGNhbm5vdFxuLy8gYmUgcmUtdXNlZCB3aXRob3V0IGxvc2luZyBzdGF0ZSBvciBkYXRhLlxuZnVuY3Rpb24gaXNEaXN0dXJiZWQgKGJvZHkpIHtcbiAgLy8gVE9ETyAoZml4KTogV2h5IGlzIGJvZHlba0JvZHlVc2VkXSBuZWVkZWQ/XG4gIHJldHVybiAhIShib2R5ICYmIChzdHJlYW0uaXNEaXN0dXJiZWQoYm9keSkgfHwgYm9keVtrQm9keVVzZWRdKSlcbn1cblxuZnVuY3Rpb24gaXNFcnJvcmVkIChib2R5KSB7XG4gIHJldHVybiAhIShib2R5ICYmIHN0cmVhbS5pc0Vycm9yZWQoYm9keSkpXG59XG5cbmZ1bmN0aW9uIGlzUmVhZGFibGUgKGJvZHkpIHtcbiAgcmV0dXJuICEhKGJvZHkgJiYgc3RyZWFtLmlzUmVhZGFibGUoYm9keSkpXG59XG5cbmZ1bmN0aW9uIGdldFNvY2tldEluZm8gKHNvY2tldCkge1xuICByZXR1cm4ge1xuICAgIGxvY2FsQWRkcmVzczogc29ja2V0LmxvY2FsQWRkcmVzcyxcbiAgICBsb2NhbFBvcnQ6IHNvY2tldC5sb2NhbFBvcnQsXG4gICAgcmVtb3RlQWRkcmVzczogc29ja2V0LnJlbW90ZUFkZHJlc3MsXG4gICAgcmVtb3RlUG9ydDogc29ja2V0LnJlbW90ZVBvcnQsXG4gICAgcmVtb3RlRmFtaWx5OiBzb2NrZXQucmVtb3RlRmFtaWx5LFxuICAgIHRpbWVvdXQ6IHNvY2tldC50aW1lb3V0LFxuICAgIGJ5dGVzV3JpdHRlbjogc29ja2V0LmJ5dGVzV3JpdHRlbixcbiAgICBieXRlc1JlYWQ6IHNvY2tldC5ieXRlc1JlYWRcbiAgfVxufVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ1JlYWRhYmxlU3RyZWFtJ119ICovXG5mdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZyb20gKGl0ZXJhYmxlKSB7XG4gIC8vIFdlIGNhbm5vdCB1c2UgUmVhZGFibGVTdHJlYW0uZnJvbSBoZXJlIGJlY2F1c2UgaXQgZG9lcyBub3QgcmV0dXJuIGEgYnl0ZSBzdHJlYW0uXG5cbiAgbGV0IGl0ZXJhdG9yXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oXG4gICAge1xuICAgICAgYXN5bmMgc3RhcnQgKCkge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbCAoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdGVyYXRvci5uZXh0KClcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYnlvYlJlcXVlc3Q/LnJlc3BvbmQoMClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgPyB2YWx1ZSA6IEJ1ZmZlci5mcm9tKHZhbHVlKVxuICAgICAgICAgIGlmIChidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmRlc2lyZWRTaXplID4gMFxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCAocmVhc29uKSB7XG4gICAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybigpXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH1cbiAgKVxufVxuXG4vLyBUaGUgY2h1bmsgc2hvdWxkIGJlIGEgRm9ybURhdGEgaW5zdGFuY2UgYW5kIGNvbnRhaW5zXG4vLyBhbGwgdGhlIHJlcXVpcmVkIG1ldGhvZHMuXG5mdW5jdGlvbiBpc0Zvcm1EYXRhTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiAoXG4gICAgb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmFwcGVuZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZGVsZXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmdldEFsbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuaGFzID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5zZXQgPT09ICdmdW5jdGlvbicgJiZcbiAgICBvYmplY3RbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJ1xuICApXG59XG5cbmZ1bmN0aW9uIGFkZEFib3J0TGlzdGVuZXIgKHNpZ25hbCwgbGlzdGVuZXIpIHtcbiAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBzaWduYWwpIHtcbiAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pXG4gICAgcmV0dXJuICgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGxpc3RlbmVyKVxuICB9XG4gIHNpZ25hbC5hZGRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgcmV0dXJuICgpID0+IHNpZ25hbC5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbn1cblxuY29uc3QgaGFzVG9XZWxsRm9ybWVkID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudG9XZWxsRm9ybWVkID09PSAnZnVuY3Rpb24nXG5jb25zdCBoYXNJc1dlbGxGb3JtZWQgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5pc1dlbGxGb3JtZWQgPT09ICdmdW5jdGlvbidcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKi9cbmZ1bmN0aW9uIHRvVVNWU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIGhhc1RvV2VsbEZvcm1lZCA/IGAke3ZhbH1gLnRvV2VsbEZvcm1lZCgpIDogbm9kZVV0aWwudG9VU1ZTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqL1xuLy8gVE9ETzogbW92ZSB0aGlzIHRvIHdlYmlkbFxuZnVuY3Rpb24gaXNVU1ZTdHJpbmcgKHZhbCkge1xuICByZXR1cm4gaGFzSXNXZWxsRm9ybWVkID8gYCR7dmFsfWAuaXNXZWxsRm9ybWVkKCkgOiB0b1VTVlN0cmluZyh2YWwpID09PSBgJHt2YWx9YFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjIuNlxuICogQHBhcmFtIHtudW1iZXJ9IGNcbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkNoYXJDb2RlIChjKSB7XG4gIHN3aXRjaCAoYykge1xuICAgIGNhc2UgMHgyMjpcbiAgICBjYXNlIDB4Mjg6XG4gICAgY2FzZSAweDI5OlxuICAgIGNhc2UgMHgyYzpcbiAgICBjYXNlIDB4MmY6XG4gICAgY2FzZSAweDNhOlxuICAgIGNhc2UgMHgzYjpcbiAgICBjYXNlIDB4M2M6XG4gICAgY2FzZSAweDNkOlxuICAgIGNhc2UgMHgzZTpcbiAgICBjYXNlIDB4M2Y6XG4gICAgY2FzZSAweDQwOlxuICAgIGNhc2UgMHg1YjpcbiAgICBjYXNlIDB4NWM6XG4gICAgY2FzZSAweDVkOlxuICAgIGNhc2UgMHg3YjpcbiAgICBjYXNlIDB4N2Q6XG4gICAgICAvLyBEUVVPVEUgYW5kIFwiKCksLzo7PD0+P0BbXFxde31cIlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFZDSEFSICV4MjEtN0VcbiAgICAgIHJldHVybiBjID49IDB4MjEgJiYgYyA8PSAweDdlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyc1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkSFRUUFRva2VuIChjaGFyYWN0ZXJzKSB7XG4gIGlmIChjaGFyYWN0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcmFjdGVycy5sZW5ndGg7ICsraSkge1xuICAgIGlmICghaXNUb2tlbkNoYXJDb2RlKGNoYXJhY3RlcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBoZWFkZXJDaGFyUmVnZXggaGF2ZSBiZWVuIGxpZnRlZCBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYWluL2xpYi9faHR0cF9jb21tb24uanNcblxuLyoqXG4gKiBNYXRjaGVzIGlmIHZhbCBjb250YWlucyBhbiBpbnZhbGlkIGZpZWxkLXZjaGFyXG4gKiAgZmllbGQtdmFsdWUgICAgPSAqKCBmaWVsZC1jb250ZW50IC8gb2JzLWZvbGQgKVxuICogIGZpZWxkLWNvbnRlbnQgID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogIGZpZWxkLXZjaGFyICAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICovXG5jb25zdCBoZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyc1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGVhZGVyVmFsdWUgKGNoYXJhY3RlcnMpIHtcbiAgcmV0dXJuICFoZWFkZXJDaGFyUmVnZXgudGVzdChjaGFyYWN0ZXJzKVxufVxuXG4vLyBQYXJzZWQgYWNjb3JkaW5nbHkgdG8gUkZDIDkxMTBcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEwI2ZpZWxkLmNvbnRlbnQtcmFuZ2VcbmZ1bmN0aW9uIHBhcnNlUmFuZ2VIZWFkZXIgKHJhbmdlKSB7XG4gIGlmIChyYW5nZSA9PSBudWxsIHx8IHJhbmdlID09PSAnJykgcmV0dXJuIHsgc3RhcnQ6IDAsIGVuZDogbnVsbCwgc2l6ZTogbnVsbCB9XG5cbiAgY29uc3QgbSA9IHJhbmdlID8gcmFuZ2UubWF0Y2goL15ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspPyQvKSA6IG51bGxcbiAgcmV0dXJuIG1cbiAgICA/IHtcbiAgICAgICAgc3RhcnQ6IHBhcnNlSW50KG1bMV0pLFxuICAgICAgICBlbmQ6IG1bMl0gPyBwYXJzZUludChtWzJdKSA6IG51bGwsXG4gICAgICAgIHNpemU6IG1bM10gPyBwYXJzZUludChtWzNdKSA6IG51bGxcbiAgICAgIH1cbiAgICA6IG51bGxcbn1cblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIgKG9iaiwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gKG9ialtrTGlzdGVuZXJzXSA/Pz0gW10pXG4gIGxpc3RlbmVycy5wdXNoKFtuYW1lLCBsaXN0ZW5lcl0pXG4gIG9iai5vbihuYW1lLCBsaXN0ZW5lcilcbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMgKG9iaikge1xuICBmb3IgKGNvbnN0IFtuYW1lLCBsaXN0ZW5lcl0gb2Ygb2JqW2tMaXN0ZW5lcnNdID8/IFtdKSB7XG4gICAgb2JqLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKVxuICB9XG4gIG9ialtrTGlzdGVuZXJzXSA9IG51bGxcbn1cblxuZnVuY3Rpb24gZXJyb3JSZXF1ZXN0IChjbGllbnQsIHJlcXVlc3QsIGVycikge1xuICB0cnkge1xuICAgIHJlcXVlc3Qub25FcnJvcihlcnIpXG4gICAgYXNzZXJ0KHJlcXVlc3QuYWJvcnRlZClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2xpZW50LmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbmNvbnN0IGtFbnVtZXJhYmxlUHJvcGVydHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5rRW51bWVyYWJsZVByb3BlcnR5LmVudW1lcmFibGUgPSB0cnVlXG5cbmNvbnN0IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSA9IHtcbiAgZGVsZXRlOiAnREVMRVRFJyxcbiAgREVMRVRFOiAnREVMRVRFJyxcbiAgZ2V0OiAnR0VUJyxcbiAgR0VUOiAnR0VUJyxcbiAgaGVhZDogJ0hFQUQnLFxuICBIRUFEOiAnSEVBRCcsXG4gIG9wdGlvbnM6ICdPUFRJT05TJyxcbiAgT1BUSU9OUzogJ09QVElPTlMnLFxuICBwb3N0OiAnUE9TVCcsXG4gIFBPU1Q6ICdQT1NUJyxcbiAgcHV0OiAnUFVUJyxcbiAgUFVUOiAnUFVUJ1xufVxuXG5jb25zdCBub3JtYWxpemVkTWV0aG9kUmVjb3JkcyA9IHtcbiAgLi4ubm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLFxuICBwYXRjaDogJ3BhdGNoJyxcbiAgUEFUQ0g6ICdQQVRDSCdcbn1cblxuLy8gTm90ZTogb2JqZWN0IHByb3RvdHlwZXMgc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGJlIHJlZmVyZW5jZWQuIGUuZy4gYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAuXG5PYmplY3Quc2V0UHJvdG90eXBlT2Yobm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLCBudWxsKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzLCBudWxsKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgbm9wLFxuICBpc0Rpc3R1cmJlZCxcbiAgaXNFcnJvcmVkLFxuICBpc1JlYWRhYmxlLFxuICB0b1VTVlN0cmluZyxcbiAgaXNVU1ZTdHJpbmcsXG4gIGlzQmxvYkxpa2UsXG4gIHBhcnNlT3JpZ2luLFxuICBwYXJzZVVSTCxcbiAgZ2V0U2VydmVyTmFtZSxcbiAgaXNTdHJlYW0sXG4gIGlzSXRlcmFibGUsXG4gIGlzQXN5bmNJdGVyYWJsZSxcbiAgaXNEZXN0cm95ZWQsXG4gIGhlYWRlck5hbWVUb1N0cmluZyxcbiAgYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSxcbiAgYWRkTGlzdGVuZXIsXG4gIHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZXJyb3JSZXF1ZXN0LFxuICBwYXJzZVJhd0hlYWRlcnMsXG4gIHBhcnNlSGVhZGVycyxcbiAgcGFyc2VLZWVwQWxpdmVUaW1lb3V0LFxuICBkZXN0cm95LFxuICBib2R5TGVuZ3RoLFxuICBkZWVwQ2xvbmUsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgaXNCdWZmZXIsXG4gIHZhbGlkYXRlSGFuZGxlcixcbiAgZ2V0U29ja2V0SW5mbyxcbiAgaXNGb3JtRGF0YUxpa2UsXG4gIGJ1aWxkVVJMLFxuICBhZGRBYm9ydExpc3RlbmVyLFxuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzVG9rZW5DaGFyQ29kZSxcbiAgcGFyc2VSYW5nZUhlYWRlcixcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlLFxuICBub3JtYWxpemVkTWV0aG9kUmVjb3JkcyxcbiAgaXNWYWxpZFBvcnQsXG4gIGlzSHR0cE9ySHR0cHNQcmVmaXhlZCxcbiAgbm9kZU1ham9yLFxuICBub2RlTWlub3IsXG4gIHNhZmVIVFRQTWV0aG9kczogWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1RSQUNFJ10sXG4gIHdyYXBSZXF1ZXN0Qm9keVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const client of this[kClients].values()) {\n      ret += client[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    let dispatcher = this[kClients].get(key)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n      // TODO(mcollina): remove te timer when the client/pool do not have any more\n      // active connections.\n      this[kClients].set(key, dispatcher)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const client of this[kClients].values()) {\n      closePromises.push(client.close())\n    }\n    this[kClients].clear()\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const client of this[kClients].values()) {\n      destroyPromises.push(client.destroy(err))\n    }\n    this[kClients].clear()\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxpRUFBaUUsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwRyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsa0NBQWtDLG1CQUFPLENBQUMsZ0hBQXFDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHFFQUFxRSxJQUFJO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCOztBQUV0RCx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxhZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrQ2xpZW50cywga1J1bm5pbmcsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvcicpXG5cbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrTWF4UmVkaXJlY3Rpb25zID0gU3ltYm9sKCdtYXhSZWRpcmVjdGlvbnMnKVxuY29uc3Qga09uRHJhaW4gPSBTeW1ib2woJ29uRHJhaW4nKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIG9wdHMuY29ubmVjdGlvbnMgPT09IDFcbiAgICA/IG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxuICAgIDogbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKHsgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LCBtYXhSZWRpcmVjdGlvbnMgPSAwLCBjb25uZWN0LCAuLi5vcHRpb25zIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSB7IC4uLmNvbm5lY3QgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBvcHRpb25zLmludGVyY2VwdG9ycz8uQWdlbnQgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5BZ2VudClcbiAgICAgID8gb3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnRcbiAgICAgIDogW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tNYXhSZWRpcmVjdGlvbnNdID0gbWF4UmVkaXJlY3Rpb25zXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG4gICAgdGhpc1trQ2xpZW50c10gPSBuZXcgTWFwKClcblxuICAgIHRoaXNba09uRHJhaW5dID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3RoaXMsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkRpc2Nvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cblxuICAgIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICByZXQgKz0gY2xpZW50W2tSdW5uaW5nXVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGxldCBrZXlcbiAgICBpZiAob3B0cy5vcmlnaW4gJiYgKHR5cGVvZiBvcHRzLm9yaWdpbiA9PT0gJ3N0cmluZycgfHwgb3B0cy5vcmlnaW4gaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgICBrZXkgPSBTdHJpbmcob3B0cy5vcmlnaW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5vcmlnaW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgVVJMLicpXG4gICAgfVxuXG4gICAgbGV0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5nZXQoa2V5KVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3B0cy5vcmlnaW4sIHRoaXNba09wdGlvbnNdKVxuICAgICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAgIC5vbignY29ubmVjdCcsIHRoaXNba09uQ29ubmVjdF0pXG4gICAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXNba09uRGlzY29ubmVjdF0pXG4gICAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgICAvLyBUaGlzIGludHJvZHVjZXMgYSB0aW55IG1lbW9yeSBsZWFrLCBhcyBkaXNwYXRjaGVycyBhcmUgbmV2ZXIgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgICAvLyBUT0RPKG1jb2xsaW5hKTogcmVtb3ZlIHRlIHRpbWVyIHdoZW4gdGhlIGNsaWVudC9wb29sIGRvIG5vdCBoYXZlIGFueSBtb3JlXG4gICAgICAvLyBhY3RpdmUgY29ubmVjdGlvbnMuXG4gICAgICB0aGlzW2tDbGllbnRzXS5zZXQoa2V5LCBkaXNwYXRjaGVyKVxuICAgIH1cblxuICAgIHJldHVybiBkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgY29uc3QgY2xvc2VQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGNsb3NlUHJvbWlzZXMucHVzaChjbGllbnQuY2xvc2UoKSlcbiAgICB9XG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcylcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGNvbnN0IGRlc3Ryb3lQcm9taXNlcyA9IFtdXG4gICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpc1trQ2xpZW50c10udmFsdWVzKCkpIHtcbiAgICAgIGRlc3Ryb3lQcm9taXNlcy5wdXNoKGNsaWVudC5kZXN0cm95KGVycikpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGRlc3Ryb3lQcm9taXNlcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\nfunction getGreatestCommonDivisor (a, b) {\n  if (b === 0) return a\n  return getGreatestCommonDivisor(b, a % b)\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsb0NBQW9DLElBQUk7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcYmFsYW5jZWQtcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn0gPSByZXF1aXJlKCcuL3Bvb2wtYmFzZScpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgcGFyc2VPcmlnaW4gfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcbmNvbnN0IGtHcmVhdGVzdENvbW1vbkRpdmlzb3IgPSBTeW1ib2woJ2tHcmVhdGVzdENvbW1vbkRpdmlzb3InKVxuY29uc3Qga0N1cnJlbnRXZWlnaHQgPSBTeW1ib2woJ2tDdXJyZW50V2VpZ2h0JylcbmNvbnN0IGtJbmRleCA9IFN5bWJvbCgna0luZGV4JylcbmNvbnN0IGtXZWlnaHQgPSBTeW1ib2woJ2tXZWlnaHQnKVxuY29uc3Qga01heFdlaWdodFBlclNlcnZlciA9IFN5bWJvbCgna01heFdlaWdodFBlclNlcnZlcicpXG5jb25zdCBrRXJyb3JQZW5hbHR5ID0gU3ltYm9sKCdrRXJyb3JQZW5hbHR5JylcblxuZnVuY3Rpb24gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yIChhLCBiKSB7XG4gIGlmIChiID09PSAwKSByZXR1cm4gYVxuICByZXR1cm4gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNsYXNzIEJhbGFuY2VkUG9vbCBleHRlbmRzIFBvb2xCYXNlIHtcbiAgY29uc3RydWN0b3IgKHVwc3RyZWFtcyA9IFtdLCB7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgLi4ub3B0cyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tPcHRpb25zXSA9IG9wdHNcbiAgICB0aGlzW2tJbmRleF0gPSAtMVxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gMFxuXG4gICAgdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSA9IHRoaXNba09wdGlvbnNdLm1heFdlaWdodFBlclNlcnZlciB8fCAxMDBcbiAgICB0aGlzW2tFcnJvclBlbmFsdHldID0gdGhpc1trT3B0aW9uc10uZXJyb3JQZW5hbHR5IHx8IDE1XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodXBzdHJlYW1zKSkge1xuICAgICAgdXBzdHJlYW1zID0gW3Vwc3RyZWFtc11cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0cy5pbnRlcmNlcHRvcnM/LkJhbGFuY2VkUG9vbCAmJiBBcnJheS5pc0FycmF5KG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuQmFsYW5jZWRQb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trRmFjdG9yeV0gPSBmYWN0b3J5XG5cbiAgICBmb3IgKGNvbnN0IHVwc3RyZWFtIG9mIHVwc3RyZWFtcykge1xuICAgICAgdGhpcy5hZGRVcHN0cmVhbSh1cHN0cmVhbSlcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICB9XG5cbiAgYWRkVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBpZiAodGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgY29uc3QgcG9vbCA9IHRoaXNba0ZhY3RvcnldKHVwc3RyZWFtT3JpZ2luLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tPcHRpb25zXSkpXG5cbiAgICB0aGlzW2tBZGRDbGllbnRdKHBvb2wpXG4gICAgcG9vbC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1pbih0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdLCBwb29sW2tXZWlnaHRdICsgdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICB9KVxuXG4gICAgcG9vbC5vbignY29ubmVjdGlvbkVycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgIH0pXG5cbiAgICBwb29sLm9uKCdkaXNjb25uZWN0JywgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGFyZ3NbMl1cbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdVTkRfRVJSX1NPQ0tFVCcpIHtcbiAgICAgICAgLy8gZGVjcmVhc2UgdGhlIHdlaWdodCBvZiB0aGUgcG9vbC5cbiAgICAgICAgcG9vbFtrV2VpZ2h0XSA9IE1hdGgubWF4KDEsIHBvb2xba1dlaWdodF0gLSB0aGlzW2tFcnJvclBlbmFsdHldKVxuICAgICAgICB0aGlzLl91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBjbGllbnRba1dlaWdodF0gPSB0aGlzW2tNYXhXZWlnaHRQZXJTZXJ2ZXJdXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF91cGRhdGVCYWxhbmNlZFBvb2xTdGF0cyAoKSB7XG4gICAgdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXSA9IHRoaXNba0NsaWVudHNdLm1hcChwID0+IHBba1dlaWdodF0pLnJlZHVjZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIDApXG4gIH1cblxuICByZW1vdmVVcHN0cmVhbSAodXBzdHJlYW0pIHtcbiAgICBjb25zdCB1cHN0cmVhbU9yaWdpbiA9IHBhcnNlT3JpZ2luKHVwc3RyZWFtKS5vcmlnaW5cblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXS5maW5kKChwb29sKSA9PiAoXG4gICAgICBwb29sW2tVcmxdLm9yaWdpbiA9PT0gdXBzdHJlYW1PcmlnaW4gJiZcbiAgICAgIHBvb2wuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBwb29sLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAocG9vbCkge1xuICAgICAgdGhpc1trUmVtb3ZlQ2xpZW50XShwb29sKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgdXBzdHJlYW1zICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11cbiAgICAgIC5maWx0ZXIoZGlzcGF0Y2hlciA9PiBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJiBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZSlcbiAgICAgIC5tYXAoKHApID0+IHBba1VybF0ub3JpZ2luKVxuICB9XG5cbiAgW2tHZXREaXNwYXRjaGVyXSAoKSB7XG4gICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBwb29scyBpcyBncmVhdGVyIHRoYW4gMCxcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byB3YWl0IHVudGlsIGFuIHVwc3RyZWFtXG4gICAgLy8gaXMgYWRkZWQsIHdoaWNoIG1pZ2h0IG5ldmVyIGhhcHBlbi5cbiAgICBpZiAodGhpc1trQ2xpZW50c10ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tDbGllbnRzXS5maW5kKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFsbENsaWVudHNCdXN5ID0gdGhpc1trQ2xpZW50c10ubWFwKHBvb2wgPT4gcG9vbFtrTmVlZERyYWluXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG5cbiAgICBpZiAoYWxsQ2xpZW50c0J1c3kpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBjb3VudGVyID0gMFxuXG4gICAgbGV0IG1heFdlaWdodEluZGV4ID0gdGhpc1trQ2xpZW50c10uZmluZEluZGV4KHBvb2wgPT4gIXBvb2xba05lZWREcmFpbl0pXG5cbiAgICB3aGlsZSAoY291bnRlcisrIDwgdGhpc1trQ2xpZW50c10ubGVuZ3RoKSB7XG4gICAgICB0aGlzW2tJbmRleF0gPSAodGhpc1trSW5kZXhdICsgMSkgJSB0aGlzW2tDbGllbnRzXS5sZW5ndGhcbiAgICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tDbGllbnRzXVt0aGlzW2tJbmRleF1dXG5cbiAgICAgIC8vIGZpbmQgcG9vbCBpbmRleCB3aXRoIHRoZSBsYXJnZXN0IHdlaWdodFxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF0gJiYgIXBvb2xba05lZWREcmFpbl0pIHtcbiAgICAgICAgbWF4V2VpZ2h0SW5kZXggPSB0aGlzW2tJbmRleF1cbiAgICAgIH1cblxuICAgICAgLy8gZGVjcmVhc2UgdGhlIGN1cnJlbnQgd2VpZ2h0IGV2ZXJ5IGB0aGlzW2tDbGllbnRzXS5sZW5ndGhgLlxuICAgICAgaWYgKHRoaXNba0luZGV4XSA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgd2VpZ2h0IHRvIHRoZSBuZXh0IGxvd2VyIHdlaWdodC5cbiAgICAgICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAtIHRoaXNba0dyZWF0ZXN0Q29tbW9uRGl2aXNvcl1cblxuICAgICAgICBpZiAodGhpc1trQ3VycmVudFdlaWdodF0gPD0gMCkge1xuICAgICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9vbFtrV2VpZ2h0XSA+PSB0aGlzW2tDdXJyZW50V2VpZ2h0XSAmJiAoIXBvb2xba05lZWREcmFpbl0pKSB7XG4gICAgICAgIHJldHVybiBwb29sXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trQ3VycmVudFdlaWdodF0gPSB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1ba1dlaWdodF1cbiAgICB0aGlzW2tJbmRleF0gPSBtYXhXZWlnaHRJbmRleFxuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXVttYXhXZWlnaHRJbmRleF1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhbGFuY2VkUG9vbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\")\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(ssr)/./node_modules/undici/lib/util/timers.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext\n} = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(ssr)/./node_modules/undici/lib/llhttp/constants.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst addListener = util.addListener\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]())\n    } else {\n      client[kResume]()\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nasync function connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = await llhttpPromise\n    llhttpPromise = null\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  addListener(socket, 'error', function (err) {\n    const parser = this[kParser]\n\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n  addListener(socket, 'readable', function () {\n    const parser = this[kParser]\n\n    if (parser) {\n      parser.readMore()\n    }\n  })\n  addListener(socket, 'end', function () {\n    const parser = this[kParser]\n\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n  addListener(socket, 'close', function () {\n    const client = this[kClient]\n    const parser = this[kParser]\n\n    if (parser) {\n      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n        // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete()\n      }\n\n      this[kParser].destroy()\n      this[kParser] = null\n    }\n\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      const request = client[kQueue][client[kRunningIdx]]\n      client[kQueue][client[kRunningIdx]++] = null\n\n      util.errorRequest(client, request, err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (...args) {\n      return writeH1(client, ...args)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored))\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null))\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjs7QUFFaEMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsdUZBQTBCOztBQUV4RjtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsaUdBQStCO0FBQzNFLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBTyxDQUFDLHVGQUEwQjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwrQ0FBK0M7O0FBRTNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNDQUFzQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQThDOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMEZBQTBGOztBQUV0RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw4QkFBOEI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsK0NBQStDOztBQUV6RCxRQUFRLCtCQUErQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixrSEFBMkM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7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QUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUVBQXVFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0VBQStFOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTyxrQkFBa0IsY0FBYztBQUMvRDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtFQUErRTtBQUMzRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQixRQUFRO0FBQ1Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3QkFBd0I7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGNsaWVudC1oMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIFdlYkFzc2VtYmx5ICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vY29yZS9kaWFnbm9zdGljcy5qcycpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuLi91dGlsL3RpbWVycy5qcycpXG5jb25zdCB7XG4gIFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgSGVhZGVyc1RpbWVvdXRFcnJvcixcbiAgSGVhZGVyc092ZXJmbG93RXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIEJvZHlUaW1lb3V0RXJyb3IsXG4gIEhUVFBQYXJzZXJFcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzLmpzJylcbmNvbnN0IHtcbiAga1VybCxcbiAga1Jlc2V0LFxuICBrQ2xpZW50LFxuICBrUGFyc2VyLFxuICBrQmxvY2tpbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtXcml0aW5nLFxuICBrUXVldWUsXG4gIGtOb1JlZixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrU29ja2V0LFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga1Jlc3VtZSxcbiAga0hUVFBDb250ZXh0XG59ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzLmpzJylcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vbGxodHRwL2NvbnN0YW50cy5qcycpXG5jb25zdCBFTVBUWV9CVUYgPSBCdWZmZXIuYWxsb2MoMClcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdXG5jb25zdCBhZGRMaXN0ZW5lciA9IHV0aWwuYWRkTGlzdGVuZXJcbmNvbnN0IHJlbW92ZUFsbExpc3RlbmVycyA9IHV0aWwucmVtb3ZlQWxsTGlzdGVuZXJzXG5cbmxldCBleHRyYWN0Qm9keVxuXG5hc3luYyBmdW5jdGlvbiBsYXp5bGxodHRwICgpIHtcbiAgY29uc3QgbGxodHRwV2FzbURhdGEgPSBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA/IHJlcXVpcmUoJy4uL2xsaHR0cC9sbGh0dHAtd2FzbS5qcycpIDogdW5kZWZpbmVkXG5cbiAgbGV0IG1vZFxuICB0cnkge1xuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUocmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cF9zaW1kLXdhc20uanMnKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAvLyBXZSBjb3VsZCBjaGVjayBpZiB0aGUgZXJyb3Igd2FzIGNhdXNlZCBieSB0aGUgc2ltZCBvcHRpb24gbm90XG4gICAgLy8gYmVpbmcgZW5hYmxlZCwgYnV0IHRoZSBvY2N1cnJpbmcgb2YgdGhpcyBvdGhlciBlcnJvclxuICAgIC8vICogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xMTQ5NVxuICAgIC8vIGdvdCBtZSB0byByZW1vdmUgdGhhdCBjaGVjayB0byBhdm9pZCBicmVha2luZyBOb2RlIDEyLlxuICAgIG1vZCA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGUobGxodHRwV2FzbURhdGEgfHwgcmVxdWlyZSgnLi4vbGxodHRwL2xsaHR0cC13YXNtLmpzJykpXG4gIH1cblxuICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kLCB7XG4gICAgZW52OiB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblxuICAgICAgd2FzbV9vbl91cmw6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9zdGF0dXM6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25TdGF0dXMobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9tZXNzYWdlX2JlZ2luOiAocCkgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uTWVzc2FnZUJlZ2luKCkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX2ZpZWxkOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY3VycmVudFBhcnNlci5wdHIsIHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyRmllbGQobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJfdmFsdWU6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJWYWx1ZShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcnNfY29tcGxldGU6IChwLCBzdGF0dXNDb2RlLCB1cGdyYWRlLCBzaG91bGRLZWVwQWxpdmUpID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlcnNDb21wbGV0ZShzdGF0dXNDb2RlLCBCb29sZWFuKHVwZ3JhZGUpLCBCb29sZWFuKHNob3VsZEtlZXBBbGl2ZSkpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2JvZHk6IChwLCBhdCwgbGVuKSA9PiB7XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChjdXJyZW50UGFyc2VyLnB0ciwgcClcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBhdCAtIGN1cnJlbnRCdWZmZXJQdHIgKyBjdXJyZW50QnVmZmVyUmVmLmJ5dGVPZmZzZXRcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25Cb2R5KG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZTogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGN1cnJlbnRQYXJzZXIucHRyLCBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpIHx8IDBcbiAgICAgIH1cblxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9XG4gIH0pXG59XG5cbmxldCBsbGh0dHBJbnN0YW5jZSA9IG51bGxcbmxldCBsbGh0dHBQcm9taXNlID0gbGF6eWxsaHR0cCgpXG5sbGh0dHBQcm9taXNlLmNhdGNoKClcblxubGV0IGN1cnJlbnRQYXJzZXIgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbmxldCBjdXJyZW50QnVmZmVyU2l6ZSA9IDBcbmxldCBjdXJyZW50QnVmZmVyUHRyID0gbnVsbFxuXG5jb25zdCBUSU1FT1VUX0hFQURFUlMgPSAxXG5jb25zdCBUSU1FT1VUX0JPRFkgPSAyXG5jb25zdCBUSU1FT1VUX0lETEUgPSAzXG5cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yIChjbGllbnQsIHNvY2tldCwgeyBleHBvcnRzIH0pIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGNsaWVudFtrTWF4SGVhZGVyc1NpemVdKSAmJiBjbGllbnRba01heEhlYWRlcnNTaXplXSA+IDApXG5cbiAgICB0aGlzLmxsaHR0cCA9IGV4cG9ydHNcbiAgICB0aGlzLnB0ciA9IHRoaXMubGxodHRwLmxsaHR0cF9hbGxvYyhjb25zdGFudHMuVFlQRS5SRVNQT05TRSlcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMudGltZW91dFZhbHVlID0gbnVsbFxuICAgIHRoaXMudGltZW91dFR5cGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnXG4gICAgdGhpcy51cGdyYWRlID0gZmFsc2VcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG4gICAgdGhpcy5oZWFkZXJzTWF4U2l6ZSA9IGNsaWVudFtrTWF4SGVhZGVyc1NpemVdXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSBmYWxzZVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLnJlc3VtZSA9IHRoaXMucmVzdW1lLmJpbmQodGhpcylcblxuICAgIHRoaXMuYnl0ZXNSZWFkID0gMFxuXG4gICAgdGhpcy5rZWVwQWxpdmUgPSAnJ1xuICAgIHRoaXMuY29udGVudExlbmd0aCA9ICcnXG4gICAgdGhpcy5jb25uZWN0aW9uID0gJydcbiAgICB0aGlzLm1heFJlc3BvbnNlU2l6ZSA9IGNsaWVudFtrTWF4UmVzcG9uc2VTaXplXVxuICB9XG5cbiAgc2V0VGltZW91dCAodmFsdWUsIHR5cGUpIHtcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gdHlwZVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy50aW1lb3V0VmFsdWUpIHtcbiAgICAgIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVycy5zZXRUaW1lb3V0KG9uUGFyc2VyVGltZW91dCwgdmFsdWUsIHRoaXMpXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgICB9XG4gICAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LmRlc3Ryb3llZCB8fCAhdGhpcy5wYXVzZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG5cbiAgICB0aGlzLmxsaHR0cC5sbGh0dHBfcmVzdW1lKHRoaXMucHRyKVxuXG4gICAgYXNzZXJ0KHRoaXMudGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSlcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5leGVjdXRlKHRoaXMuc29ja2V0LnJlYWQoKSB8fCBFTVBUWV9CVUYpIC8vIEZsdXNoIHBhcnNlci5cbiAgICB0aGlzLnJlYWRNb3JlKClcbiAgfVxuXG4gIHJlYWRNb3JlICgpIHtcbiAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIHRoaXMucHRyKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuc29ja2V0LnJlYWQoKVxuICAgICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGUoY2h1bmspXG4gICAgfVxuICB9XG5cbiAgZXhlY3V0ZSAoZGF0YSkge1xuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG4gICAgYXNzZXJ0KCF0aGlzLnBhdXNlZClcblxuICAgIGNvbnN0IHsgc29ja2V0LCBsbGh0dHAgfSA9IHRoaXNcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IGN1cnJlbnRCdWZmZXJTaXplKSB7XG4gICAgICBpZiAoY3VycmVudEJ1ZmZlclB0cikge1xuICAgICAgICBsbGh0dHAuZnJlZShjdXJyZW50QnVmZmVyUHRyKVxuICAgICAgfVxuICAgICAgY3VycmVudEJ1ZmZlclNpemUgPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0MDk2KSAqIDQwOTZcbiAgICAgIGN1cnJlbnRCdWZmZXJQdHIgPSBsbGh0dHAubWFsbG9jKGN1cnJlbnRCdWZmZXJTaXplKVxuICAgIH1cblxuICAgIG5ldyBVaW50OEFycmF5KGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBjdXJyZW50QnVmZmVyUHRyLCBjdXJyZW50QnVmZmVyU2l6ZSkuc2V0KGRhdGEpXG5cbiAgICAvLyBDYWxsIGBleGVjdXRlYCBvbiB0aGUgd2FzbSBwYXJzZXIuXG4gICAgLy8gV2UgcGFzcyB0aGUgYGxsaHR0cF9wYXJzZXJgIHBvaW50ZXIgYWRkcmVzcywgdGhlIHBvaW50ZXIgYWRkcmVzcyBvZiBidWZmZXIgdmlldyBkYXRhLFxuICAgIC8vIGFuZCBmaW5hbGx5IHRoZSBsZW5ndGggb2YgYnl0ZXMgdG8gcGFyc2UuXG4gICAgLy8gVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBlcnJvciBjb2RlIG9yIGBjb25zdGFudHMuRVJST1IuT0tgLlxuICAgIHRyeSB7XG4gICAgICBsZXQgcmV0XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGN1cnJlbnRCdWZmZXJSZWYgPSBkYXRhXG4gICAgICAgIGN1cnJlbnRQYXJzZXIgPSB0aGlzXG4gICAgICAgIHJldCA9IGxsaHR0cC5sbGh0dHBfZXhlY3V0ZSh0aGlzLnB0ciwgY3VycmVudEJ1ZmZlclB0ciwgZGF0YS5sZW5ndGgpXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhdGNoICovXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRQYXJzZXIgPSBudWxsXG4gICAgICAgIGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9mZnNldCA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3Bvcyh0aGlzLnB0cikgLSBjdXJyZW50QnVmZmVyUHRyXG5cbiAgICAgIGlmIChyZXQgPT09IGNvbnN0YW50cy5FUlJPUi5QQVVTRURfVVBHUkFERSkge1xuICAgICAgICB0aGlzLm9uVXBncmFkZShkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9IGVsc2UgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWVcbiAgICAgICAgc29ja2V0LnVuc2hpZnQoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfSBlbHNlIGlmIChyZXQgIT09IGNvbnN0YW50cy5FUlJPUi5PSykge1xuICAgICAgICBjb25zdCBwdHIgPSBsbGh0dHAubGxodHRwX2dldF9lcnJvcl9yZWFzb24odGhpcy5wdHIpXG4gICAgICAgIGxldCBtZXNzYWdlID0gJydcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgICAgICBpZiAocHRyKSB7XG4gICAgICAgICAgY29uc3QgbGVuID0gbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIHB0cikuaW5kZXhPZigwKVxuICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgJ1Jlc3BvbnNlIGRvZXMgbm90IG1hdGNoIHRoZSBIVFRQLzEuMSBwcm90b2NvbCAoJyArXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyLCBsZW4pLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgJyknXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEhUVFBQYXJzZXJFcnJvcihtZXNzYWdlLCBjb25zdGFudHMuRVJST1JbcmV0XSwgZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGFzc2VydCh0aGlzLnB0ciAhPSBudWxsKVxuICAgIGFzc2VydChjdXJyZW50UGFyc2VyID09IG51bGwpXG5cbiAgICB0aGlzLmxsaHR0cC5sbGh0dHBfZnJlZSh0aGlzLnB0cilcbiAgICB0aGlzLnB0ciA9IG51bGxcblxuICAgIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB9XG5cbiAgb25TdGF0dXMgKGJ1Zikge1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGJ1Zi50b1N0cmluZygpXG4gIH1cblxuICBvbk1lc3NhZ2VCZWdpbiAoKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcbiAgfVxuXG4gIG9uSGVhZGVyRmllbGQgKGJ1Zikge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGhcblxuICAgIGlmICgobGVuICYgMSkgPT09IDApIHtcbiAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1ZilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcbiAgfVxuXG4gIG9uSGVhZGVyVmFsdWUgKGJ1Zikge1xuICAgIGxldCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAxKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgICBsZW4gKz0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5oZWFkZXJzW2xlbiAtIDJdXG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEwKSB7XG4gICAgICBjb25zdCBoZWFkZXJOYW1lID0gdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSlcbiAgICAgIGlmIChoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgKz0gYnVmLnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ2Nvbm5lY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYgdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSkgPT09ICdjb250ZW50LWxlbmd0aCcpIHtcbiAgICAgIHRoaXMuY29udGVudExlbmd0aCArPSBidWYudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcbiAgfVxuXG4gIHRyYWNrSGVhZGVyIChsZW4pIHtcbiAgICB0aGlzLmhlYWRlcnNTaXplICs9IGxlblxuICAgIGlmICh0aGlzLmhlYWRlcnNTaXplID49IHRoaXMuaGVhZGVyc01heFNpemUpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLnNvY2tldCwgbmV3IEhlYWRlcnNPdmVyZmxvd0Vycm9yKCkpXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChoZWFkKSB7XG4gICAgY29uc3QgeyB1cGdyYWRlLCBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzQ29kZSB9ID0gdGhpc1xuXG4gICAgYXNzZXJ0KHVwZ3JhZGUpXG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydCghc29ja2V0LmRlc3Ryb3llZClcbiAgICBhc3NlcnQoc29ja2V0ID09PSBjbGllbnRba1NvY2tldF0pXG4gICAgYXNzZXJ0KCF0aGlzLnBhdXNlZClcbiAgICBhc3NlcnQocmVxdWVzdC51cGdyYWRlIHx8IHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IG51bGxcblxuICAgIGFzc2VydCh0aGlzLmhlYWRlcnMubGVuZ3RoICUgMiA9PT0gMClcbiAgICB0aGlzLmhlYWRlcnMgPSBbXVxuICAgIHRoaXMuaGVhZGVyc1NpemUgPSAwXG5cbiAgICBzb2NrZXQudW5zaGlmdChoZWFkKVxuXG4gICAgc29ja2V0W2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgIHNvY2tldFtrUGFyc2VyXSA9IG51bGxcblxuICAgIHNvY2tldFtrQ2xpZW50XSA9IG51bGxcbiAgICBzb2NrZXRba0Vycm9yXSA9IG51bGxcblxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhzb2NrZXQpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsIC8vIFRPRE8gKGZpeCk6IFRoaXMgaXMgaGFja3kuLi5cbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigndXBncmFkZScpKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3Qub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9XG5cbiAgb25IZWFkZXJzQ29tcGxldGUgKHN0YXR1c0NvZGUsIHVwZ3JhZGUsIHNob3VsZEtlZXBBbGl2ZSkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBzb2NrZXQsIGhlYWRlcnMsIHN0YXR1c1RleHQgfSA9IHRoaXNcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBkaWZmaWN1bHQgdG8gbWFrZSBhIHRlc3QgY2FzZSBmb3IgKi9cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBhc3NlcnQoIXRoaXMudXBncmFkZSlcbiAgICBhc3NlcnQodGhpcy5zdGF0dXNDb2RlIDwgMjAwKVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgcmVzcG9uc2UnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICAvKiB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiBzZXJ2ZXIgaXMgbWlzYmVoYXZpbmcgKi9cbiAgICBpZiAodXBncmFkZSAmJiAhcmVxdWVzdC51cGdyYWRlKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgU29ja2V0RXJyb3IoJ2JhZCB1cGdyYWRlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHRoaXMudGltZW91dFR5cGUsIFRJTUVPVVRfSEVBREVSUylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IChcbiAgICAgIHNob3VsZEtlZXBBbGl2ZSB8fFxuICAgICAgLy8gT3ZlcnJpZGUgbGxodHRwIHZhbHVlIHdoaWNoIGRvZXMgbm90IGFsbG93IGtlZXBBbGl2ZSBmb3IgSEVBRC5cbiAgICAgIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnICYmICFzb2NrZXRba1Jlc2V0XSAmJiB0aGlzLmNvbm5lY3Rpb24udG9Mb3dlckNhc2UoKSA9PT0gJ2tlZXAtYWxpdmUnKVxuICAgIClcblxuICAgIGlmICh0aGlzLnN0YXR1c0NvZGUgPj0gMjAwKSB7XG4gICAgICBjb25zdCBib2R5VGltZW91dCA9IHJlcXVlc3QuYm9keVRpbWVvdXQgIT0gbnVsbFxuICAgICAgICA/IHJlcXVlc3QuYm9keVRpbWVvdXRcbiAgICAgICAgOiBjbGllbnRba0JvZHlUaW1lb3V0XVxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGJvZHlUaW1lb3V0LCBUSU1FT1VUX0JPRFkpXG4gICAgfSBlbHNlIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAxKVxuICAgICAgdGhpcy51cGdyYWRlID0gdHJ1ZVxuICAgICAgcmV0dXJuIDJcbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5oZWFkZXJzLmxlbmd0aCAlIDIgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBwYXVzZSA9IHJlcXVlc3Qub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2VcblxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2UgPyBjb25zdGFudHMuRVJST1IuUEFVU0VEIDogMFxuICB9XG5cbiAgb25Cb2R5IChidWYpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCBtYXhSZXNwb25zZVNpemUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0aGlzLnRpbWVvdXRUeXBlLCBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShidWYpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9XG4gIH1cblxuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICBhc3NlcnQoc3RhdHVzQ29kZSA+PSAxMDApXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuXG4gICAgYXNzZXJ0KHRoaXMuaGVhZGVycy5sZW5ndGggJSAyID09PSAwKVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIGJlIGhhbmRsZWQgYnkgbGxodHRwPyAqL1xuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnICYmIGNvbnRlbnRMZW5ndGggJiYgYnl0ZXNSZWFkICE9PSBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uQ29tcGxldGUoaGVhZGVycylcblxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG5cbiAgICBpZiAoc29ja2V0W2tXcml0aW5nXSkge1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNsaWVudFtrUnVubmluZ10sIDApXG4gICAgICAvLyBSZXNwb25zZSBjb21wbGV0ZWQgYmVmb3JlIHJlcXVlc3QuXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKCFzaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoc29ja2V0W2tSZXNldF0gJiYgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCkge1xuICAgICAgLy8gRGVzdHJveSBzb2NrZXQgb25jZSBhbGwgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBhdCB0aGUgdGFpbCBvZiB0aGUgcGlwZWxpbmUgaXMgdGhlIG9uZVxuICAgICAgLy8gdGhhdCByZXF1ZXN0ZWQgcmVzZXQgYW5kIG5vIGZ1cnRoZXIgcmVxdWVzdHMgc2hvdWxkXG4gICAgICAvLyBoYXZlIGJlZW4gcXVldWVkIHNpbmNlIHRoZW4uXG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdyZXNldCcpKVxuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUGlwZWxpbmluZ10gPT0gbnVsbCB8fCBjbGllbnRba1BpcGVsaW5pbmddID09PSAxKSB7XG4gICAgICAvLyBXZSBtdXN0IHdhaXQgYSBmdWxsIGV2ZW50IGxvb3AgY3ljbGUgdG8gcmV1c2UgdGhpcyBzb2NrZXQgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IG5vbi1zcGVjIGNvbXBsaWFudCBzZXJ2ZXJzIGFyZSBub3QgY2xvc2luZyB0aGUgY29ubmVjdGlvbiBldmVuIGlmIHRoZXlcbiAgICAgIC8vIHNhaWQgdGhleSB3b24ndC5cbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiBjbGllbnRba1Jlc3VtZV0oKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25QYXJzZXJUaW1lb3V0IChwYXJzZXIpIHtcbiAgY29uc3QgeyBzb2NrZXQsIHRpbWVvdXRUeXBlLCBjbGllbnQgfSA9IHBhcnNlclxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgaWYgKCFzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldC53cml0YWJsZU5lZWREcmFpbiB8fCBjbGllbnRba1J1bm5pbmddID4gMSkge1xuICAgICAgYXNzZXJ0KCFwYXJzZXIucGF1c2VkLCAnY2Fubm90IGJlIHBhdXNlZCB3aGlsZSB3YWl0aW5nIGZvciBoZWFkZXJzJylcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBIZWFkZXJzVGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpIHtcbiAgICBpZiAoIXBhcnNlci5wYXVzZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBCb2R5VGltZW91dEVycm9yKCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0lETEUpIHtcbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMCAmJiBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0pXG4gICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcignc29ja2V0IGlkbGUgdGltZW91dCcpKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RIMSAoY2xpZW50LCBzb2NrZXQpIHtcbiAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0XG5cbiAgaWYgKCFsbGh0dHBJbnN0YW5jZSkge1xuICAgIGxsaHR0cEluc3RhbmNlID0gYXdhaXQgbGxodHRwUHJvbWlzZVxuICAgIGxsaHR0cFByb21pc2UgPSBudWxsXG4gIH1cblxuICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuICBzb2NrZXRba1Jlc2V0XSA9IGZhbHNlXG4gIHNvY2tldFtrQmxvY2tpbmddID0gZmFsc2VcbiAgc29ja2V0W2tQYXJzZXJdID0gbmV3IFBhcnNlcihjbGllbnQsIHNvY2tldCwgbGxodHRwSW5zdGFuY2UpXG5cbiAgYWRkTGlzdGVuZXIoc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgICAvLyBPbiBNYWMgT1MsIHdlIGdldCBhbiBFQ09OTlJFU0VUIGV2ZW4gaWYgdGhlcmUgaXMgYSBmdWxsIGJvZHkgdG8gYmUgZm9yd2FyZGVkXG4gICAgLy8gdG8gdGhlIHVzZXIuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcgJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZvciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXNba0Vycm9yXSA9IGVyclxuXG4gICAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxuICB9KVxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBwYXJzZXIucmVhZE1vcmUoKVxuICAgIH1cbiAgfSlcbiAgYWRkTGlzdGVuZXIoc29ja2V0LCAnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICAgIGlmIChwYXJzZXIuc3RhdHVzQ29kZSAmJiAhcGFyc2VyLnNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZmFyIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdXRpbC5kZXN0cm95KHRoaXMsIG5ldyBTb2NrZXRFcnJvcignb3RoZXIgc2lkZSBjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpKVxuICB9KVxuICBhZGRMaXN0ZW5lcihzb2NrZXQsICdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzW2tDbGllbnRdXG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgaWYgKCF0aGlzW2tFcnJvcl0gJiYgcGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgICAgLy8gV2UgdHJlYXQgYWxsIGluY29taW5nIGRhdGEgc28gZmFyIGFzIGEgdmFsaWQgcmVzcG9uc2UuXG4gICAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXNba1BhcnNlcl0uZGVzdHJveSgpXG4gICAgICB0aGlzW2tQYXJzZXJdID0gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoJ2Nsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSlcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgICBjbGllbnRba0hUVFBDb250ZXh0XSA9IG51bGwgLy8gVE9ETyAoZml4KTogVGhpcyBpcyBoYWNreS4uLlxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJykge1xuICAgICAgLy8gRmFpbCBoZWFkIG9mIHBpcGVsaW5lLlxuICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuXG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XVxuXG4gICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG5cbiAgICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIGVycilcblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0pXG5cbiAgbGV0IGNsb3NlZCA9IGZhbHNlXG4gIHNvY2tldC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogJ2gxJyxcbiAgICBkZWZhdWx0UGlwZWxpbmluZzogMSxcbiAgICB3cml0ZSAoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHdyaXRlSDEoY2xpZW50LCAuLi5hcmdzKVxuICAgIH0sXG4gICAgcmVzdW1lICgpIHtcbiAgICAgIHJlc3VtZUgxKGNsaWVudClcbiAgICB9LFxuICAgIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQuZGVzdHJveShlcnIpLm9uKCdjbG9zZScsIGNhbGxiYWNrKVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgICByZXR1cm4gc29ja2V0LmRlc3Ryb3llZFxuICAgIH0sXG4gICAgYnVzeSAocmVxdWVzdCkge1xuICAgICAgaWYgKHNvY2tldFtrV3JpdGluZ10gfHwgc29ja2V0W2tSZXNldF0gfHwgc29ja2V0W2tCbG9ja2luZ10pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmICFyZXF1ZXN0LmlkZW1wb3RlbnQpIHtcbiAgICAgICAgICAvLyBOb24taWRlbXBvdGVudCByZXF1ZXN0IGNhbm5vdCBiZSByZXRyaWVkLlxuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIG90aGVyIHJlcXVlc3RzIGFyZSBpbmZsaWdodCBhbmRcbiAgICAgICAgICAvLyBjb3VsZCBjYXVzZSBmYWlsdXJlLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgKHJlcXVlc3QudXBncmFkZSB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSkge1xuICAgICAgICAgIC8vIERvbid0IGRpc3BhdGNoIGFuIHVwZ3JhZGUgdW50aWwgYWxsIHByZWNlZGluZyByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgICAgICAvLyBBIG1pc2JlaGF2aW5nIHNlcnZlciBtaWdodCB1cGdyYWRlIHRoZSBjb25uZWN0aW9uIGJlZm9yZSBhbGwgcGlwZWxpbmVkXG4gICAgICAgICAgLy8gcmVxdWVzdCBoYXMgY29tcGxldGVkLlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgdXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgIT09IDAgJiZcbiAgICAgICAgICAodXRpbC5pc1N0cmVhbShyZXF1ZXN0LmJvZHkpIHx8IHV0aWwuaXNBc3luY0l0ZXJhYmxlKHJlcXVlc3QuYm9keSkgfHwgdXRpbC5pc0Zvcm1EYXRhTGlrZShyZXF1ZXN0LmJvZHkpKSkge1xuICAgICAgICAgIC8vIFJlcXVlc3Qgd2l0aCBzdHJlYW0gb3IgaXRlcmF0b3IgYm9keSBjYW4gZXJyb3Igd2hpbGUgb3RoZXIgcmVxdWVzdHNcbiAgICAgICAgICAvLyBhcmUgaW5mbGlnaHQgYW5kIGluZGlyZWN0bHkgZXJyb3IgdGhvc2UgYXMgd2VsbC5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBieSB3YWl0aW5nIGZvciBpbmZsaWdodFxuICAgICAgICAgIC8vIHRvIGNvbXBsZXRlIGJlZm9yZSBkaXNwYXRjaGluZy5cblxuICAgICAgICAgIC8vIFJlcXVlc3Qgd2l0aCBzdHJlYW0gb3IgaXRlcmF0b3IgYm9keSBjYW5ub3QgYmUgcmV0cmllZC5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBubyBvdGhlciByZXF1ZXN0cyBhcmUgaW5mbGlnaHQgYW5kXG4gICAgICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVIMSAoY2xpZW50KSB7XG4gIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gIGlmIChzb2NrZXQgJiYgIXNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgaWYgKCFzb2NrZXRba05vUmVmXSAmJiBzb2NrZXQudW5yZWYpIHtcbiAgICAgICAgc29ja2V0LnVucmVmKClcbiAgICAgICAgc29ja2V0W2tOb1JlZl0gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb2NrZXRba05vUmVmXSAmJiBzb2NrZXQucmVmKSB7XG4gICAgICBzb2NrZXQucmVmKClcbiAgICAgIHNvY2tldFtrTm9SZWZdID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSAhPT0gVElNRU9VVF9JRExFKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS5zZXRUaW1lb3V0KGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSwgVElNRU9VVF9JRExFKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDAgJiYgc29ja2V0W2tQYXJzZXJdLnN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICAgICAgY29uc3QgaGVhZGVyc1RpbWVvdXQgPSByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0ICE9IG51bGxcbiAgICAgICAgICA/IHJlcXVlc3QuaGVhZGVyc1RpbWVvdXRcbiAgICAgICAgICA6IGNsaWVudFtrSGVhZGVyc1RpbWVvdXRdXG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS5zZXRUaW1lb3V0KGhlYWRlcnNUaW1lb3V0LCBUSU1FT1VUX0hFQURFUlMpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbmZ1bmN0aW9uIHNob3VsZFNlbmRDb250ZW50TGVuZ3RoIChtZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCAhPT0gJ0dFVCcgJiYgbWV0aG9kICE9PSAnSEVBRCcgJiYgbWV0aG9kICE9PSAnT1BUSU9OUycgJiYgbWV0aG9kICE9PSAnVFJBQ0UnICYmIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDEgKGNsaWVudCwgcmVxdWVzdCkge1xuICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgaG9zdCwgdXBncmFkZSwgYmxvY2tpbmcsIHJlc2V0IH0gPSByZXF1ZXN0XG5cbiAgbGV0IHsgYm9keSwgaGVhZGVycywgY29udGVudExlbmd0aCB9ID0gcmVxdWVzdFxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjFcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMlxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy41XG5cbiAgLy8gU2VuZGluZyBhIHBheWxvYWQgYm9keSBvbiBhIHJlcXVlc3QgdGhhdCBkb2VzIG5vdFxuICAvLyBleHBlY3QgaXQgY2FuIGNhdXNlIHVuZGVmaW5lZCBiZWhhdmlvciBvbiBzb21lXG4gIC8vIHNlcnZlcnMgYW5kIGNvcnJ1cHQgY29ubmVjdGlvbiBzdGF0ZS4gRG8gbm90XG4gIC8vIHJlLXVzZSB0aGUgY29ubmVjdGlvbiBmb3IgZnVydGhlciByZXF1ZXN0cy5cblxuICBjb25zdCBleHBlY3RzUGF5bG9hZCA9IChcbiAgICBtZXRob2QgPT09ICdQVVQnIHx8XG4gICAgbWV0aG9kID09PSAnUE9TVCcgfHxcbiAgICBtZXRob2QgPT09ICdQQVRDSCdcbiAgKVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKGJvZHkpKSB7XG4gICAgaWYgKCFleHRyYWN0Qm9keSkge1xuICAgICAgZXh0cmFjdEJvZHkgPSByZXF1aXJlKCcuLi93ZWIvZmV0Y2gvYm9keS5qcycpLmV4dHJhY3RCb2R5XG4gICAgfVxuXG4gICAgY29uc3QgW2JvZHlTdHJlYW0sIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KGJvZHkpXG4gICAgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgPT0gbnVsbCkge1xuICAgICAgaGVhZGVycy5wdXNoKCdjb250ZW50LXR5cGUnLCBjb250ZW50VHlwZSlcbiAgICB9XG4gICAgYm9keSA9IGJvZHlTdHJlYW0uc3RyZWFtXG4gICAgY29udGVudExlbmd0aCA9IGJvZHlTdHJlYW0ubGVuZ3RoXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpICYmIHJlcXVlc3QuY29udGVudFR5cGUgPT0gbnVsbCAmJiBib2R5LnR5cGUpIHtcbiAgICBoZWFkZXJzLnB1c2goJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSlcbiAgfVxuXG4gIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnJlYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUcnkgdG8gcmVhZCBFT0YgaW4gb3JkZXIgdG8gZ2V0IGxlbmd0aC5cbiAgICBib2R5LnJlYWQoMClcbiAgfVxuXG4gIGNvbnN0IGJvZHlMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBjb250ZW50TGVuZ3RoID0gYm9keUxlbmd0aCA/PyBjb250ZW50TGVuZ3RoXG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCAmJiAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiByZXF1ZXN0LmNvbnRlbnRMZW5ndGggIT09IGNvbnRlbnRMZW5ndGgpIHtcbiAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgfVxuXG4gIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyIHx8IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG5cbiAgICB1dGlsLmRlc3Ryb3koYm9keSlcbiAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdhYm9ydGVkJykpXG4gIH1cblxuICB0cnkge1xuICAgIHJlcXVlc3Qub25Db25uZWN0KGFib3J0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChtZXRob2QgPT09ICdIRUFEJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvaXNzdWVzLzI1OFxuICAgIC8vIENsb3NlIGFmdGVyIGEgSEVBRCByZXF1ZXN0IHRvIGludGVyb3Agd2l0aCBtaXNiZWhhdmluZyBzZXJ2ZXJzXG4gICAgLy8gdGhhdCBtYXkgc2VuZCBhIGJvZHkgaW4gdGhlIHJlc3BvbnNlLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAodXBncmFkZSB8fCBtZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgIC8vIE9uIENPTk5FQ1Qgb3IgdXBncmFkZSwgYmxvY2sgcGlwZWxpbmUgZnJvbSBkaXNwYXRjaGluZyBmdXJ0aGVyXG4gICAgLy8gcmVxdWVzdHMgb24gdGhpcyBjb25uZWN0aW9uLlxuXG4gICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gIH1cblxuICBpZiAocmVzZXQgIT0gbnVsbCkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gcmVzZXRcbiAgfVxuXG4gIGlmIChjbGllbnRba01heFJlcXVlc3RzXSAmJiBzb2NrZXRba0NvdW50ZXJdKysgPj0gY2xpZW50W2tNYXhSZXF1ZXN0c10pIHtcbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChibG9ja2luZykge1xuICAgIHNvY2tldFtrQmxvY2tpbmddID0gdHJ1ZVxuICB9XG5cbiAgbGV0IGhlYWRlciA9IGAke21ldGhvZH0gJHtwYXRofSBIVFRQLzEuMVxcclxcbmBcblxuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgaGVhZGVyICs9IGBob3N0OiAke2hvc3R9XFxyXFxuYFxuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSBjbGllbnRba0hvc3RIZWFkZXJdXG4gIH1cblxuICBpZiAodXBncmFkZSkge1xuICAgIGhlYWRlciArPSBgY29ubmVjdGlvbjogdXBncmFkZVxcclxcbnVwZ3JhZGU6ICR7dXBncmFkZX1cXHJcXG5gXG4gIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSAmJiAhc29ja2V0W2tSZXNldF0pIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGtlZXAtYWxpdmVcXHJcXG4nXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9ICdjb25uZWN0aW9uOiBjbG9zZVxcclxcbidcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBoZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBoZWFkZXJzW24gKyAwXVxuICAgICAgY29uc3QgdmFsID0gaGVhZGVyc1tuICsgMV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhlYWRlciArPSBgJHtrZXl9OiAke3ZhbFtpXX1cXHJcXG5gXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlciArPSBgJHtrZXl9OiAke3ZhbH1cXHJcXG5gXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoYW5uZWxzLnNlbmRIZWFkZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc2VuZEhlYWRlcnMucHVibGlzaCh7IHJlcXVlc3QsIGhlYWRlcnM6IGhlYWRlciwgc29ja2V0IH0pXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogYXNzZXJ0aW9uICovXG4gIGlmICghYm9keSB8fCBib2R5TGVuZ3RoID09PSAwKSB7XG4gICAgd3JpdGVCdWZmZXIoYWJvcnQsIG51bGwsIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKVxuICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICB3cml0ZUJ1ZmZlcihhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgaWYgKHR5cGVvZiBib2R5LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd3JpdGVJdGVyYWJsZShhYm9ydCwgYm9keS5zdHJlYW0oKSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdyaXRlQmxvYihhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gICAgfVxuICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICB3cml0ZVN0cmVhbShhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0l0ZXJhYmxlKGJvZHkpKSB7XG4gICAgd3JpdGVJdGVyYWJsZShhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gd3JpdGVTdHJlYW0gKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZCkge1xuICBhc3NlcnQoY29udGVudExlbmd0aCAhPT0gMCB8fCBjbGllbnRba1J1bm5pbmddID09PSAwLCAnc3RyZWFtIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGZpbmlzaGVkID0gZmFsc2VcblxuICBjb25zdCB3cml0ZXIgPSBuZXcgQXN5bmNXcml0ZXIoeyBhYm9ydCwgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcblxuICBjb25zdCBvbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIXdyaXRlci53cml0ZShjaHVuaykgJiYgdGhpcy5wYXVzZSkge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLCBlcnIpXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICAgIGJvZHkucmVzdW1lKClcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAnY2xvc2UnIG1pZ2h0IGJlIGVtaXR0ZWQgKmJlZm9yZSogJ2Vycm9yJyBmb3JcbiAgICAvLyBicm9rZW4gc3RyZWFtcy4gV2FpdCBhIHRpY2sgdG8gYXZvaWQgdGhpcyBjYXNlLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIEl0J3Mgb25seSBzYWZlIHRvIHJlbW92ZSAnZXJyb3InIGxpc3RlbmVyIGFmdGVyXG4gICAgICAvLyAnY2xvc2UnLlxuICAgICAgYm9keS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIH0pXG5cbiAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBvbkZpbmlzaGVkKGVycikpXG4gICAgfVxuICB9XG4gIGNvbnN0IG9uRmluaXNoZWQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmaW5pc2hlZCA9IHRydWVcblxuICAgIGFzc2VydChzb2NrZXQuZGVzdHJveWVkIHx8IChzb2NrZXRba1dyaXRpbmddICYmIGNsaWVudFtrUnVubmluZ10gPD0gMSkpXG5cbiAgICBzb2NrZXRcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2Vycm9yJywgb25GaW5pc2hlZClcblxuICAgIGJvZHlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSlcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25GaW5pc2hlZClcbiAgICAgIC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdyaXRlci5lbmQoKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgZXJyID0gZXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZXIuZGVzdHJveShlcnIpXG5cbiAgICBpZiAoZXJyICYmIChlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgfHwgZXJyLm1lc3NhZ2UgIT09ICdyZXNldCcpKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmRlc3Ryb3koYm9keSlcbiAgICB9XG4gIH1cblxuICBib2R5XG4gICAgLm9uKCdkYXRhJywgb25EYXRhKVxuICAgIC5vbignZW5kJywgb25GaW5pc2hlZClcbiAgICAub24oJ2Vycm9yJywgb25GaW5pc2hlZClcbiAgICAub24oJ2Nsb3NlJywgb25DbG9zZSlcblxuICBpZiAoYm9keS5yZXN1bWUpIHtcbiAgICBib2R5LnJlc3VtZSgpXG4gIH1cblxuICBzb2NrZXRcbiAgICAub24oJ2RyYWluJywgb25EcmFpbilcbiAgICAub24oJ2Vycm9yJywgb25GaW5pc2hlZClcblxuICBpZiAoYm9keS5lcnJvckVtaXR0ZWQgPz8gYm9keS5lcnJvcmVkKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IG9uRmluaXNoZWQoYm9keS5lcnJvcmVkKSlcbiAgfSBlbHNlIGlmIChib2R5LmVuZEVtaXR0ZWQgPz8gYm9keS5yZWFkYWJsZUVuZGVkKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IG9uRmluaXNoZWQobnVsbCkpXG4gIH1cblxuICBpZiAoYm9keS5jbG9zZUVtaXR0ZWQgPz8gYm9keS5jbG9zZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUob25DbG9zZSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUJ1ZmZlciAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gbnVsbCwgJ25vIGJvZHkgbXVzdCBub3QgaGF2ZSBjb250ZW50IGxlbmd0aCcpXG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9XFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcblxuICAgICAgc29ja2V0LmNvcmsoKVxuICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgc29ja2V0LndyaXRlKGJvZHkpXG4gICAgICBzb2NrZXQudW5jb3JrKClcbiAgICAgIHJlcXVlc3Qub25Cb2R5U2VudChib2R5KVxuXG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgYWJvcnQoZXJyKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LnNpemUsICdibG9iIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcblxuICB0cnkge1xuICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwgJiYgY29udGVudExlbmd0aCAhPT0gYm9keS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBib2R5LmFycmF5QnVmZmVyKCkpXG5cbiAgICBzb2NrZXQuY29yaygpXG4gICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgIHNvY2tldC53cml0ZShidWZmZXIpXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYnVmZmVyKVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVJdGVyYWJsZSAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdpdGVyYXRvciBib2R5IGNhbm5vdCBiZSBwaXBlbGluZWQnKVxuXG4gIGxldCBjYWxsYmFjayA9IG51bGxcbiAgZnVuY3Rpb24gb25EcmFpbiAoKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICBjb25zdCB3YWl0Rm9yRHJhaW4gPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYXNzZXJ0KGNhbGxiYWNrID09PSBudWxsKVxuXG4gICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICByZWplY3Qoc29ja2V0W2tFcnJvcl0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gcmVzb2x2ZVxuICAgIH1cbiAgfSlcblxuICBzb2NrZXRcbiAgICAub24oJ2Nsb3NlJywgb25EcmFpbilcbiAgICAub24oJ2RyYWluJywgb25EcmFpbilcblxuICBjb25zdCB3cml0ZXIgPSBuZXcgQXN5bmNXcml0ZXIoeyBhYm9ydCwgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSlcbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yRHJhaW4oKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5lbmQoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB3cml0ZXIuZGVzdHJveShlcnIpXG4gIH0gZmluYWxseSB7XG4gICAgc29ja2V0XG4gICAgICAub2ZmKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgICAub2ZmKCdkcmFpbicsIG9uRHJhaW4pXG4gIH1cbn1cblxuY2xhc3MgQXN5bmNXcml0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBhYm9ydCwgc29ja2V0LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSkge1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICAgIHRoaXMuY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGhcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMFxuICAgIHRoaXMuZXhwZWN0c1BheWxvYWQgPSBleHBlY3RzUGF5bG9hZFxuICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gdHJ1ZVxuICB9XG5cbiAgd3JpdGUgKGNodW5rKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgYnl0ZXNXcml0dGVuLCBleHBlY3RzUGF5bG9hZCwgaGVhZGVyIH0gPSB0aGlzXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rKVxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFdlIHNob3VsZCBkZWZlciB3cml0aW5nIGNodW5rcy5cbiAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiBieXRlc1dyaXR0ZW4gKyBsZW4gPiBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKCkpXG4gICAgfVxuXG4gICAgc29ja2V0LmNvcmsoKVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKCFleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn10cmFuc2Zlci1lbmNvZGluZzogY2h1bmtlZFxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogJHtjb250ZW50TGVuZ3RofVxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250ZW50TGVuZ3RoID09PSBudWxsKSB7XG4gICAgICBzb2NrZXQud3JpdGUoYFxcclxcbiR7bGVuLnRvU3RyaW5nKDE2KX1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICB9XG5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBsZW5cblxuICAgIGNvbnN0IHJldCA9IHNvY2tldC53cml0ZShjaHVuaylcblxuICAgIHNvY2tldC51bmNvcmsoKVxuXG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZW5kICgpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIsIHJlcXVlc3QgfSA9IHRoaXNcbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgfVxuXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChieXRlc1dyaXR0ZW4gPT09IDApIHtcbiAgICAgIGlmIChleHBlY3RzUGF5bG9hZCkge1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgICAgIC8vIEEgdXNlciBhZ2VudCBTSE9VTEQgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGluIGEgcmVxdWVzdCBtZXNzYWdlIHdoZW5cbiAgICAgICAgLy8gbm8gVHJhbnNmZXItRW5jb2RpbmcgaXMgc2VudCBhbmQgdGhlIHJlcXVlc3QgbWV0aG9kIGRlZmluZXMgYSBtZWFuaW5nXG4gICAgICAgIC8vIGZvciBhbiBlbmNsb3NlZCBwYXlsb2FkIGJvZHkuXG5cbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1jb250ZW50LWxlbmd0aDogMFxcclxcblxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZSgnXFxyXFxuMFxcclxcblxcclxcbicsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiAhPT0gY29udGVudExlbmd0aCkge1xuICAgICAgaWYgKGNsaWVudFtrU3RyaWN0Q29udGVudExlbmd0aF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQgJiYgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9XG5cbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCwgYWJvcnQgfSA9IHRoaXNcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSBmYWxzZVxuXG4gICAgaWYgKGVycikge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPD0gMSwgJ3BpcGVsaW5lIHNob3VsZCBvbmx5IGNvbnRhaW4gdGhpcyByZXF1ZXN0JylcbiAgICAgIGFib3J0KGVycilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0SDFcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume\n} = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOpenStreams = Symbol('open streams')\n\n// Experimental\nlet h2ExperimentalWarned = false\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = __webpack_require__(/*! node:http2 */ \"node:http2\")\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nasync function connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  if (!h2ExperimentalWarned) {\n    h2ExperimentalWarned = true\n    process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n      code: 'UNDICI-H2'\n    })\n  }\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHTTP2GoAway)\n  util.addListener(session, 'close', function () {\n    const { [kClient]: client } = this\n    const { [kSocket]: socket } = client\n\n    const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n    client[kHTTP2Session] = null\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    }\n  })\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n\n  util.addListener(socket, 'end', function () {\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n\n  util.addListener(socket, 'close', function () {\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n\n    if (this[kHTTP2Session] != null) {\n      this[kHTTP2Session].destroy(err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (...args) {\n      // TODO (fix): return\n      writeH2(client, ...args)\n    },\n    resume () {\n\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        // Destroying the socket will trigger the session close\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */\nfunction onHTTP2GoAway (code) {\n  const err = new RequestAbortedError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`)\n\n  // We need to trigger the close cycle right away\n  // We need to destroy the session and the socket\n  // Requests should be failed with the error after the current one is handled\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n\n  this.unref()\n\n  util.destroy(this[kSocket], err)\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const session = client[kHTTP2Session]\n  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `,${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      util.destroy(stream, err)\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream get's destroyed and the session remains to create new streams\n    util.destroy(body, err)\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      const err = new RequestAbortedError()\n      util.errorRequest(client, request, err)\n      util.destroy(stream, err)\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n\n    stream.on('data', (chunk) => {\n      if (request.onData(chunk) === false) {\n        stream.pause()\n      }\n    })\n  })\n\n  stream.once('end', () => {\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      request.onComplete([])\n      return\n    }\n\n    // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n    // It does not have sense to continue working with the stream as we do not\n    // have yet RST_STREAM support on client-side\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n\n    abort(new InformationalError('HTTP/2: stream half-closed (remote)'))\n  })\n\n  stream.once('close', () => {\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Support push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRWhDOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyw4QkFBWTtBQUM5QixFQUFFO0FBQ0Y7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksb0JBQW9COztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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LE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxjbGllbnQtaDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3Qge1xuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5jb25zdCB7XG4gIGtVcmwsXG4gIGtSZXNldCxcbiAga0NsaWVudCxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrUXVldWUsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrU29ja2V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga09uRXJyb3IsXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtcyxcbiAga0hUVFAyU2Vzc2lvbixcbiAga1Jlc3VtZVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5cbmNvbnN0IGtPcGVuU3RyZWFtcyA9IFN5bWJvbCgnb3BlbiBzdHJlYW1zJylcblxuLy8gRXhwZXJpbWVudGFsXG5sZXQgaDJFeHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG4vKiogQHR5cGUge2ltcG9ydCgnaHR0cDInKX0gKi9cbmxldCBodHRwMlxudHJ5IHtcbiAgaHR0cDIgPSByZXF1aXJlKCdub2RlOmh0dHAyJylcbn0gY2F0Y2gge1xuICAvLyBAdHMtaWdub3JlXG4gIGh0dHAyID0geyBjb25zdGFudHM6IHt9IH1cbn1cblxuY29uc3Qge1xuICBjb25zdGFudHM6IHtcbiAgICBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLFxuICAgIEhUVFAyX0hFQURFUl9NRVRIT0QsXG4gICAgSFRUUDJfSEVBREVSX1BBVEgsXG4gICAgSFRUUDJfSEVBREVSX1NDSEVNRSxcbiAgICBIVFRQMl9IRUFERVJfQ09OVEVOVF9MRU5HVEgsXG4gICAgSFRUUDJfSEVBREVSX0VYUEVDVCxcbiAgICBIVFRQMl9IRUFERVJfU1RBVFVTXG4gIH1cbn0gPSBodHRwMlxuXG5mdW5jdGlvbiBwYXJzZUgySGVhZGVycyAoaGVhZGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgIC8vIGgyIG1heSBjb25jYXQgdGhlIGhlYWRlciB2YWx1ZSBieSBhcnJheVxuICAgIC8vIGUuZy4gU2V0LUNvb2tpZVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBzdWJ2YWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWFjaCBoZWFkZXIgdmFsdWUgb2YgaGVhZGVyIG5hbWVcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgaGVhZGVycyBoYW5kbGVyIGV4cGVjdCBuYW1lLXZhbHVlIHBhaXJcbiAgICAgICAgcmVzdWx0LnB1c2goQnVmZmVyLmZyb20obmFtZSksIEJ1ZmZlci5mcm9tKHN1YnZhbHVlKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goQnVmZmVyLmZyb20obmFtZSksIEJ1ZmZlci5mcm9tKHZhbHVlKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RIMiAoY2xpZW50LCBzb2NrZXQpIHtcbiAgY2xpZW50W2tTb2NrZXRdID0gc29ja2V0XG5cbiAgaWYgKCFoMkV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgIGgyRXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0gyIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgY29kZTogJ1VORElDSS1IMidcbiAgICB9KVxuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyLmNvbm5lY3QoY2xpZW50W2tVcmxdLCB7XG4gICAgY3JlYXRlQ29ubmVjdGlvbjogKCkgPT4gc29ja2V0LFxuICAgIHBlZXJNYXhDb25jdXJyZW50U3RyZWFtczogY2xpZW50W2tNYXhDb25jdXJyZW50U3RyZWFtc11cbiAgfSlcblxuICBzZXNzaW9uW2tPcGVuU3RyZWFtc10gPSAwXG4gIHNlc3Npb25ba0NsaWVudF0gPSBjbGllbnRcbiAgc2Vzc2lvbltrU29ja2V0XSA9IHNvY2tldFxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2Vycm9yJywgb25IdHRwMlNlc3Npb25FcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZnJhbWVFcnJvcicsIG9uSHR0cDJGcmFtZUVycm9yKVxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdlbmQnLCBvbkh0dHAyU2Vzc2lvbkVuZClcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZ29hd2F5Jywgb25IVFRQMkdvQXdheSlcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeyBba0NsaWVudF06IGNsaWVudCB9ID0gdGhpc1xuICAgIGNvbnN0IHsgW2tTb2NrZXRdOiBzb2NrZXQgfSA9IGNsaWVudFxuXG4gICAgY29uc3QgZXJyID0gdGhpc1trU29ja2V0XVtrRXJyb3JdIHx8IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoJ2Nsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKVxuXG4gICAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gbnVsbFxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuXG4gICAgICAvLyBGYWlsIGVudGlyZSBxdWV1ZS5cbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgc2Vzc2lvbi51bnJlZigpXG5cbiAgY2xpZW50W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuICBzb2NrZXRba0hUVFAyU2Vzc2lvbl0gPSBzZXNzaW9uXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICAgIHRoaXNba0Vycm9yXSA9IGVyclxuXG4gICAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxuICB9KVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIHV0aWwuZGVzdHJveSh0aGlzLCBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKSlcbiAgfSlcblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoJ2Nsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSlcblxuICAgIGNsaWVudFtrU29ja2V0XSA9IG51bGxcblxuICAgIGlmICh0aGlzW2tIVFRQMlNlc3Npb25dICE9IG51bGwpIHtcbiAgICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0uZGVzdHJveShlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuXG4gICAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9KVxuXG4gIGxldCBjbG9zZWQgPSBmYWxzZVxuICBzb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdoMicsXG4gICAgZGVmYXVsdFBpcGVsaW5pbmc6IEluZmluaXR5LFxuICAgIHdyaXRlICguLi5hcmdzKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiByZXR1cm5cbiAgICAgIHdyaXRlSDIoY2xpZW50LCAuLi5hcmdzKVxuICAgIH0sXG4gICAgcmVzdW1lICgpIHtcblxuICAgIH0sXG4gICAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERlc3Ryb3lpbmcgdGhlIHNvY2tldCB3aWxsIHRyaWdnZXIgdGhlIHNlc3Npb24gY2xvc2VcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyKS5vbignY2xvc2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBkZXN0cm95ZWQgKCkge1xuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95ZWRcbiAgICB9LFxuICAgIGJ1c3kgKCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyRnJhbWVFcnJvciAodHlwZSwgY29kZSwgaWQpIHtcbiAgaWYgKGlkID09PSAwKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YClcbiAgICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FbmQgKCkge1xuICBjb25zdCBlcnIgPSBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXNba1NvY2tldF0pKVxuICB0aGlzLmRlc3Ryb3koZXJyKVxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgZXJyKVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHJvb3QgY2F1c2Ugb2YgIzMwMTFcbiAqIFdlIG5lZWQgdG8gaGFuZGxlIEdPQVdBWSBmcmFtZXMgcHJvcGVybHksIGFuZCB0cmlnZ2VyIHRoZSBzZXNzaW9uIGNsb3NlXG4gKiBhbG9uZyB3aXRoIHRoZSBzb2NrZXQgcmlnaHQgYXdheVxuICovXG5mdW5jdGlvbiBvbkhUVFAyR29Bd2F5IChjb2RlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKGBIVFRQLzI6IFwiR09BV0FZXCIgZnJhbWUgcmVjZWl2ZWQgd2l0aCBjb2RlICR7Y29kZX1gKVxuXG4gIC8vIFdlIG5lZWQgdG8gdHJpZ2dlciB0aGUgY2xvc2UgY3ljbGUgcmlnaHQgYXdheVxuICAvLyBXZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHNlc3Npb24gYW5kIHRoZSBzb2NrZXRcbiAgLy8gUmVxdWVzdHMgc2hvdWxkIGJlIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBhZnRlciB0aGUgY3VycmVudCBvbmUgaXMgaGFuZGxlZFxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxuXG4gIHRoaXMudW5yZWYoKVxuXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBlcnIpXG59XG5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbmZ1bmN0aW9uIHNob3VsZFNlbmRDb250ZW50TGVuZ3RoIChtZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCAhPT0gJ0dFVCcgJiYgbWV0aG9kICE9PSAnSEVBRCcgJiYgbWV0aG9kICE9PSAnT1BUSU9OUycgJiYgbWV0aG9kICE9PSAnVFJBQ0UnICYmIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDIgKGNsaWVudCwgcmVxdWVzdCkge1xuICBjb25zdCBzZXNzaW9uID0gY2xpZW50W2tIVFRQMlNlc3Npb25dXG4gIGNvbnN0IHsgYm9keSwgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBleHBlY3RDb250aW51ZSwgc2lnbmFsLCBoZWFkZXJzOiByZXFIZWFkZXJzIH0gPSByZXF1ZXN0XG5cbiAgaWYgKHVwZ3JhZGUpIHtcbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBFcnJvcignVXBncmFkZSBub3Qgc3VwcG9ydGVkIGZvciBIMicpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgaGVhZGVycyA9IHt9XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcmVxSGVhZGVycy5sZW5ndGg7IG4gKz0gMikge1xuICAgIGNvbnN0IGtleSA9IHJlcUhlYWRlcnNbbiArIDBdXG4gICAgY29uc3QgdmFsID0gcmVxSGVhZGVyc1tuICsgMV1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChoZWFkZXJzW2tleV0pIHtcbiAgICAgICAgICBoZWFkZXJzW2tleV0gKz0gYCwke3ZhbFtpXX1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyc1trZXldID0gdmFsXG4gICAgfVxuICB9XG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6aHR0cDInKS5DbGllbnRIdHRwMlN0cmVhbX0gKi9cbiAgbGV0IHN0cmVhbVxuXG4gIGNvbnN0IHsgaG9zdG5hbWUsIHBvcnQgfSA9IGNsaWVudFtrVXJsXVxuXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0IHx8IGAke2hvc3RuYW1lfSR7cG9ydCA/IGA6JHtwb3J0fWAgOiAnJ31gXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX01FVEhPRF0gPSBtZXRob2RcblxuICBjb25zdCBhYm9ydCA9IChlcnIpID0+IHtcbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkIHx8IHJlcXVlc3QuY29tcGxldGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlcnIgPSBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG5cbiAgICBpZiAoc3RyZWFtICE9IG51bGwpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzdHJlYW0sIGVycilcbiAgICB9XG5cbiAgICAvLyBXZSBkbyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGFzIHdlIGNhbiBjb250aW51ZSB1c2luZyB0aGUgc2Vzc2lvblxuICAgIC8vIHRoZSBzdHJlYW0gZ2V0J3MgZGVzdHJveWVkIGFuZCB0aGUgc2Vzc2lvbiByZW1haW5zIHRvIGNyZWF0ZSBuZXcgc3RyZWFtc1xuICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZy5cbiAgICAvLyBXZSBjYW4gY2FsbCBvbiBjb25uZWN0LCBhbmQgd2FpdCBmb3IgYWJvcnRcbiAgICByZXF1ZXN0Lm9uQ29ubmVjdChhYm9ydClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBzZXNzaW9uLnJlZigpXG4gICAgLy8gV2UgYXJlIGFscmVhZHkgY29ubmVjdGVkLCBzdHJlYW1zIGFyZSBwZW5kaW5nLCBmaXJzdCByZXF1ZXN0XG4gICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgc3RyZWFtLiBXZSB0cmlnZ2VyIGEgcmVxdWVzdCB0byBjcmVhdGUgdGhlIHN0cmVhbSBhbmQgd2FpdCB1bnRpbFxuICAgIC8vIGByZWFkeWAgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgLy8gV2UgZGlzYWJsZWQgZW5kU3RyZWFtIHRvIGFsbG93IHRoZSB1c2VyIHRvIHdyaXRlIHRvIHRoZSBzdHJlYW1cbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgeyBlbmRTdHJlYW06IGZhbHNlLCBzaWduYWwgfSlcblxuICAgIGlmIChzdHJlYW0uaWQgJiYgIXN0cmVhbS5wZW5kaW5nKSB7XG4gICAgICByZXF1ZXN0Lm9uVXBncmFkZShudWxsLCBudWxsLCBzdHJlYW0pXG4gICAgICArK3Nlc3Npb25ba09wZW5TdHJlYW1zXVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3Qub25VcGdyYWRlKG51bGwsIG51bGwsIHN0cmVhbSlcbiAgICAgICAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgc2Vzc2lvbltrT3BlblN0cmVhbXNdIC09IDFcbiAgICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHNlc3Npb24udW5yZWYoKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1NDAjc2VjdGlvbi04LjNcbiAgLy8gOnBhdGggYW5kIDpzY2hlbWUgaGVhZGVycyBtdXN0IGJlIG9taXR0ZWQgd2hlbiBzZW5kaW5nIENPTk5FQ1RcblxuICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IHBhdGhcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfU0NIRU1FXSA9ICdodHRwcydcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnXG4gIClcblxuICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVHJ5IHRvIHJlYWQgRU9GIGluIG9yZGVyIHRvIGdldCBsZW5ndGguXG4gICAgYm9keS5yZWFkKDApXG4gIH1cblxuICBsZXQgY29udGVudExlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCB8fCAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGFzc2VydChib2R5LCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSF0gPSBgJHtjb250ZW50TGVuZ3RofWBcbiAgfVxuXG4gIHNlc3Npb24ucmVmKClcblxuICBjb25zdCBzaG91bGRFbmRTdHJlYW0gPSBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IGJvZHkgPT09IG51bGxcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBzaG91bGRFbmRTdHJlYW0sIHNpZ25hbCB9KVxuXG4gICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgd3JpdGVCb2R5SDIpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzdHJlYW1zIG9wZW5cbiAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBjb25zdCB7IFtIVFRQMl9IRUFERVJfU1RBVFVTXTogc3RhdHVzQ29kZSwgLi4ucmVhbEhlYWRlcnMgfSA9IGhlYWRlcnNcbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcblxuICAgIC8vIER1ZSB0byB0aGUgc3RyZWFtIG5hdHVyZSwgaXQgaXMgcG9zc2libGUgd2UgZmFjZSBhIHJhY2UgY29uZGl0aW9uXG4gICAgLy8gd2hlcmUgdGhlIHN0cmVhbSBoYXMgYmVlbiBhc3NpZ25lZCwgYnV0IHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcbiAgICAvLyB0aGUgcmVxdWVzdCByZW1haW5zIGluLWZsaWdodCBhbmQgaGVhZGVycyBoYXNuJ3QgYmVlbiByZWNlaXZlZCB5ZXRcbiAgICAvLyBmb3IgdGhvc2Ugc2NlbmFyaW9zLCBiZXN0IGVmZm9ydCBpcyB0byBkZXN0cm95IHRoZSBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAvLyBhcyB0aGVyZSdzIG5vIHZhbHVlIHRvIGtlZXAgaXQgb3Blbi5cbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIHV0aWwuZGVzdHJveShzdHJlYW0sIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm9uSGVhZGVycyhOdW1iZXIoc3RhdHVzQ29kZSksIHBhcnNlSDJIZWFkZXJzKHJlYWxIZWFkZXJzKSwgc3RyZWFtLnJlc3VtZS5iaW5kKHN0cmVhbSksICcnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5vbkRhdGEoY2h1bmspID09PSBmYWxzZSkge1xuICAgICAgICBzdHJlYW0ucGF1c2UoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAvLyBXaGVuIHN0YXRlIGlzIG51bGwsIGl0IG1lYW5zIHdlIGhhdmVuJ3QgY29uc3VtZWQgYm9keSBhbmQgdGhlIHN0cmVhbSBzdGlsbCBkbyBub3QgaGF2ZVxuICAgIC8vIGEgc3RhdGUuXG4gICAgLy8gUHJlc2VudCBzcGVjaWFsbHkgd2hlbiB1c2luZyBwaXBlbGluZSBvciBzdHJlYW1cbiAgICBpZiAoc3RyZWFtLnN0YXRlPy5zdGF0ZSA9PSBudWxsIHx8IHN0cmVhbS5zdGF0ZS5zdGF0ZSA8IDYpIHtcbiAgICAgIHJlcXVlc3Qub25Db21wbGV0ZShbXSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFN0cmVhbSBpcyBjbG9zZWQgb3IgaGFsZi1jbG9zZWQtcmVtb3RlICg2KSwgZGVjcmVtZW50IGNvdW50ZXIgYW5kIGNsZWFudXBcbiAgICAvLyBJdCBkb2VzIG5vdCBoYXZlIHNlbnNlIHRvIGNvbnRpbnVlIHdvcmtpbmcgd2l0aCB0aGUgc3RyZWFtIGFzIHdlIGRvIG5vdFxuICAgIC8vIGhhdmUgeWV0IFJTVF9TVFJFQU0gc3VwcG9ydCBvbiBjbGllbnQtc2lkZVxuICAgIGlmIChzZXNzaW9uW2tPcGVuU3RyZWFtc10gPT09IDApIHtcbiAgICAgIHNlc3Npb24udW5yZWYoKVxuICAgIH1cblxuICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ0hUVFAvMjogc3RyZWFtIGhhbGYtY2xvc2VkIChyZW1vdGUpJykpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHNlc3Npb25ba09wZW5TdHJlYW1zXSAtPSAxXG4gICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkge1xuICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2ZyYW1lRXJyb3InLCAodHlwZSwgY29kZSkgPT4ge1xuICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApKVxuICB9KVxuXG4gIC8vIHN0cmVhbS5vbignYWJvcnRlZCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgYWJvcnRlZFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndGltZW91dCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdGltZW91dFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigncHVzaCcsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCBwdXNoXG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCd0cmFpbGVycycsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCB0cmFpbGVyc1xuICAvLyB9KVxuXG4gIHJldHVybiB0cnVlXG5cbiAgZnVuY3Rpb24gd3JpdGVCb2R5SDIgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgICBpZiAoIWJvZHkgfHwgY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyaXRlSXRlcmFibGUoXG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJvZHkuc3RyZWFtKCksXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVCbG9iKFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHdyaXRlU3RyZWFtKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgd3JpdGVJdGVyYWJsZShcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXIgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIHRyeSB7XG4gICAgaWYgKGJvZHkgIT0gbnVsbCAmJiB1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgICAgaDJzdHJlYW0ud3JpdGUoYm9keSlcbiAgICAgIGgyc3RyZWFtLnVuY29yaygpXG4gICAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYWJvcnQoZXJyb3IpXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVTdHJlYW0gKGFib3J0LCBzb2NrZXQsIGV4cGVjdHNQYXlsb2FkLCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICAvLyBGb3IgSFRUUC8yLCBpcyBlbm91Z2ggdG8gcGlwZSB0aGUgc3RyZWFtXG4gIGNvbnN0IHBpcGUgPSBwaXBlbGluZShcbiAgICBib2R5LFxuICAgIGgyc3RyZWFtLFxuICAgIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHBpcGUsIGVycilcbiAgICAgICAgYWJvcnQoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5yZW1vdmVBbGxMaXN0ZW5lcnMocGlwZSlcbiAgICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIocGlwZSwgJ2RhdGEnLCBvblBpcGVEYXRhKVxuXG4gIGZ1bmN0aW9uIG9uUGlwZURhdGEgKGNodW5rKSB7XG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgIGgyc3RyZWFtLndyaXRlKGJ1ZmZlcilcbiAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIGgyc3RyZWFtLmVuZCgpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYnVmZmVyKVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVJdGVyYWJsZSAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGgyc3RyZWFtXG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGgyc3RyZWFtLndyaXRlKGNodW5rKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdEgyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// @ts-check\n\n\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst http = __webpack_require__(/*! node:http */ \"node:http\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\")\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(ssr)/./node_modules/undici/lib/core/request.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ../core/errors.js */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = __webpack_require__(/*! ../core/symbols.js */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h1.js\")\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(ssr)/./node_modules/undici/lib/dispatcher/client-h2.js\")\nlet deprecatedInterceptorWarned = false\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n      this[kInterceptors] = interceptors.Client\n      if (!deprecatedInterceptorWarned) {\n        deprecatedInterceptorWarned = true\n        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n          code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n        })\n      }\n    } else {\n      this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })]\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor.js */ \"(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? await connectH2(client, socket)\n        : await connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', () => {})\n      throw err\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        util.errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  client[kResume]()\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFvQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFnQjtBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsLmpzJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZGlhZ25vc3RpY3MuanMnKVxuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL2NvcmUvcmVxdWVzdC5qcycpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdC5qcycpXG5jb25zdCB7XG4gIGtVcmwsXG4gIGtTZXJ2ZXJOYW1lLFxuICBrQ2xpZW50LFxuICBrQnVzeSxcbiAga0Nvbm5lY3QsXG4gIGtSZXN1bWluZyxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrU2l6ZSxcbiAga1F1ZXVlLFxuICBrQ29ubmVjdGVkLFxuICBrQ29ubmVjdGluZyxcbiAga05lZWREcmFpbixcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0LFxuICBrSG9zdEhlYWRlcixcbiAga1BlbmRpbmdJZHgsXG4gIGtSdW5uaW5nSWR4LFxuICBrRXJyb3IsXG4gIGtQaXBlbGluaW5nLFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlLFxuICBrTWF4SGVhZGVyc1NpemUsXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0LFxuICBrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAga0hlYWRlcnNUaW1lb3V0LFxuICBrQm9keVRpbWVvdXQsXG4gIGtTdHJpY3RDb250ZW50TGVuZ3RoLFxuICBrQ29ubmVjdG9yLFxuICBrTWF4UmVkaXJlY3Rpb25zLFxuICBrTWF4UmVxdWVzdHMsXG4gIGtDb3VudGVyLFxuICBrQ2xvc2UsXG4gIGtEZXN0cm95LFxuICBrRGlzcGF0Y2gsXG4gIGtJbnRlcmNlcHRvcnMsXG4gIGtMb2NhbEFkZHJlc3MsXG4gIGtNYXhSZXNwb25zZVNpemUsXG4gIGtPbkVycm9yLFxuICBrSFRUUENvbnRleHQsXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtcyxcbiAga1Jlc3VtZVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5jb25zdCBjb25uZWN0SDEgPSByZXF1aXJlKCcuL2NsaWVudC1oMS5qcycpXG5jb25zdCBjb25uZWN0SDIgPSByZXF1aXJlKCcuL2NsaWVudC1oMi5qcycpXG5sZXQgZGVwcmVjYXRlZEludGVyY2VwdG9yV2FybmVkID0gZmFsc2VcblxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2tDbG9zZWRSZXNvbHZlJylcblxuZnVuY3Rpb24gZ2V0UGlwZWxpbmluZyAoY2xpZW50KSB7XG4gIHJldHVybiBjbGllbnRba1BpcGVsaW5pbmddID8/IGNsaWVudFtrSFRUUENvbnRleHRdPy5kZWZhdWx0UGlwZWxpbmluZyA/PyAxXG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2xpZW50LmpzJykuZGVmYXVsdH1cbiAqL1xuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NsaWVudC5qcycpLkNsaWVudC5PcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7XG4gICAgaW50ZXJjZXB0b3JzLFxuICAgIG1heEhlYWRlclNpemUsXG4gICAgaGVhZGVyc1RpbWVvdXQsXG4gICAgc29ja2V0VGltZW91dCxcbiAgICByZXF1ZXN0VGltZW91dCxcbiAgICBjb25uZWN0VGltZW91dCxcbiAgICBib2R5VGltZW91dCxcbiAgICBpZGxlVGltZW91dCxcbiAgICBrZWVwQWxpdmUsXG4gICAga2VlcEFsaXZlVGltZW91dCxcbiAgICBtYXhLZWVwQWxpdmVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZU1heFRpbWVvdXQsXG4gICAga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCxcbiAgICBzb2NrZXRQYXRoLFxuICAgIHBpcGVsaW5pbmcsXG4gICAgdGxzLFxuICAgIHN0cmljdENvbnRlbnRMZW5ndGgsXG4gICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgIGNvbm5lY3QsXG4gICAgbWF4UmVxdWVzdHNQZXJDbGllbnQsXG4gICAgbG9jYWxBZGRyZXNzLFxuICAgIG1heFJlc3BvbnNlU2l6ZSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5LFxuICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCxcbiAgICAvLyBoMlxuICAgIG1heENvbmN1cnJlbnRTdHJlYW1zLFxuICAgIGFsbG93SDJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgaWYgKGtlZXBBbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGtlZXBBbGl2ZSwgdXNlIHBpcGVsaW5pbmc9MCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHNvY2tldFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIHJlcXVlc3RUaW1lb3V0LCB1c2UgaGVhZGVyc1RpbWVvdXQgJiBib2R5VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAoaWRsZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBpZGxlVGltZW91dCwgdXNlIGtlZXBBbGl2ZVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKG1heEtlZXBBbGl2ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd1bnN1cHBvcnRlZCBtYXhLZWVwQWxpdmVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlTWF4VGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4SGVhZGVyU2l6ZSAhPSBudWxsICYmICFOdW1iZXIuaXNGaW5pdGUobWF4SGVhZGVyU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBtYXhIZWFkZXJTaXplJylcbiAgICB9XG5cbiAgICBpZiAoc29ja2V0UGF0aCAhPSBudWxsICYmIHR5cGVvZiBzb2NrZXRQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHNvY2tldFBhdGgnKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3RUaW1lb3V0KSB8fCBjb25uZWN0VGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlVGltZW91dCkgfHwga2VlcEFsaXZlVGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoa2VlcEFsaXZlTWF4VGltZW91dCkgfHwga2VlcEFsaXZlTWF4VGltZW91dCA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZU1heFRpbWVvdXQnKVxuICAgIH1cblxuICAgIGlmIChrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQnKVxuICAgIH1cblxuICAgIGlmIChoZWFkZXJzVGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzVGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIoYm9keVRpbWVvdXQpIHx8IGJvZHlUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYm9keVRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3QgIT0gbnVsbCAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29ubmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignY29ubmVjdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXF1ZXN0c1BlckNsaWVudCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXF1ZXN0c1BlckNsaWVudCkgfHwgbWF4UmVxdWVzdHNQZXJDbGllbnQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZXF1ZXN0c1BlckNsaWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAobG9jYWxBZGRyZXNzICE9IG51bGwgJiYgKHR5cGVvZiBsb2NhbEFkZHJlc3MgIT09ICdzdHJpbmcnIHx8IG5ldC5pc0lQKGxvY2FsQWRkcmVzcykgPT09IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2xvY2FsQWRkcmVzcyBtdXN0IGJlIHZhbGlkIHN0cmluZyBJUCBhZGRyZXNzJylcbiAgICB9XG5cbiAgICBpZiAobWF4UmVzcG9uc2VTaXplICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlc3BvbnNlU2l6ZSkgfHwgbWF4UmVzcG9uc2VTaXplIDwgLTEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlc3BvbnNlU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgIT0gbnVsbCAmJlxuICAgICAgKCFOdW1iZXIuaXNJbnRlZ2VyKGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCkgfHwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IDwgLTEpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2F1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJylcbiAgICB9XG5cbiAgICAvLyBoMlxuICAgIGlmIChhbGxvd0gyICE9IG51bGwgJiYgdHlwZW9mIGFsbG93SDIgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdhbGxvd0gyIG11c3QgYmUgYSB2YWxpZCBib29sZWFuIHZhbHVlJylcbiAgICB9XG5cbiAgICBpZiAobWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCAmJiAodHlwZW9mIG1heENvbmN1cnJlbnRTdHJlYW1zICE9PSAnbnVtYmVyJyB8fCBtYXhDb25jdXJyZW50U3RyZWFtcyA8IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENvbmN1cnJlbnRTdHJlYW1zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBncmVhdGVyIHRoYW4gMCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJjZXB0b3JzPy5DbGllbnQgJiYgQXJyYXkuaXNBcnJheShpbnRlcmNlcHRvcnMuQ2xpZW50KSkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IGludGVyY2VwdG9ycy5DbGllbnRcbiAgICAgIGlmICghZGVwcmVjYXRlZEludGVyY2VwdG9yV2FybmVkKSB7XG4gICAgICAgIGRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCA9IHRydWVcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnQ2xpZW50Lk9wdGlvbnMjaW50ZXJjZXB0b3IgaXMgZGVwcmVjYXRlZC4gVXNlIERpc3BhdGNoZXIjY29tcG9zZSBpbnN0ZWFkLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUNMSUVOVC1JTlRFUkNFUFRPUi1ERVBSRUNBVEVEJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gW2NyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IoeyBtYXhSZWRpcmVjdGlvbnMgfSldXG4gICAgfVxuXG4gICAgdGhpc1trVXJsXSA9IHV0aWwucGFyc2VPcmlnaW4odXJsKVxuICAgIHRoaXNba0Nvbm5lY3Rvcl0gPSBjb25uZWN0XG4gICAgdGhpc1trUGlwZWxpbmluZ10gPSBwaXBlbGluaW5nICE9IG51bGwgPyBwaXBlbGluaW5nIDogMVxuICAgIHRoaXNba01heEhlYWRlcnNTaXplXSA9IG1heEhlYWRlclNpemUgfHwgaHR0cC5tYXhIZWFkZXJTaXplXG4gICAgdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdID0ga2VlcEFsaXZlVGltZW91dCA9PSBudWxsID8gNGUzIDoga2VlcEFsaXZlVGltZW91dFxuICAgIHRoaXNba0tlZXBBbGl2ZU1heFRpbWVvdXRdID0ga2VlcEFsaXZlTWF4VGltZW91dCA9PSBudWxsID8gNjAwZTMgOiBrZWVwQWxpdmVNYXhUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0gPSBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkID09IG51bGwgPyAyZTMgOiBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXG4gICAgdGhpc1trS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IHRoaXNba0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0XVxuICAgIHRoaXNba1NlcnZlck5hbWVdID0gbnVsbFxuICAgIHRoaXNba0xvY2FsQWRkcmVzc10gPSBsb2NhbEFkZHJlc3MgIT0gbnVsbCA/IGxvY2FsQWRkcmVzcyA6IG51bGxcbiAgICB0aGlzW2tSZXN1bWluZ10gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba05lZWREcmFpbl0gPSAwIC8vIDAsIGlkbGUsIDEsIHNjaGVkdWxlZCwgMiByZXN1bWluZ1xuICAgIHRoaXNba0hvc3RIZWFkZXJdID0gYGhvc3Q6ICR7dGhpc1trVXJsXS5ob3N0bmFtZX0ke3RoaXNba1VybF0ucG9ydCA/IGA6JHt0aGlzW2tVcmxdLnBvcnR9YCA6ICcnfVxcclxcbmBcbiAgICB0aGlzW2tCb2R5VGltZW91dF0gPSBib2R5VGltZW91dCAhPSBudWxsID8gYm9keVRpbWVvdXQgOiAzMDBlM1xuICAgIHRoaXNba0hlYWRlcnNUaW1lb3V0XSA9IGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgPyBoZWFkZXJzVGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trU3RyaWN0Q29udGVudExlbmd0aF0gPSBzdHJpY3RDb250ZW50TGVuZ3RoID09IG51bGwgPyB0cnVlIDogc3RyaWN0Q29udGVudExlbmd0aFxuICAgIHRoaXNba01heFJlZGlyZWN0aW9uc10gPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzW2tNYXhSZXF1ZXN0c10gPSBtYXhSZXF1ZXN0c1BlckNsaWVudFxuICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgIHRoaXNba01heFJlc3BvbnNlU2l6ZV0gPSBtYXhSZXNwb25zZVNpemUgPiAtMSA/IG1heFJlc3BvbnNlU2l6ZSA6IC0xXG4gICAgdGhpc1trTWF4Q29uY3VycmVudFN0cmVhbXNdID0gbWF4Q29uY3VycmVudFN0cmVhbXMgIT0gbnVsbCA/IG1heENvbmN1cnJlbnRTdHJlYW1zIDogMTAwIC8vIE1heCBwZWVyQ29uY3VycmVudFN0cmVhbXMgZm9yIGEgTm9kZSBoMiBzZXJ2ZXJcbiAgICB0aGlzW2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgICAvLyBrUXVldWUgaXMgYnVpbHQgdXAgb2YgMyBzZWN0aW9ucyBzZXBhcmF0ZWQgYnlcbiAgICAvLyB0aGUga1J1bm5pbmdJZHggYW5kIGtQZW5kaW5nSWR4IGluZGljZXMuXG4gICAgLy8gfCAgIGNvbXBsZXRlICAgfCAgIHJ1bm5pbmcgICB8ICAgcGVuZGluZyAgIHxcbiAgICAvLyAgICAgICAgICAgICAgICBeIGtSdW5uaW5nSWR4IF4ga1BlbmRpbmdJZHggXiBrUXVldWUubGVuZ3RoXG4gICAgLy8ga1J1bm5pbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBydW5uaW5nIGVsZW1lbnQuXG4gICAgLy8ga1BlbmRpbmdJZHggcG9pbnRzIHRvIHRoZSBmaXJzdCBwZW5kaW5nIGVsZW1lbnQuXG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIGEgZmFzdCBxdWV1ZSB3aXRoIGFuIGFtb3J0aXplZFxuICAgIC8vIHRpbWUgb2YgTygxKS5cblxuICAgIHRoaXNba1F1ZXVlXSA9IFtdXG4gICAgdGhpc1trUnVubmluZ0lkeF0gPSAwXG4gICAgdGhpc1trUGVuZGluZ0lkeF0gPSAwXG5cbiAgICB0aGlzW2tSZXN1bWVdID0gKHN5bmMpID0+IHJlc3VtZSh0aGlzLCBzeW5jKVxuICAgIHRoaXNba09uRXJyb3JdID0gKGVycikgPT4gb25FcnJvcih0aGlzLCBlcnIpXG4gIH1cblxuICBnZXQgcGlwZWxpbmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1BpcGVsaW5pbmddXG4gIH1cblxuICBzZXQgcGlwZWxpbmluZyAodmFsdWUpIHtcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHZhbHVlXG4gICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUGVuZGluZ0lkeF1cbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGVuZGluZ0lkeF0gLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tRdWV1ZV0ubGVuZ3RoIC0gdGhpc1trUnVubmluZ0lkeF1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiAhIXRoaXNba0hUVFBDb250ZXh0XSAmJiAhdGhpc1trQ29ubmVjdGluZ10gJiYgIXRoaXNba0hUVFBDb250ZXh0XS5kZXN0cm95ZWRcbiAgfVxuXG4gIGdldCBba0J1c3ldICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIHRoaXNba0hUVFBDb250ZXh0XT8uYnVzeShudWxsKSB8fFxuICAgICAgKHRoaXNba1NpemVdID49IChnZXRQaXBlbGluaW5nKHRoaXMpIHx8IDEpKSB8fFxuICAgICAgdGhpc1trUGVuZGluZ10gPiAwXG4gICAgKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlOiBvbmx5IHVzZWQgZm9yIHRlc3QgKi9cbiAgW2tDb25uZWN0XSAoY2IpIHtcbiAgICBjb25uZWN0KHRoaXMpXG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgY2IpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdHMub3JpZ2luIHx8IHRoaXNba1VybF0ub3JpZ2luXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KG9yaWdpbiwgb3B0cywgaGFuZGxlcilcblxuICAgIHRoaXNba1F1ZXVlXS5wdXNoKHJlcXVlc3QpXG4gICAgaWYgKHRoaXNba1Jlc3VtaW5nXSkge1xuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2UgaWYgKHV0aWwuYm9keUxlbmd0aChyZXF1ZXN0LmJvZHkpID09IG51bGwgJiYgdXRpbC5pc0l0ZXJhYmxlKHJlcXVlc3QuYm9keSkpIHtcbiAgICAgIC8vIFdhaXQgYSB0aWNrIGluIGNhc2Ugc3RyZWFtL2l0ZXJhdG9yIGlzIGVuZGVkIGluIHRoZSBzYW1lIHRpY2suXG4gICAgICB0aGlzW2tSZXN1bWluZ10gPSAxXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZXN1bWUodGhpcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba1Jlc3VtZV0odHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpc1trUmVzdW1pbmddICYmIHRoaXNba05lZWREcmFpbl0gIT09IDIgJiYgdGhpc1trQnVzeV0pIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSAyXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl0gPCAyXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgLy8gVE9ETzogZm9yIEgyIHdlIG5lZWQgdG8gZ3JhY2VmdWxseSBmbHVzaCB0aGUgcmVtYWluaW5nIGVucXVldWVkXG4gICAgLy8gcmVxdWVzdCBhbmQgY2xvc2UgZWFjaCBzdHJlYW0uXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAodGhpc1trU2l6ZV0pIHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzW2tRdWV1ZV0uc3BsaWNlKHRoaXNba1BlbmRpbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QodGhpcywgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXNba0Nsb3NlZFJlc29sdmVdKSB7XG4gICAgICAgICAgLy8gVE9ETyAoZml4KTogU2hvdWxkIHdlIGVycm9yIGhlcmUgd2l0aCBDbGllbnREZXN0cm95ZWRFcnJvcj9cbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSgpXG4gICAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShudWxsKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trSFRUUENvbnRleHRdKSB7XG4gICAgICAgIHRoaXNba0hUVFBDb250ZXh0XS5kZXN0cm95KGVyciwgY2FsbGJhY2spXG4gICAgICAgIHRoaXNba0hUVFBDb250ZXh0XSA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tSZXN1bWVdKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcycpXG5cbmZ1bmN0aW9uIG9uRXJyb3IgKGNsaWVudCwgZXJyKSB7XG4gIGlmIChcbiAgICBjbGllbnRba1J1bm5pbmddID09PSAwICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX0lORk8nICYmXG4gICAgZXJyLmNvZGUgIT09ICdVTkRfRVJSX1NPQ0tFVCdcbiAgKSB7XG4gICAgLy8gRXJyb3IgaXMgbm90IGNhdXNlZCBieSBydW5uaW5nIHJlcXVlc3QgYW5kIG5vdCBhIHJlY292ZXJhYmxlXG4gICAgLy8gc29ja2V0IGVycm9yLlxuXG4gICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ0lkeF0gPT09IGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RzW2ldXG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICB9XG4gICAgYXNzZXJ0KGNsaWVudFtrU2l6ZV0gPT09IDApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29ubmVjdCAoY2xpZW50KSB7XG4gIGFzc2VydCghY2xpZW50W2tDb25uZWN0aW5nXSlcbiAgYXNzZXJ0KCFjbGllbnRba0hUVFBDb250ZXh0XSlcblxuICBsZXQgeyBob3N0LCBob3N0bmFtZSwgcHJvdG9jb2wsIHBvcnQgfSA9IGNsaWVudFtrVXJsXVxuXG4gIC8vIFJlc29sdmUgaXB2NlxuICBpZiAoaG9zdG5hbWVbMF0gPT09ICdbJykge1xuICAgIGNvbnN0IGlkeCA9IGhvc3RuYW1lLmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgY29uc3QgaXAgPSBob3N0bmFtZS5zdWJzdHJpbmcoMSwgaWR4KVxuXG4gICAgYXNzZXJ0KG5ldC5pc0lQKGlwKSlcbiAgICBob3N0bmFtZSA9IGlwXG4gIH1cblxuICBjbGllbnRba0Nvbm5lY3RpbmddID0gdHJ1ZVxuXG4gIGlmIChjaGFubmVscy5iZWZvcmVDb25uZWN0Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5wdWJsaXNoKHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgaG9zdCxcbiAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwb3J0LFxuICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHNvY2tldCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudFtrQ29ubmVjdG9yXSh7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgIH0sIChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge30pLCBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICB0cnkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBzb2NrZXQuYWxwblByb3RvY29sID09PSAnaDInXG4gICAgICAgID8gYXdhaXQgY29ubmVjdEgyKGNsaWVudCwgc29ja2V0KVxuICAgICAgICA6IGF3YWl0IGNvbm5lY3RIMShjbGllbnQsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCkub24oJ2Vycm9yJywgKCkgPT4ge30pXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIHNvY2tldFtrQ291bnRlcl0gPSAwXG4gICAgc29ja2V0W2tNYXhSZXF1ZXN0c10gPSBjbGllbnRba01heFJlcXVlc3RzXVxuICAgIHNvY2tldFtrQ2xpZW50XSA9IGNsaWVudFxuICAgIHNvY2tldFtrRXJyb3JdID0gbnVsbFxuXG4gICAgaWYgKGNoYW5uZWxzLmNvbm5lY3RlZC5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY29ubmVjdGVkLnB1Ymxpc2goe1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIHZlcnNpb246IGNsaWVudFtrSFRUUENvbnRleHRdPy52ZXJzaW9uLFxuICAgICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgICAgbG9jYWxBZGRyZXNzOiBjbGllbnRba0xvY2FsQWRkcmVzc11cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl0sXG4gICAgICAgIHNvY2tldFxuICAgICAgfSlcbiAgICB9XG4gICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xpZW50W2tDb25uZWN0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0RXJyb3IucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJykge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDApXG4gICAgICB3aGlsZSAoY2xpZW50W2tQZW5kaW5nXSA+IDAgJiYgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XV0uc2VydmVybmFtZSA9PT0gY2xpZW50W2tTZXJ2ZXJOYW1lXSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tQZW5kaW5nSWR4XSsrXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihjbGllbnQsIGVycilcbiAgICB9XG5cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuICB9XG5cbiAgY2xpZW50W2tSZXN1bWVdKClcbn1cblxuZnVuY3Rpb24gZW1pdERyYWluIChjbGllbnQpIHtcbiAgY2xpZW50W2tOZWVkRHJhaW5dID0gMFxuICBjbGllbnQuZW1pdCgnZHJhaW4nLCBjbGllbnRba1VybF0sIFtjbGllbnRdKVxufVxuXG5mdW5jdGlvbiByZXN1bWUgKGNsaWVudCwgc3luYykge1xuICBpZiAoY2xpZW50W2tSZXN1bWluZ10gPT09IDIpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMlxuXG4gIF9yZXN1bWUoY2xpZW50LCBzeW5jKVxuICBjbGllbnRba1Jlc3VtaW5nXSA9IDBcblxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA+IDI1Nikge1xuICAgIGNsaWVudFtrUXVldWVdLnNwbGljZSgwLCBjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gLT0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUnVubmluZ0lkeF0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGNsaWVudC5kZXN0cm95ZWQpIHtcbiAgICAgIGFzc2VydChjbGllbnRba1BlbmRpbmddID09PSAwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0gJiYgIWNsaWVudFtrU2l6ZV0pIHtcbiAgICAgIGNsaWVudFtrQ2xvc2VkUmVzb2x2ZV0oKVxuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0ucmVzdW1lKClcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tCdXN5XSkge1xuICAgICAgY2xpZW50W2tOZWVkRHJhaW5dID0gMlxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tOZWVkRHJhaW5dID09PSAyKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBjbGllbnRba05lZWREcmFpbl0gPSAxXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGVtaXREcmFpbihjbGllbnQpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdERyYWluKGNsaWVudClcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUGVuZGluZ10gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba1J1bm5pbmddID49IChnZXRQaXBlbGluaW5nKGNsaWVudCkgfHwgMSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXVxuXG4gICAgaWYgKGNsaWVudFtrVXJsXS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgY2xpZW50W2tTZXJ2ZXJOYW1lXSAhPT0gcmVxdWVzdC5zZXJ2ZXJuYW1lKSB7XG4gICAgICBpZiAoY2xpZW50W2tSdW5uaW5nXSA+IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNsaWVudFtrU2VydmVyTmFtZV0gPSByZXF1ZXN0LnNlcnZlcm5hbWVcbiAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdPy5kZXN0cm95KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NlcnZlcm5hbWUgY2hhbmdlZCcpLCAoKSA9PiB7XG4gICAgICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgICByZXN1bWUoY2xpZW50KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tDb25uZWN0aW5nXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFjbGllbnRba0hUVFBDb250ZXh0XSkge1xuICAgICAgY29ubmVjdChjbGllbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tIVFRQQ29udGV4dF0uYnVzeShyZXF1ZXN0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0LmFib3J0ZWQgJiYgY2xpZW50W2tIVFRQQ29udGV4dF0ud3JpdGUocmVxdWVzdCkpIHtcbiAgICAgIGNsaWVudFtrUGVuZGluZ0lkeF0rK1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1F1ZXVlXS5zcGxpY2UoY2xpZW50W2tQZW5kaW5nSWR4XSwgMSlcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\nconst kInterceptedDispatch = Symbol('Intercepted Dispatch')\n\nclass DispatcherBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kDestroyed] = false\n    this[kOnDestroyed] = null\n    this[kClosed] = false\n    this[kOnClosed] = []\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get interceptors () {\n    return this[kInterceptors]\n  }\n\n  set interceptors (newInterceptors) {\n    if (newInterceptors) {\n      for (let i = newInterceptors.length - 1; i >= 0; i--) {\n        const interceptor = this[kInterceptors][i]\n        if (typeof interceptor !== 'function') {\n          throw new InvalidArgumentError('interceptor must be an function')\n        }\n      }\n    }\n\n    this[kInterceptors] = newInterceptors\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  [kInterceptedDispatch] (opts, handler) {\n    if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n      this[kInterceptedDispatch] = this[kDispatch]\n      return this[kDispatch](opts, handler)\n    }\n\n    let dispatch = this[kDispatch].bind(this)\n    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {\n      dispatch = this[kInterceptors][i](dispatch)\n    }\n    this[kInterceptedDispatch] = dispatch\n    return dispatch(opts, handler)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kInterceptedDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixRQUFRLGtFQUFrRSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUVyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxkaXNwYXRjaGVyLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3Qge1xuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBrRGVzdHJveSwga0Nsb3NlLCBrQ2xvc2VkLCBrRGVzdHJveWVkLCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5cbmNvbnN0IGtPbkRlc3Ryb3llZCA9IFN5bWJvbCgnb25EZXN0cm95ZWQnKVxuY29uc3Qga09uQ2xvc2VkID0gU3ltYm9sKCdvbkNsb3NlZCcpXG5jb25zdCBrSW50ZXJjZXB0ZWREaXNwYXRjaCA9IFN5bWJvbCgnSW50ZXJjZXB0ZWQgRGlzcGF0Y2gnKVxuXG5jbGFzcyBEaXNwYXRjaGVyQmFzZSBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IGZhbHNlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgIHRoaXNba0Nsb3NlZF0gPSBmYWxzZVxuICAgIHRoaXNba09uQ2xvc2VkXSA9IFtdXG4gIH1cblxuICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trRGVzdHJveWVkXVxuICB9XG5cbiAgZ2V0IGNsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nsb3NlZF1cbiAgfVxuXG4gIGdldCBpbnRlcmNlcHRvcnMgKCkge1xuICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRvcnNdXG4gIH1cblxuICBzZXQgaW50ZXJjZXB0b3JzIChuZXdJbnRlcmNlcHRvcnMpIHtcbiAgICBpZiAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgICBmb3IgKGxldCBpID0gbmV3SW50ZXJjZXB0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yID0gdGhpc1trSW50ZXJjZXB0b3JzXVtpXVxuICAgICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnRlcmNlcHRvciBtdXN0IGJlIGFuIGZ1bmN0aW9uJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBuZXdJbnRlcmNlcHRvcnNcbiAgfVxuXG4gIGNsb3NlIChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpLCBudWxsKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICBpZiAodGhpc1trT25DbG9zZWRdKSB7XG4gICAgICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobnVsbCwgbnVsbCkpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzW2tDbG9zZWRdID0gdHJ1ZVxuICAgIHRoaXNba09uQ2xvc2VkXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgY29uc3Qgb25DbG9zZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzW2tPbkNsb3NlZF1cbiAgICAgIHRoaXNba09uQ2xvc2VkXSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXShudWxsLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBub3QgZXJyb3IuXG4gICAgdGhpc1trQ2xvc2VdKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuZGVzdHJveSgpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhvbkNsb3NlZClcbiAgICAgIH0pXG4gIH1cblxuICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZXJyXG4gICAgICBlcnIgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gZXJyID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciBlcnJvciAqLyByZWplY3QoZXJyKSA6IHJlc29sdmUoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNhbGxiYWNrJylcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRGVzdHJveWVkXSkge1xuICAgICAgaWYgKHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGVyciA9IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgdGhpc1trRGVzdHJveWVkXSA9IHRydWVcbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSB0aGlzW2tPbkRlc3Ryb3llZF0gfHwgW11cbiAgICB0aGlzW2tPbkRlc3Ryb3llZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uRGVzdHJveWVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25EZXN0cm95ZWRdXG4gICAgICB0aGlzW2tPbkRlc3Ryb3llZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Rlc3Ryb3ldKGVycikudGhlbigoKSA9PiB7XG4gICAgICBxdWV1ZU1pY3JvdGFzayhvbkRlc3Ryb3llZClcbiAgICB9KVxuICB9XG5cbiAgW2tJbnRlcmNlcHRlZERpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghdGhpc1trSW50ZXJjZXB0b3JzXSB8fCB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0gPSB0aGlzW2tEaXNwYXRjaF1cbiAgICAgIHJldHVybiB0aGlzW2tEaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9XG5cbiAgICBsZXQgZGlzcGF0Y2ggPSB0aGlzW2tEaXNwYXRjaF0uYmluZCh0aGlzKVxuICAgIGZvciAobGV0IGkgPSB0aGlzW2tJbnRlcmNlcHRvcnNdLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBkaXNwYXRjaCA9IHRoaXNba0ludGVyY2VwdG9yc11baV0oZGlzcGF0Y2gpXG4gICAgfVxuICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gZGlzcGF0Y2hcbiAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QuJylcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0gfHwgdGhpc1trT25EZXN0cm95ZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnREZXN0cm95ZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tDbG9zZWRdKSB7XG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDbG9zZWRFcnJvcigpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXShvcHRzLCBoYW5kbGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uRXJyb3IgbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaGFuZGxlci5vbkVycm9yKGVycilcblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlckJhc2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\")\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n\n  compose (...args) {\n    // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n    const interceptors = Array.isArray(args[0]) ? args[0] : args\n    let dispatch = this.dispatch.bind(this)\n\n    for (const interceptor of interceptors) {\n      if (interceptor == null) {\n        continue\n      }\n\n      if (typeof interceptor !== 'function') {\n        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`)\n      }\n\n      dispatch = interceptor(dispatch)\n\n      if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n        throw new TypeError('invalid interceptor')\n      }\n    }\n\n    return new ComposedDispatcher(this, dispatch)\n  }\n}\n\nclass ComposedDispatcher extends Dispatcher {\n  #dispatcher = null\n  #dispatch = null\n\n  constructor (dispatcher, dispatch) {\n    super()\n    this.#dispatcher = dispatcher\n    this.#dispatch = dispatch\n  }\n\n  dispatch (...args) {\n    this.#dispatch(...args)\n  }\n\n  close (...args) {\n    return this.#dispatcher.close(...args)\n  }\n\n  destroy (...args) {\n    return this.#dispatcher.destroy(...args)\n  }\n}\n\nmodule.exports = Dispatcher\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxtQkFBbUI7QUFDbEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxkaXNwYXRjaGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuXG5jbGFzcyBEaXNwYXRjaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZGlzcGF0Y2ggKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBjb21wb3NlICguLi5hcmdzKSB7XG4gICAgLy8gU28gd2UgaGFuZGxlIFtpbnRlcmNlcHRvcjEsIGludGVyY2VwdG9yMl0gb3IgaW50ZXJjZXB0b3IxLCBpbnRlcmNlcHRvcjIsIC4uLlxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJnc1xuICAgIGxldCBkaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKVxuXG4gICAgZm9yIChjb25zdCBpbnRlcmNlcHRvciBvZiBpbnRlcmNlcHRvcnMpIHtcbiAgICAgIGlmIChpbnRlcmNlcHRvciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlcmNlcHRvciwgZXhwZWN0ZWQgZnVuY3Rpb24gcmVjZWl2ZWQgJHt0eXBlb2YgaW50ZXJjZXB0b3J9YClcbiAgICAgIH1cblxuICAgICAgZGlzcGF0Y2ggPSBpbnRlcmNlcHRvcihkaXNwYXRjaClcblxuICAgICAgaWYgKGRpc3BhdGNoID09IG51bGwgfHwgdHlwZW9mIGRpc3BhdGNoICE9PSAnZnVuY3Rpb24nIHx8IGRpc3BhdGNoLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGludGVyY2VwdG9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbXBvc2VkRGlzcGF0Y2hlcih0aGlzLCBkaXNwYXRjaClcbiAgfVxufVxuXG5jbGFzcyBDb21wb3NlZERpc3BhdGNoZXIgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgI2Rpc3BhdGNoZXIgPSBudWxsXG4gICNkaXNwYXRjaCA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2hlciwgZGlzcGF0Y2gpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy4jZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXJcbiAgICB0aGlzLiNkaXNwYXRjaCA9IGRpc3BhdGNoXG4gIH1cblxuICBkaXNwYXRjaCAoLi4uYXJncykge1xuICAgIHRoaXMuI2Rpc3BhdGNoKC4uLmFyZ3MpXG4gIH1cblxuICBjbG9zZSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNkaXNwYXRjaGVyLmNsb3NlKC4uLmFyZ3MpXG4gIH1cblxuICBkZXN0cm95ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc3BhdGNoZXIuZGVzdHJveSguLi5hcmdzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nconst DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443\n}\n\nlet experimentalWarned = false\n\nclass EnvHttpProxyAgent extends DispatcherBase {\n  #noProxyValue = null\n  #noProxyEntries = null\n  #opts = null\n\n  constructor (opts = {}) {\n    super()\n    this.#opts = opts\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EnvHttpProxyAgent is experimental, expect them to change at any time.', {\n        code: 'UNDICI-EHPA'\n      })\n    }\n\n    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts\n\n    this[kNoProxyAgent] = new Agent(agentOpts)\n\n    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY\n    if (HTTP_PROXY) {\n      this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY })\n    } else {\n      this[kHttpProxyAgent] = this[kNoProxyAgent]\n    }\n\n    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY\n    if (HTTPS_PROXY) {\n      this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY })\n    } else {\n      this[kHttpsProxyAgent] = this[kHttpProxyAgent]\n    }\n\n    this.#parseNoProxy()\n  }\n\n  [kDispatch] (opts, handler) {\n    const url = new URL(opts.origin)\n    const agent = this.#getProxyAgentForUrl(url)\n    return agent.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    await this[kNoProxyAgent].close()\n    if (!this[kHttpProxyAgent][kClosed]) {\n      await this[kHttpProxyAgent].close()\n    }\n    if (!this[kHttpsProxyAgent][kClosed]) {\n      await this[kHttpsProxyAgent].close()\n    }\n  }\n\n  async [kDestroy] (err) {\n    await this[kNoProxyAgent].destroy(err)\n    if (!this[kHttpProxyAgent][kDestroyed]) {\n      await this[kHttpProxyAgent].destroy(err)\n    }\n    if (!this[kHttpsProxyAgent][kDestroyed]) {\n      await this[kHttpsProxyAgent].destroy(err)\n    }\n  }\n\n  #getProxyAgentForUrl (url) {\n    let { protocol, host: hostname, port } = url\n\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, '').toLowerCase()\n    port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0\n    if (!this.#shouldProxy(hostname, port)) {\n      return this[kNoProxyAgent]\n    }\n    if (protocol === 'https:') {\n      return this[kHttpsProxyAgent]\n    }\n    return this[kHttpProxyAgent]\n  }\n\n  #shouldProxy (hostname, port) {\n    if (this.#noProxyChanged) {\n      this.#parseNoProxy()\n    }\n\n    if (this.#noProxyEntries.length === 0) {\n      return true // Always proxy if NO_PROXY is not set or empty.\n    }\n    if (this.#noProxyValue === '*') {\n      return false // Never proxy if wildcard is set.\n    }\n\n    for (let i = 0; i < this.#noProxyEntries.length; i++) {\n      const entry = this.#noProxyEntries[i]\n      if (entry.port && entry.port !== port) {\n        continue // Skip if ports don't match.\n      }\n      if (!/^[.*]/.test(entry.hostname)) {\n        // No wildcards, so don't proxy only if there is not an exact match.\n        if (hostname === entry.hostname) {\n          return false\n        }\n      } else {\n        // Don't proxy if the hostname ends with the no_proxy host.\n        if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  #parseNoProxy () {\n    const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv\n    const noProxySplit = noProxyValue.split(/[,\\s]/)\n    const noProxyEntries = []\n\n    for (let i = 0; i < noProxySplit.length; i++) {\n      const entry = noProxySplit[i]\n      if (!entry) {\n        continue\n      }\n      const parsed = entry.match(/^(.+):(\\d+)$/)\n      noProxyEntries.push({\n        hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n        port: parsed ? Number.parseInt(parsed[2], 10) : 0\n      })\n    }\n\n    this.#noProxyValue = noProxyValue\n    this.#noProxyEntries = noProxyEntries\n  }\n\n  get #noProxyChanged () {\n    if (this.#opts.noProxy !== undefined) {\n      return false\n    }\n    return this.#noProxyValue !== this.#noProxyEnv\n  }\n\n  get #noProxyEnv () {\n    return process.env.no_proxy ?? process.env.NO_PROXY ?? ''\n  }\n}\n\nmodule.exports = EnvHttpProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHFHQUFxRyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsWUFBWSwrQ0FBK0M7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxlbnYtaHR0cC1wcm94eS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7IGtDbG9zZSwga0Rlc3Ryb3ksIGtDbG9zZWQsIGtEZXN0cm95ZWQsIGtEaXNwYXRjaCwga05vUHJveHlBZ2VudCwga0h0dHBQcm94eUFnZW50LCBrSHR0cHNQcm94eUFnZW50IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4vcHJveHktYWdlbnQnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50JylcblxuY29uc3QgREVGQVVMVF9QT1JUUyA9IHtcbiAgJ2h0dHA6JzogODAsXG4gICdodHRwczonOiA0NDNcbn1cblxubGV0IGV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbmNsYXNzIEVudkh0dHBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICAjbm9Qcm94eVZhbHVlID0gbnVsbFxuICAjbm9Qcm94eUVudHJpZXMgPSBudWxsXG4gICNvcHRzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy4jb3B0cyA9IG9wdHNcblxuICAgIGlmICghZXhwZXJpbWVudGFsV2FybmVkKSB7XG4gICAgICBleHBlcmltZW50YWxXYXJuZWQgPSB0cnVlXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdFbnZIdHRwUHJveHlBZ2VudCBpcyBleHBlcmltZW50YWwsIGV4cGVjdCB0aGVtIHRvIGNoYW5nZSBhdCBhbnkgdGltZS4nLCB7XG4gICAgICAgIGNvZGU6ICdVTkRJQ0ktRUhQQSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgeyBodHRwUHJveHksIGh0dHBzUHJveHksIG5vUHJveHksIC4uLmFnZW50T3B0cyB9ID0gb3B0c1xuXG4gICAgdGhpc1trTm9Qcm94eUFnZW50XSA9IG5ldyBBZ2VudChhZ2VudE9wdHMpXG5cbiAgICBjb25zdCBIVFRQX1BST1hZID0gaHR0cFByb3h5ID8/IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWVxuICAgIGlmIChIVFRQX1BST1hZKSB7XG4gICAgICB0aGlzW2tIdHRwUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQX1BST1hZIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0h0dHBQcm94eUFnZW50XSA9IHRoaXNba05vUHJveHlBZ2VudF1cbiAgICB9XG5cbiAgICBjb25zdCBIVFRQU19QUk9YWSA9IGh0dHBzUHJveHkgPz8gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgPz8gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFlcbiAgICBpZiAoSFRUUFNfUFJPWFkpIHtcbiAgICAgIHRoaXNba0h0dHBzUHJveHlBZ2VudF0gPSBuZXcgUHJveHlBZ2VudCh7IC4uLmFnZW50T3B0cywgdXJpOiBIVFRQU19QUk9YWSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdID0gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gICAgfVxuXG4gICAgdGhpcy4jcGFyc2VOb1Byb3h5KClcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICBjb25zdCBhZ2VudCA9IHRoaXMuI2dldFByb3h5QWdlbnRGb3JVcmwodXJsKVxuICAgIHJldHVybiBhZ2VudC5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIGlmICghdGhpc1trSHR0cFByb3h5QWdlbnRdW2tDbG9zZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgICBpZiAoIXRoaXNba0h0dHBzUHJveHlBZ2VudF1ba0Nsb3NlZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBzUHJveHlBZ2VudF0uY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIGF3YWl0IHRoaXNba05vUHJveHlBZ2VudF0uZGVzdHJveShlcnIpXG4gICAgaWYgKCF0aGlzW2tIdHRwUHJveHlBZ2VudF1ba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGF3YWl0IHRoaXNba0h0dHBQcm94eUFnZW50XS5kZXN0cm95KGVycilcbiAgICB9XG4gICAgaWYgKCF0aGlzW2tIdHRwc1Byb3h5QWdlbnRdW2tEZXN0cm95ZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gICNnZXRQcm94eUFnZW50Rm9yVXJsICh1cmwpIHtcbiAgICBsZXQgeyBwcm90b2NvbCwgaG9zdDogaG9zdG5hbWUsIHBvcnQgfSA9IHVybFxuXG4gICAgLy8gU3RyaXBwaW5nIHBvcnRzIGluIHRoaXMgd2F5IGluc3RlYWQgb2YgdXNpbmcgcGFyc2VkVXJsLmhvc3RuYW1lIHRvIG1ha2VcbiAgICAvLyBzdXJlIHRoYXQgdGhlIGJyYWNrZXRzIGFyb3VuZCBJUHY2IGFkZHJlc3NlcyBhcmUga2VwdC5cbiAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnJlcGxhY2UoLzpcXGQqJC8sICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgcG9ydCA9IE51bWJlci5wYXJzZUludChwb3J0LCAxMCkgfHwgREVGQVVMVF9QT1JUU1twcm90b2NvbF0gfHwgMFxuICAgIGlmICghdGhpcy4jc2hvdWxkUHJveHkoaG9zdG5hbWUsIHBvcnQpKSB7XG4gICAgICByZXR1cm4gdGhpc1trTm9Qcm94eUFnZW50XVxuICAgIH1cbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICByZXR1cm4gdGhpc1trSHR0cHNQcm94eUFnZW50XVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1trSHR0cFByb3h5QWdlbnRdXG4gIH1cblxuICAjc2hvdWxkUHJveHkgKGhvc3RuYW1lLCBwb3J0KSB7XG4gICAgaWYgKHRoaXMuI25vUHJveHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNwYXJzZU5vUHJveHkoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlIC8vIEFsd2F5cyBwcm94eSBpZiBOT19QUk9YWSBpcyBub3Qgc2V0IG9yIGVtcHR5LlxuICAgIH1cbiAgICBpZiAodGhpcy4jbm9Qcm94eVZhbHVlID09PSAnKicpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBOZXZlciBwcm94eSBpZiB3aWxkY2FyZCBpcyBzZXQuXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiNub1Byb3h5RW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLiNub1Byb3h5RW50cmllc1tpXVxuICAgICAgaWYgKGVudHJ5LnBvcnQgJiYgZW50cnkucG9ydCAhPT0gcG9ydCkge1xuICAgICAgICBjb250aW51ZSAvLyBTa2lwIGlmIHBvcnRzIGRvbid0IG1hdGNoLlxuICAgICAgfVxuICAgICAgaWYgKCEvXlsuKl0vLnRlc3QoZW50cnkuaG9zdG5hbWUpKSB7XG4gICAgICAgIC8vIE5vIHdpbGRjYXJkcywgc28gZG9uJ3QgcHJveHkgb25seSBpZiB0aGVyZSBpcyBub3QgYW4gZXhhY3QgbWF0Y2guXG4gICAgICAgIGlmIChob3N0bmFtZSA9PT0gZW50cnkuaG9zdG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJveHkgaWYgdGhlIGhvc3RuYW1lIGVuZHMgd2l0aCB0aGUgbm9fcHJveHkgaG9zdC5cbiAgICAgICAgaWYgKGhvc3RuYW1lLmVuZHNXaXRoKGVudHJ5Lmhvc3RuYW1lLnJlcGxhY2UoL15cXCovLCAnJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI3BhcnNlTm9Qcm94eSAoKSB7XG4gICAgY29uc3Qgbm9Qcm94eVZhbHVlID0gdGhpcy4jb3B0cy5ub1Byb3h5ID8/IHRoaXMuI25vUHJveHlFbnZcbiAgICBjb25zdCBub1Byb3h5U3BsaXQgPSBub1Byb3h5VmFsdWUuc3BsaXQoL1ssXFxzXS8pXG4gICAgY29uc3Qgbm9Qcm94eUVudHJpZXMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub1Byb3h5U3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbm9Qcm94eVNwbGl0W2ldXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBwYXJzZWQgPSBlbnRyeS5tYXRjaCgvXiguKyk6KFxcZCspJC8pXG4gICAgICBub1Byb3h5RW50cmllcy5wdXNoKHtcbiAgICAgICAgaG9zdG5hbWU6IChwYXJzZWQgPyBwYXJzZWRbMV0gOiBlbnRyeSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcG9ydDogcGFyc2VkID8gTnVtYmVyLnBhcnNlSW50KHBhcnNlZFsyXSwgMTApIDogMFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNub1Byb3h5VmFsdWUgPSBub1Byb3h5VmFsdWVcbiAgICB0aGlzLiNub1Byb3h5RW50cmllcyA9IG5vUHJveHlFbnRyaWVzXG4gIH1cblxuICBnZXQgI25vUHJveHlDaGFuZ2VkICgpIHtcbiAgICBpZiAodGhpcy4jb3B0cy5ub1Byb3h5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbm9Qcm94eVZhbHVlICE9PSB0aGlzLiNub1Byb3h5RW52XG4gIH1cblxuICBnZXQgI25vUHJveHlFbnYgKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ub19wcm94eSA/PyBwcm9jZXNzLmVudi5OT19QUk9YWSA/PyAnJ1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW52SHR0cFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */\n\n\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZml4ZWQtcXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8vIEV4dHJhY3RlZCBmcm9tIG5vZGUvbGliL2ludGVybmFsL2ZpeGVkX3F1ZXVlLmpzXG5cbi8vIEN1cnJlbnRseSBvcHRpbWFsIHF1ZXVlIHNpemUsIHRlc3RlZCBvbiBWOCA2LjAgLSA2LjYuIE11c3QgYmUgcG93ZXIgb2YgdHdvLlxuY29uc3Qga1NpemUgPSAyMDQ4O1xuY29uc3Qga01hc2sgPSBrU2l6ZSAtIDE7XG5cbi8vIFRoZSBGaXhlZFF1ZXVlIGlzIGltcGxlbWVudGVkIGFzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IG9mIGZpeGVkLXNpemVcbi8vIGNpcmN1bGFyIGJ1ZmZlcnMuIEl0IGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gIGhlYWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFxuLy8gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgPC0tLS0tXFwgICAgICAgKy0tLS0tLS0tLS0tKyA8LS0tLS0tXFwgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICBcXC0tLS0tIHwgICBuZXh0ICAgIHwgICAgICAgICBcXC0tLS0tLS0gfCAgIG5leHQgICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgIGJvdHRvbSAtLT4gfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgIC4uLiAgICB8ICAgICAgICAgICAgICAgfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHwgPC0tIHRvcCAgdG9wIC0tPiB8ICBbZW1wdHldICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vXG4vLyBPciwgaWYgdGhlcmUgaXMgb25seSBvbmUgY2lyY3VsYXIgYnVmZmVyLCBpdCBsb29rcyBzb21ldGhpbmdcbi8vIGxpa2UgZWl0aGVyIG9mIHRoZXNlOlxuLy9cbi8vICBoZWFkICAgdGFpbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgICB0YWlsXG4vLyAgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgIHxcbi8vICAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgdlxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vLyB8ICBbbnVsbF0gICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIFtudWxsXSAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICAgICAgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICBbZW1wdHldICB8IDwtLSB0b3AgICAgICAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gQWRkaW5nIGEgdmFsdWUgbWVhbnMgbW92aW5nIGB0b3BgIGZvcndhcmQgYnkgb25lLCByZW1vdmluZyBtZWFuc1xuLy8gbW92aW5nIGBib3R0b21gIGZvcndhcmQgYnkgb25lLiBBZnRlciByZWFjaGluZyB0aGUgZW5kLCB0aGUgcXVldWVcbi8vIHdyYXBzIGFyb3VuZC5cbi8vXG4vLyBXaGVuIGB0b3AgPT09IGJvdHRvbWAgdGhlIGN1cnJlbnQgcXVldWUgaXMgZW1wdHkgYW5kIHdoZW5cbi8vIGB0b3AgKyAxID09PSBib3R0b21gIGl0J3MgZnVsbC4gVGhpcyB3YXN0ZXMgYSBzaW5nbGUgc3BhY2Ugb2Ygc3RvcmFnZVxuLy8gYnV0IGFsbG93cyBtdWNoIHF1aWNrZXIgY2hlY2tzLlxuXG5jbGFzcyBGaXhlZENpcmN1bGFyQnVmZmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib3R0b20gPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICB0aGlzLmxpc3QgPSBuZXcgQXJyYXkoa1NpemUpO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnRvcCA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBpc0Z1bGwoKSB7XG4gICAgcmV0dXJuICgodGhpcy50b3AgKyAxKSAmIGtNYXNrKSA9PT0gdGhpcy5ib3R0b207XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICB0aGlzLmxpc3RbdGhpcy50b3BdID0gZGF0YTtcbiAgICB0aGlzLnRvcCA9ICh0aGlzLnRvcCArIDEpICYga01hc2s7XG4gIH1cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCBuZXh0SXRlbSA9IHRoaXMubGlzdFt0aGlzLmJvdHRvbV07XG4gICAgaWYgKG5leHRJdGVtID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0aGlzLmxpc3RbdGhpcy5ib3R0b21dID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gKHRoaXMuYm90dG9tICsgMSkgJiBrTWFzaztcbiAgICByZXR1cm4gbmV4dEl0ZW07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaXhlZFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IEZpeGVkQ2lyY3VsYXJCdWZmZXIoKTtcbiAgfVxuXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZC5pc0VtcHR5KCk7XG4gIH1cblxuICBwdXNoKGRhdGEpIHtcbiAgICBpZiAodGhpcy5oZWFkLmlzRnVsbCgpKSB7XG4gICAgICAvLyBIZWFkIGlzIGZ1bGw6IENyZWF0ZXMgYSBuZXcgcXVldWUsIHNldHMgdGhlIG9sZCBxdWV1ZSdzIGAubmV4dGAgdG8gaXQsXG4gICAgICAvLyBhbmQgc2V0cyBpdCBhcyB0aGUgbmV3IG1haW4gcXVldWUuXG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gICAgfVxuICAgIHRoaXMuaGVhZC5wdXNoKGRhdGEpO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMudGFpbDtcbiAgICBjb25zdCBuZXh0ID0gdGFpbC5zaGlmdCgpO1xuICAgIGlmICh0YWlsLmlzRW1wdHkoKSAmJiB0YWlsLm5leHQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcXVldWUsIGl0IGZvcm1zIHRoZSBuZXcgdGFpbC5cbiAgICAgIHRoaXMudGFpbCA9IHRhaWwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return this[kStats]\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      return Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      return new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    return Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsUUFBUSxrR0FBa0csRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUNySSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHBvb2wtYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCBGaXhlZFF1ZXVlID0gcmVxdWlyZSgnLi9maXhlZC1xdWV1ZScpXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplLCBrUnVubmluZywga1BlbmRpbmcsIGtRdWV1ZWQsIGtCdXN5LCBrRnJlZSwga1VybCwga0Nsb3NlLCBrRGVzdHJveSwga0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgUG9vbFN0YXRzID0gcmVxdWlyZSgnLi9wb29sLXN0YXRzJylcblxuY29uc3Qga0NsaWVudHMgPSBTeW1ib2woJ2NsaWVudHMnKVxuY29uc3Qga05lZWREcmFpbiA9IFN5bWJvbCgnbmVlZERyYWluJylcbmNvbnN0IGtRdWV1ZSA9IFN5bWJvbCgncXVldWUnKVxuY29uc3Qga0Nsb3NlZFJlc29sdmUgPSBTeW1ib2woJ2Nsb3NlZCByZXNvbHZlJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtPbkNvbm5lY3QgPSBTeW1ib2woJ29uQ29ubmVjdCcpXG5jb25zdCBrT25EaXNjb25uZWN0ID0gU3ltYm9sKCdvbkRpc2Nvbm5lY3QnKVxuY29uc3Qga09uQ29ubmVjdGlvbkVycm9yID0gU3ltYm9sKCdvbkNvbm5lY3Rpb25FcnJvcicpXG5jb25zdCBrR2V0RGlzcGF0Y2hlciA9IFN5bWJvbCgnZ2V0IGRpc3BhdGNoZXInKVxuY29uc3Qga0FkZENsaWVudCA9IFN5bWJvbCgnYWRkIGNsaWVudCcpXG5jb25zdCBrUmVtb3ZlQ2xpZW50ID0gU3ltYm9sKCdyZW1vdmUgY2xpZW50JylcbmNvbnN0IGtTdGF0cyA9IFN5bWJvbCgnc3RhdHMnKVxuXG5jbGFzcyBQb29sQmFzZSBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba1F1ZXVlXSA9IG5ldyBGaXhlZFF1ZXVlKClcbiAgICB0aGlzW2tDbGllbnRzXSA9IFtdXG4gICAgdGhpc1trUXVldWVkXSA9IDBcblxuICAgIGNvbnN0IHBvb2wgPSB0aGlzXG5cbiAgICB0aGlzW2tPbkRyYWluXSA9IGZ1bmN0aW9uIG9uRHJhaW4gKG9yaWdpbiwgdGFyZ2V0cykge1xuICAgICAgY29uc3QgcXVldWUgPSBwb29sW2tRdWV1ZV1cblxuICAgICAgbGV0IG5lZWREcmFpbiA9IGZhbHNlXG5cbiAgICAgIHdoaWxlICghbmVlZERyYWluKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcG9vbFtrUXVldWVkXS0tXG4gICAgICAgIG5lZWREcmFpbiA9ICF0aGlzLmRpc3BhdGNoKGl0ZW0ub3B0cywgaXRlbS5oYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gbmVlZERyYWluXG5cbiAgICAgIGlmICghdGhpc1trTmVlZERyYWluXSAmJiBwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIHBvb2xba05lZWREcmFpbl0gPSBmYWxzZVxuICAgICAgICBwb29sLmVtaXQoJ2RyYWluJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgICB9XG5cbiAgICAgIGlmIChwb29sW2tDbG9zZWRSZXNvbHZlXSAmJiBxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgUHJvbWlzZVxuICAgICAgICAgIC5hbGwocG9vbFtrQ2xpZW50c10ubWFwKGMgPT4gYy5jbG9zZSgpKSlcbiAgICAgICAgICAudGhlbihwb29sW2tDbG9zZWRSZXNvbHZlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgcG9vbC5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbcG9vbCwgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tTdGF0c10gPSBuZXcgUG9vbFN0YXRzKHRoaXMpXG4gIH1cblxuICBnZXQgW2tCdXN5XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIGdldCBba0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSkubGVuZ3RoXG4gIH1cblxuICBnZXQgW2tGcmVlXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdLmZpbHRlcihjbGllbnQgPT4gY2xpZW50W2tDb25uZWN0ZWRdICYmICFjbGllbnRba05lZWREcmFpbl0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrUGVuZGluZ10gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrUGVuZGluZ106IHBlbmRpbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHBlbmRpbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIGxldCByZXQgPSAwXG4gICAgZm9yIChjb25zdCB7IFtrUnVubmluZ106IHJ1bm5pbmcgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHJ1bm5pbmdcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IFtrU2l6ZV0gKCkge1xuICAgIGxldCByZXQgPSB0aGlzW2tRdWV1ZWRdXG4gICAgZm9yIChjb25zdCB7IFtrU2l6ZV06IHNpemUgfSBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgcmV0ICs9IHNpemVcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgZ2V0IHN0YXRzICgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RhdHNdXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNba1F1ZXVlXS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSByZXNvbHZlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrRGVzdHJveV0gKGVycikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trUXVldWVdLnNoaWZ0KClcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaXRlbS5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmRlc3Ryb3koZXJyKSkpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tHZXREaXNwYXRjaGVyXSgpXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIHRoaXNba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tRdWV1ZV0ucHVzaCh7IG9wdHMsIGhhbmRsZXIgfSlcbiAgICAgIHRoaXNba1F1ZXVlZF0rK1xuICAgIH0gZWxzZSBpZiAoIWRpc3BhdGNoZXIuZGlzcGF0Y2gob3B0cywgaGFuZGxlcikpIHtcbiAgICAgIGRpc3BhdGNoZXJba05lZWREcmFpbl0gPSB0cnVlXG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gIXRoaXNba0dldERpc3BhdGNoZXJdKClcbiAgICB9XG5cbiAgICByZXR1cm4gIXRoaXNba05lZWREcmFpbl1cbiAgfVxuXG4gIFtrQWRkQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50XG4gICAgICAub24oJ2RyYWluJywgdGhpc1trT25EcmFpbl0pXG4gICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgLm9uKCdkaXNjb25uZWN0JywgdGhpc1trT25EaXNjb25uZWN0XSlcbiAgICAgIC5vbignY29ubmVjdGlvbkVycm9yJywgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdKVxuXG4gICAgdGhpc1trQ2xpZW50c10ucHVzaChjbGllbnQpXG5cbiAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trTmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNba09uRHJhaW5dKGNsaWVudFtrVXJsXSwgW3RoaXMsIGNsaWVudF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFtrUmVtb3ZlQ2xpZW50XSAoY2xpZW50KSB7XG4gICAgY2xpZW50LmNsb3NlKCgpID0+IHtcbiAgICAgIGNvbnN0IGlkeCA9IHRoaXNba0NsaWVudHNdLmluZGV4T2YoY2xpZW50KVxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpc1trTmVlZERyYWluXSA9IHRoaXNba0NsaWVudHNdLnNvbWUoZGlzcGF0Y2hlciA9PiAoXG4gICAgICAhZGlzcGF0Y2hlcltrTmVlZERyYWluXSAmJlxuICAgICAgZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIGRpc3BhdGNoZXIuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrUmVtb3ZlQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-stats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst kPool = Symbol('pool')\n\nclass PoolStats {\n  constructor (pool) {\n    this[kPool] = pool\n  }\n\n  get connected () {\n    return this[kPool][kConnected]\n  }\n\n  get free () {\n    return this[kPool][kFree]\n  }\n\n  get pending () {\n    return this[kPool][kPending]\n  }\n\n  get queued () {\n    return this[kPool][kQueued]\n  }\n\n  get running () {\n    return this[kPool][kRunning]\n  }\n\n  get size () {\n    return this[kPool][kSize]\n  }\n}\n\nmodule.exports = PoolStats\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtc3RhdHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSx3REFBd0QsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccG9vbC1zdGF0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGtGcmVlLCBrQ29ubmVjdGVkLCBrUGVuZGluZywga1F1ZXVlZCwga1J1bm5pbmcsIGtTaXplIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3Qga1Bvb2wgPSBTeW1ib2woJ3Bvb2wnKVxuXG5jbGFzcyBQb29sU3RhdHMge1xuICBjb25zdHJ1Y3RvciAocG9vbCkge1xuICAgIHRoaXNba1Bvb2xdID0gcG9vbFxuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tDb25uZWN0ZWRdXG4gIH1cblxuICBnZXQgZnJlZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tGcmVlXVxuICB9XG5cbiAgZ2V0IHBlbmRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUGVuZGluZ11cbiAgfVxuXG4gIGdldCBxdWV1ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUXVldWVkXVxuICB9XG5cbiAgZ2V0IHJ1bm5pbmcgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrUnVubmluZ11cbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1NpemVdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sU3RhdHNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool-stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool)\n      ? options.interceptors.Pool\n      : []\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2 }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n  }\n\n  [kGetDispatcher] () {\n    for (const client of this[kClients]) {\n      if (!client[kNeedDrain]) {\n        return client\n      }\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsZUFBZSxtQkFBTyxDQUFDLHNFQUFVO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWlCOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbURBQW1EO0FBQ3BGO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufSA9IHJlcXVpcmUoJy4vcG9vbC1iYXNlJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0Nvbm5lY3Rpb25zID0gU3ltYm9sKCdjb25uZWN0aW9ucycpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgY29ubmVjdGlvbnMsXG4gICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgdGxzLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIHNvY2tldFBhdGgsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgYWxsb3dIMixcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnM/LlBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sKVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trQ29ubmVjdGlvbnNdID0gY29ubmVjdGlvbnMgfHwgbnVsbFxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKG9yaWdpbilcbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QsIGFsbG93SDIgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdKSB7XG4gICAgICBpZiAoIWNsaWVudFtrTmVlZERyYWluXSkge1xuICAgICAgICByZXR1cm4gY2xpZW50XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzW2tDb25uZWN0aW9uc10gfHwgdGhpc1trQ2xpZW50c10ubGVuZ3RoIDwgdGhpc1trQ29ubmVjdGlvbnNdKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0odGhpc1trVXJsXSwgdGhpc1trT3B0aW9uc10pXG4gICAgICB0aGlzW2tBZGRDbGllbnRdKGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { URL } = __webpack_require__(/*! node:url */ \"node:url\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(ssr)/./node_modules/undici/lib/core/connect.js\")\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super()\n\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', () => {}).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDN0UsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQywwQkFBVTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHdFQUF3RSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzFHLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFpQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDRFQUE0RTs7QUFFeEYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxlQUFlLDZCQUE2QixHQUFHLDZCQUE2QixzQkFBc0I7QUFDOUo7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RCw4Q0FBOEMsb0JBQW9CO0FBQ2xFLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsdUNBQXVDO0FBQ3ZDLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHByb3h5LWFnZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtQcm94eSwga0Nsb3NlLCBrRGVzdHJveSwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdub2RlOnVybCcpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IsIFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBidWlsZENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvY29ubmVjdCcpXG5cbmNvbnN0IGtBZ2VudCA9IFN5bWJvbCgncHJveHkgYWdlbnQnKVxuY29uc3Qga0NsaWVudCA9IFN5bWJvbCgncHJveHkgY2xpZW50JylcbmNvbnN0IGtQcm94eUhlYWRlcnMgPSBTeW1ib2woJ3Byb3h5IGhlYWRlcnMnKVxuY29uc3Qga1JlcXVlc3RUbHMgPSBTeW1ib2woJ3JlcXVlc3QgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtQcm94eVRscyA9IFN5bWJvbCgncHJveHkgdGxzIHNldHRpbmdzJylcbmNvbnN0IGtDb25uZWN0RW5kcG9pbnQgPSBTeW1ib2woJ2Nvbm5lY3QgZW5kcG9pbnQgZnVuY3Rpb24nKVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJvdG9jb2xQb3J0IChwcm90b2NvbCkge1xuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODBcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKClcblxuICAgIGlmICghb3B0cyB8fCAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICEob3B0cyBpbnN0YW5jZW9mIFVSTCkgJiYgIW9wdHMudXJpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSB1cmkgaXMgbWFuZGF0b3J5JylcbiAgICB9XG5cbiAgICBjb25zdCB7IGNsaWVudEZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSB9ID0gb3B0c1xuICAgIGlmICh0eXBlb2YgY2xpZW50RmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLmNsaWVudEZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gdGhpcy4jZ2V0VXJsKG9wdHMpXG4gICAgY29uc3QgeyBocmVmLCBvcmlnaW4sIHBvcnQsIHByb3RvY29sLCB1c2VybmFtZSwgcGFzc3dvcmQsIGhvc3RuYW1lOiBwcm94eUhvc3RuYW1lIH0gPSB1cmxcblxuICAgIHRoaXNba1Byb3h5XSA9IHsgdXJpOiBocmVmLCBwcm90b2NvbCB9XG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzPy5Qcm94eUFnZW50ICYmIEFycmF5LmlzQXJyYXkob3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudFxuICAgICAgOiBbXVxuICAgIHRoaXNba1JlcXVlc3RUbHNdID0gb3B0cy5yZXF1ZXN0VGxzXG4gICAgdGhpc1trUHJveHlUbHNdID0gb3B0cy5wcm94eVRsc1xuICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSBvcHRzLmhlYWRlcnMgfHwge31cblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfSBlbHNlIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gXG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHVybCwgeyBjb25uZWN0IH0pXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBjb25uZWN0OiBhc3luYyAob3B0cywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IHJlcXVlc3RlZFBhdGggPSBvcHRzLmhvc3RcbiAgICAgICAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgICAgICByZXF1ZXN0ZWRQYXRoICs9IGA6JHtkZWZhdWx0UHJvdG9jb2xQb3J0KG9wdHMucHJvdG9jb2wpfWBcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgc29ja2V0LCBzdGF0dXNDb2RlIH0gPSBhd2FpdCB0aGlzW2tDbGllbnRdLmNvbm5lY3Qoe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHJlcXVlc3RlZFBhdGgsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAuLi50aGlzW2tQcm94eUhlYWRlcnNdLFxuICAgICAgICAgICAgICBob3N0OiBvcHRzLmhvc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiB0aGlzW2tQcm94eVRsc10/LnNlcnZlcm5hbWUgfHwgcHJveHlIb3N0bmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHt9KS5kZXN0cm95KClcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKGBQcm94eSByZXNwb25zZSAoJHtzdGF0dXNDb2RlfSkgIT09IDIwMCB3aGVuIEhUVFAgVHVubmVsaW5nYCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc29ja2V0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBzZXJ2ZXJuYW1lXG4gICAgICAgICAgaWYgKHRoaXNba1JlcXVlc3RUbHNdKSB7XG4gICAgICAgICAgICBzZXJ2ZXJuYW1lID0gdGhpc1trUmVxdWVzdFRsc10uc2VydmVybmFtZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0oeyAuLi5vcHRzLCBzZXJ2ZXJuYW1lLCBodHRwU29ja2V0OiBzb2NrZXQgfSwgY2FsbGJhY2spXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBlcnJvciB0byBhdm9pZCBsb29wIGluIGNsaWVudC5qcyNjb25uZWN0XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IoZXJyKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBidWlsZEhlYWRlcnMob3B0cy5oZWFkZXJzKVxuICAgIHRocm93SWZQcm94eUF1dGhJc1NlbnQoaGVhZGVycylcblxuICAgIGlmIChoZWFkZXJzICYmICEoJ2hvc3QnIGluIGhlYWRlcnMpICYmICEoJ0hvc3QnIGluIGhlYWRlcnMpKSB7XG4gICAgICBjb25zdCB7IGhvc3QgfSA9IG5ldyBVUkwob3B0cy5vcmlnaW4pXG4gICAgICBoZWFkZXJzLmhvc3QgPSBob3N0XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL3Byb3h5LWFnZW50JykuUHJveHlBZ2VudC5PcHRpb25zIHwgc3RyaW5nIHwgVVJMfSBvcHRzXG4gICAqIEByZXR1cm5zIHtVUkx9XG4gICAqL1xuICAjZ2V0VXJsIChvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwob3B0cylcbiAgICB9IGVsc2UgaWYgKG9wdHMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgIHJldHVybiBvcHRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVVJMKG9wdHMudXJpKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uY2xvc2UoKVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoKSB7XG4gICAgYXdhaXQgdGhpc1trQWdlbnRdLmRlc3Ryb3koKVxuICAgIGF3YWl0IHRoaXNba0NsaWVudF0uZGVzdHJveSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVycyAoaGVhZGVycykge1xuICAvLyBXaGVuIHVzaW5nIHVuZGljaS5mZXRjaCwgdGhlIGhlYWRlcnMgbGlzdCBpcyBzdG9yZWRcbiAgLy8gYXMgYW4gYXJyYXkuXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIGNvbnN0IGhlYWRlcnNQYWlyID0ge31cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaGVhZGVyc1BhaXJbaGVhZGVyc1tpXV0gPSBoZWFkZXJzW2kgKyAxXVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzUGFpclxuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGhlYWRlcnNcbiAqXG4gKiBQcmV2aW91cyB2ZXJzaW9ucyBvZiBQcm94eUFnZW50IHN1Z2dlc3RzIHRoZSBQcm94eS1BdXRob3JpemF0aW9uIGluIHJlcXVlc3QgaGVhZGVyc1xuICogTmV2ZXJ0aGVsZXNzLCBpdCB3YXMgY2hhbmdlZCBhbmQgdG8gYXZvaWQgYSBzZWN1cml0eSB2dWxuZXJhYmlsaXR5IGJ5IGVuZCB1c2Vyc1xuICogdGhpcyBjaGVjayB3YXMgY3JlYXRlZC5cbiAqIEl0IHNob3VsZCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAqL1xuZnVuY3Rpb24gdGhyb3dJZlByb3h5QXV0aElzU2VudCAoaGVhZGVycykge1xuICBjb25zdCBleGlzdFByb3h5QXV0aCA9IGhlYWRlcnMgJiYgT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAuZmluZCgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ3Byb3h5LWF1dGhvcml6YXRpb24nKVxuICBpZiAoZXhpc3RQcm94eUF1dGgpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Byb3h5LUF1dGhvcml6YXRpb24gc2hvdWxkIGJlIHNlbnQgaW4gUHJveHlBZ2VudCBjb25zdHJ1Y3RvcicpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm94eUFnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nclass RetryAgent extends Dispatcher {\n  #agent = null\n  #options = null\n  constructor (agent, options = {}) {\n    super(options)\n    this.#agent = agent\n    this.#options = options\n  }\n\n  dispatch (opts, handler) {\n    const retry = new RetryHandler({\n      ...opts,\n      retryOptions: this.#options\n    }, {\n      dispatch: this.#agent.dispatch.bind(this.#agent),\n      handler\n    })\n    return this.#agent.dispatch(opts, retry)\n  }\n\n  close () {\n    return this.#agent.close()\n  }\n\n  destroy () {\n    return this.#agent.destroy()\n  }\n}\n\nmodule.exports = RetryAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxyZXRyeS1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlcicpXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5jbGFzcyBSZXRyeUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICNhZ2VudCA9IG51bGxcbiAgI29wdGlvbnMgPSBudWxsXG4gIGNvbnN0cnVjdG9yIChhZ2VudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucylcbiAgICB0aGlzLiNhZ2VudCA9IGFnZW50XG4gICAgdGhpcy4jb3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmV0cnkgPSBuZXcgUmV0cnlIYW5kbGVyKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZXRyeU9wdGlvbnM6IHRoaXMuI29wdGlvbnNcbiAgICB9LCB7XG4gICAgICBkaXNwYXRjaDogdGhpcy4jYWdlbnQuZGlzcGF0Y2guYmluZCh0aGlzLiNhZ2VudCksXG4gICAgICBoYW5kbGVyXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGlzcGF0Y2gob3B0cywgcmV0cnkpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmNsb3NlKClcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5kZXN0cm95KClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBb0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZ2xvYmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXZSBpbmNsdWRlIGEgdmVyc2lvbiBudW1iZXIgZm9yIHRoZSBEaXNwYXRjaGVyIEFQSS4gSW4gY2FzZSBvZiBicmVha2luZyBjaGFuZ2VzLFxuLy8gdGhpcyB2ZXJzaW9uIG51bWJlciBtdXN0IGJlIGluY3JlYXNlZCB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxEaXNwYXRjaGVyID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbERpc3BhdGNoZXIuMScpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuL2NvcmUvZXJyb3JzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyL2FnZW50JylcblxuaWYgKGdldEdsb2JhbERpc3BhdGNoZXIoKSA9PT0gdW5kZWZpbmVkKSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IEFnZW50KCkpXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbERpc3BhdGNoZXIgKGFnZW50KSB7XG4gIGlmICghYWdlbnQgfHwgdHlwZW9mIGFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBhZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbERpc3BhdGNoZXIsIHtcbiAgICB2YWx1ZTogYWdlbnQsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxEaXNwYXRjaGVyICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsRGlzcGF0Y2hlcl1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldEdsb2JhbERpc3BhdGNoZXIsXG4gIGdldEdsb2JhbERpc3BhdGNoZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = class DecoratorHandler {\n  #handler\n\n  constructor (handler) {\n    if (typeof handler !== 'object' || handler === null) {\n      throw new TypeError('handler must be an object')\n    }\n    this.#handler = handler\n  }\n\n  onConnect (...args) {\n    return this.#handler.onConnect?.(...args)\n  }\n\n  onError (...args) {\n    return this.#handler.onError?.(...args)\n  }\n\n  onUpgrade (...args) {\n    return this.#handler.onUpgrade?.(...args)\n  }\n\n  onResponseStarted (...args) {\n    return this.#handler.onResponseStarted?.(...args)\n  }\n\n  onHeaders (...args) {\n    return this.#handler.onHeaders?.(...args)\n  }\n\n  onData (...args) {\n    return this.#handler.onData?.(...args)\n  }\n\n  onComplete (...args) {\n    return this.#handler.onComplete?.(...args)\n  }\n\n  onBodySent (...args) {\n    return this.#handler.onBodySent?.(...args)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXGRlY29yYXRvci1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIERlY29yYXRvckhhbmRsZXIge1xuICAjaGFuZGxlclxuXG4gIGNvbnN0cnVjdG9yIChoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0JyB8fCBoYW5kbGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoYW5kbGVyIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uQ29ubmVjdCAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdD8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkVycm9yICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25FcnJvcj8uKC4uLmFyZ3MpXG4gIH1cblxuICBvblVwZ3JhZGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblVwZ3JhZGU/LiguLi5hcmdzKVxuICB9XG5cbiAgb25SZXNwb25zZVN0YXJ0ZWQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vblJlc3BvbnNlU3RhcnRlZD8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkhlYWRlcnMgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkhlYWRlcnM/LiguLi5hcmdzKVxuICB9XG5cbiAgb25EYXRhICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25EYXRhPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkNvbXBsZXRlPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uQm9keVNlbnQgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkJvZHlTZW50Py4oLi4uYXJncylcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatch = dispatch\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n    this.redirectionLimitReached = false\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n      if (this.request) {\n        this.request.abort(new Error('max redirects'))\n      }\n\n      this.redirectionLimitReached = true\n      this.abort(new Error('max redirects'))\n      return\n    }\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n    this.opts.query = null\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].length === 8 && util.headerNameToString(headers[i]) === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  if (header.length === 4) {\n    return util.headerNameToString(header) === 'host'\n  }\n  if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n    return true\n  }\n  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n    const name = util.headerNameToString(header)\n    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'\n  }\n  return false\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDLDZCQUE2QixTQUFTLEVBQUUsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaGFuZGxlclxccmVkaXJlY3QtaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGtCb2R5VXNlZCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuXG5jb25zdCByZWRpcmVjdGFibGVTdGF0dXNDb2RlcyA9IFszMDAsIDMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5jb25zdCBrQm9keSA9IFN5bWJvbCgnYm9keScpXG5cbmNsYXNzIEJvZHlBc3luY0l0ZXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKGJvZHkpIHtcbiAgICB0aGlzW2tCb2R5XSA9IGJvZHlcbiAgICB0aGlzW2tCb2R5VXNlZF0gPSBmYWxzZVxuICB9XG5cbiAgYXN5bmMgKiBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdICgpIHtcbiAgICBhc3NlcnQoIXRoaXNba0JvZHlVc2VkXSwgJ2Rpc3R1cmJlZCcpXG4gICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgIHlpZWxkICogdGhpc1trQm9keV1cbiAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoZGlzcGF0Y2gsIG1heFJlZGlyZWN0aW9ucywgb3B0cywgaGFuZGxlcikge1xuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgdXRpbC52YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgb3B0cy5tZXRob2QsIG9wdHMudXBncmFkZSlcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICAgIHRoaXMubG9jYXRpb24gPSBudWxsXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLm9wdHMgPSB7IC4uLm9wdHMsIG1heFJlZGlyZWN0aW9uczogMCB9IC8vIG9wdHMgbXVzdCBiZSBhIGNvcHlcbiAgICB0aGlzLm1heFJlZGlyZWN0aW9ucyA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxuICAgIHRoaXMucmVkaXJlY3Rpb25MaW1pdFJlYWNoZWQgPSBmYWxzZVxuXG4gICAgaWYgKHV0aWwuaXNTdHJlYW0odGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBQcm92aWRlIHNvbWUgd2F5IGZvciB0aGUgdXNlciB0byBjYWNoZSB0aGUgZmlsZSB0byBlLmcuIC90bXBcbiAgICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIDEwMC1leHBlY3Qgc3VwcG9ydCB0byBwcm92aWRlIGEgd2F5IHRvIGRvIHRoaXMgcHJvcGVybHk/XG4gICAgICBpZiAodXRpbC5ib2R5TGVuZ3RoKHRoaXMub3B0cy5ib2R5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVxuICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSlcbiAgICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5ib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMub3B0cy5ib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgICBFRS5wcm90b3R5cGUub24uY2FsbCh0aGlzLm9wdHMuYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpc1trQm9keVVzZWRdID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmJvZHkgJiYgdHlwZW9mIHRoaXMub3B0cy5ib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVE9ETyAoZml4KTogV2UgY2FuJ3QgYWNjZXNzIFJlYWRhYmxlU3RyZWFtIGludGVybmFsIHN0YXRlXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgaXQgaGFzIGJlZW4gZGlzdHVyYmVkLiBUaGlzIGlzIGp1c3RcbiAgICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLm9wdHMuYm9keSAmJlxuICAgICAgdHlwZW9mIHRoaXMub3B0cy5ib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyh0aGlzLm9wdHMuYm9keSkgJiZcbiAgICAgIHV0aWwuaXNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhbGxvdyByZS11c2luZyBpdGVyYWJsZSBpZiAhdGhpcy5vcHRzLmlkZW1wb3RlbnRcbiAgICAgIC8vIG9yIHRocm91Z2ggc29tZSBvdGhlciBmbGFnP1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBuZXcgQm9keUFzeW5jSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuaGFuZGxlci5vbkNvbm5lY3QoYWJvcnQsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5IH0pXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIHRoaXMuaGFuZGxlci5vblVwZ3JhZGUoc3RhdHVzQ29kZSwgaGVhZGVycywgc29ja2V0KVxuICB9XG5cbiAgb25FcnJvciAoZXJyb3IpIHtcbiAgICB0aGlzLmhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPj0gdGhpcy5tYXhSZWRpcmVjdGlvbnMgfHwgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSlcbiAgICAgID8gbnVsbFxuICAgICAgOiBwYXJzZUxvY2F0aW9uKHN0YXR1c0NvZGUsIGhlYWRlcnMpXG5cbiAgICBpZiAodGhpcy5vcHRzLnRocm93T25NYXhSZWRpcmVjdCAmJiB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5hYm9ydChuZXcgRXJyb3IoJ21heCByZWRpcmVjdHMnKSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWRpcmVjdGlvbkxpbWl0UmVhY2hlZCA9IHRydWVcbiAgICAgIHRoaXMuYWJvcnQobmV3IEVycm9yKCdtYXggcmVkaXJlY3RzJykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLm9yaWdpbikge1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2gobmV3IFVSTCh0aGlzLm9wdHMucGF0aCwgdGhpcy5vcHRzLm9yaWdpbikpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXN1bWUsIHN0YXR1c1RleHQpXG4gICAgfVxuXG4gICAgY29uc3QgeyBvcmlnaW4sIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHV0aWwucGFyc2VVUkwobmV3IFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLm9wdHMub3JpZ2luICYmIG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKSlcbiAgICBjb25zdCBwYXRoID0gc2VhcmNoID8gYCR7cGF0aG5hbWV9JHtzZWFyY2h9YCA6IHBhdGhuYW1lXG5cbiAgICAvLyBSZW1vdmUgaGVhZGVycyByZWZlcnJpbmcgdG8gdGhlIG9yaWdpbmFsIFVSTC5cbiAgICAvLyBCeSBkZWZhdWx0IGl0IGlzIEhvc3Qgb25seSwgdW5sZXNzIGl0J3MgYSAzMDMgKHNlZSBiZWxvdyksIHdoaWNoIHJlbW92ZXMgYWxzbyBhbGwgQ29udGVudC0qIGhlYWRlcnMuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcbiAgICB0aGlzLm9wdHMuaGVhZGVycyA9IGNsZWFuUmVxdWVzdEhlYWRlcnModGhpcy5vcHRzLmhlYWRlcnMsIHN0YXR1c0NvZGUgPT09IDMwMywgdGhpcy5vcHRzLm9yaWdpbiAhPT0gb3JpZ2luKVxuICAgIHRoaXMub3B0cy5wYXRoID0gcGF0aFxuICAgIHRoaXMub3B0cy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLm9wdHMubWF4UmVkaXJlY3Rpb25zID0gMFxuICAgIHRoaXMub3B0cy5xdWVyeSA9IG51bGxcblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbiAgICAvLyBJbiBjYXNlIG9mIEhUVFAgMzAzLCBhbHdheXMgcmVwbGFjZSBtZXRob2QgdG8gYmUgZWl0aGVyIEhFQUQgb3IgR0VUXG4gICAgaWYgKHN0YXR1c0NvZGUgPT09IDMwMyAmJiB0aGlzLm9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgIHRoaXMub3B0cy5tZXRob2QgPSAnR0VUJ1xuICAgICAgdGhpcy5vcHRzLmJvZHkgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgYm9kaWVzLlxuXG4gICAgICAgIFJlZGlyZWN0aW9uIGlzIHVzZWQgdG8gc2VydmUgdGhlIHJlcXVlc3RlZCByZXNvdXJjZSBmcm9tIGFub3RoZXIgVVJMLCBzbyBpdCBpcyBhc3N1bWVzIHRoYXRcbiAgICAgICAgbm8gYm9keSBpcyBnZW5lcmF0ZWQgKGFuZCB0aHVzIGNhbiBiZSBpZ25vcmVkKS4gRXZlbiB0aG91Z2ggZ2VuZXJhdGluZyBhIGJvZHkgaXMgbm90IHByb2hpYml0ZWQuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDEsIDMwMiwgMzAzLCAzMDcgYW5kIDMwOCAodGhlIGxhdHRlciBmcm9tIFJGQyA3MjM4KSwgdGhlIHNwZWNzIG1lbnRpb24gdGhhdCB0aGUgYm9keSB1c3VhbGx5XG4gICAgICAgICh3aGljaCBtZWFucyBpdCdzIG9wdGlvbmFsIGFuZCBub3QgbWFuZGF0ZWQpIGNvbnRhaW4ganVzdCBhbiBoeXBlcmxpbmsgdG8gdGhlIHZhbHVlIG9mXG4gICAgICAgIHRoZSBMb2NhdGlvbiByZXNwb25zZSBoZWFkZXIsIHNvIHRoZSBib2R5IGNhbiBiZSBpZ25vcmVkIHNhZmVseS5cblxuICAgICAgICBGb3Igc3RhdHVzIDMwMCwgd2hpY2ggaXMgXCJNdWx0aXBsZSBDaG9pY2VzXCIsIHRoZSBzcGVjIG1lbnRpb25zIGJvdGggZ2VuZXJhdGluZyBhIExvY2F0aW9uXG4gICAgICAgIHJlc3BvbnNlIGhlYWRlciBBTkQgYSByZXNwb25zZSBib2R5IHdpdGggdGhlIG90aGVyIHBvc3NpYmxlIGxvY2F0aW9uIHRvIGZvbGxvdy5cbiAgICAgICAgU2luY2UgdGhlIHNwZWMgZXhwbGljaXRseSBjaG9vc2VzIG5vdCB0byBzcGVjaWZ5IGEgZm9ybWF0IGZvciBzdWNoIGJvZHkgYW5kIGxlYXZlIGl0IHRvXG4gICAgICAgIHNlcnZlcnMgYW5kIGJyb3dzZXJzIGltcGxlbWVudG9ycywgd2UgaWdub3JlIHRoZSBib2R5IGFzIHRoZXJlIGlzIG5vIHNwZWNpZmllZCB3YXkgdG8gZXZlbnR1YWxseSBwYXJzZSBpdC5cbiAgICAgICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25EYXRhKGNodW5rKVxuICAgIH1cbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMubG9jYXRpb24pIHtcbiAgICAgIC8qXG4gICAgICAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5cbiAgICAgICAgVExEUjogdW5kaWNpIGFsd2F5cyBpZ25vcmVzIDN4eCByZXNwb25zZSB0cmFpbGVycyBhcyB0aGV5IGFyZSBub3QgZXhwZWN0ZWQgaW4gY2FzZSBvZiByZWRpcmVjdGlvbnNcbiAgICAgICAgYW5kIG5laXRoZXIgYXJlIHVzZWZ1bCBpZiBwcmVzZW50LlxuXG4gICAgICAgIFNlZSBjb21tZW50IG9uIG9uRGF0YSBtZXRob2QgYWJvdmUgZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXG4gICAgICAqL1xuXG4gICAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vbkNvbXBsZXRlKHRyYWlsZXJzKVxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Cb2R5U2VudChjaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhdGlvbiAoc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICBpZiAocmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMuaW5kZXhPZihzdGF0dXNDb2RlKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgaWYgKGhlYWRlcnNbaV0ubGVuZ3RoID09PSA4ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcnNbaV0pID09PSAnbG9jYXRpb24nKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjQuNFxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlSGVhZGVyIChoZWFkZXIsIHJlbW92ZUNvbnRlbnQsIHVua25vd25PcmlnaW4pIHtcbiAgaWYgKGhlYWRlci5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKSA9PT0gJ2hvc3QnXG4gIH1cbiAgaWYgKHJlbW92ZUNvbnRlbnQgJiYgdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKS5zdGFydHNXaXRoKCdjb250ZW50LScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodW5rbm93bk9yaWdpbiAmJiAoaGVhZGVyLmxlbmd0aCA9PT0gMTMgfHwgaGVhZGVyLmxlbmd0aCA9PT0gNiB8fCBoZWFkZXIubGVuZ3RoID09PSAxOSkpIHtcbiAgICBjb25zdCBuYW1lID0gdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyKVxuICAgIHJldHVybiBuYW1lID09PSAnYXV0aG9yaXphdGlvbicgfHwgbmFtZSA9PT0gJ2Nvb2tpZScgfHwgbmFtZSA9PT0gJ3Byb3h5LWF1dGhvcml6YXRpb24nXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG5mdW5jdGlvbiBjbGVhblJlcXVlc3RIZWFkZXJzIChoZWFkZXJzLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGNvbnN0IHJldCA9IFtdXG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoIXNob3VsZFJlbW92ZUhlYWRlcihoZWFkZXJzW2ldLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChoZWFkZXJzW2ldLCBoZWFkZXJzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoa2V5LCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSkge1xuICAgICAgICByZXQucHVzaChrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGhlYWRlcnMgPT0gbnVsbCwgJ2hlYWRlcnMgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXknKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdEhhbmRsZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader,\n  wrapRequestBody\n} = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  return new Date(retryAfter).getTime() - current\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        return this.handler.onHeaders(\n          statusCode,\n          rawHeaders,\n          resume,\n          statusMessage\n        )\n      } else {\n        this.abort(\n          new RequestRetryError('Request failed', statusCode, {\n            headers,\n            data: {\n              count: this.retryCount\n            }\n          })\n        )\n        return false\n      }\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      if (statusCode !== 206) {\n        return true\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (this.etag != null && this.etag.startsWith('W/')) {\n        this.etag = null\n      }\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      data: { count: this.retryCount }\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n        // Weak etag check - weak etags will make comparison algorithms never match\n        if (this.etag != null) {\n          headers['if-match'] = this.etag\n        }\n\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            ...headers\n          }\n        }\n      }\n\n      try {\n        this.retryCountCheckpoint = this.retryCount\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDL0QsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsYUFBYTtBQUMxRCxZQUFZLDRCQUE0QjtBQUN4QyxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVksVUFBVTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDBCQUEwQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0IsV0FBVyxHQUFHLGVBQWU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxoYW5kbGVyXFxyZXRyeS1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCB7IGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnkgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IFJlcXVlc3RSZXRyeUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB7XG4gIGlzRGlzdHVyYmVkLFxuICBwYXJzZUhlYWRlcnMsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIHdyYXBSZXF1ZXN0Qm9keVxufSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIgKHJldHJ5QWZ0ZXIpIHtcbiAgY29uc3QgY3VycmVudCA9IERhdGUubm93KClcbiAgcmV0dXJuIG5ldyBEYXRlKHJldHJ5QWZ0ZXIpLmdldFRpbWUoKSAtIGN1cnJlbnRcbn1cblxuY2xhc3MgUmV0cnlIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGhhbmRsZXJzKSB7XG4gICAgY29uc3QgeyByZXRyeU9wdGlvbnMsIC4uLmRpc3BhdGNoT3B0cyB9ID0gb3B0c1xuICAgIGNvbnN0IHtcbiAgICAgIC8vIFJldHJ5IHNjb3BlZFxuICAgICAgcmV0cnk6IHJldHJ5Rm4sXG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWF4VGltZW91dCxcbiAgICAgIG1pblRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgLy8gUmVzcG9uc2Ugc2NvcGVkXG4gICAgICBtZXRob2RzLFxuICAgICAgZXJyb3JDb2RlcyxcbiAgICAgIHJldHJ5QWZ0ZXIsXG4gICAgICBzdGF0dXNDb2Rlc1xuICAgIH0gPSByZXRyeU9wdGlvbnMgPz8ge31cblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBoYW5kbGVycy5kaXNwYXRjaFxuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXJzLmhhbmRsZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRpc3BhdGNoT3B0cywgYm9keTogd3JhcFJlcXVlc3RCb2R5KG9wdHMuYm9keSkgfVxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2VcbiAgICB0aGlzLnJldHJ5T3B0cyA9IHtcbiAgICAgIHJldHJ5OiByZXRyeUZuID8/IFJldHJ5SGFuZGxlcltrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5XSxcbiAgICAgIHJldHJ5QWZ0ZXI6IHJldHJ5QWZ0ZXIgPz8gdHJ1ZSxcbiAgICAgIG1heFRpbWVvdXQ6IG1heFRpbWVvdXQgPz8gMzAgKiAxMDAwLCAvLyAzMHMsXG4gICAgICBtaW5UaW1lb3V0OiBtaW5UaW1lb3V0ID8/IDUwMCwgLy8gLjVzXG4gICAgICB0aW1lb3V0RmFjdG9yOiB0aW1lb3V0RmFjdG9yID8/IDIsXG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDUsXG4gICAgICAvLyBXaGF0IGVycm9ycyB3ZSBzaG91bGQgcmV0cnlcbiAgICAgIG1ldGhvZHM6IG1ldGhvZHMgPz8gWydHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BVVCcsICdERUxFVEUnLCAnVFJBQ0UnXSxcbiAgICAgIC8vIEluZGljYXRlcyB3aGljaCBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIHN0YXR1c0NvZGVzOiBzdGF0dXNDb2RlcyA/PyBbNTAwLCA1MDIsIDUwMywgNTA0LCA0MjldLFxuICAgICAgLy8gTGlzdCBvZiBlcnJvcnMgdG8gcmV0cnlcbiAgICAgIGVycm9yQ29kZXM6IGVycm9yQ29kZXMgPz8gW1xuICAgICAgICAnRUNPTk5SRVNFVCcsXG4gICAgICAgICdFQ09OTlJFRlVTRUQnLFxuICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgJ0VORVRET1dOJyxcbiAgICAgICAgJ0VORVRVTlJFQUNIJyxcbiAgICAgICAgJ0VIT1NURE9XTicsXG4gICAgICAgICdFSE9TVFVOUkVBQ0gnLFxuICAgICAgICAnRVBJUEUnLFxuICAgICAgICAnVU5EX0VSUl9TT0NLRVQnXG4gICAgICBdXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSAwXG4gICAgdGhpcy5zdGFydCA9IDBcbiAgICB0aGlzLmVuZCA9IG51bGxcbiAgICB0aGlzLmV0YWcgPSBudWxsXG4gICAgdGhpcy5yZXN1bWUgPSBudWxsXG5cbiAgICAvLyBIYW5kbGUgcG9zc2libGUgb25Db25uZWN0IGR1cGxpY2F0aW9uXG4gICAgdGhpcy5oYW5kbGVyLm9uQ29ubmVjdChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgdGhpcy5hYm9ydChyZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvblxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvblJlcXVlc3RTZW50ICgpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uUmVxdWVzdFNlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlci5vblJlcXVlc3RTZW50KClcbiAgICB9XG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25VcGdyYWRlKSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgICB9XG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0KSB7XG4gICAgaWYgKHRoaXMuYWJvcnRlZCkge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIH1cbiAgfVxuXG4gIG9uQm9keVNlbnQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KSByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspXG4gIH1cblxuICBzdGF0aWMgW2tSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnldIChlcnIsIHsgc3RhdGUsIG9wdHMgfSwgY2IpIHtcbiAgICBjb25zdCB7IHN0YXR1c0NvZGUsIGNvZGUsIGhlYWRlcnMgfSA9IGVyclxuICAgIGNvbnN0IHsgbWV0aG9kLCByZXRyeU9wdGlvbnMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgbWluVGltZW91dCxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICB0aW1lb3V0RmFjdG9yLFxuICAgICAgc3RhdHVzQ29kZXMsXG4gICAgICBlcnJvckNvZGVzLFxuICAgICAgbWV0aG9kc1xuICAgIH0gPSByZXRyeU9wdGlvbnNcbiAgICBjb25zdCB7IGNvdW50ZXIgfSA9IHN0YXRlXG5cbiAgICAvLyBBbnkgY29kZSB0aGF0IGlzIG5vdCBhIFVuZGljaSdzIG9yaWdpbmF0ZWQgYW5kIGFsbG93ZWQgdG8gcmV0cnlcbiAgICBpZiAoY29kZSAmJiBjb2RlICE9PSAnVU5EX0VSUl9SRVFfUkVUUlknICYmICFlcnJvckNvZGVzLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBhIHNldCBvZiBtZXRob2QgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBtZXRob2QgaXMgbm90IGluIHRoZSBsaXN0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0aG9kcykgJiYgIW1ldGhvZHMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgYSBzZXQgb2Ygc3RhdHVzIGNvZGUgYXJlIHByb3ZpZGVkIGFuZCB0aGUgY3VycmVudCBzdGF0dXMgY29kZSBpcyBub3QgaW4gdGhlIGxpc3RcbiAgICBpZiAoXG4gICAgICBzdGF0dXNDb2RlICE9IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoc3RhdHVzQ29kZXMpICYmXG4gICAgICAhc3RhdHVzQ29kZXMuaW5jbHVkZXMoc3RhdHVzQ29kZSlcbiAgICApIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIG1heCBudW1iZXIgb2YgcmV0cmllc1xuICAgIGlmIChjb3VudGVyID4gbWF4UmV0cmllcykge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJldHJ5QWZ0ZXJIZWFkZXIgPSBoZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ11cbiAgICBpZiAocmV0cnlBZnRlckhlYWRlcikge1xuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlcihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA9IE51bWJlci5pc05hTihyZXRyeUFmdGVySGVhZGVyKVxuICAgICAgICA/IGNhbGN1bGF0ZVJldHJ5QWZ0ZXJIZWFkZXIocmV0cnlBZnRlckhlYWRlcilcbiAgICAgICAgOiByZXRyeUFmdGVySGVhZGVyICogMWUzIC8vIFJldHJ5LUFmdGVyIGlzIGluIHNlY29uZHNcbiAgICB9XG5cbiAgICBjb25zdCByZXRyeVRpbWVvdXQgPVxuICAgICAgcmV0cnlBZnRlckhlYWRlciA+IDBcbiAgICAgICAgPyBNYXRoLm1pbihyZXRyeUFmdGVySGVhZGVyLCBtYXhUaW1lb3V0KVxuICAgICAgICA6IE1hdGgubWluKG1pblRpbWVvdXQgKiB0aW1lb3V0RmFjdG9yICoqIChjb3VudGVyIC0gMSksIG1heFRpbWVvdXQpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGNiKG51bGwpLCByZXRyeVRpbWVvdXQpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA+PSAzMDApIHtcbiAgICAgIGlmICh0aGlzLnJldHJ5T3B0cy5zdGF0dXNDb2Rlcy5pbmNsdWRlcyhzdGF0dXNDb2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICAgIHJlc3VtZSxcbiAgICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWJvcnQoXG4gICAgICAgICAgbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGNvdW50OiB0aGlzLnJldHJ5Q291bnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrcG9pbnQgZm9yIHJlc3VtZSBmcm9tIHdoZXJlIHdlIGxlZnQgaXRcbiAgICBpZiAodGhpcy5yZXN1bWUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yZXN1bWUgPSBudWxsXG5cbiAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udGVudFJhbmdlID0gcGFyc2VSYW5nZUhlYWRlcihoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pXG4gICAgICAvLyBJZiBubyBjb250ZW50IHJhbmdlXG4gICAgICBpZiAoIWNvbnRlbnRSYW5nZSkge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignQ29udGVudC1SYW5nZSBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIExldCdzIHN0YXJ0IHdpdGggYSB3ZWFrIGV0YWcgY2hlY2tcbiAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCAmJiB0aGlzLmV0YWcgIT09IGhlYWRlcnMuZXRhZykge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignRVRhZyBtaXNtYXRjaCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgfSA9IGNvbnRlbnRSYW5nZVxuXG4gICAgICBhc3NlcnQodGhpcy5zdGFydCA9PT0gc3RhcnQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcbiAgICAgIGFzc2VydCh0aGlzLmVuZCA9PSBudWxsIHx8IHRoaXMuZW5kID09PSBlbmQsICdjb250ZW50LXJhbmdlIG1pc21hdGNoJylcblxuICAgICAgdGhpcy5yZXN1bWUgPSByZXN1bWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlID09PSAyMDYpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSByZWNlaXZlIDIwNlxuICAgICAgICBjb25zdCByYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuXG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgcmF3SGVhZGVycyxcbiAgICAgICAgICAgIHJlc3VtZSxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBzaXplLCBlbmQgPSBzaXplIH0gPSByYW5nZVxuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgc3RhcnQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhcnQpLFxuICAgICAgICAgICdjb250ZW50LXJhbmdlIG1pc21hdGNoJ1xuICAgICAgICApXG4gICAgICAgIGFzc2VydChlbmQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSwgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnKVxuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydFxuICAgICAgICB0aGlzLmVuZCA9IGVuZFxuICAgICAgfVxuXG4gICAgICAvLyBXZSBtYWtlIG91ciBiZXN0IHRvIGNoZWNrcG9pbnQgdGhlIGJvZHkgZm9yIGZ1cnRoZXIgcmFuZ2UgaGVhZGVyc1xuICAgICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICAgICAgdGhpcy5lbmQgPSBjb250ZW50TGVuZ3RoICE9IG51bGwgPyBOdW1iZXIoY29udGVudExlbmd0aCkgOiBudWxsXG4gICAgICB9XG5cbiAgICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUodGhpcy5zdGFydCkpXG4gICAgICBhc3NlcnQoXG4gICAgICAgIHRoaXMuZW5kID09IG51bGwgfHwgTnVtYmVyLmlzRmluaXRlKHRoaXMuZW5kKSxcbiAgICAgICAgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnXG4gICAgICApXG5cbiAgICAgIHRoaXMucmVzdW1lID0gcmVzdW1lXG4gICAgICB0aGlzLmV0YWcgPSBoZWFkZXJzLmV0YWcgIT0gbnVsbCA/IGhlYWRlcnMuZXRhZyA6IG51bGxcblxuICAgICAgLy8gV2VhayBldGFncyBhcmUgbm90IHVzZWZ1bCBmb3IgY29tcGFyaXNvbiBub3IgY2FjaGVcbiAgICAgIC8vIGZvciBpbnN0YW5jZSBub3Qgc2FmZSB0byBhc3N1bWUgaWYgdGhlIHJlc3BvbnNlIGlzIGJ5dGUtcGVyLWJ5dGVcbiAgICAgIC8vIGVxdWFsXG4gICAgICBpZiAodGhpcy5ldGFnICE9IG51bGwgJiYgdGhpcy5ldGFnLnN0YXJ0c1dpdGgoJ1cvJykpIHtcbiAgICAgICAgdGhpcy5ldGFnID0gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgcmF3SGVhZGVycyxcbiAgICAgICAgcmVzdW1lLFxuICAgICAgICBzdGF0dXNNZXNzYWdlXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgZXJyID0gbmV3IFJlcXVlc3RSZXRyeUVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgIH0pXG5cbiAgICB0aGlzLmFib3J0KGVycilcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIHRoaXMuc3RhcnQgKz0gY2h1bmsubGVuZ3RoXG5cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuaylcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHJhd1RyYWlsZXJzKSB7XG4gICAgdGhpcy5yZXRyeUNvdW50ID0gMFxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25Db21wbGV0ZShyYXdUcmFpbGVycylcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGlmICh0aGlzLmFib3J0ZWQgfHwgaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgIH1cblxuICAgIC8vIFdlIHJlY29uY2lsZSBpbiBjYXNlIG9mIGEgbWl4IGJldHdlZW4gbmV0d29yayBlcnJvcnNcbiAgICAvLyBhbmQgc2VydmVyIGVycm9yIHJlc3BvbnNlXG4gICAgaWYgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPiAwKSB7XG4gICAgICAvLyBXZSBjb3VudCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IGNoZWNrcG9pbnQgYW5kIHRoZSBjdXJyZW50IHJldHJ5IGNvdW50XG4gICAgICB0aGlzLnJldHJ5Q291bnQgPVxuICAgICAgICB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ICtcbiAgICAgICAgKHRoaXMucmV0cnlDb3VudCAtIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmV0cnlDb3VudCArPSAxXG4gICAgfVxuXG4gICAgdGhpcy5yZXRyeU9wdHMucmV0cnkoXG4gICAgICBlcnIsXG4gICAgICB7XG4gICAgICAgIHN0YXRlOiB7IGNvdW50ZXI6IHRoaXMucmV0cnlDb3VudCB9LFxuICAgICAgICBvcHRzOiB7IHJldHJ5T3B0aW9uczogdGhpcy5yZXRyeU9wdHMsIC4uLnRoaXMub3B0cyB9XG4gICAgICB9LFxuICAgICAgb25SZXRyeS5iaW5kKHRoaXMpXG4gICAgKVxuXG4gICAgZnVuY3Rpb24gb25SZXRyeSAoZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwgfHwgdGhpcy5hYm9ydGVkIHx8IGlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCAhPT0gMCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyByYW5nZTogYGJ5dGVzPSR7dGhpcy5zdGFydH0tJHt0aGlzLmVuZCA/PyAnJ31gIH1cblxuICAgICAgICAvLyBXZWFrIGV0YWcgY2hlY2sgLSB3ZWFrIGV0YWdzIHdpbGwgbWFrZSBjb21wYXJpc29uIGFsZ29yaXRobXMgbmV2ZXIgbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsKSB7XG4gICAgICAgICAgaGVhZGVyc1snaWYtbWF0Y2gnXSA9IHRoaXMuZXRhZ1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRzID0ge1xuICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdHMuaGVhZGVycyxcbiAgICAgICAgICAgIC4uLmhlYWRlcnNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCA9IHRoaXMucmV0cnlDb3VudFxuICAgICAgICB0aGlzLmRpc3BhdGNoKHRoaXMub3B0cywgdGhpcylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(ssr)/./node_modules/undici/lib/handler/decorator-handler.js\")\n\nclass DumpHandler extends DecoratorHandler {\n  #maxSize = 1024 * 1024\n  #abort = null\n  #dumped = false\n  #aborted = false\n  #size = 0\n  #reason = null\n  #handler = null\n\n  constructor ({ maxSize }, handler) {\n    super(handler)\n\n    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n      throw new InvalidArgumentError('maxSize must be a number greater than 0')\n    }\n\n    this.#maxSize = maxSize ?? this.#maxSize\n    this.#handler = handler\n  }\n\n  onConnect (abort) {\n    this.#abort = abort\n\n    this.#handler.onConnect(this.#customAbort.bind(this))\n  }\n\n  #customAbort (reason) {\n    this.#aborted = true\n    this.#reason = reason\n  }\n\n  // TODO: will require adjustment after new hooks are out\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = util.parseHeaders(rawHeaders)\n    const contentLength = headers['content-length']\n\n    if (contentLength != null && contentLength > this.#maxSize) {\n      throw new RequestAbortedError(\n        `Response size (${contentLength}) larger than maxSize (${\n          this.#maxSize\n        })`\n      )\n    }\n\n    if (this.#aborted) {\n      return true\n    }\n\n    return this.#handler.onHeaders(\n      statusCode,\n      rawHeaders,\n      resume,\n      statusMessage\n    )\n  }\n\n  onError (err) {\n    if (this.#dumped) {\n      return\n    }\n\n    err = this.#reason ?? err\n\n    this.#handler.onError(err)\n  }\n\n  onData (chunk) {\n    this.#size = this.#size + chunk.length\n\n    if (this.#size >= this.#maxSize) {\n      this.#dumped = true\n\n      if (this.#aborted) {\n        this.#handler.onError(this.#reason)\n      } else {\n        this.#handler.onComplete([])\n      }\n    }\n\n    return true\n  }\n\n  onComplete (trailers) {\n    if (this.#dumped) {\n      return\n    }\n\n    if (this.#aborted) {\n      this.#handler.onError(this.reason)\n      return\n    }\n\n    this.#handler.onComplete(trailers)\n  }\n}\n\nfunction createDumpInterceptor (\n  { maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n  }\n) {\n  return dispatch => {\n    return function Intercept (opts, handler) {\n      const { dumpMaxSize = defaultMaxSize } =\n        opts\n\n      const dumpHandler = new DumpHandler(\n        { maxSize: dumpMaxSize },\n        handler\n      )\n\n      return dispatch(opts, dumpHandler)\n    }\n  }\n}\n\nmodule.exports = createDumpInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzlFLHlCQUF5QixtQkFBTyxDQUFDLGtHQUE4Qjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7O0FBRUE7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaW50ZXJjZXB0b3JcXGR1bXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuXG5jbGFzcyBEdW1wSGFuZGxlciBleHRlbmRzIERlY29yYXRvckhhbmRsZXIge1xuICAjbWF4U2l6ZSA9IDEwMjQgKiAxMDI0XG4gICNhYm9ydCA9IG51bGxcbiAgI2R1bXBlZCA9IGZhbHNlXG4gICNhYm9ydGVkID0gZmFsc2VcbiAgI3NpemUgPSAwXG4gICNyZWFzb24gPSBudWxsXG4gICNoYW5kbGVyID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yICh7IG1heFNpemUgfSwgaGFuZGxlcikge1xuICAgIHN1cGVyKGhhbmRsZXIpXG5cbiAgICBpZiAobWF4U2l6ZSAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKG1heFNpemUpIHx8IG1heFNpemUgPCAxKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKVxuICAgIH1cblxuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplID8/IHRoaXMuI21heFNpemVcbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIHRoaXMuI2Fib3J0ID0gYWJvcnRcblxuICAgIHRoaXMuI2hhbmRsZXIub25Db25uZWN0KHRoaXMuI2N1c3RvbUFib3J0LmJpbmQodGhpcykpXG4gIH1cblxuICAjY3VzdG9tQWJvcnQgKHJlYXNvbikge1xuICAgIHRoaXMuI2Fib3J0ZWQgPSB0cnVlXG4gICAgdGhpcy4jcmVhc29uID0gcmVhc29uXG4gIH1cblxuICAvLyBUT0RPOiB3aWxsIHJlcXVpcmUgYWRqdXN0bWVudCBhZnRlciBuZXcgaG9va3MgYXJlIG91dFxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddXG5cbiAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsICYmIGNvbnRlbnRMZW5ndGggPiB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcihcbiAgICAgICAgYFJlc3BvbnNlIHNpemUgKCR7Y29udGVudExlbmd0aH0pIGxhcmdlciB0aGFuIG1heFNpemUgKCR7XG4gICAgICAgICAgdGhpcy4jbWF4U2l6ZVxuICAgICAgICB9KWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgcmF3SGVhZGVycyxcbiAgICAgIHJlc3VtZSxcbiAgICAgIHN0YXR1c01lc3NhZ2VcbiAgICApXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBpZiAodGhpcy4jZHVtcGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBlcnIgPSB0aGlzLiNyZWFzb24gPz8gZXJyXG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IoZXJyKVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIHRoaXMuI3NpemUgPSB0aGlzLiNzaXplICsgY2h1bmsubGVuZ3RoXG5cbiAgICBpZiAodGhpcy4jc2l6ZSA+PSB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aGlzLiNkdW1wZWQgPSB0cnVlXG5cbiAgICAgIGlmICh0aGlzLiNhYm9ydGVkKSB7XG4gICAgICAgIHRoaXMuI2hhbmRsZXIub25FcnJvcih0aGlzLiNyZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGUoW10pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgaWYgKHRoaXMuI2R1bXBlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2Fib3J0ZWQpIHtcbiAgICAgIHRoaXMuI2hhbmRsZXIub25FcnJvcih0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuI2hhbmRsZXIub25Db21wbGV0ZSh0cmFpbGVycylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEdW1wSW50ZXJjZXB0b3IgKFxuICB7IG1heFNpemU6IGRlZmF1bHRNYXhTaXplIH0gPSB7XG4gICAgbWF4U2l6ZTogMTAyNCAqIDEwMjRcbiAgfVxuKSB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBkdW1wTWF4U2l6ZSA9IGRlZmF1bHRNYXhTaXplIH0gPVxuICAgICAgICBvcHRzXG5cbiAgICAgIGNvbnN0IGR1bXBIYW5kbGVyID0gbmV3IER1bXBIYW5kbGVyKFxuICAgICAgICB7IG1heFNpemU6IGR1bXBNYXhTaXplIH0sXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGR1bXBIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUR1bXBJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect-interceptor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections } = opts\n\n      if (!maxRedirections) {\n        return dispatch(opts, handler)\n      }\n\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler)\n      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n      return dispatch(opts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBNkI7O0FBRTdELHNDQUFzQyx5Q0FBeUM7QUFDL0U7QUFDQTtBQUNBLGNBQWMsMkNBQTJDOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxyZWRpcmVjdC1pbnRlcmNlcHRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgUmVkaXJlY3RIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9yZWRpcmVjdC1oYW5kbGVyJylcblxuZnVuY3Rpb24gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciAoeyBtYXhSZWRpcmVjdGlvbnM6IGRlZmF1bHRNYXhSZWRpcmVjdGlvbnMgfSkge1xuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIEludGVyY2VwdCAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0gPSBvcHRzXG5cbiAgICAgIGlmICghbWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICBvcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBTdG9wIHN1YiBkaXNwYXRjaGVyIGZyb20gYWxzbyByZWRpcmVjdGluZy5cbiAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCByZWRpcmVjdEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(ssr)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nmodule.exports = opts => {\n  const globalMaxRedirections = opts?.maxRedirections\n  return dispatch => {\n    return function redirectInterceptor (opts, handler) {\n      const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts\n\n      if (!maxRedirections) {\n        return dispatch(opts, handler)\n      }\n\n      const redirectHandler = new RedirectHandler(\n        dispatch,\n        maxRedirections,\n        opts,\n        handler\n      )\n\n      return dispatch(baseOpts, redirectHandler)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHdCQUF3QixtQkFBTyxDQUFDLGdHQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUF1RDs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxyZWRpcmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gb3B0cyA9PiB7XG4gIGNvbnN0IGdsb2JhbE1heFJlZGlyZWN0aW9ucyA9IG9wdHM/Lm1heFJlZGlyZWN0aW9uc1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiByZWRpcmVjdEludGVyY2VwdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICBjb25zdCB7IG1heFJlZGlyZWN0aW9ucyA9IGdsb2JhbE1heFJlZGlyZWN0aW9ucywgLi4uYmFzZU9wdHMgfSA9IG9wdHNcblxuICAgICAgaWYgKCFtYXhSZWRpcmVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZGlyZWN0SGFuZGxlciA9IG5ldyBSZWRpcmVjdEhhbmRsZXIoXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBtYXhSZWRpcmVjdGlvbnMsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIGhhbmRsZXJcbiAgICAgIClcblxuICAgICAgcmV0dXJuIGRpc3BhdGNoKGJhc2VPcHRzLCByZWRpcmVjdEhhbmRsZXIpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(ssr)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nmodule.exports = globalOpts => {\n  return dispatch => {\n    return function retryInterceptor (opts, handler) {\n      return dispatch(\n        opts,\n        new RetryHandler(\n          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },\n          {\n            handler,\n            dispatch\n          }\n        )\n      )\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUIsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxyZXRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IFJldHJ5SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmV0cnktaGFuZGxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT3B0cyA9PiB7XG4gIHJldHVybiBkaXNwYXRjaCA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJldHJ5SW50ZXJjZXB0b3IgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaChcbiAgICAgICAgb3B0cyxcbiAgICAgICAgbmV3IFJldHJ5SGFuZGxlcihcbiAgICAgICAgICB7IC4uLm9wdHMsIHJldHJ5T3B0aW9uczogeyAuLi5nbG9iYWxPcHRzLCAuLi5vcHRzLnJldHJ5T3B0aW9ucyB9IH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIGRpc3BhdGNoXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function (ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function (TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function (FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function (LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function (METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */\n    METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */\n    METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */\n    METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */\n    METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */\n    METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */\n    METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */\n    METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */\n    METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */\n    METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */\n    METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */\n    METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE,\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST,\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key) => {\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function (FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR\n    .concat(['\\t', '\\f']);\n// All characters with 0x80 bit set to 1\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.STRICT_TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([' ']);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function (HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQy9qQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsWUFBWSxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEMscUJBQXFCLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDLGVBQWUsS0FBSztBQUNyRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRCxhQUFhO0FBQ2IsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGxsaHR0cFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TUEVDSUFMX0hFQURFUlMgPSBleHBvcnRzLkhFQURFUl9TVEFURSA9IGV4cG9ydHMuTUlOT1IgPSBleHBvcnRzLk1BSk9SID0gZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBleHBvcnRzLlRPS0VOID0gZXhwb3J0cy5TVFJJQ1RfVE9LRU4gPSBleHBvcnRzLkhFWCA9IGV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IGV4cG9ydHMuVVNFUklORk9fQ0hBUlMgPSBleHBvcnRzLk1BUksgPSBleHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5OVU0gPSBleHBvcnRzLkhFWF9NQVAgPSBleHBvcnRzLk5VTV9NQVAgPSBleHBvcnRzLkFMUEhBID0gZXhwb3J0cy5GSU5JU0ggPSBleHBvcnRzLkhfTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EX01BUCA9IGV4cG9ydHMuTUVUSE9EU19SVFNQID0gZXhwb3J0cy5NRVRIT0RTX0lDRSA9IGV4cG9ydHMuTUVUSE9EU19IVFRQID0gZXhwb3J0cy5NRVRIT0RTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5GTEFHUyA9IGV4cG9ydHMuVFlQRSA9IGV4cG9ydHMuRVJST1IgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBDIGhlYWRlcnNcbnZhciBFUlJPUjtcbihmdW5jdGlvbiAoRVJST1IpIHtcbiAgICBFUlJPUltFUlJPUltcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlRFUk5BTFwiXSA9IDFdID0gXCJJTlRFUk5BTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiU1RSSUNUXCJdID0gMl0gPSBcIlNUUklDVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiTEZfRVhQRUNURURcIl0gPSAzXSA9IFwiTEZfRVhQRUNURURcIjtcbiAgICBFUlJPUltFUlJPUltcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIl0gPSA0XSA9IFwiVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0xPU0VEX0NPTk5FQ1RJT05cIl0gPSA1XSA9IFwiQ0xPU0VEX0NPTk5FQ1RJT05cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfTUVUSE9EXCJdID0gNl0gPSBcIklOVkFMSURfTUVUSE9EXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1VSTFwiXSA9IDddID0gXCJJTlZBTElEX1VSTFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9DT05TVEFOVFwiXSA9IDhdID0gXCJJTlZBTElEX0NPTlNUQU5UXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1ZFUlNJT05cIl0gPSA5XSA9IFwiSU5WQUxJRF9WRVJTSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0hFQURFUl9UT0tFTlwiXSA9IDEwXSA9IFwiSU5WQUxJRF9IRUFERVJfVE9LRU5cIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIl0gPSAxMV0gPSBcIklOVkFMSURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ0hVTktfU0laRVwiXSA9IDEyXSA9IFwiSU5WQUxJRF9DSFVOS19TSVpFXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX1NUQVRVU1wiXSA9IDEzXSA9IFwiSU5WQUxJRF9TVEFUVVNcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfRU9GX1NUQVRFXCJdID0gMTRdID0gXCJJTlZBTElEX0VPRl9TVEFURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDE1XSA9IFwiSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9CRUdJTlwiXSA9IDE2XSA9IFwiQ0JfTUVTU0FHRV9CRUdJTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfSEVBREVSU19DT01QTEVURVwiXSA9IDE3XSA9IFwiQ0JfSEVBREVSU19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfTUVTU0FHRV9DT01QTEVURVwiXSA9IDE4XSA9IFwiQ0JfTUVTU0FHRV9DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiQ0JfQ0hVTktfSEVBREVSXCJdID0gMTldID0gXCJDQl9DSFVOS19IRUFERVJcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0NPTVBMRVRFXCJdID0gMjBdID0gXCJDQl9DSFVOS19DT01QTEVURVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEXCJdID0gMjFdID0gXCJQQVVTRURcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9VUEdSQURFXCJdID0gMjJdID0gXCJQQVVTRURfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiUEFVU0VEX0gyX1VQR1JBREVcIl0gPSAyM10gPSBcIlBBVVNFRF9IMl9VUEdSQURFXCI7XG4gICAgRVJST1JbRVJST1JbXCJVU0VSXCJdID0gMjRdID0gXCJVU0VSXCI7XG59KShFUlJPUiA9IGV4cG9ydHMuRVJST1IgfHwgKGV4cG9ydHMuRVJST1IgPSB7fSkpO1xudmFyIFRZUEU7XG4oZnVuY3Rpb24gKFRZUEUpIHtcbiAgICBUWVBFW1RZUEVbXCJCT1RIXCJdID0gMF0gPSBcIkJPVEhcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVFVRVNUXCJdID0gMV0gPSBcIlJFUVVFU1RcIjtcbiAgICBUWVBFW1RZUEVbXCJSRVNQT05TRVwiXSA9IDJdID0gXCJSRVNQT05TRVwiO1xufSkoVFlQRSA9IGV4cG9ydHMuVFlQRSB8fCAoZXhwb3J0cy5UWVBFID0ge30pKTtcbnZhciBGTEFHUztcbihmdW5jdGlvbiAoRkxBR1MpIHtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiXSA9IDFdID0gXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSAyXSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gNF0gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ0hVTktFRFwiXSA9IDhdID0gXCJDSFVOS0VEXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJVUEdSQURFXCJdID0gMTZdID0gXCJVUEdSQURFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05URU5UX0xFTkdUSFwiXSA9IDMyXSA9IFwiQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlNLSVBCT0RZXCJdID0gNjRdID0gXCJTS0lQQk9EWVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVFJBSUxJTkdcIl0gPSAxMjhdID0gXCJUUkFJTElOR1wiO1xuICAgIC8vIDEgPDwgOCBpcyB1bnVzZWRcbiAgICBGTEFHU1tGTEFHU1tcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gNTEyXSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdcIjtcbn0pKEZMQUdTID0gZXhwb3J0cy5GTEFHUyB8fCAoZXhwb3J0cy5GTEFHUyA9IHt9KSk7XG52YXIgTEVOSUVOVF9GTEFHUztcbihmdW5jdGlvbiAoTEVOSUVOVF9GTEFHUykge1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkhFQURFUlNcIl0gPSAxXSA9IFwiSEVBREVSU1wiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIkNIVU5LRURfTEVOR1RIXCJdID0gMl0gPSBcIkNIVU5LRURfTEVOR1RIXCI7XG4gICAgTEVOSUVOVF9GTEFHU1tMRU5JRU5UX0ZMQUdTW1wiS0VFUF9BTElWRVwiXSA9IDRdID0gXCJLRUVQX0FMSVZFXCI7XG59KShMRU5JRU5UX0ZMQUdTID0gZXhwb3J0cy5MRU5JRU5UX0ZMQUdTIHx8IChleHBvcnRzLkxFTklFTlRfRkxBR1MgPSB7fSkpO1xudmFyIE1FVEhPRFM7XG4oZnVuY3Rpb24gKE1FVEhPRFMpIHtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJERUxFVEVcIl0gPSAwXSA9IFwiREVMRVRFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiR0VUXCJdID0gMV0gPSBcIkdFVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkhFQURcIl0gPSAyXSA9IFwiSEVBRFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBPU1RcIl0gPSAzXSA9IFwiUE9TVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBVVFwiXSA9IDRdID0gXCJQVVRcIjtcbiAgICAvKiBwYXRob2xvZ2ljYWwgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT05ORUNUXCJdID0gNV0gPSBcIkNPTk5FQ1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJPUFRJT05TXCJdID0gNl0gPSBcIk9QVElPTlNcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJUUkFDRVwiXSA9IDddID0gXCJUUkFDRVwiO1xuICAgIC8qIFdlYkRBViAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNPUFlcIl0gPSA4XSA9IFwiQ09QWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkxPQ0tcIl0gPSA5XSA9IFwiTE9DS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQ09MXCJdID0gMTBdID0gXCJNS0NPTFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1PVkVcIl0gPSAxMV0gPSBcIk1PVkVcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QRklORFwiXSA9IDEyXSA9IFwiUFJPUEZJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQUk9QUEFUQ0hcIl0gPSAxM10gPSBcIlBST1BQQVRDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFQVJDSFwiXSA9IDE0XSA9IFwiU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MT0NLXCJdID0gMTVdID0gXCJVTkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJCSU5EXCJdID0gMTZdID0gXCJCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVCSU5EXCJdID0gMTddID0gXCJSRUJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJVTkJJTkRcIl0gPSAxOF0gPSBcIlVOQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFDTFwiXSA9IDE5XSA9IFwiQUNMXCI7XG4gICAgLyogc3VidmVyc2lvbiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFUE9SVFwiXSA9IDIwXSA9IFwiUkVQT1JUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtBQ1RJVklUWVwiXSA9IDIxXSA9IFwiTUtBQ1RJVklUWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkNIRUNLT1VUXCJdID0gMjJdID0gXCJDSEVDS09VVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1FUkdFXCJdID0gMjNdID0gXCJNRVJHRVwiO1xuICAgIC8qIHVwbnAgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNLVNFQVJDSFwiXSA9IDI0XSA9IFwiTS1TRUFSQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJOT1RJRllcIl0gPSAyNV0gPSBcIk5PVElGWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNVQlNDUklCRVwiXSA9IDI2XSA9IFwiU1VCU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5TVUJTQ1JJQkVcIl0gPSAyN10gPSBcIlVOU1VCU0NSSUJFXCI7XG4gICAgLyogUkZDLTU3ODkgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVRDSFwiXSA9IDI4XSA9IFwiUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVJHRVwiXSA9IDI5XSA9IFwiUFVSR0VcIjtcbiAgICAvKiBDYWxEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NBTEVOREFSXCJdID0gMzBdID0gXCJNS0NBTEVOREFSXCI7XG4gICAgLyogUkZDLTIwNjgsIHNlY3Rpb24gMTkuNi4xLjIgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMSU5LXCJdID0gMzFdID0gXCJMSU5LXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5MSU5LXCJdID0gMzJdID0gXCJVTkxJTktcIjtcbiAgICAvKiBpY2VjYXN0ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU09VUkNFXCJdID0gMzNdID0gXCJTT1VSQ0VcIjtcbiAgICAvKiBSRkMtNzU0MCwgc2VjdGlvbiAxMS42ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJJXCJdID0gMzRdID0gXCJQUklcIjtcbiAgICAvKiBSRkMtMjMyNiBSVFNQICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVTQ1JJQkVcIl0gPSAzNV0gPSBcIkRFU0NSSUJFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQU5OT1VOQ0VcIl0gPSAzNl0gPSBcIkFOTk9VTkNFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUVVBcIl0gPSAzN10gPSBcIlNFVFVQXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUExBWVwiXSA9IDM4XSA9IFwiUExBWVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBBVVNFXCJdID0gMzldID0gXCJQQVVTRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlRFQVJET1dOXCJdID0gNDBdID0gXCJURUFSRE9XTlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVF9QQVJBTUVURVJcIl0gPSA0MV0gPSBcIkdFVF9QQVJBTUVURVJcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRVRfUEFSQU1FVEVSXCJdID0gNDJdID0gXCJTRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVESVJFQ1RcIl0gPSA0M10gPSBcIlJFRElSRUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUkVDT1JEXCJdID0gNDRdID0gXCJSRUNPUkRcIjtcbiAgICAvKiBSQU9QICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiRkxVU0hcIl0gPSA0NV0gPSBcIkZMVVNIXCI7XG59KShNRVRIT0RTID0gZXhwb3J0cy5NRVRIT0RTIHx8IChleHBvcnRzLk1FVEhPRFMgPSB7fSkpO1xuZXhwb3J0cy5NRVRIT0RTX0hUVFAgPSBbXG4gICAgTUVUSE9EUy5ERUxFVEUsXG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5IRUFELFxuICAgIE1FVEhPRFMuUE9TVCxcbiAgICBNRVRIT0RTLlBVVCxcbiAgICBNRVRIT0RTLkNPTk5FQ1QsXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuVFJBQ0UsXG4gICAgTUVUSE9EUy5DT1BZLFxuICAgIE1FVEhPRFMuTE9DSyxcbiAgICBNRVRIT0RTLk1LQ09MLFxuICAgIE1FVEhPRFMuTU9WRSxcbiAgICBNRVRIT0RTLlBST1BGSU5ELFxuICAgIE1FVEhPRFMuUFJPUFBBVENILFxuICAgIE1FVEhPRFMuU0VBUkNILFxuICAgIE1FVEhPRFMuVU5MT0NLLFxuICAgIE1FVEhPRFMuQklORCxcbiAgICBNRVRIT0RTLlJFQklORCxcbiAgICBNRVRIT0RTLlVOQklORCxcbiAgICBNRVRIT0RTLkFDTCxcbiAgICBNRVRIT0RTLlJFUE9SVCxcbiAgICBNRVRIT0RTLk1LQUNUSVZJVFksXG4gICAgTUVUSE9EUy5DSEVDS09VVCxcbiAgICBNRVRIT0RTLk1FUkdFLFxuICAgIE1FVEhPRFNbJ00tU0VBUkNIJ10sXG4gICAgTUVUSE9EUy5OT1RJRlksXG4gICAgTUVUSE9EUy5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5VTlNVQlNDUklCRSxcbiAgICBNRVRIT0RTLlBBVENILFxuICAgIE1FVEhPRFMuUFVSR0UsXG4gICAgTUVUSE9EUy5NS0NBTEVOREFSLFxuICAgIE1FVEhPRFMuTElOSyxcbiAgICBNRVRIT0RTLlVOTElOSyxcbiAgICBNRVRIT0RTLlBSSSxcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBzaG91bGQgd2UgYWxsb3cgaXQgd2l0aCBIVFRQP1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19JQ0UgPSBbXG4gICAgTUVUSE9EUy5TT1VSQ0UsXG5dO1xuZXhwb3J0cy5NRVRIT0RTX1JUU1AgPSBbXG4gICAgTUVUSE9EUy5PUFRJT05TLFxuICAgIE1FVEhPRFMuREVTQ1JJQkUsXG4gICAgTUVUSE9EUy5BTk5PVU5DRSxcbiAgICBNRVRIT0RTLlNFVFVQLFxuICAgIE1FVEhPRFMuUExBWSxcbiAgICBNRVRIT0RTLlBBVVNFLFxuICAgIE1FVEhPRFMuVEVBUkRPV04sXG4gICAgTUVUSE9EUy5HRVRfUEFSQU1FVEVSLFxuICAgIE1FVEhPRFMuU0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlJFRElSRUNULFxuICAgIE1FVEhPRFMuUkVDT1JELFxuICAgIE1FVEhPRFMuRkxVU0gsXG4gICAgLy8gRm9yIEFpclBsYXlcbiAgICBNRVRIT0RTLkdFVCxcbiAgICBNRVRIT0RTLlBPU1QsXG5dO1xuZXhwb3J0cy5NRVRIT0RfTUFQID0gdXRpbHNfMS5lbnVtVG9NYXAoTUVUSE9EUyk7XG5leHBvcnRzLkhfTUVUSE9EX01BUCA9IHt9O1xuT2JqZWN0LmtleXMoZXhwb3J0cy5NRVRIT0RfTUFQKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoL15ILy50ZXN0KGtleSkpIHtcbiAgICAgICAgZXhwb3J0cy5IX01FVEhPRF9NQVBba2V5XSA9IGV4cG9ydHMuTUVUSE9EX01BUFtrZXldO1xuICAgIH1cbn0pO1xudmFyIEZJTklTSDtcbihmdW5jdGlvbiAoRklOSVNIKSB7XG4gICAgRklOSVNIW0ZJTklTSFtcIlNBRkVcIl0gPSAwXSA9IFwiU0FGRVwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFX1dJVEhfQ0JcIl0gPSAxXSA9IFwiU0FGRV9XSVRIX0NCXCI7XG4gICAgRklOSVNIW0ZJTklTSFtcIlVOU0FGRVwiXSA9IDJdID0gXCJVTlNBRkVcIjtcbn0pKEZJTklTSCA9IGV4cG9ydHMuRklOSVNIIHx8IChleHBvcnRzLkZJTklTSCA9IHt9KSk7XG5leHBvcnRzLkFMUEhBID0gW107XG5mb3IgKGxldCBpID0gJ0EnLmNoYXJDb2RlQXQoMCk7IGkgPD0gJ1onLmNoYXJDb2RlQXQoMCk7IGkrKykge1xuICAgIC8vIFVwcGVyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSk7XG4gICAgLy8gTG93ZXIgY2FzZVxuICAgIGV4cG9ydHMuQUxQSEEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAweDIwKSk7XG59XG5leHBvcnRzLk5VTV9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxufTtcbmV4cG9ydHMuSEVYX01BUCA9IHtcbiAgICAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LFxuICAgIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksXG4gICAgQTogMFhBLCBCOiAwWEIsIEM6IDBYQywgRDogMFhELCBFOiAwWEUsIEY6IDBYRixcbiAgICBhOiAweGEsIGI6IDB4YiwgYzogMHhjLCBkOiAweGQsIGU6IDB4ZSwgZjogMHhmLFxufTtcbmV4cG9ydHMuTlVNID0gW1xuICAgICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5Jyxcbl07XG5leHBvcnRzLkFMUEhBTlVNID0gZXhwb3J0cy5BTFBIQS5jb25jYXQoZXhwb3J0cy5OVU0pO1xuZXhwb3J0cy5NQVJLID0gWyctJywgJ18nLCAnLicsICchJywgJ34nLCAnKicsICdcXCcnLCAnKCcsICcpJ107XG5leHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5BTFBIQU5VTVxuICAgIC5jb25jYXQoZXhwb3J0cy5NQVJLKVxuICAgIC5jb25jYXQoWyclJywgJzsnLCAnOicsICcmJywgJz0nLCAnKycsICckJywgJywnXSk7XG4vLyBUT0RPKGluZHV0bnkpOiB1c2UgUkZDXG5leHBvcnRzLlNUUklDVF9VUkxfQ0hBUiA9IFtcbiAgICAnIScsICdcIicsICckJywgJyUnLCAnJicsICdcXCcnLFxuICAgICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLFxuICAgICc6JywgJzsnLCAnPCcsICc9JywgJz4nLFxuICAgICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXycsXG4gICAgJ2AnLFxuICAgICd7JywgJ3wnLCAnfScsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5VUkxfQ0hBUiA9IGV4cG9ydHMuU1RSSUNUX1VSTF9DSEFSXG4gICAgLmNvbmNhdChbJ1xcdCcsICdcXGYnXSk7XG4vLyBBbGwgY2hhcmFjdGVycyB3aXRoIDB4ODAgYml0IHNldCB0byAxXG5mb3IgKGxldCBpID0gMHg4MDsgaSA8PSAweGZmOyBpKyspIHtcbiAgICBleHBvcnRzLlVSTF9DSEFSLnB1c2goaSk7XG59XG5leHBvcnRzLkhFWCA9IGV4cG9ydHMuTlVNLmNvbmNhdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJ10pO1xuLyogVG9rZW5zIGFzIGRlZmluZWQgYnkgcmZjIDI2MTYuIEFsc28gbG93ZXJjYXNlcyB0aGVtLlxuICogICAgICAgIHRva2VuICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiAqICAgICBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAqICAgICAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKi9cbmV4cG9ydHMuU1RSSUNUX1RPS0VOID0gW1xuICAgICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKicsICcrJywgJy0nLCAnLicsXG4gICAgJ14nLCAnXycsICdgJyxcbiAgICAnfCcsICd+Jyxcbl0uY29uY2F0KGV4cG9ydHMuQUxQSEFOVU0pO1xuZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOLmNvbmNhdChbJyAnXSk7XG4vKlxuICogVmVyaWZ5IHRoYXQgYSBjaGFyIGlzIGEgdmFsaWQgdmlzaWJsZSAocHJpbnRhYmxlKSBVUy1BU0NJSVxuICogY2hhcmFjdGVyIG9yICV4ODAtRkZcbiAqL1xuZXhwb3J0cy5IRUFERVJfQ0hBUlMgPSBbJ1xcdCddO1xuZm9yIChsZXQgaSA9IDMyOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDEyNykge1xuICAgICAgICBleHBvcnRzLkhFQURFUl9DSEFSUy5wdXNoKGkpO1xuICAgIH1cbn1cbi8vICcsJyA9IFxceDQ0XG5leHBvcnRzLkNPTk5FQ1RJT05fVE9LRU5fQ0hBUlMgPSBleHBvcnRzLkhFQURFUl9DSEFSUy5maWx0ZXIoKGMpID0+IGMgIT09IDQ0KTtcbmV4cG9ydHMuTUFKT1IgPSBleHBvcnRzLk5VTV9NQVA7XG5leHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUjtcbnZhciBIRUFERVJfU1RBVEU7XG4oZnVuY3Rpb24gKEhFQURFUl9TVEFURSkge1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJHRU5FUkFMXCJdID0gMF0gPSBcIkdFTkVSQUxcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTlwiXSA9IDFdID0gXCJDT05ORUNUSU9OXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTlRFTlRfTEVOR1RIXCJdID0gMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HXCJdID0gM10gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlVQR1JBREVcIl0gPSA0XSA9IFwiVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSA1XSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05fQ0xPU0VcIl0gPSA2XSA9IFwiQ09OTkVDVElPTl9DTE9TRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX1VQR1JBREVcIl0gPSA3XSA9IFwiQ09OTkVDVElPTl9VUEdSQURFXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIl0gPSA4XSA9IFwiVFJBTlNGRVJfRU5DT0RJTkdfQ0hVTktFRFwiO1xufSkoSEVBREVSX1NUQVRFID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgfHwgKGV4cG9ydHMuSEVBREVSX1NUQVRFID0ge30pKTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0ge1xuICAgICdjb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ2NvbnRlbnQtbGVuZ3RoJzogSEVBREVSX1NUQVRFLkNPTlRFTlRfTEVOR1RILFxuICAgICdwcm94eS1jb25uZWN0aW9uJzogSEVBREVSX1NUQVRFLkNPTk5FQ1RJT04sXG4gICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogSEVBREVSX1NUQVRFLlRSQU5TRkVSX0VOQ09ESU5HLFxuICAgICd1cGdyYWRlJzogSEVBREVSX1NUQVRFLlVQR1JBREUsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIdbGxodHRwX3NldF9sZW5pZW50X2tlZXBfYWxpdmUAIyRsbGh0dHBfc2V0X2xlbmllbnRfdHJhbnNmZXJfZW5jb2RpbmcAJBhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YALgkXAQBBAQsRAQIDBAUKBgcrLSwqKSglJyYK07MCLBYAQYjQACgCAARAAAtBiNAAQQE2AgALFAAgABAwIAAgAjYCOCAAIAE6ACgLFAAgACAALwEyIAAtAC4gABAvEAALHgEBf0HAABAyIgEQMCABQYAINgI4IAEgADoAKCABC48MAQd/AkAgAEUNACAAQQhrIgEgAEEEaygCACIAQXhxIgRqIQUCQCAAQQFxDQAgAEEDcUUNASABIAEoAgAiAGsiAUGc0AAoAgBJDQEgACAEaiEEAkACQEGg0AAoAgAgAUcEQCAAQf8BTQRAIABBA3YhAyABKAIIIgAgASgCDCICRgRAQYzQAEGM0AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyABKAIYIQYgASABKAIMIgBHBEAgACABKAIIIgI2AgggAiAANgIMDAMLIAFBFGoiAygCACICRQRAIAEoAhAiAkUNAiABQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFKAIEIgBBA3FBA0cNAiAFIABBfnE2AgRBlNAAIAQ2AgAgBSAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCABKAIcIgJBAnRBvNIAaiIDKAIAIAFGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgAUYbaiAANgIAIABFDQELIAAgBjYCGCABKAIQIgIEQCAAIAI2AhAgAiAANgIYCyABQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAFTw0AIAUoAgQiAEEBcUUNAAJAAkACQAJAIABBAnFFBEBBpNAAKAIAIAVGBEBBpNAAIAE2AgBBmNAAQZjQACgCACAEaiIANgIAIAEgAEEBcjYCBCABQaDQACgCAEcNBkGU0ABBADYCAEGg0ABBADYCAAwGC0Gg0AAoAgAgBUYEQEGg0AAgATYCAEGU0ABBlNAAKAIAIARqIgA2AgAgASAAQQFyNgIEIAAgAWogADYCAAwGCyAAQXhxIARqIQQgAEH/AU0EQCAAQQN2IQMgBSgCCCIAIAUoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgBSgCGCEGIAUgBSgCDCIARwRAQZzQACgCABogACAFKAIIIgI2AgggAiAANgIMDAMLIAVBFGoiAygCACICRQRAIAUoAhAiAkUNAiAFQRBqIQMLA0AgAyEHIAIiAEEUaiIDKAIAIgINACAAQRBqIQMgACgCECICDQALIAdBADYCAAwCCyAFIABBfnE2AgQgASAEaiAENgIAIAEgBEEBcjYCBAwDC0EAIQALIAZFDQACQCAFKAIcIgJBAnRBvNIAaiIDKAIAIAVGBEAgAyAANgIAIAANAUGQ0ABBkNAAKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiAANgIAIABFDQELIAAgBjYCGCAFKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAFQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAEaiAENgIAIAEgBEEBcjYCBCABQaDQACgCAEcNAEGU0AAgBDYCAAwBCyAEQf8BTQRAIARBeHFBtNAAaiEAAn9BjNAAKAIAIgJBASAEQQN2dCIDcUUEQEGM0AAgAiADcjYCACAADAELIAAoAggLIgIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCAwBC0EfIQIgBEH///8HTQRAIARBJiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAgsgASACNgIcIAFCADcCECACQQJ0QbzSAGohAAJAQZDQACgCACIDQQEgAnQiB3FFBEAgACABNgIAQZDQACADIAdyNgIAIAEgADYCGCABIAE2AgggASABNgIMDAELIARBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAAJAA0AgACIDKAIEQXhxIARGDQEgAkEddiEAIAJBAXQhAiADIABBBHFqQRBqIgcoAgAiAA0ACyAHIAE2AgAgASADNgIYIAEgATYCDCABIAE2AggMAQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0Gs0ABBrNAAKAIAQQFrIgBBfyAAGzYCAAsLBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LQAEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABAwIAAgBDYCOCAAIAM6ACggACACOgAtIAAgATYCGAu74gECB38DfiABIAJqIQQCQCAAIgIoAgwiAA0AIAIoAgQEQCACIAE2AgQLIwBBEGsiCCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIoAhwiA0EBaw7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBywHKAbgByQG5AcgBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgEA3AELQQAMxgELQQ4MxQELQQ0MxAELQQ8MwwELQRAMwgELQRMMwQELQRQMwAELQRUMvwELQRYMvgELQRgMvQELQRkMvAELQRoMuwELQRsMugELQRwMuQELQR0MuAELQQgMtwELQR4MtgELQSAMtQELQR8MtAELQQcMswELQSEMsgELQSIMsQELQSMMsAELQSQMrwELQRIMrgELQREMrQELQSUMrAELQSYMqwELQScMqgELQSgMqQELQcMBDKgBC0EqDKcBC0ErDKYBC0EsDKUBC0EtDKQBC0EuDKMBC0EvDKIBC0HEAQyhAQtBMAygAQtBNAyfAQtBDAyeAQtBMQydAQtBMgycAQtBMwybAQtBOQyaAQtBNQyZAQtBxQEMmAELQQsMlwELQToMlgELQTYMlQELQQoMlAELQTcMkwELQTgMkgELQTwMkQELQTsMkAELQT0MjwELQQkMjgELQSkMjQELQT4MjAELQT8MiwELQcAADIoBC0HBAAyJAQtBwgAMiAELQcMADIcBC0HEAAyGAQtBxQAMhQELQcYADIQBC0EXDIMBC0HHAAyCAQtByAAMgQELQckADIABC0HKAAx/C0HLAAx+C0HNAAx9C0HMAAx8C0HOAAx7C0HPAAx6C0HQAAx5C0HRAAx4C0HSAAx3C0HTAAx2C0HUAAx1C0HWAAx0C0HVAAxzC0EGDHILQdcADHELQQUMcAtB2AAMbwtBBAxuC0HZAAxtC0HaAAxsC0HbAAxrC0HcAAxqC0EDDGkLQd0ADGgLQd4ADGcLQd8ADGYLQeEADGULQeAADGQLQeIADGMLQeMADGILQQIMYQtB5AAMYAtB5QAMXwtB5gAMXgtB5wAMXQtB6AAMXAtB6QAMWwtB6gAMWgtB6wAMWQtB7AAMWAtB7QAMVwtB7gAMVgtB7wAMVQtB8AAMVAtB8QAMUwtB8gAMUgtB8wAMUQtB9AAMUAtB9QAMTwtB9gAMTgtB9wAMTQtB+AAMTAtB+QAMSwtB+gAMSgtB+wAMSQtB/AAMSAtB/QAMRwtB/gAMRgtB/wAMRQtBgAEMRAtBgQEMQwtBggEMQgtBgwEMQQtBhAEMQAtBhQEMPwtBhgEMPgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv', 'base64')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGxsaHR0cC13YXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlci5mcm9tKCdBR0Z6YlFFQUFBQUJKd2RnQVg4QmYyQURmMzkvQVg5Z0FYOEFZQUovZndCZ0JIOS9mMzhCZjJBQUFHQURmMzkvQUFMTEFRZ0RaVzUyR0hkaGMyMWZiMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUFFQTJWdWRoVjNZWE50WDI5dVgyMWxjM05oWjJWZlltVm5hVzRBQUFObGJuWUxkMkZ6YlY5dmJsOTFjbXdBQVFObGJuWU9kMkZ6YlY5dmJsOXpkR0YwZFhNQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZabWxsYkdRQUFRTmxibllVZDJGemJWOXZibDlvWldGa1pYSmZkbUZzZFdVQUFRTmxibllNZDJGemJWOXZibDlpYjJSNUFBRURaVzUyR0hkaGMyMWZiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaUUFBQXkwc0JRWUFBQUlBQUFBQUFBQUNBUUlBQWdJQ0FBQURBQUFBQUFNREF3TUJBUUVCQVFFQkFRRUFBQUlBQUFBRUJRRndBUklTQlFNQkFBSUdDQUYvQVVHQTFBUUxCOUVGSWdadFpXMXZjbmtDQUF0ZmFXNXBkR2xoYkdsNlpRQUlHVjlmYVc1a2FYSmxZM1JmWm5WdVkzUnBiMjVmZEdGaWJHVUJBQXRzYkdoMGRIQmZhVzVwZEFBSkdHeHNhSFIwY0Y5emFHOTFiR1JmYTJWbGNGOWhiR2wyWlFBdkRHeHNhSFIwY0Y5aGJHeHZZd0FMQm0xaGJHeHZZd0F4QzJ4c2FIUjBjRjltY21WbEFBd0VabkpsWlFBTUQyeHNhSFIwY0Y5blpYUmZkSGx3WlFBTkZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dFlXcHZjZ0FPRld4c2FIUjBjRjluWlhSZmFIUjBjRjl0YVc1dmNnQVBFV3hzYUhSMGNGOW5aWFJmYldWMGFHOWtBQkFXYkd4b2RIUndYMmRsZEY5emRHRjBkWE5mWTI5a1pRQVJFbXhzYUhSMGNGOW5aWFJmZFhCbmNtRmtaUUFTREd4c2FIUjBjRjl5WlhObGRBQVREbXhzYUhSMGNGOWxlR1ZqZFhSbEFCUVViR3hvZEhSd1gzTmxkSFJwYm1kelgybHVhWFFBRlExc2JHaDBkSEJmWm1sdWFYTm9BQllNYkd4b2RIUndYM0JoZFhObEFCY05iR3hvZEhSd1gzSmxjM1Z0WlFBWUcyeHNhSFIwY0Y5eVpYTjFiV1ZmWVdaMFpYSmZkWEJuY21Ga1pRQVpFR3hzYUhSMGNGOW5aWFJmWlhKeWJtOEFHaGRzYkdoMGRIQmZaMlYwWDJWeWNtOXlYM0psWVhOdmJnQWJGMnhzYUhSMGNGOXpaWFJmWlhKeWIzSmZjbVZoYzI5dUFCd1ViR3hvZEhSd1gyZGxkRjlsY25KdmNsOXdiM01BSFJGc2JHaDBkSEJmWlhKeWJtOWZibUZ0WlFBZUVteHNhSFIwY0Y5dFpYUm9iMlJmYm1GdFpRQWZFbXhzYUhSMGNGOXpkR0YwZFhOZmJtRnRaUUFnR214c2FIUjBjRjl6WlhSZmJHVnVhV1Z1ZEY5b1pXRmtaWEp6QUNFaGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgyTm9kVzVyWldSZmJHVnVaM1JvQUNJZGJHeG9kSFJ3WDNObGRGOXNaVzVwWlc1MFgydGxaWEJmWVd4cGRtVUFJeVJzYkdoMGRIQmZjMlYwWDJ4bGJtbGxiblJmZEhKaGJuTm1aWEpmWlc1amIyUnBibWNBSkJoc2JHaDBkSEJmYldWemMyRm5aVjl1WldWa2MxOWxiMllBTGdrWEFRQkJBUXNSQVFJREJBVUtCZ2NyTFN3cUtTZ2xKeVlLMDdNQ0xCWUFRWWpRQUNnQ0FBUkFBQXRCaU5BQVFRRTJBZ0FMRkFBZ0FCQXdJQUFnQWpZQ09DQUFJQUU2QUNnTEZBQWdBQ0FBTHdFeUlBQXRBQzRnQUJBdkVBQUxIZ0VCZjBIQUFCQXlJZ0VRTUNBQlFZQUlOZ0k0SUFFZ0FEb0FLQ0FCQzQ4TUFRZC9Ba0FnQUVVTkFDQUFRUWhySWdFZ0FFRUVheWdDQUNJQVFYaHhJZ1JxSVFVQ1FDQUFRUUZ4RFFBZ0FFRURjVVVOQVNBQklBRW9BZ0FpQUdzaUFVR2MwQUFvQWdCSkRRRWdBQ0FFYWlFRUFrQUNRRUdnMEFBb0FnQWdBVWNFUUNBQVFmOEJUUVJBSUFCQkEzWWhBeUFCS0FJSUlnQWdBU2dDRENJQ1JnUkFRWXpRQUVHTTBBQW9BZ0JCZmlBRGQzRTJBZ0FNQlFzZ0FpQUFOZ0lJSUFBZ0FqWUNEQXdFQ3lBQktBSVlJUVlnQVNBQktBSU1JZ0JIQkVBZ0FDQUJLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQUZCRkdvaUF5Z0NBQ0lDUlFSQUlBRW9BaEFpQWtVTkFpQUJRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGS0FJRUlnQkJBM0ZCQTBjTkFpQUZJQUJCZm5FMkFnUkJsTkFBSUFRMkFnQWdCU0FFTmdJQUlBRWdCRUVCY2pZQ0JBd0RDMEVBSVFBTElBWkZEUUFDUUNBQktBSWNJZ0pCQW5SQnZOSUFhaUlES0FJQUlBRkdCRUFnQXlBQU5nSUFJQUFOQVVHUTBBQkJrTkFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQVpCRUVFVUlBWW9BaEFnQVVZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQmpZQ0dDQUJLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBQlFSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FGVHcwQUlBVW9BZ1FpQUVFQmNVVU5BQUpBQWtBQ1FBSkFJQUJCQW5GRkJFQkJwTkFBS0FJQUlBVkdCRUJCcE5BQUlBRTJBZ0JCbU5BQVFaalFBQ2dDQUNBRWFpSUFOZ0lBSUFFZ0FFRUJjallDQkNBQlFhRFFBQ2dDQUVjTkJrR1UwQUJCQURZQ0FFR2cwQUJCQURZQ0FBd0dDMEdnMEFBb0FnQWdCVVlFUUVHZzBBQWdBVFlDQUVHVTBBQkJsTkFBS0FJQUlBUnFJZ0EyQWdBZ0FTQUFRUUZ5TmdJRUlBQWdBV29nQURZQ0FBd0dDeUFBUVhoeElBUnFJUVFnQUVIL0FVMEVRQ0FBUVFOMklRTWdCU2dDQ0NJQUlBVW9BZ3dpQWtZRVFFR00wQUJCak5BQUtBSUFRWDRnQTNkeE5nSUFEQVVMSUFJZ0FEWUNDQ0FBSUFJMkFnd01CQXNnQlNnQ0dDRUdJQVVnQlNnQ0RDSUFSd1JBUVp6UUFDZ0NBQm9nQUNBRktBSUlJZ0kyQWdnZ0FpQUFOZ0lNREFNTElBVkJGR29pQXlnQ0FDSUNSUVJBSUFVb0FoQWlBa1VOQWlBRlFSQnFJUU1MQTBBZ0F5RUhJQUlpQUVFVWFpSURLQUlBSWdJTkFDQUFRUkJxSVFNZ0FDZ0NFQ0lDRFFBTElBZEJBRFlDQUF3Q0N5QUZJQUJCZm5FMkFnUWdBU0FFYWlBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUZLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQVZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FGS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUZRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkNBQlFhRFFBQ2dDQUVjTkFFR1UwQUFnQkRZQ0FBd0JDeUFFUWY4QlRRUkFJQVJCZUhGQnROQUFhaUVBQW45QmpOQUFLQUlBSWdKQkFTQUVRUU4yZENJRGNVVUVRRUdNMEFBZ0FpQURjallDQUNBQURBRUxJQUFvQWdnTElnSWdBVFlDRENBQUlBRTJBZ2dnQVNBQU5nSU1JQUVnQWpZQ0NBd0JDMEVmSVFJZ0JFSC8vLzhIVFFSQUlBUkJKaUFFUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEFnc2dBU0FDTmdJY0lBRkNBRGNDRUNBQ1FRSjBRYnpTQUdvaEFBSkFRWkRRQUNnQ0FDSURRUUVnQW5RaUIzRkZCRUFnQUNBQk5nSUFRWkRRQUNBRElBZHlOZ0lBSUFFZ0FEWUNHQ0FCSUFFMkFnZ2dBU0FCTmdJTURBRUxJQVJCR1NBQ1FRRjJhMEVBSUFKQkgwY2JkQ0VDSUFBb0FnQWhBQUpBQTBBZ0FDSURLQUlFUVhoeElBUkdEUUVnQWtFZGRpRUFJQUpCQVhRaEFpQURJQUJCQkhGcVFSQnFJZ2NvQWdBaUFBMEFDeUFISUFFMkFnQWdBU0FETmdJWUlBRWdBVFlDRENBQklBRTJBZ2dNQVFzZ0F5Z0NDQ0lBSUFFMkFnd2dBeUFCTmdJSUlBRkJBRFlDR0NBQklBTTJBZ3dnQVNBQU5nSUlDMEdzMEFCQnJOQUFLQUlBUVFGcklnQkJmeUFBR3pZQ0FBc0xCd0FnQUMwQUtBc0hBQ0FBTFFBcUN3Y0FJQUF0QUNzTEJ3QWdBQzBBS1FzSEFDQUFMd0V5Q3djQUlBQXRBQzRMUUFFRWZ5QUFLQUlZSVFFZ0FDMEFMU0VDSUFBdEFDZ2hBeUFBS0FJNElRUWdBQkF3SUFBZ0JEWUNPQ0FBSUFNNkFDZ2dBQ0FDT2dBdElBQWdBVFlDR0F1NzRnRUNCMzhEZmlBQklBSnFJUVFDUUNBQUlnSW9BZ3dpQUEwQUlBSW9BZ1FFUUNBQ0lBRTJBZ1FMSXdCQkVHc2lDQ1FBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFJb0Fod2lBMEVCYXc3ZEFkb0JBZGtCQWdNRUJRWUhDQWtLQ3d3TkR0Z0JEeERYQVJFUzFnRVRGQlVXRnhnWkdodmdBZDhCSEIwZTFRRWZJQ0VpSXlRbDFBRW1KeWdwS2lzczB3SFNBUzB1MFFIUUFTOHdNVEl6TkRVMk56ZzVPanM4UFQ0L1FFRkNRMFJGUnRzQlIwaEpTczhCemdGTHpRRk16QUZOVGs5UVVWSlRWRlZXVjFoWldsdGNYVjVmWUdGaVkyUmxabWRvYVdwcmJHMXViM0J4Y25OMGRYWjNlSGw2ZTN4OWZuK0FBWUVCZ2dHREFZUUJoUUdHQVljQmlBR0pBWW9CaXdHTUFZMEJqZ0dQQVpBQmtRR1NBWk1CbEFHVkFaWUJsd0dZQVprQm1nR2JBWndCblFHZUFaOEJvQUdoQWFJQm93R2tBYVVCcGdHbkFhZ0JxUUdxQWFzQnJBR3RBYTRCcndHd0FiRUJzZ0d6QWJRQnRRRzJBYmNCeXdIS0FiZ0J5UUc1QWNnQnVnRzdBYndCdlFHK0FiOEJ3QUhCQWNJQnd3SEVBY1VCeGdFQTNBRUxRUUFNeGdFTFFRNE14UUVMUVEwTXhBRUxRUThNd3dFTFFSQU13Z0VMUVJNTXdRRUxRUlFNd0FFTFFSVU12d0VMUVJZTXZnRUxRUmdNdlFFTFFSa012QUVMUVJvTXV3RUxRUnNNdWdFTFFSd011UUVMUVIwTXVBRUxRUWdNdHdFTFFSNE10Z0VMUVNBTXRRRUxRUjhNdEFFTFFRY01zd0VMUVNFTXNnRUxRU0lNc1FFTFFTTU1zQUVMUVNRTXJ3RUxRUklNcmdFTFFSRU1yUUVMUVNVTXJBRUxRU1lNcXdFTFFTY01xZ0VMUVNnTXFRRUxRY01CREtnQkMwRXFES2NCQzBFckRLWUJDMEVzREtVQkMwRXRES1FCQzBFdURLTUJDMEV2REtJQkMwSEVBUXloQVF0Qk1BeWdBUXRCTkF5ZkFRdEJEQXllQVF0Qk1ReWRBUXRCTWd5Y0FRdEJNd3liQVF0Qk9ReWFBUXRCTlF5WkFRdEJ4UUVNbUFFTFFRc01sd0VMUVRvTWxnRUxRVFlNbFFFTFFRb01sQUVMUVRjTWt3RUxRVGdNa2dFTFFUd01rUUVMUVRzTWtBRUxRVDBNandFTFFRa01qZ0VMUVNrTWpRRUxRVDRNakFFTFFUOE1pd0VMUWNBQURJb0JDMEhCQUF5SkFRdEJ3Z0FNaUFFTFFjTUFESWNCQzBIRUFBeUdBUXRCeFFBTWhRRUxRY1lBRElRQkMwRVhESU1CQzBISEFBeUNBUXRCeUFBTWdRRUxRY2tBRElBQkMwSEtBQXgvQzBITEFBeCtDMEhOQUF4OUMwSE1BQXg4QzBIT0FBeDdDMEhQQUF4NkMwSFFBQXg1QzBIUkFBeDRDMEhTQUF4M0MwSFRBQXgyQzBIVUFBeDFDMEhXQUF4MEMwSFZBQXh6QzBFR0RISUxRZGNBREhFTFFRVU1jQXRCMkFBTWJ3dEJCQXh1QzBIWkFBeHRDMEhhQUF4c0MwSGJBQXhyQzBIY0FBeHFDMEVEREdrTFFkMEFER2dMUWQ0QURHY0xRZDhBREdZTFFlRUFER1VMUWVBQURHUUxRZUlBREdNTFFlTUFER0lMUVFJTVlRdEI1QUFNWUF0QjVRQU1Yd3RCNWdBTVhndEI1d0FNWFF0QjZBQU1YQXRCNlFBTVd3dEI2Z0FNV2d0QjZ3QU1XUXRCN0FBTVdBdEI3UUFNVnd0QjdnQU1WZ3RCN3dBTVZRdEI4QUFNVkF0QjhRQU1Vd3RCOGdBTVVndEI4d0FNVVF0QjlBQU1VQXRCOVFBTVR3dEI5Z0FNVGd0Qjl3QU1UUXRCK0FBTVRBdEIrUUFNU3d0QitnQU1TZ3RCK3dBTVNRdEIvQUFNU0F0Qi9RQU1Sd3RCL2dBTVJndEIvd0FNUlF0QmdBRU1SQXRCZ1FFTVF3dEJnZ0VNUWd0Qmd3RU1RUXRCaEFFTVFBdEJoUUVNUHd0QmhnRU1QZ3RCaHdFTVBRdEJpQUVNUEF0QmlRRU1Pd3RCaWdFTU9ndEJpd0VNT1F0QmpBRU1PQXRCalFFTU53dEJqZ0VNTmd0Qmp3RU1OUXRCa0FFTU5BdEJrUUVNTXd0QmtnRU1NZ3RCa3dFTU1RdEJsQUVNTUF0QmxRRU1Md3RCbGdFTUxndEJsd0VNTFF0Qm1BRU1MQXRCbVFFTUt3dEJtZ0VNS2d0Qm13RU1LUXRCbkFFTUtBdEJuUUVNSnd0Qm5nRU1KZ3RCbndFTUpRdEJvQUVNSkF0Qm9RRU1Jd3RCb2dFTUlndEJvd0VNSVF0QnBBRU1JQXRCcFFFTUh3dEJwZ0VNSGd0QnB3RU1IUXRCcUFFTUhBdEJxUUVNR3d0QnFnRU1HZ3RCcXdFTUdRdEJyQUVNR0F0QnJRRU1Gd3RCcmdFTUZndEJBUXdWQzBHdkFRd1VDMEd3QVF3VEMwR3hBUXdTQzBHekFRd1JDMEd5QVF3UUMwRzBBUXdQQzBHMUFRd09DMEcyQVF3TkMwRzNBUXdNQzBHNEFRd0xDMEc1QVF3S0MwRzZBUXdKQzBHN0FRd0lDMEhHQVF3SEMwRzhBUXdHQzBHOUFRd0ZDMEcrQVF3RUMwRy9BUXdEQzBIQUFRd0NDMEhDQVF3QkMwSEJBUXNoQXdOQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSi9Ba0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBZ0ovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBRERzWUJBQUVDQXdRRkJnY0lDUW9MREEwT0R4QVJFaE1VRlJZWEdCa2FHeHdkSHlBaEl5VW1LQ29yTEM4d01USXpORFUyTnprNk96dzlsQU5BUWtSRlJrbExUazlRVVZKVFZGVldXRnBiWEYxZVgyQmhZbU5rWldabmFHcHNiM0J4YzNWMmVIbDZlM3gvZ0FHQkFZSUJnd0dFQVlVQmhnR0hBWWdCaVFHS0FZc0JqQUdOQVk0Qmp3R1FBWkVCa2dHVEFaUUJsUUdXQVpjQm1BR1pBWm9CbXdHY0FaMEJuZ0dmQWFBQm9RR2lBYU1CcEFHbEFhWUJwd0dvQWFrQnFnR3JBYXdCclFHdUFhOEJzQUd4QWJJQnN3RzBBYlVCdGdHM0FiZ0J1UUc2QWJzQnZBRzlBYjRCdndIQUFjRUJ3Z0hEQWNRQnhRSEdBY2NCeUFISkFjc0J6QUhOQWM0Qnp3R0tBNGtEaUFPSEE0UURnd09BQS9zQytnTDVBdmdDOXdMMEF2TUM4Z0xMQXNFQ3NBTFpBUXNnQVNBRVJ3M3dBa0hkQVNFRERMTURDeUFCSUFSSERjZ0JRY01CSVFNTXNnTUxJQUVnQkVjTmUwSDNBQ0VERExFREN5QUJJQVJIRFhCQjd3QWhBd3l3QXdzZ0FTQUVSdzFwUWVvQUlRTU1yd01MSUFFZ0JFY05aVUhvQUNFRERLNERDeUFCSUFSSERXSkI1Z0FoQXd5dEF3c2dBU0FFUncwYVFSZ2hBd3lzQXdzZ0FTQUVSdzBWUVJJaEF3eXJBd3NnQVNBRVJ3MUNRY1VBSVFNTXFnTUxJQUVnQkVjTk5FRS9JUU1NcVFNTElBRWdCRWNOTWtFOElRTU1xQU1MSUFFZ0JFY05LMEV4SVFNTXB3TUxJQUl0QUM1QkFVWU5ud01Nd1FJTFFRQWhBQUpBQWtBQ1FDQUNMUUFxUlEwQUlBSXRBQ3RGRFFBZ0FpOEJNQ0lEUVFKeFJRMEJEQUlMSUFJdkFUQWlBMEVCY1VVTkFRdEJBU0VBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ1ZCNUFCclFlUUFTUTBBSUFWQnpBRkdEUUFnQlVHd0FrWU5BQ0FEUWNBQWNRMEFRUUFoQUNBRFFZZ0VjVUdBQkVZTkFDQURRU2h4UVFCSElRQUxJQUpCQURzQk1DQUNRUUE2QUM4Z0FFVU4zd0lnQWtJQU53TWdET0FDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ0xDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM01BU0FBUVJWSERkMENJQUpCQkRZQ0hDQUNJQUUyQWhRZ0FrR3dHRFlDRUNBQ1FSVTJBZ3hCQUNFRERLUURDeUFCSUFSR0JFQkJCaUVEREtRREN5QUJRUUZxSVFGQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FBM1pBZ3djQ3lBQ1FnQTNBeUJCRWlFRERJa0RDeUFCSUFSSERSWkJIU0VEREtFREN5QUJJQVJIQkVBZ0FVRUJhaUVCUVJBaEF3eUlBd3RCQnlFRERLQURDeUFDSUFJcEF5QWlDaUFFSUFGcnJTSUxmU0lNUWdBZ0NpQU1XaHMzQXlBZ0NpQUxXQTNVQWtFSUlRTU1ud01MSUFFZ0JFY0VRQ0FDUVFrMkFnZ2dBaUFCTmdJRVFSUWhBd3lHQXd0QkNTRURESjREQ3lBQ0tRTWdRZ0JTRGNjQklBSWdBaThCTUVHQUFYSTdBVEFNUWdzZ0FTQUVSdzAvUWRBQUlRTU1uQU1MSUFFZ0JFWUVRRUVMSVFNTW5BTUxJQUZCQVdvaEFVRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NVQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEYzhDRE1ZQkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNHQVNBQVFSVkhEYzBDSUFKQkN6WUNIQ0FDSUFFMkFoUWdBa0dDR1RZQ0VDQUNRUlUyQWd4QkFDRURESm9EQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1NDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRME1JQUJCRlVjTnlnSWdBa0VhTmdJY0lBSWdBVFlDRkNBQ1FZSVpOZ0lRSUFKQkZUWUNERUVBSVFNTW1RTUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUpNSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRGNRQklBQkJGVWNOeHdJZ0FrRUxOZ0ljSUFJZ0FUWUNGQ0FDUVpFWE5nSVFJQUpCRlRZQ0RFRUFJUU1NbUFNTElBRWdCRVlFUUVFUElRTU1tQU1MSUFFdEFBQWlBRUU3UmcwSElBQkJEVWNOeEFJZ0FVRUJhaUVCRE1NQkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNEQVNBQVFSVkhEY0lDSUFKQkR6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESllEQ3dOQUlBRXRBQUJCOERWcUxRQUFJZ0JCQVVjRVFDQUFRUUpIRGNFQ0lBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCUVFGcUlnRVFMU0lBRGNJQ0RNVUJDeUFFSUFGQkFXb2lBVWNOQUF0QkVpRURESlVEQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1RDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM0ZBU0FBUVJWSERiMENJQUpCR3pZQ0hDQUNJQUUyQWhRZ0FrR1JGellDRUNBQ1FSVTJBZ3hCQUNFRERKUURDeUFCSUFSR0JFQkJGaUVEREpRREN5QUNRUW8yQWdnZ0FpQUJOZ0lFUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKSUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjSUJJQUJCRlVjTnVRSWdBa0VWTmdJY0lBSWdBVFlDRkNBQ1FZSVpOZ0lRSUFKQkZUWUNERUVBSVFNTWt3TUxJQUVnQkVjRVFBTkFJQUV0QUFCQjhEZHFMUUFBSWdCQkFrY0VRQUpBSUFCQkFXc09CTVFDdlFJQXZnSzlBZ3NnQVVFQmFpRUJRUWdoQXd6OEFnc2dCQ0FCUVFGcUlnRkhEUUFMUVJVaEF3eVRBd3RCRlNFRERKSURDd05BSUFFdEFBQkI4RGxxTFFBQUlnQkJBa2NFUUNBQVFRRnJEZ1RGQXJjQ3d3SzRBcmNDQ3lBRUlBRkJBV29pQVVjTkFBdEJHQ0VEREpFREN5QUJJQVJIQkVBZ0FrRUxOZ0lJSUFJZ0FUWUNCRUVISVFNTStBSUxRUmtoQXd5UUF3c2dBVUVCYWlFQkRBSUxJQUVnQkVZRVFFRWFJUU1NandNTEFrQWdBUzBBQUVFTmF3NFV0UUcvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0VBdndFTFFRQWhBeUFDUVFBMkFod2dBa0d2Q3pZQ0VDQUNRUUkyQWd3Z0FpQUJRUUZxTmdJVURJNERDeUFCSUFSR0JFQkJHeUVEREk0REN5QUJMUUFBSWdCQk8wY0VRQ0FBUVExSERiRUNJQUZCQVdvaEFReTZBUXNnQVVFQmFpRUJDMEVpSVFNTTh3SUxJQUVnQkVZRVFFRWNJUU1NakFNTFFnQWhDZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FTMEFBRUV3YXc0M3dRTEFBZ0FCQWdNRUJRWUgwQUhRQWRBQjBBSFFBZEFCMEFFSUNRb0xEQTNRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUJEZzhRRVJJVDBBRUxRZ0loQ2d6QUFndENBeUVLREw4Q0MwSUVJUW9NdmdJTFFnVWhDZ3k5QWd0Q0JpRUtETHdDQzBJSElRb011d0lMUWdnaENneTZBZ3RDQ1NFS0RMa0NDMElLSVFvTXVBSUxRZ3NoQ2d5M0FndENEQ0VLRExZQ0MwSU5JUW9NdFFJTFFnNGhDZ3kwQWd0Q0R5RUtETE1DQzBJS0lRb01zZ0lMUWdzaENneXhBZ3RDRENFS0RMQUNDMElOSVFvTXJ3SUxRZzRoQ2d5dUFndENEeUVLREswQ0MwSUFJUW9DUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRXRBQUJCTUdzT044QUN2d0lBQVFJREJBVUdCNzRDdmdLK0FyNEN2Z0srQXI0Q0NBa0tDd3dOdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBZzRQRUJFU0U3NENDMElDSVFvTXZ3SUxRZ01oQ2d5K0FndENCQ0VLREwwQ0MwSUZJUW9NdkFJTFFnWWhDZ3k3QWd0Q0J5RUtETG9DQzBJSUlRb011UUlMUWdraENneTRBZ3RDQ2lFS0RMY0NDMElMSVFvTXRnSUxRZ3doQ2d5MUFndENEU0VLRExRQ0MwSU9JUW9Nc3dJTFFnOGhDZ3l5QWd0Q0NpRUtETEVDQzBJTElRb01zQUlMUWd3aENneXZBZ3RDRFNFS0RLNENDMElPSVFvTXJRSUxRZzhoQ2d5c0Fnc2dBaUFDS1FNZ0lnb2dCQ0FCYTYwaUMzMGlERUlBSUFvZ0RGb2JOd01nSUFvZ0MxZ05wd0pCSHlFRERJa0RDeUFCSUFSSEJFQWdBa0VKTmdJSUlBSWdBVFlDQkVFbElRTU04QUlMUVNBaEF3eUlBd3RCQVNFRklBSXZBVEFpQTBFSWNVVUVRQ0FDS1FNZ1FnQlNJUVVMQWtBZ0FpMEFMZ1JBUVFFaEFDQUNMUUFwUVFWR0RRRWdBMEhBQUhGRklBVnhSUTBCQzBFQUlRQWdBMEhBQUhFTkFFRUNJUUFnQTBFSWNRMEFJQU5CZ0FSeEJFQUNRQ0FDTFFBb1FRRkhEUUFnQWkwQUxVRUtjUTBBUVFVaEFBd0NDMEVFSVFBTUFRc2dBMEVnY1VVRVFBSkFJQUl0QUNoQkFVWU5BQ0FDTHdFeUlnQkI1QUJyUWVRQVNRMEFJQUJCekFGR0RRQWdBRUd3QWtZTkFFRUVJUUFnQTBFb2NVVU5BaUFEUVlnRWNVR0FCRVlOQWd0QkFDRUFEQUVMUVFCQkF5QUNLUU1nVUJzaEFBc2dBRUVCYXc0RnZnSUFzQUVCcEFLaEFndEJFU0VERE8wQ0N5QUNRUUU2QUM4TWhBTUxJQUVnQkVjTm5RSkJKQ0VERElRREN5QUJJQVJIRFJ4QnhnQWhBd3lEQXd0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FrUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5KeUFBUVJWSERaZ0NJQUpCMEFBMkFod2dBaUFCTmdJVUlBSkJrUmcyQWhBZ0FrRVZOZ0lNUVFBaEF3eUNBd3NnQVNBRVJnUkFRU2doQXd5Q0F3dEJBQ0VESUFKQkFEWUNCQ0FDUVF3MkFnZ2dBaUFCSUFFUUtpSUFSUTJVQWlBQ1FTYzJBaHdnQWlBQk5nSVVJQUlnQURZQ0RBeUJBd3NnQVNBRVJnUkFRU2toQXd5QkF3c2dBUzBBQUNJQVFTQkdEUk1nQUVFSlJ3MlZBaUFCUVFGcUlRRU1GQXNnQVNBRVJ3UkFJQUZCQVdvaEFRd1dDMEVxSVFNTS93SUxJQUVnQkVZRVFFRXJJUU1NL3dJTElBRXRBQUFpQUVFSlJ5QUFRU0JIY1EyUUFpQUNMUUFzUVFoSERkMENJQUpCQURvQUxBemRBZ3NnQVNBRVJnUkFRU3doQXd6K0Fnc2dBUzBBQUVFS1J3Mk9BaUFCUVFGcUlRRU1zQUVMSUFFZ0JFY05pZ0pCTHlFRERQd0NDd05BSUFFdEFBQWlBRUVnUndSQUlBQkJDbXNPQklRQ2lBS0lBb1FDaGdJTElBUWdBVUVCYWlJQlJ3MEFDMEV4SVFNTSt3SUxRVEloQXlBQklBUkdEZm9DSUFJb0FnQWlBQ0FFSUFGcmFpRUhJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FFSHdPMm90QUFBZ0FTMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEUUVnQUVFRFJnUkFRUVloQVF6aUFnc2dBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFjMkFnQU0rd0lMSUFKQkFEWUNBQXlHQWd0Qk15RURJQVFnQVNJQVJnMzVBaUFFSUFGcklBSW9BZ0FpQVdvaEJ5QUFJQUZyUVFocUlRWUNRQU5BSUFGQjlEdHFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEJJQUZCQ0VZRVFFRUZJUUVNNFFJTElBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURQb0NDeUFDUVFBMkFnQWdBQ0VCRElVQ0MwRTBJUU1nQkNBQklnQkdEZmdDSUFRZ0FXc2dBaWdDQUNJQmFpRUhJQUFnQVd0QkJXb2hCZ0pBQTBBZ0FVSFF3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkJVWUVRRUVISVFFTTRBSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUGtDQ3lBQ1FRQTJBZ0FnQUNFQkRJUUNDeUFCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1JnMEpESUVDQ3lBRUlBRkJBV29pQVVjTkFBdEJNQ0VERFBnQ0MwRXdJUU1NOXdJTElBRWdCRWNFUUFOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JQOEIvZ0grQWY4Qi9nRUxJQVFnQVVFQmFpSUJSdzBBQzBFNElRTU05d0lMUVRnaEF3ejJBZ3NEUUNBQkxRQUFJZ0JCSUVjZ0FFRUpSM0VOOWdFZ0JDQUJRUUZxSWdGSERRQUxRVHdoQXd6MUFnc0RRQ0FCTFFBQUlnQkJJRWNFUUFKQUlBQkJDbXNPQlBrQkJBVDVBUUFMSUFCQkxFWU45UUVNQXdzZ0JDQUJRUUZxSWdGSERRQUxRVDhoQXd6MEFndEJ3QUFoQXlBQklBUkdEZk1DSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FFR0FRR3N0QUFBZ0FTMEFBRUVnY2tjTkFTQUFRUVpHRGRzQ0lBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURQUUNDeUFDUVFBMkFnQUxRVFloQXd6WkFnc2dBU0FFUmdSQVFjRUFJUU1NOGdJTElBSkJERFlDQ0NBQ0lBRTJBZ1FnQWkwQUxFRUJhdzRFK3dIdUFld0I2d0hVQWdzZ0FVRUJhaUVCRFBvQkN5QUJJQVJIQkVBRFFBSkFJQUV0QUFBaUFFRWdjaUFBSUFCQndRQnJRZjhCY1VFYVNSdEIvd0Z4SWdCQkNVWU5BQ0FBUVNCR0RRQUNRQUpBQWtBQ1FDQUFRZU1BYXc0VEFBTURBd01EQXdNQkF3TURBd01EQXdNREFnTUxJQUZCQVdvaEFVRXhJUU1NM0FJTElBRkJBV29oQVVFeUlRTU0yd0lMSUFGQkFXb2hBVUV6SVFNTTJnSUxEUDRCQ3lBRUlBRkJBV29pQVVjTkFBdEJOU0VERFBBQ0MwRTFJUU1NN3dJTElBRWdCRWNFUUFOQUlBRXRBQUJCZ0R4cUxRQUFRUUZIRGZjQklBUWdBVUVCYWlJQlJ3MEFDMEU5SVFNTTd3SUxRVDBoQXd6dUFndEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba0FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOQVNBQVFSVkhEZVlCSUFKQndnQTJBaHdnQWlBQk5nSVVJQUpCNHhnMkFoQWdBa0VWTmdJTVFRQWhBd3p0QWdzZ0FVRUJhaUVCQzBFOElRTU0wZ0lMSUFFZ0JFWUVRRUhDQUNFRERPc0NDd0pBQTBBQ1FDQUJMUUFBUVFsckRoZ0FBc3dDekFMUkFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFnRE1BZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFjSUFJUU1NNndJTElBRkJBV29oQVNBQ0xRQXRRUUZ4UlEzK0FRdEJMQ0VERE5BQ0N5QUJJQVJIRGQ0QlFjUUFJUU1NNkFJTEEwQWdBUzBBQUVHUXdBQnFMUUFBUVFGSERad0JJQVFnQVVFQmFpSUJSdzBBQzBIRkFDRURET2NDQ3lBQkxRQUFJZ0JCSUVZTi9nRWdBRUU2UnczQUFpQUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBcElnQU4zZ0VNM1FFTFFjY0FJUU1nQkNBQklnQkdEZVVDSUFRZ0FXc2dBaWdDQUNJQmFpRUhJQUFnQVd0QkJXb2hCZ05BSUFGQmtNSUFhaTBBQUNBQUxRQUFJZ1ZCSUhJZ0JTQUZRY0VBYTBIL0FYRkJHa2tiUWY4QmNVY052d0lnQVVFRlJnM0NBaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpsQWd0QnlBQWhBeUFFSUFFaUFFWU41QUlnQkNBQmF5QUNLQUlBSWdGcUlRY2dBQ0FCYTBFSmFpRUdBMEFnQVVHV3dnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MitBa0VDSUFGQkNVWU53Z0lhSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRE9RQ0N5QUJJQVJHQkVCQnlRQWhBd3prQWdzQ1FBSkFJQUV0QUFBaUFFRWdjaUFBSUFCQndRQnJRZjhCY1VFYVNSdEIvd0Z4UWU0QWF3NEhBTDhDdndLL0FyOEN2d0lCdndJTElBRkJBV29oQVVFK0lRTU15d0lMSUFGQkFXb2hBVUUvSVFNTXlnSUxRY29BSVFNZ0JDQUJJZ0JHRGVJQ0lBUWdBV3NnQWlnQ0FDSUJhaUVHSUFBZ0FXdEJBV29oQndOQUlBRkJvTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdkFJZ0FVRUJSZzIrQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCallDQUF6aUFndEJ5d0FoQXlBRUlBRWlBRVlONFFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRU9haUVHQTBBZ0FVR2l3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzI3QWlBQlFRNUdEYjRDSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRE9FQ0MwSE1BQ0VESUFRZ0FTSUFSZzNnQWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFROXFJUVlEUUNBQlFjRENBR290QUFBZ0FDMEFBQ0lGUVNCeUlBVWdCVUhCQUd0Qi93RnhRUnBKRzBIL0FYRkhEYm9DUVFNZ0FVRVBSZzIrQWhvZ0FVRUJhaUVCSUFRZ0FFRUJhaUlBUncwQUN5QUNJQWMyQWdBTTRBSUxRYzBBSVFNZ0JDQUJJZ0JHRGQ4Q0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkIwTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdVFKQkJDQUJRUVZHRGIwQ0dpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQnpZQ0FBemZBZ3NnQVNBRVJnUkFRYzRBSVFNTTN3SUxBa0FDUUFKQUFrQWdBUzBBQUNJQVFTQnlJQUFnQUVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZCNHdCckRoTUF2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0N2QUs4QXJ3Q0Fid0N2QUs4QWdJRHZBSUxJQUZCQVdvaEFVSEJBQ0VERE1nQ0N5QUJRUUZxSVFGQndnQWhBd3pIQWdzZ0FVRUJhaUVCUWNNQUlRTU14Z0lMSUFGQkFXb2hBVUhFQUNFRERNVUNDeUFCSUFSSEJFQWdBa0VOTmdJSUlBSWdBVFlDQkVIRkFDRURETVVDQzBIUEFDRURETjBDQ3dKQUFrQWdBUzBBQUVFS2F3NEVBWkFCa0FFQWtBRUxJQUZCQVdvaEFRdEJLQ0VERE1NQ0N5QUJJQVJHQkVCQjBRQWhBd3pjQWdzZ0FTMEFBRUVnUncwQUlBRkJBV29oQVNBQ0xRQXRRUUZ4UlEzUUFRdEJGeUVERE1FQ0N5QUJJQVJIRGNzQlFkSUFJUU1NMlFJTFFkTUFJUU1nQVNBRVJnM1lBaUFDS0FJQUlnQWdCQ0FCYTJvaEJpQUJJQUJyUVFGcUlRVURRQ0FCTFFBQUlBQkIxc0lBYWkwQUFFY054d0VnQUVFQlJnM0tBU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JqWUNBQXpZQWdzZ0FTQUVSZ1JBUWRVQUlRTU0yQUlMSUFFdEFBQkJDa2NOd2dFZ0FVRUJhaUVCRE1vQkN5QUJJQVJHQkVCQjFnQWhBd3pYQWdzQ1FBSkFJQUV0QUFCQkNtc09CQUREQWNNQkFjTUJDeUFCUVFGcUlRRU15Z0VMSUFGQkFXb2hBVUhLQUNFRERMMENDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDUENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGI4QlFjMEFJUU1NdkFJTElBSXRBQ2xCSWtZTnp3SU1pUUVMSUFRZ0FTSUZSZ1JBUWRzQUlRTU0xQUlMUVFBaEFFRUJJUUZCQVNFR1FRQWhBd0pBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQ0FGTFFBQVFUQnJEZ3JGQWNRQkFBRUNBd1FGQmdqREFRdEJBZ3dHQzBFRERBVUxRUVFNQkF0QkJRd0RDMEVHREFJTFFRY01BUXRCQ0FzaEEwRUFJUUZCQUNFR0RMMEJDMEVKSVFOQkFTRUFRUUFoQVVFQUlRWU12QUVMSUFFZ0JFWUVRRUhkQUNFREROTUNDeUFCTFFBQVFTNUhEYmdCSUFGQkFXb2hBUXlJQVFzZ0FTQUVSdzIyQVVIZkFDRURETkVDQ3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFSFFBQ0VERExnQ0MwSGdBQ0VERE5BQ0MwSGhBQ0VESUFFZ0JFWU56d0lnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBMEFnQVMwQUFDQUFRZUxDQUdvdEFBQkhEYkVCSUFCQkEwWU5zd0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNendJTFFlSUFJUU1nQVNBRVJnM09BaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWURRQ0FCTFFBQUlBQkI1c0lBYWkwQUFFY05zQUVnQUVFQ1JnMnZBU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXpPQWd0QjR3QWhBeUFCSUFSR0RjMENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnTkFJQUV0QUFBZ0FFSHB3Z0JxTFFBQVJ3MnZBU0FBUVFOR0RhMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFETTBDQ3lBQklBUkdCRUJCNVFBaEF3ek5BZ3NnQVVFQmFpRUJRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUl3SWdORkRRQWdBaUFERVFBQUlRQUxJQUFOcWdGQjFnQWhBd3l6QWdzZ0FTQUVSd1JBQTBBZ0FTMEFBQ0lBUVNCSEJFQUNRQUpBQWtBZ0FFSElBR3NPQ3dBQnN3R3pBYk1Cc3dHekFiTUJzd0d6QVFLekFRc2dBVUVCYWlFQlFkSUFJUU1NdHdJTElBRkJBV29oQVVIVEFDRURETFlDQ3lBQlFRRnFJUUZCMUFBaEF3eTFBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlUUFJUU1NekFJTFFlUUFJUU1NeXdJTEEwQWdBUzBBQUVId3dnQnFMUUFBSWdCQkFVY0VRQ0FBUVFKckRnT25BYVlCcFFHa0FRc2dCQ0FCUVFGcUlnRkhEUUFMUWVZQUlRTU15Z0lMSUFGQkFXb2dBU0FFUncwQ0drSG5BQ0VERE1rQ0N3TkFJQUV0QUFCQjhNUUFhaTBBQUNJQVFRRkhCRUFDUUNBQVFRSnJEZ1NpQWFFQm9BRUFud0VMUWRjQUlRTU1zUUlMSUFRZ0FVRUJhaUlCUncwQUMwSG9BQ0VERE1nQ0N5QUJJQVJHQkVCQjZRQWhBd3pJQWdzQ1FDQUJMUUFBSWdCQkNtc09HcmNCbXdHYkFiUUJtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0JwQUdiQVpzQkFKa0JDeUFCUVFGcUN5RUJRUVloQXd5dEFnc0RRQ0FCTFFBQVFmREdBR290QUFCQkFVY05mU0FFSUFGQkFXb2lBVWNOQUF0QjZnQWhBd3pGQWdzZ0FVRUJhaUFCSUFSSERRSWFRZXNBSVFNTXhBSUxJQUVnQkVZRVFFSHNBQ0VERE1RQ0N5QUJRUUZxREFFTElBRWdCRVlFUUVIdEFDRURETU1DQ3lBQlFRRnFDeUVCUVFRaEF3eW9BZ3NnQVNBRVJnUkFRZTRBSVFNTXdRSUxBa0FDUUFKQUlBRXRBQUJCOE1nQWFpMEFBRUVCYXc0SGtBR1BBWTRCQUh3QkFvMEJDeUFCUVFGcUlRRU1Dd3NnQVVFQmFneVRBUXRCQUNFRElBSkJBRFlDSENBQ1Fac1NOZ0lRSUFKQkJ6WUNEQ0FDSUFGQkFXbzJBaFFNd0FJTEFrQURRQ0FCTFFBQVFmRElBR290QUFBaUFFRUVSd1JBQWtBQ1FDQUFRUUZyRGdlVUFaTUJrZ0dOQVFBRUFZMEJDMEhhQUNFRERLb0NDeUFCUVFGcUlRRkIzQUFoQXd5cEFnc2dCQ0FCUVFGcUlnRkhEUUFMUWU4QUlRTU13QUlMSUFGQkFXb01rUUVMSUFRZ0FTSUFSZ1JBUWZBQUlRTU12d0lMSUFBdEFBQkJMMGNOQVNBQVFRRnFJUUVNQndzZ0JDQUJJZ0JHQkVCQjhRQWhBd3krQWdzZ0FDMEFBQ0lCUVM5R0JFQWdBRUVCYWlFQlFkMEFJUU1NcFFJTElBRkJDbXNpQTBFV1N3MEFJQUFoQVVFQklBTjBRWW1BZ0FKeERma0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FEWUNGQ0FDUVl3Y05nSVFJQUpCQnpZQ0RBeThBZ3NnQVNBRVJ3UkFJQUZCQVdvaEFVSGVBQ0VEREtNQ0MwSHlBQ0VERExzQ0N5QUJJQVJHQkVCQjlBQWhBd3k3QWdzQ1FDQUJMUUFBUWZETUFHb3RBQUJCQVdzT0EvY0Jjd0NDQVF0QjRRQWhBd3loQWdzZ0FTQUVSd1JBQTBBZ0FTMEFBRUh3eWdCcUxRQUFJZ0JCQTBjRVFBSkFJQUJCQVdzT0F2a0JBSVVCQzBIZkFDRURES01DQ3lBRUlBRkJBV29pQVVjTkFBdEI4d0FoQXd5NkFndEI4d0FoQXd5NUFnc2dBU0FFUndSQUlBSkJEellDQ0NBQ0lBRTJBZ1JCNEFBaEF3eWdBZ3RCOVFBaEF3eTRBZ3NnQVNBRVJnUkFRZllBSVFNTXVBSUxJQUpCRHpZQ0NDQUNJQUUyQWdRTFFRTWhBd3lkQWdzRFFDQUJMUUFBUVNCSERZNENJQVFnQVVFQmFpSUJSdzBBQzBIM0FDRURETFVDQ3lBQklBUkdCRUJCK0FBaEF3eTFBZ3NnQVMwQUFFRWdSdzE2SUFGQkFXb2hBUXhiQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURYZ01nQUlMSUFFZ0JFWUVRRUg2QUNFRERMTUNDeUFCTFFBQVFjd0FSdzEwSUFGQkFXb2hBVUVUREhZTFFmc0FJUU1nQVNBRVJnMnhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWURRQ0FCTFFBQUlBQkI4TTRBYWkwQUFFY05jeUFBUVFWR0RYVWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1zUUlMSUFFZ0JFWUVRRUg4QUNFRERMRUNDd0pBQWtBZ0FTMEFBRUhEQUdzT0RBQjBkSFIwZEhSMGRIUjBBWFFMSUFGQkFXb2hBVUhtQUNFRERKZ0NDeUFCUVFGcUlRRkI1d0FoQXd5WEFndEIvUUFoQXlBQklBUkdEYThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFhJZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRExBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVJBTWN3dEIvZ0FoQXlBQklBUkdEYTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWZiT0FHb3RBQUJIRFhFZ0FFRUZSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREs4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVJZTWNndEIvd0FoQXlBQklBUkdEYTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWZ6T0FHb3RBQUJIRFhBZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREs0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFVTWNRc2dBU0FFUmdSQVFZQUJJUU1NclFJTElBRXRBQUJCMlFCSERXNGdBVUVCYWlFQlFRZ01jQXNnQVNBRVJnUkFRWUVCSVFNTXJBSUxBa0FDUUNBQkxRQUFRYzRBYXc0REFHOEJid3NnQVVFQmFpRUJRZXNBSVFNTWt3SUxJQUZCQVdvaEFVSHNBQ0VEREpJQ0N5QUJJQVJHQkVCQmdnRWhBd3lyQWdzQ1FBSkFJQUV0QUFCQnlBQnJEZ2dBYm01dWJtNXVBVzRMSUFGQkFXb2hBVUhxQUNFRERKSUNDeUFCUVFGcUlRRkI3UUFoQXd5UkFndEJnd0VoQXlBQklBUkdEYWtDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUVlEUEFHb3RBQUJIRFd3Z0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREtvQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFBTWJRdEJoQUVoQXlBQklBUkdEYWdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJHb2hCZ0pBQTBBZ0FTMEFBQ0FBUVlQUEFHb3RBQUJIRFdzZ0FFRUVSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREtrQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNNTWJBc2dBU0FFUmdSQVFZVUJJUU1NcUFJTEFrQUNRQ0FCTFFBQVFjd0FhdzRJQUd0cmEydHJhd0ZyQ3lBQlFRRnFJUUZCN3dBaEF3eVBBZ3NnQVVFQmFpRUJRZkFBSVFNTWpnSUxJQUVnQkVZRVFFR0dBU0VEREtjQ0N5QUJMUUFBUWNVQVJ3MW9JQUZCQVdvaEFReGdDMEdIQVNFRElBRWdCRVlOcFFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQWtBRFFDQUJMUUFBSUFCQmlNOEFhaTBBQUVjTmFDQUFRUU5HRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXBnSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkxReHBDMEdJQVNFRElBRWdCRVlOcEFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUlhaUVHQWtBRFFDQUJMUUFBSUFCQjBNOEFhaTBBQUVjTlp5QUFRUWhHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXBRSUxJQUpCQURZQ0FDQUdRUUZxSVFGQktReG9DeUFCSUFSR0JFQkJpUUVoQXd5a0FndEJBU0FCTFFBQVFkOEFSdzFuR2lBQlFRRnFJUUVNWGd0QmlnRWhBeUFCSUFSR0RhSUNJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnTkFJQUV0QUFBZ0FFR016d0JxTFFBQVJ3MWtJQUJCQVVZTitnRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1vZ0lMUVlzQklRTWdBU0FFUmcyaEFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR096d0JxTFFBQVJ3MWtJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWlBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRUNER1VMUVl3QklRTWdBU0FFUmcyZ0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSHd6d0JxTFFBQVJ3MWpJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWhBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRWZER1FMUVkwQklRTWdBU0FFUmcyZkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSHl6d0JxTFFBQVJ3MWlJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWdBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRUpER01MSUFFZ0JFWUVRRUdPQVNFRERKOENDd0pBQWtBZ0FTMEFBRUhKQUdzT0J3QmlZbUppWWdGaUN5QUJRUUZxSVFGQitBQWhBd3lHQWdzZ0FVRUJhaUVCUWZrQUlRTU1oUUlMUVk4QklRTWdBU0FFUmcyZEFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFR1J6d0JxTFFBQVJ3MWdJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWVBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVlER0VMUVpBQklRTWdBU0FFUmcyY0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR1h6d0JxTFFBQVJ3MWZJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWRBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVhER0FMUVpFQklRTWdBU0FFUmcyYkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVpxSVFZQ1FBTkFJQUV0QUFBZ0FFR2F6d0JxTFFBQVJ3MWVJQUJCQmtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWNBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVZERjhMUVpJQklRTWdBU0FFUmcyYUFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFR2h6d0JxTFFBQVJ3MWRJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeWJBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRWVERjRMSUFFZ0JFWUVRRUdUQVNFRERKb0NDeUFCTFFBQVFjd0FSdzFiSUFGQkFXb2hBVUVLREYwTElBRWdCRVlFUUVHVUFTRURESmtDQ3dKQUFrQWdBUzBBQUVIQkFHc09Ed0JjWEZ4Y1hGeGNYRnhjWEZ4Y0FWd0xJQUZCQVdvaEFVSCtBQ0VERElBQ0N5QUJRUUZxSVFGQi93QWhBd3ovQVFzZ0FTQUVSZ1JBUVpVQklRTU1tQUlMQWtBQ1FDQUJMUUFBUWNFQWF3NERBRnNCV3dzZ0FVRUJhaUVCUWYwQUlRTU0vd0VMSUFGQkFXb2hBVUdBQVNFRERQNEJDMEdXQVNFRElBRWdCRVlObGdJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnA4OEFhaTBBQUVjTldTQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWx3SUxJQUpCQURZQ0FDQUdRUUZxSVFGQkN3eGFDeUFCSUFSR0JFQkJsd0VoQXd5V0Fnc0NRQUpBQWtBQ1FDQUJMUUFBUVMxckRpTUFXMXRiVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzFzQlcxdGJXMXNDVzF0YkExc0xJQUZCQVdvaEFVSDdBQ0VERFA4QkN5QUJRUUZxSVFGQi9BQWhBd3orQVFzZ0FVRUJhaUVCUVlFQklRTU0vUUVMSUFGQkFXb2hBVUdDQVNFRERQd0JDMEdZQVNFRElBRWdCRVlObEFJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUVhaUVHQWtBRFFDQUJMUUFBSUFCQnFjOEFhaTBBQUVjTlZ5QUFRUVJHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWxRSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkdReFlDMEdaQVNFRElBRWdCRVlOa3dJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUZhaUVHQWtBRFFDQUJMUUFBSUFCQnJzOEFhaTBBQUVjTlZpQUFRUVZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWxBSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkJneFhDMEdhQVNFRElBRWdCRVlOa2dJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnRNOEFhaTBBQUVjTlZTQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWt3SUxJQUpCQURZQ0FDQUdRUUZxSVFGQkhBeFdDMEdiQVNFRElBRWdCRVlOa1FJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQnRzOEFhaTBBQUVjTlZDQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTWtnSUxJQUpCQURZQ0FDQUdRUUZxSVFGQkp3eFZDeUFCSUFSR0JFQkJuQUVoQXd5UkFnc0NRQUpBSUFFdEFBQkIxQUJyRGdJQUFWUUxJQUZCQVdvaEFVR0dBU0VERFBnQkN5QUJRUUZxSVFGQmh3RWhBd3ozQVF0Qm5RRWhBeUFCSUFSR0RZOENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYmpQQUdvdEFBQkhEVklnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESkFDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU1lNVXd0Qm5nRWhBeUFCSUFSR0RZNENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQVdvaEJnSkFBMEFnQVMwQUFDQUFRYnJQQUdvdEFBQkhEVkVnQUVFQlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESThDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUU1NVWd0Qm53RWhBeUFCSUFSR0RZMENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRZTNQQUdvdEFBQkhEVkFnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESTRDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUXdNVVF0Qm9BRWhBeUFCSUFSR0RZd0NJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRYnpQQUdvdEFBQkhEVThnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESTBDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUTBNVUFzZ0FTQUVSZ1JBUWFFQklRTU1qQUlMQWtBQ1FDQUJMUUFBUWNZQWF3NExBRTlQVDA5UFQwOVBUd0ZQQ3lBQlFRRnFJUUZCaXdFaEF3enpBUXNnQVVFQmFpRUJRWXdCSVFNTThnRUxJQUVnQkVZRVFFR2lBU0VERElzQ0N5QUJMUUFBUWRBQVJ3MU1JQUZCQVdvaEFReEdDeUFCSUFSR0JFQkJvd0VoQXd5S0Fnc0NRQUpBSUFFdEFBQkJ5UUJyRGdjQlRVMU5UVTBBVFFzZ0FVRUJhaUVCUVk0QklRTU04UUVMSUFGQkFXb2hBVUVpREUwTFFhUUJJUU1nQVNBRVJnMklBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUhBendCcUxRQUFSdzFMSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlKQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVkREV3TElBRWdCRVlFUUVHbEFTRURESWdDQ3dKQUFrQWdBUzBBQUVIU0FHc09Bd0JMQVVzTElBRkJBV29oQVVHUUFTRURETzhCQ3lBQlFRRnFJUUZCQkF4TEN5QUJJQVJHQkVCQnBnRWhBd3lIQWdzQ1FBSkFBa0FDUUFKQUlBRXRBQUJCd1FCckRoVUFUVTFOVFUxTlRVMU5UUUZOVFFKTlRRTk5UUVJOQ3lBQlFRRnFJUUZCaUFFaEF3enhBUXNnQVVFQmFpRUJRWWtCSVFNTThBRUxJQUZCQVdvaEFVR0tBU0VERE84QkN5QUJRUUZxSVFGQmp3RWhBd3p1QVFzZ0FVRUJhaUVCUVpFQklRTU03UUVMUWFjQklRTWdBU0FFUmcyRkFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSHR6d0JxTFFBQVJ3MUlJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUdBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVJERWtMUWFnQklRTWdBU0FFUmcyRUFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSEN6d0JxTFFBQVJ3MUhJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUZBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRXNERWdMUWFrQklRTWdBU0FFUmcyREFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVJxSVFZQ1FBTkFJQUV0QUFBZ0FFSEZ6d0JxTFFBQVJ3MUdJQUJCQkVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUVBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRXJERWNMUWFvQklRTWdBU0FFUmcyQ0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSEt6d0JxTFFBQVJ3MUZJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeURBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRVVERVlMSUFFZ0JFWUVRRUdyQVNFRERJSUNDd0pBQWtBQ1FBSkFJQUV0QUFCQndnQnJEZzhBQVFKSFIwZEhSMGRIUjBkSFJ3TkhDeUFCUVFGcUlRRkJrd0VoQXd6ckFRc2dBVUVCYWlFQlFaUUJJUU1NNmdFTElBRkJBV29oQVVHVkFTRURET2tCQ3lBQlFRRnFJUUZCbGdFaEF3em9BUXNnQVNBRVJnUkFRYXdCSVFNTWdRSUxJQUV0QUFCQnhRQkhEVUlnQVVFQmFpRUJERDBMUWEwQklRTWdBU0FFUmczL0FTQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSE56d0JxTFFBQVJ3MUNJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUFBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRU9ERU1MSUFFZ0JFWUVRRUd1QVNFRERQOEJDeUFCTFFBQVFkQUFSdzFBSUFGQkFXb2hBVUVsREVJTFFhOEJJUU1nQVNBRVJnMzlBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFocUlRWUNRQU5BSUFFdEFBQWdBRUhRendCcUxRQUFSdzFBSUFCQkNFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXorQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVxREVFTElBRWdCRVlFUUVHd0FTRUREUDBCQ3dKQUFrQWdBUzBBQUVIVkFHc09Dd0JBUUVCQVFFQkFRRUFCUUFzZ0FVRUJhaUVCUVpvQklRTU01QUVMSUFGQkFXb2hBVUdiQVNFRERPTUJDeUFCSUFSR0JFQkJzUUVoQXd6OEFRc0NRQUpBSUFFdEFBQkJ3UUJyRGhRQVB6OC9QejgvUHo4L1B6OC9QejgvUHo4L0FUOExJQUZCQVdvaEFVR1pBU0VERE9NQkN5QUJRUUZxSVFGQm5BRWhBd3ppQVF0QnNnRWhBeUFCSUFSR0Rmb0JJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRZG5QQUdvdEFBQkhEVDBnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUHNCQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU0VNUGd0QnN3RWhBeUFCSUFSR0Rma0JJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQm1vaEJnSkFBMEFnQVMwQUFDQUFRZDNQQUdvdEFBQkhEVHdnQUVFR1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUG9CQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUm9NUFFzZ0FTQUVSZ1JBUWJRQklRTU0rUUVMQWtBQ1FBSkFJQUV0QUFCQnhRQnJEaEVBUFQwOVBUMDlQVDA5QVQwOVBUMDlBajBMSUFGQkFXb2hBVUdkQVNFRERPRUJDeUFCUVFGcUlRRkJuZ0VoQXd6Z0FRc2dBVUVCYWlFQlFaOEJJUU1NM3dFTFFiVUJJUU1nQVNBRVJnMzNBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUhrendCcUxRQUFSdzA2SUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXo0QVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVvRERzTFFiWUJJUU1nQVNBRVJnMzJBU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhxendCcUxRQUFSdzA1SUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXozQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVIRERvTElBRWdCRVlFUUVHM0FTRUREUFlCQ3dKQUFrQWdBUzBBQUVIRkFHc09EZ0E1T1RrNU9UazVPVGs1T1RrQk9Rc2dBVUVCYWlFQlFhRUJJUU1NM1FFTElBRkJBV29oQVVHaUFTRURETndCQzBHNEFTRURJQUVnQkVZTjlBRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVDYWlFR0FrQURRQ0FCTFFBQUlBQkI3YzhBYWkwQUFFY05OeUFBUVFKR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU05UUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJFZ3c0QzBHNUFTRURJQUVnQkVZTjh3RWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI4TThBYWkwQUFFY05OaUFBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU05QUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJJQXczQzBHNkFTRURJQUVnQkVZTjhnRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkI4czhBYWkwQUFFY05OU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU04d0VMSUFKQkFEWUNBQ0FHUVFGcUlRRkJEd3cyQ3lBQklBUkdCRUJCdXdFaEF3enlBUXNDUUFKQUlBRXRBQUJCeVFCckRnY0FOVFUxTlRVQk5Rc2dBVUVCYWlFQlFhVUJJUU1NMlFFTElBRkJBV29oQVVHbUFTRURETmdCQzBHOEFTRURJQUVnQkVZTjhBRWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVIYWlFR0FrQURRQ0FCTFFBQUlBQkI5TThBYWkwQUFFY05NeUFBUVFkR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU04UUVMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHd3cwQ3lBQklBUkdCRUJCdlFFaEF3endBUXNDUUFKQUFrQWdBUzBBQUVIQ0FHc09FZ0EwTkRRME5EUTBORFFCTkRRME5EUTBBalFMSUFGQkFXb2hBVUdrQVNFREROZ0JDeUFCUVFGcUlRRkJwd0VoQXd6WEFRc2dBVUVCYWlFQlFhZ0JJUU1NMWdFTElBRWdCRVlFUUVHK0FTRURETzhCQ3lBQkxRQUFRYzRBUncwd0lBRkJBV29oQVF3c0N5QUJJQVJHQkVCQnZ3RWhBd3p1QVFzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCTFFBQVFjRUFhdzRWQUFFQ0F6OEVCUVkvUHo4SENBa0tDejhNRFE0UFB3c2dBVUVCYWlFQlFlZ0FJUU1NNHdFTElBRkJBV29oQVVIcEFDRURET0lCQ3lBQlFRRnFJUUZCN2dBaEF3emhBUXNnQVVFQmFpRUJRZklBSVFNTTRBRUxJQUZCQVdvaEFVSHpBQ0VERE44QkN5QUJRUUZxSVFGQjlnQWhBd3plQVFzZ0FVRUJhaUVCUWZjQUlRTU0zUUVMSUFGQkFXb2hBVUg2QUNFREROd0JDeUFCUVFGcUlRRkJnd0VoQXd6YkFRc2dBVUVCYWlFQlFZUUJJUU1NMmdFTElBRkJBV29oQVVHRkFTRURETmtCQ3lBQlFRRnFJUUZCa2dFaEF3ellBUXNnQVVFQmFpRUJRWmdCSVFNTTF3RUxJQUZCQVdvaEFVR2dBU0VERE5ZQkN5QUJRUUZxSVFGQm93RWhBd3pWQVFzZ0FVRUJhaUVCUWFvQklRTU0xQUVMSUFFZ0JFY0VRQ0FDUVJBMkFnZ2dBaUFCTmdJRVFhc0JJUU1NMUFFTFFjQUJJUU1NN0FFTFFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSTBJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEVjRnQUVFVlJ3MEhJQUpCMFFBMkFod2dBaUFCTmdJVUlBSkJzQmMyQWhBZ0FrRVZOZ0lNUVFBaEF3enJBUXNnQVVFQmFpQUJJQVJIRFFnYVFjSUJJUU1NNmdFTEEwQUNRQ0FCTFFBQVFRcHJEZ1FJQUFBTEFBc2dCQ0FCUVFGcUlnRkhEUUFMUWNNQklRTU02UUVMSUFFZ0JFY0VRQ0FDUVJFMkFnZ2dBaUFCTmdJRVFRRWhBd3pRQVF0QnhBRWhBd3pvQVFzZ0FTQUVSZ1JBUWNVQklRTU02QUVMQWtBQ1FDQUJMUUFBUVFwckRnUUJLQ2dBS0FzZ0FVRUJhZ3dKQ3lBQlFRRnFEQVVMSUFFZ0JFWUVRRUhHQVNFRERPY0JDd0pBQWtBZ0FTMEFBRUVLYXc0WEFRc0xBUXNMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd0FMQ3lBQlFRRnFJUUVMUWJBQklRTU16UUVMSUFFZ0JFWUVRRUhJQVNFRERPWUJDeUFCTFFBQVFTQkhEUWtnQWtFQU93RXlJQUZCQVdvaEFVR3pBU0VERE13QkN3TkFJQUVoQUFKQUlBRWdCRWNFUUNBQkxRQUFRVEJyUWY4QmNTSURRUXBKRFFFTUp3dEJ4d0VoQXd6bUFRc0NRQ0FDTHdFeUlnRkJtVE5MRFFBZ0FpQUJRUXBzSWdVN0FUSWdCVUgrL3dOeElBTkIvLzhEYzBzTkFDQUFRUUZxSVFFZ0FpQURJQVZxSWdNN0FUSWdBMEgvL3dOeFFlZ0hTUTBCQ3d0QkFDRURJQUpCQURZQ0hDQUNRY0VKTmdJUUlBSkJEVFlDRENBQ0lBQkJBV28yQWhRTTVBRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHdERFlDRUNBQ1FSczJBZ3hCQUNFRERPTUJDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNZaUFBMEJJQUZCQVdvTElRRkJyUUVoQXd6SUFRc2dBa0hCQVRZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVVFRQWhBd3pnQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW1JZ0FOQVNBQlFRRnFDeUVCUWE0QklRTU14UUVMSUFKQndnRTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGRUVBSVFNTTNRRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1hDellDRUNBQ1FRMDJBZ3hCQUNFREROd0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0eEEyQWhBZ0FrRUpOZ0lNUVFBaEF3emJBUXNnQWtFQ09nQW9ES3dCQzBFQUlRTWdBa0VBTmdJY0lBSkJyd3MyQWhBZ0FrRUNOZ0lNSUFJZ0FVRUJhallDRkF6WkFRdEJBaUVEREw4QkMwRU5JUU1NdmdFTFFTWWhBd3k5QVF0QkZTRURETHdCQzBFV0lRTU11d0VMUVJnaEF3eTZBUXRCSENFRERMa0JDMEVkSVFNTXVBRUxRU0FoQXd5M0FRdEJJU0VERExZQkMwRWpJUU1NdFFFTFFjWUFJUU1NdEFFTFFTNGhBd3l6QVF0QlBTRURETElCQzBITEFDRURETEVCQzBIT0FDRURETEFCQzBIWUFDRURESzhCQzBIWkFDRURESzRCQzBIYkFDRURESzBCQzBIeEFDRURES3dCQzBIMEFDRURES3NCQzBHTkFTRURES29CQzBHWEFTRURES2tCQzBHcEFTRURES2dCQzBHdkFTRURES2NCQzBHeEFTRURES1lCQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhSczJBaEFnQWtFR05nSU1ETDBCQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU1FMT2dBcElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKeUlBUlFSQVFlVUFJUU1Nb3dFTElBSkIrUUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXV3RUxJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd5N0FRc2dBa0g0QURZQ0hDQUNJQUUyQWhRZ0FrSEtHRFlDRUNBQ1FSVTJBZ3hCQUNFRERMb0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJqaHMyQWhBZ0FrRUdOZ0lNUVFBaEF3eTVBUXNnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjRSTmdJUUlBSkJCellDREVFQUlRTU11QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dNSERZQ0VDQUNRUWMyQWd4QkFDRURETGNCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCd3c4MkFoQWdBa0VITmdJTVFRQWhBd3kyQVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNNUE5nSVFJQUpCQnpZQ0RFRUFJUU1NdFFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwUklBSkI1UUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXRBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGdJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zd0VMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBpSUFKQjBnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc2dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwT0lBSkI1UUEyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGRJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBmSUFKQjBnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NcndFTElBQkJQMGNOQVNBQlFRRnFDeUVCUVFVaEF3eVVBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIOUVqWUNFQ0FDUVFjMkFnd01yQUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hjQ0RZQ0VDQUNRUWMyQWd4QkFDRURES3NCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOQnlBQ1FlVUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtvQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkZpQUNRZE1BTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLa0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5HQ0FDUWRJQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2dCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCeGdvMkFoQWdBa0VITmdJTVFRQWhBd3luQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFNZ0FrSGxBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5bUFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRSSWdBa0hUQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWxBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUlFnQWtIU0FEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lrQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFBZ0FrSGxBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5akFRdEIxUUFoQXd5SkFRc2dBRUVWUndSQUlBSkJBRFlDSENBQ0lBRTJBaFFnQWtHNURUWUNFQ0FDUVJvMkFneEJBQ0VEREtJQkN5QUNRZVFBTmdJY0lBSWdBVFlDRkNBQ1FlTVhOZ0lRSUFKQkZUWUNERUVBSVFNTW9RRUxJQUpCQURZQ0FDQUdRUUZxSVFFZ0FpMEFLU0lBUVNOclFRdEpEUVFDUUNBQVFRWkxEUUJCQVNBQWRFSEtBSEZGRFFBTUJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0gzQ1RZQ0VDQUNRUWcyQWd3TW9BRUxJQUpCQURZQ0FDQUdRUUZxSVFFZ0FpMEFLVUVoUmcwRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYkNqWUNFQ0FDUVFnMkFneEJBQ0VEREo4QkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJrRE0yQWhBZ0FrRUlOZ0lNREowQkN5QUNRUUEyQWdBZ0JrRUJhaUVCSUFJdEFDbEJJMGtOQUNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCMHdrMkFoQWdBa0VJTmdJTVFRQWhBd3ljQVF0QjBRQWhBd3lDQVFzZ0FTMEFBRUV3YXlJQVFmOEJjVUVLU1FSQUlBSWdBRG9BS2lBQlFRRnFJUUZCendBaEF3eUNBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBb0lnQkZEWVlCSUFKQjNnQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NbWdFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEyR0FTQUNRZHdBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERKa0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FGRUNnaUFFVUVRQ0FGSVFFTWh3RUxJQUpCMmdBMkFod2dBaUFGTmdJVUlBSWdBRFlDREF5WUFRdEJBQ0VCUVFFaEF3c2dBaUFET2dBcklBVkJBV29oQXdKQUFrQUNRQ0FDTFFBdFFSQnhEUUFDUUFKQUFrQWdBaTBBS2c0REFRQUNCQXNnQmtVTkF3d0NDeUFBRFFFTUFnc2dBVVVOQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0F4QW9JZ0JGQkVBZ0F5RUJEQUlMSUFKQjJBQTJBaHdnQWlBRE5nSVVJQUlnQURZQ0RFRUFJUU1NbUFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBTVFLQ0lBUlFSQUlBTWhBUXlIQVFzZ0FrSFpBRFlDSENBQ0lBTTJBaFFnQWlBQU5nSU1RUUFoQXd5WEFRdEJ6QUFoQXd4OUN5QUFRUlZIQkVBZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpRTk5nSVFJQUpCSVRZQ0RFRUFJUU1NbGdFTElBSkIxd0EyQWh3Z0FpQUJOZ0lVSUFKQnlSYzJBaEFnQWtFVk5nSU1RUUFoQXd5VkFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dBRVRZQ0VDQUNRUWsyQWd3TWxBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMEFJQUpCMHdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1rd0VMUWNrQUlRTU1lUXNnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY0VvTmdJUUlBSkJCellDRENBQ1FRQTJBZ0JCQUNFRERKRUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFFBZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1ESkFCQzBISUFDRURESFlMSUFKQkFEWUNBQ0FGSVFFTElBSkJnQkk3QVNvZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTkFRdEJ4d0FoQXd4ekN5QUFRUlZHQkVBZ0FrSFJBRFlDSENBQ0lBRTJBaFFnQWtIakZ6WUNFQ0FDUVJVMkFneEJBQ0VEREl3QkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmtOTmdJUUlBSkJHallDREF5TEFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dnR1RZQ0VDQUNRUjQyQWd3TWlnRUxJQUV0QUFCQk9rWUVRQ0FDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0JGRFFFZ0FrSERBRFlDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVRElvQkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYkVSTmdJUUlBSkJDallDREF5SkFRc2dBVUVCYWlFQlFUc2hBd3h2Q3lBQ1FjTUFOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNaHdFTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4QTQyQWhBZ0FrRWNOZ0lNRElZQkN5QUNJQUl2QVRCQkVISTdBVEFNWmdzQ1FDQUNMd0V3SWdCQkNIRkZEUUFnQWkwQUtFRUJSdzBBSUFJdEFDMUJDSEZGRFFNTElBSWdBRUgzK3dOeFFZQUVjanNCTUF3RUN5QUJJQVJIQkVBQ1FBTkFJQUV0QUFCQk1Hc2lBRUgvQVhGQkNrOEVRRUUxSVFNTWJnc2dBaWtESUNJS1FwbXo1c3lacytiTUdWWU5BU0FDSUFwQ0NuNGlDamNESUNBS0lBQ3RRdjhCZ3lJTFFuK0ZWZzBCSUFJZ0NpQUxmRGNESUNBRUlBRkJBV29pQVVjTkFBdEJPU0VERElVQkN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVVFQmFpSUJFQ29pQUEwTURIY0xRVGtoQXd5REFRc2dBaTBBTUVFZ2NRMEdRY1VCSVFNTWFRdEJBQ0VESUFKQkFEWUNCQ0FDSUFFZ0FSQXFJZ0JGRFFRZ0FrRTZOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZ1FFTElBSXRBQ2hCQVVjTkFDQUNMUUF0UVFoeFJRMEJDMEUzSVFNTVpnc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFCRUFnQWtFN05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1md3NnQVVFQmFpRUJERzRMSUFKQkNEb0FMQXdFQ3lBQlFRRnFJUUVNYlF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGtFallDRUNBQ1FRUTJBZ3dNZXdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQVJRMXNJQUpCTnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhvTElBSWdBaThCTUVFZ2Nqc0JNQXRCTUNFRERGOExJQUpCTmpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhjTElBQkJMRWNOQVNBQlFRRnFJUUJCQVNFQkFrQUNRQUpBQWtBQ1FDQUNMUUFzUVFWckRnUURBUUlFQUFzZ0FDRUJEQVFMUVFJaEFRd0JDMEVFSVFFTElBSkJBVG9BTENBQ0lBSXZBVEFnQVhJN0FUQWdBQ0VCREFFTElBSWdBaThCTUVFSWNqc0JNQ0FBSVFFTFFUa2hBd3hjQ3lBQ1FRQTZBQ3dMUVRRaEF3eGFDeUFCSUFSR0JFQkJMU0VEREhNTEFrQUNRQU5BQWtBZ0FTMEFBRUVLYXc0RUFnQUFBd0FMSUFRZ0FVRUJhaUlCUncwQUMwRXRJUU1NZEFzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQVJRMENJQUpCTERZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREhNTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQVMwQUFFRU5SZ1JBSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQ29pQUVVRVFDQUJRUUZxSVFFTUFnc2dBa0VzTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWNnc2dBaTBBTFVFQmNRUkFRY1FCSVFNTVdRc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFEUUVNWlF0Qkx5RURERmNMSUFKQkxqWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHOExRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEJRMkFoQWdBa0VETmdJTURHNExRUUVoQXdKQUFrQUNRQUpBSUFJdEFDeEJCV3NPQkFNQkFnQUVDeUFDSUFJdkFUQkJDSEk3QVRBTUF3dEJBaUVEREFFTFFRUWhBd3NnQWtFQk9nQXNJQUlnQWk4Qk1DQURjanNCTUF0QktpRURERk1MUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjRRODJBaEFnQWtFS05nSU1ER3NMUVFFaEF3SkFBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRSnJEZ2NGQkFRREFRSUFCQXNnQWlBQ0x3RXdRUWh5T3dFd0RBTUxRUUloQXd3QkMwRUVJUU1MSUFKQkFUb0FMQ0FDSUFJdkFUQWdBM0k3QVRBTFFTc2hBd3hTQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fhc1NOZ0lRSUFKQkN6WUNEQXhxQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FmME5OZ0lRSUFKQkhUWUNEQXhwQ3lBQklBUkhCRUFEUUNBQkxRQUFRU0JIRFVnZ0JDQUJRUUZxSWdGSERRQUxRU1VoQXd4cEMwRWxJUU1NYUFzZ0FpMEFMVUVCY1FSQVFjTUJJUU1NVHdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS1NJQUJFQWdBa0VtTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWFBc2dBVUVCYWlFQkRGd0xJQUZCQVdvaEFTQUNMd0V3SWdCQmdBRnhCRUJCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWxRaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkJpQUFRUlZIRFI4Z0FrRUZOZ0ljSUFJZ0FUWUNGQ0FDUWZrWE5nSVFJQUpCRlRZQ0RFRUFJUU1NWndzQ1FDQUFRYUFFY1VHZ0JFY05BQ0FDTFFBdFFRSnhEUUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHV0V6WUNFQ0FDUVFRMkFnd01ad3NnQWdKL0lBSXZBVEJCRkhGQkZFWUVRRUVCSUFJdEFDaEJBVVlOQVJvZ0FpOEJNa0hsQUVZTUFRc2dBaTBBS1VFRlJnczZBQzVCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWlRaUEwVU5BQ0FDSUFNUkFBQWhBQXNDUUFKQUFrQUNRQUpBSUFBT0ZnSUJBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQU1FQ3lBQ1FRRTZBQzRMSUFJZ0FpOEJNRUhBQUhJN0FUQUxRU2NoQXd4UEN5QUNRU00yQWh3Z0FpQUJOZ0lVSUFKQnBSWTJBaEFnQWtFVk5nSU1RUUFoQXd4bkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZFVMTmdJUUlBSkJFVFlDREF4bUMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEUUVMUVE0aEF3eExDeUFBUVJWR0JFQWdBa0VDTmdJY0lBSWdBVFlDRkNBQ1FiQVlOZ0lRSUFKQkZUWUNERUVBSVFNTVpBdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0duRGpZQ0VDQUNRUkkyQWd3TVl3dEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dxSERZQ0VDQUNRUTgyQWd3TVlnc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFZ0NxZHFJZ0VRS3lJQVJRMEFJQUpCQlRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREdFTFFROGhBd3hIQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjMFROZ0lRSUFKQkREWUNEQXhmQzBJQklRb0xJQUZCQVdvaEFRSkFJQUlwQXlBaUMwTC8vLy8vLy8vLy93OVlCRUFnQWlBTFFnU0dJQXFFTndNZ0RBRUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCclFrMkFoQWdBa0VNTmdJTURGNExRU1FoQXd4RUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4Y0N5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBc0lnQkZCRUFnQVVFQmFpRUJERklMSUFKQkZ6WUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERnNMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFQWtBZ0FpQUFJQUVRTENJQVJRUkFJQUZCQVdvaEFRd0JDeUFDUVJZMkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZBeGJDMEVmSVFNTVFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dhRHpZQ0VDQUNRU0kyQWd3TVdRc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUxTSUFSUVJBSUFGQkFXb2hBUXhRQ3lBQ1FSUTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhZQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkFKQUlBSWdBQ0FCRUMwaUFFVUVRQ0FCUVFGcUlRRU1BUXNnQWtFVE5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1XQXRCSGlFRERENExRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCeGd3MkFoQWdBa0VqTmdJTURGWUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNVGdzZ0FrRVJOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNVlFzZ0FrRVFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFnd01WQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIR0REWUNFQ0FDUVNNMkFnd01Vd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIQUZUWUNFQ0FDUVFJMkFnd01VZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FDUUNBQ0lBQWdBUkF0SWdCRkJFQWdBVUVCYWlFQkRBRUxJQUpCRGpZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURGSUxRUnNoQXd3NEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY1lNTmdJUUlBSkJJellDREF4UUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDd2lBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRU5OZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNVUF0QkdpRURERFlMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQm1nODJBaEFnQWtFaU5nSU1ERTRMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFQWtBZ0FpQUFJQUVRTENJQVJRUkFJQUZCQVdvaEFRd0JDeUFDUVF3MkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZBeE9DMEVaSVFNTU5BdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dhRHpZQ0VDQUNRU0kyQWd3TVRBc2dBRUVWUndSQVFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJnd3cyQWhBZ0FrRVROZ0lNREV3TElBSkJDallDSENBQ0lBRTJBaFFnQWtIa0ZqWUNFQ0FDUVJVMkFneEJBQ0VEREVzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCSUFxbmFpSUJFQ3NpQUFSQUlBSkJCellDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERXNMUVJNaEF3d3hDeUFBUVJWSEJFQkJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hhRFRZQ0VDQUNRUlEyQWd3TVNnc2dBa0VlTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVNRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BaXdpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOUVNBQVFSVkdCRUFnQWtFRE5nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01TQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01Sd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01SZ3NnQWtFQU9nQXZJQUl0QUMxQkJIRkZEVDhMSUFKQkFEb0FMeUFDUVFFNkFEUkJBQ0VERENzTFFRQWhBeUFDUVFBMkFod2dBa0hrRVRZQ0VDQUNRUWMyQWd3Z0FpQUJRUUZxTmdJVURFTUxBa0FEUUFKQUlBRXRBQUJCQ21zT0JBQUNBZ0FDQ3lBRUlBRkJBV29pQVVjTkFBdEIzUUVoQXd4REN3SkFBa0FnQWkwQU5FRUJSdzBBUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKWUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRRQWdBRUVWUncwQklBSkIzQUUyQWh3Z0FpQUJOZ0lVSUFKQjFSWTJBaEFnQWtFVk5nSU1RUUFoQXd4RUMwSEJBU0VERENvTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIcEN6WUNFQ0FDUVI4MkFneEJBQ0VEREVJTEFrQUNRQ0FDTFFBb1FRRnJEZ0lFQVFBTFFjQUJJUU1NS1F0QnVRRWhBd3dvQ3lBQ1FRSTZBQzlCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWdBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVRVFFSENBU0VERENnTElBQkJGVWNFUUNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCcEF3MkFoQWdBa0VRTmdJTVFRQWhBd3hCQ3lBQ1Fkc0JOZ0ljSUFJZ0FUWUNGQ0FDUWZvV05nSVFJQUpCRlRZQ0RFRUFJUU1NUUFzZ0FTQUVSZ1JBUWRvQklRTU1RQXNnQVMwQUFFSElBRVlOQVNBQ1FRRTZBQ2dMUWF3QklRTU1KUXRCdndFaEF3d2tDeUFCSUFSSEJFQWdBa0VRTmdJSUlBSWdBVFlDQkVHK0FTRUREQ1FMUWRrQklRTU1QQXNnQVNBRVJnUkFRZGdCSVFNTVBBc2dBUzBBQUVISUFFY05CQ0FCUVFGcUlRRkJ2UUVoQXd3aUN5QUJJQVJHQkVCQjF3RWhBd3c3Q3dKQUFrQWdBUzBBQUVIRkFHc09FQUFGQlFVRkJRVUZCUVVGQlFVRkJRRUZDeUFCUVFGcUlRRkJ1d0VoQXd3aUN5QUJRUUZxSVFGQnZBRWhBd3doQzBIV0FTRURJQUVnQkVZTk9TQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFR0QwQUJxTFFBQVJ3MERJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBdzZDeUFDS0FJRUlRQWdBa0lBTndNQUlBSWdBQ0FHUVFGcUlnRVFKeUlBUlFSQVFjWUJJUU1NSVFzZ0FrSFZBVFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd3NUMwSFVBU0VESUFFZ0JFWU5PQ0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUdCMEFCcUxRQUFSdzBDSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc1Q3lBQ1FZRUVPd0VvSUFJb0FnUWhBQ0FDUWdBM0F3QWdBaUFBSUFaQkFXb2lBUkFuSWdBTkF3d0NDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCMkJzMkFoQWdBa0VJTmdJTUREWUxRYm9CSVFNTUhBc2dBa0hUQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzBDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDT0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEwQUlBQkJGVVlOQVNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCekE0MkFoQWdBa0VnTmdJTVFRQWhBd3d6QzBIa0FDRUREQmtMSUFKQitBQTJBaHdnQWlBQk5nSVVJQUpCeWhnMkFoQWdBa0VWTmdJTVFRQWhBd3d4QzBIU0FTRURJQVFnQVNJQVJnMHdJQVFnQVdzZ0FpZ0NBQ0lCYWlFRklBQWdBV3RCQkdvaEJnSkFBMEFnQUMwQUFDQUJRZnpQQUdvdEFBQkhEUUVnQVVFRVJnMERJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBRk5nSUFEREVMSUFKQkFEWUNIQ0FDSUFBMkFoUWdBa0dRTXpZQ0VDQUNRUWcyQWd3Z0FrRUFOZ0lBUVFBaEF3d3dDeUFCSUFSSEJFQWdBa0VPTmdJSUlBSWdBVFlDQkVHM0FTRUREQmNMUWRFQklRTU1Md3NnQWtFQU5nSUFJQVpCQVdvaEFRdEJ1QUVoQXd3VUN5QUJJQVJHQkVCQjBBRWhBd3d0Q3lBQkxRQUFRVEJySWdCQi93RnhRUXBKQkVBZ0FpQUFPZ0FxSUFGQkFXb2hBVUcyQVNFRERCUUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMFVJQUpCendFMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1MQXNnQVNBRVJnUkFRYzRCSVFNTUxBc0NRQ0FCTFFBQVFTNUdCRUFnQVVFQmFpRUJEQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBWSUFKQnpRRTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEF0QnRRRWhBd3dTQ3lBRUlBRWlCVVlFUUVITUFTRUREQ3NMUVFBaEFFRUJJUUZCQVNFR1FRQWhBd0pBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFJQVV0QUFCQk1Hc09DZ29KQUFFQ0F3UUZCZ2dMQzBFQ0RBWUxRUU1NQlF0QkJBd0VDMEVGREFNTFFRWU1BZ3RCQnd3QkMwRUlDeUVEUVFBaEFVRUFJUVlNQWd0QkNTRURRUUVoQUVFQUlRRkJBQ0VHREFFTFFRQWhBVUVCSVFNTElBSWdBem9BS3lBRlFRRnFJUU1DUUFKQUlBSXRBQzFCRUhFTkFBSkFBa0FDUUNBQ0xRQXFEZ01CQUFJRUN5QUdSUTBEREFJTElBQU5BUXdDQ3lBQlJRMEJDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FERUNnaUFFVUVRQ0FESVFFTUF3c2dBa0hKQVRZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3d3RDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FERUNnaUFFVUVRQ0FESVFFTUdBc2dBa0hLQVRZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3d3NDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FGRUNnaUFFVUVRQ0FGSVFFTUZnc2dBa0hMQVRZQ0hDQUNJQVUyQWhRZ0FpQUFOZ0lNRENzTFFiUUJJUU1NRVF0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0Fqd2lBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FDQUFCRUFnQUVFVlJnMEJJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1VEVFlDRUNBQ1FTRTJBZ3hCQUNFRERDc0xRYklCSVFNTUVRc2dBa0hJQVRZQ0hDQUNJQUUyQWhRZ0FrSEpGellDRUNBQ1FSVTJBZ3hCQUNFRERDa0xJQUpCQURZQ0FDQUdRUUZxSVFGQjlRQWhBd3dQQ3lBQ0xRQXBRUVZHQkVCQjR3QWhBd3dQQzBIaUFDRUREQTRMSUFBaEFTQUNRUUEyQWdBTElBSkJBRG9BTEVFSklRTU1EQXNnQWtFQU5nSUFJQWRCQVdvaEFVSEFBQ0VEREFzTFFRRUxPZ0FzSUFKQkFEWUNBQ0FHUVFGcUlRRUxRU2toQXd3SUMwRTRJUU1NQndzQ1FDQUJJQVJIQkVBRFFDQUJMUUFBUVlBK2FpMEFBQ0lBUVFGSEJFQWdBRUVDUncwRElBRkJBV29oQVF3RkN5QUVJQUZCQVdvaUFVY05BQXRCUGlFRERDRUxRVDRoQXd3Z0N3c2dBa0VBT2dBc0RBRUxRUXNoQXd3RUMwRTZJUU1NQXdzZ0FVRUJhaUVCUVMwaEF3d0NDeUFDSUFFNkFDd2dBa0VBTmdJQUlBWkJBV29oQVVFTUlRTU1BUXNnQWtFQU5nSUFJQVpCQVdvaEFVRUtJUU1NQUFzQUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBRTmdJUUlBSkJDVFlDREF3WEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZWtLTmdJUUlBSkJDVFlDREF3V0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmNRTmdJUUlBSkJDVFlDREF3VkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWndSTmdJUUlBSkJDVFlDREF3VUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBRTmdJUUlBSkJDVFlDREF3VEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZWtLTmdJUUlBSkJDVFlDREF3U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYmNRTmdJUUlBSkJDVFlDREF3UkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWndSTmdJUUlBSkJDVFlDREF3UUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWmNWTmdJUUlBSkJEellDREF3UEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWmNWTmdJUUlBSkJEellDREF3T0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY0FTTmdJUUlBSkJDellDREF3TkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWlVKTmdJUUlBSkJDellDREF3TUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZUVQTmdJUUlBSkJDallDREF3TEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZnNQTmdJUUlBSkJDallDREF3S0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZkVaTmdJUUlBSkJBallDREF3SkMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY1FVTmdJUUlBSkJBallDREF3SUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZklWTmdJUUlBSkJBallDREF3SEN5QUNRUUkyQWh3Z0FpQUJOZ0lVSUFKQm5CbzJBaEFnQWtFV05nSU1RUUFoQXd3R0MwRUJJUU1NQlF0QjFBQWhBeUFCSUFSR0RRUWdDRUVJYWlFSklBSW9BZ0FoQlFKQUFrQWdBU0FFUndSQUlBVkIyTUlBYWlFSElBUWdCV29nQVdzaEFDQUZRWDl6UVFwcUlnVWdBV29oQmdOQUlBRXRBQUFnQnkwQUFFY0VRRUVDSVFjTUF3c2dCVVVFUUVFQUlRY2dCaUVCREFNTElBVkJBV3NoQlNBSFFRRnFJUWNnQkNBQlFRRnFJZ0ZIRFFBTElBQWhCU0FFSVFFTElBbEJBVFlDQUNBQ0lBVTJBZ0FNQVFzZ0FrRUFOZ0lBSUFrZ0J6WUNBQXNnQ1NBQk5nSUVJQWdvQWd3aEFDQUlLQUlJRGdNQkJBSUFDd0FMSUFKQkFEWUNIQ0FDUWJVYU5nSVFJQUpCRnpZQ0RDQUNJQUJCQVdvMkFoUkJBQ0VEREFJTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtIS0dqWUNFQ0FDUVFrMkFneEJBQ0VEREFFTElBRWdCRVlFUUVFaUlRTU1BUXNnQWtFSk5nSUlJQUlnQVRZQ0JFRWhJUU1MSUFoQkVHb2tBQ0FEUlFSQUlBSW9BZ3doQUF3QkN5QUNJQU0yQWh4QkFDRUFJQUlvQWdRaUFVVU5BQ0FDSUFFZ0JDQUNLQUlJRVFFQUlnRkZEUUFnQWlBRU5nSVVJQUlnQVRZQ0RDQUJJUUFMSUFBTHZnSUJBbjhnQUVFQU9nQUFJQUJCM0FCcUlnRkJBV3RCQURvQUFDQUFRUUE2QUFJZ0FFRUFPZ0FCSUFGQkEydEJBRG9BQUNBQlFRSnJRUUE2QUFBZ0FFRUFPZ0FESUFGQkJHdEJBRG9BQUVFQUlBQnJRUU54SWdFZ0FHb2lBRUVBTmdJQVFkd0FJQUZyUVh4eElnSWdBR29pQVVFRWEwRUFOZ0lBQWtBZ0FrRUpTUTBBSUFCQkFEWUNDQ0FBUVFBMkFnUWdBVUVJYTBFQU5nSUFJQUZCREd0QkFEWUNBQ0FDUVJsSkRRQWdBRUVBTmdJWUlBQkJBRFlDRkNBQVFRQTJBaEFnQUVFQU5nSU1JQUZCRUd0QkFEWUNBQ0FCUVJSclFRQTJBZ0FnQVVFWWEwRUFOZ0lBSUFGQkhHdEJBRFlDQUNBQ0lBQkJCSEZCR0hJaUFtc2lBVUVnU1EwQUlBQWdBbW9oQUFOQUlBQkNBRGNER0NBQVFnQTNBeEFnQUVJQU53TUlJQUJDQURjREFDQUFRU0JxSVFBZ0FVRWdheUlCUVI5TERRQUxDd3RXQVFGL0FrQWdBQ2dDREEwQUFrQUNRQUpBQWtBZ0FDMEFMdzREQVFBREFnc2dBQ2dDT0NJQlJRMEFJQUVvQWl3aUFVVU5BQ0FBSUFFUkFBQWlBUTBEQzBFQUR3c0FDeUFBUWNNV05nSVFRUTRoQVFzZ0FRc2FBQ0FBS0FJTVJRUkFJQUJCMFJzMkFoQWdBRUVWTmdJTUN3c1VBQ0FBS0FJTVFSVkdCRUFnQUVFQU5nSU1Dd3NVQUNBQUtBSU1RUlpHQkVBZ0FFRUFOZ0lNQ3dzSEFDQUFLQUlNQ3djQUlBQW9BaEFMQ1FBZ0FDQUJOZ0lRQ3djQUlBQW9BaFFMRndBZ0FFRWtUd1JBQUFzZ0FFRUNkRUdnTTJvb0FnQUxGd0FnQUVFdVR3UkFBQXNnQUVFQ2RFR3dOR29vQWdBTHZ3a0JBWDlCNnlnaEFRSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCNUFCckR2UURZMklBQVdGaFlXRmhZUUlEQkFWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhCZ2NJQ1FvTERBME9EMkZoWVdGaEVHRmhZV0ZoWVdGaFlXRmhFV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZUklURkJVV0Z4Z1pHaHRoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoSEIwZUh5QWhJaU1rSlNZbktDa3FLeXd0TGk4d01USXpORFUyWVRjNE9UcGhZV0ZoWVdGaFlUdGhZV0U4WVdGaFlUMCtQMkZoWVdGaFlXRmhRR0ZoUVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UyRmhZV0ZoWVdGaFZGVldWMWhaV2x0aFhGMWhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZlWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWDJCaEMwSGhKdzhMUWFRaER3dEJ5eXdQQzBIK01ROExRY0FrRHd0QnF5UVBDMEdOS0E4TFFlSW1Ed3RCZ0RBUEMwRzVMdzhMUWRja0R3dEI3eDhQQzBIaEh3OExRZm9mRHd0QjhpQVBDMEdvTHc4TFFhNHlEd3RCaURBUEMwSHNKdzhMUVlJaUR3dEJqaDBQQzBIUUxnOExRY29qRHd0QnhUSVBDMEhmSEE4TFFkSWNEd3RCeENBUEMwSFhJQThMUWFJZkR3dEI3UzRQQzBHck1BOExRZFFsRHd0QnpDNFBDMEg2TGc4TFFmd3JEd3RCMGpBUEMwSHhIUThMUWJzZ0R3dEI5eXNQQzBHUU1ROExRZGN4RHd0Qm9pMFBDMEhVSnc4TFFlQXJEd3RCbnl3UEMwSHJNUThMUWRVZkR3dEJ5akVQQzBIZUpROExRZFFlRHd0QjlCd1BDMEduTWc4TFFiRWREd3RCb0IwUEMwRzVNUThMUWJ3d0R3dEJraUVQQzBHekpnOExRZWtzRHd0QnJCNFBDMEhVS3c4TFFmY21Ed3RCZ0NZUEMwR3dJUThMUWY0ZUR3dEJqU01QQzBHSkxROExRZmNpRHd0Qm9ERVBDMEd1SHc4TFFjWWxEd3RCNkI0UEMwR1RJZzhMUWNJdkR3dEJ3eDBQQzBHTExBOExRZUVkRHd0QmpTOFBDMEhxSVE4TFFiUXREd3RCMGk4UEMwSGZNZzhMUWRJeUR3dEI4REFQQzBHcElnOExRZmtqRHd0Qm1SNFBDMEcxTEE4TFFac3dEd3RCa2pJUEMwRzJLdzhMUWNJaUR3dEIrRElQQzBHZUpROExRZEFpRHd0QnVoNFBDMEdCSGc4TEFBdEIxaUVoQVFzZ0FRc1dBQ0FBSUFBdEFDMUIvZ0Z4SUFGQkFFZHlPZ0F0Q3hrQUlBQWdBQzBBTFVIOUFYRWdBVUVBUjBFQmRISTZBQzBMR1FBZ0FDQUFMUUF0UWZzQmNTQUJRUUJIUVFKMGNqb0FMUXNaQUNBQUlBQXRBQzFCOXdGeElBRkJBRWRCQTNSeU9nQXRDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQnhoRTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDQ0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjlnbzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjdSbzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQmxSQTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDRkNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQnFoczJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDR0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjdSTTJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDS0NJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQjlnZzJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSENJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQndoazJBaEJCR0NFRUN5QUVDejRCQW44Q1FDQUFLQUk0SWdORkRRQWdBeWdDSUNJRFJRMEFJQUFnQVNBQ0lBRnJJQU1SQVFBaUJFRi9SdzBBSUFCQmxCUTJBaEJCR0NFRUN5QUVDMWtCQW44Q1FDQUFMUUFvUVFGR0RRQWdBQzhCTWlJQlFlUUFhMEhrQUVrTkFDQUJRY3dCUmcwQUlBRkJzQUpHRFFBZ0FDOEJNQ0lBUWNBQWNRMEFRUUVoQWlBQVFZZ0VjVUdBQkVZTkFDQUFRU2h4UlNFQ0N5QUNDNHdCQVFKL0FrQUNRQUpBSUFBdEFDcEZEUUFnQUMwQUswVU5BQ0FBTHdFd0lnRkJBbkZGRFFFTUFnc2dBQzhCTUNJQlFRRnhSUTBCQzBFQklRSWdBQzBBS0VFQlJnMEFJQUF2QVRJaUFFSGtBR3RCNUFCSkRRQWdBRUhNQVVZTkFDQUFRYkFDUmcwQUlBRkJ3QUJ4RFFCQkFDRUNJQUZCaUFSeFFZQUVSZzBBSUFGQktIRkJBRWNoQWdzZ0FndFhBQ0FBUVJocVFnQTNBd0FnQUVJQU53TUFJQUJCT0dwQ0FEY0RBQ0FBUVRCcVFnQTNBd0FnQUVFb2FrSUFOd01BSUFCQklHcENBRGNEQUNBQVFSQnFRZ0EzQXdBZ0FFRUlha0lBTndNQUlBQkIzUUUyQWh3TEJnQWdBQkF5QzVvdEFRdC9Jd0JCRUdzaUNpUUFRYVRRQUNnQ0FDSUpSUVJBUWVUVEFDZ0NBQ0lGUlFSQVFmRFRBRUovTndJQVFlalRBRUtBZ0lTQWdJREFBRGNDQUVIazB3QWdDa0VJYWtGd2NVSFlxdFdxQlhNaUJUWUNBRUg0MHdCQkFEWUNBRUhJMHdCQkFEWUNBQXRCek5NQVFZRFVCRFlDQUVHYzBBQkJnTlFFTmdJQVFiRFFBQ0FGTmdJQVFhelFBRUYvTmdJQVFkRFRBRUdBckFNMkFnQURRQ0FCUWNqUUFHb2dBVUc4MEFCcUlnSTJBZ0FnQWlBQlFiVFFBR29pQXpZQ0FDQUJRY0RRQUdvZ0F6WUNBQ0FCUWREUUFHb2dBVUhFMEFCcUlnTTJBZ0FnQXlBQ05nSUFJQUZCMk5BQWFpQUJRY3pRQUdvaUFqWUNBQ0FDSUFNMkFnQWdBVUhVMEFCcUlBSTJBZ0FnQVVFZ2FpSUJRWUFDUncwQUMwR00xQVJCd2FzRE5nSUFRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFRY0NyQXpZQ0FFR2swQUJCaU5RRU5nSUFRY3ovQjBFNE5nSUFRWWpVQkNFSkN3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjdBRk5CRUJCak5BQUtBSUFJZ1pCRUNBQVFSTnFRWEJ4SUFCQkMwa2JJZ1JCQTNZaUFIWWlBVUVEY1FSQUFrQWdBVUVCY1NBQWNrRUJjeUlDUVFOMElnQkJ0TkFBYWlJQklBQkJ2TkFBYWlnQ0FDSUFLQUlJSWdOR0JFQkJqTkFBSUFaQmZpQUNkM0UyQWdBTUFRc2dBU0FETmdJSUlBTWdBVFlDREFzZ0FFRUlhaUVCSUFBZ0FrRURkQ0lDUVFOeU5nSUVJQUFnQW1vaUFDQUFLQUlFUVFGeU5nSUVEQkVMUVpUUUFDZ0NBQ0lJSUFSUERRRWdBUVJBQWtCQkFpQUFkQ0lDUVFBZ0FtdHlJQUVnQUhSeGFDSUFRUU4wSWdKQnROQUFhaUlCSUFKQnZOQUFhaWdDQUNJQ0tBSUlJZ05HQkVCQmpOQUFJQVpCZmlBQWQzRWlCallDQUF3QkN5QUJJQU0yQWdnZ0F5QUJOZ0lNQ3lBQ0lBUkJBM0kyQWdRZ0FFRURkQ0lBSUFScklRVWdBQ0FDYWlBRk5nSUFJQUlnQkdvaUJDQUZRUUZ5TmdJRUlBZ0VRQ0FJUVhoeFFiVFFBR29oQUVHZzBBQW9BZ0FoQXdKL1FRRWdDRUVEZG5RaUFTQUdjVVVFUUVHTTBBQWdBU0FHY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQXpZQ0RDQUFJQU0yQWdnZ0F5QUFOZ0lNSUFNZ0FUWUNDQXNnQWtFSWFpRUJRYURRQUNBRU5nSUFRWlRRQUNBRk5nSUFEQkVMUVpEUUFDZ0NBQ0lMUlEwQklBdG9RUUowUWJ6U0FHb29BZ0FpQUNnQ0JFRjRjU0FFYXlFRklBQWhBZ05BQWtBZ0FpZ0NFQ0lCUlFSQUlBSkJGR29vQWdBaUFVVU5BUXNnQVNnQ0JFRjRjU0FFYXlJRElBVkpJUUlnQXlBRklBSWJJUVVnQVNBQUlBSWJJUUFnQVNFQ0RBRUxDeUFBS0FJWUlRa2dBQ2dDRENJRElBQkhCRUJCbk5BQUtBSUFHaUFESUFBb0FnZ2lBVFlDQ0NBQklBTTJBZ3dNRUFzZ0FFRVVhaUlDS0FJQUlnRkZCRUFnQUNnQ0VDSUJSUTBESUFCQkVHb2hBZ3NEUUNBQ0lRY2dBU0lEUVJScUlnSW9BZ0FpQVEwQUlBTkJFR29oQWlBREtBSVFJZ0VOQUFzZ0IwRUFOZ0lBREE4TFFYOGhCQ0FBUWI5L1N3MEFJQUJCRTJvaUFVRndjU0VFUVpEUUFDZ0NBQ0lJUlEwQVFRQWdCR3NoQlFKQUFrQUNRQUovUVFBZ0JFR0FBa2tOQUJwQkh5QUVRZi8vL3dkTERRQWFJQVJCSmlBQlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb0xJZ1pCQW5SQnZOSUFhaWdDQUNJQ1JRUkFRUUFoQVVFQUlRTU1BUXRCQUNFQklBUkJHU0FHUVFGMmEwRUFJQVpCSDBjYmRDRUFRUUFoQXdOQUFrQWdBaWdDQkVGNGNTQUVheUlISUFWUERRQWdBaUVESUFjaUJRMEFRUUFoQlNBQ0lRRU1Bd3NnQVNBQ1FSUnFLQUlBSWdjZ0J5QUNJQUJCSFhaQkJIRnFRUkJxS0FJQUlnSkdHeUFCSUFjYklRRWdBRUVCZENFQUlBSU5BQXNMSUFFZ0EzSkZCRUJCQUNFRFFRSWdCblFpQUVFQUlBQnJjaUFJY1NJQVJRMERJQUJvUVFKMFFielNBR29vQWdBaEFRc2dBVVVOQVFzRFFDQUJLQUlFUVhoeElBUnJJZ0lnQlVraEFDQUNJQVVnQUJzaEJTQUJJQU1nQUJzaEF5QUJLQUlRSWdBRWZ5QUFCU0FCUVJScUtBSUFDeUlCRFFBTEN5QURSUTBBSUFWQmxOQUFLQUlBSUFSclR3MEFJQU1vQWhnaEJ5QURJQU1vQWd3aUFFY0VRRUdjMEFBb0FnQWFJQUFnQXlnQ0NDSUJOZ0lJSUFFZ0FEWUNEQXdPQ3lBRFFSUnFJZ0lvQWdBaUFVVUVRQ0FES0FJUUlnRkZEUU1nQTBFUWFpRUNDd05BSUFJaEJpQUJJZ0JCRkdvaUFpZ0NBQ0lCRFFBZ0FFRVFhaUVDSUFBb0FoQWlBUTBBQ3lBR1FRQTJBZ0FNRFF0QmxOQUFLQUlBSWdNZ0JFOEVRRUdnMEFBb0FnQWhBUUpBSUFNZ0JHc2lBa0VRVHdSQUlBRWdCR29pQUNBQ1FRRnlOZ0lFSUFFZ0Eyb2dBallDQUNBQklBUkJBM0kyQWdRTUFRc2dBU0FEUVFOeU5nSUVJQUVnQTJvaUFDQUFLQUlFUVFGeU5nSUVRUUFoQUVFQUlRSUxRWlRRQUNBQ05nSUFRYURRQUNBQU5nSUFJQUZCQ0dvaEFRd1BDMEdZMEFBb0FnQWlBeUFFU3dSQUlBUWdDV29pQUNBRElBUnJJZ0ZCQVhJMkFnUkJwTkFBSUFBMkFnQkJtTkFBSUFFMkFnQWdDU0FFUVFOeU5nSUVJQWxCQ0dvaEFRd1BDMEVBSVFFZ0JBSi9RZVRUQUNnQ0FBUkFRZXpUQUNnQ0FBd0JDMEh3MHdCQ2Z6Y0NBRUhvMHdCQ2dJQ0VnSUNBd0FBM0FnQkI1Tk1BSUFwQkRHcEJjSEZCMktyVnFnVnpOZ0lBUWZqVEFFRUFOZ0lBUWNqVEFFRUFOZ0lBUVlDQUJBc2lBQ0FFUWNjQWFpSUZhaUlHUVFBZ0FHc2lCM0VpQWs4RVFFSDgwd0JCTURZQ0FBd1BDd0pBUWNUVEFDZ0NBQ0lCUlEwQVFielRBQ2dDQUNJSUlBSnFJUUFnQUNBQlRTQUFJQWhMY1EwQVFRQWhBVUg4MHdCQk1EWUNBQXdQQzBISTB3QXRBQUJCQkhFTkJBSkFBa0FnQ1FSQVFjelRBQ0VCQTBBZ0FTZ0NBQ0lBSUFsTkJFQWdBQ0FCS0FJRWFpQUpTdzBEQ3lBQktBSUlJZ0VOQUFzTFFRQVFNeUlBUVg5R0RRVWdBaUVHUWVqVEFDZ0NBQ0lCUVFGcklnTWdBSEVFUUNBQ0lBQnJJQUFnQTJwQkFDQUJhM0ZxSVFZTElBUWdCazhOQlNBR1FmNy8vLzhIU3cwRlFjVFRBQ2dDQUNJREJFQkJ2Tk1BS0FJQUlnY2dCbW9oQVNBQklBZE5EUVlnQVNBRFN3MEdDeUFHRURNaUFTQUFSdzBCREFjTElBWWdBMnNnQjNFaUJrSCsvLy8vQjBzTkJDQUdFRE1oQUNBQUlBRW9BZ0FnQVNnQ0JHcEdEUU1nQUNFQkN3SkFJQVlnQkVISUFHcFBEUUFnQVVGL1JnMEFRZXpUQUNnQ0FDSUFJQVVnQm10cVFRQWdBR3R4SWdCQi92Ly8vd2RMQkVBZ0FTRUFEQWNMSUFBUU0wRi9Sd1JBSUFBZ0Jtb2hCaUFCSVFBTUJ3dEJBQ0FHYXhBekdnd0VDeUFCSWdCQmYwY05CUXdEQzBFQUlRTU1EQXRCQUNFQURBb0xJQUJCZjBjTkFndEJ5Tk1BUWNqVEFDZ0NBRUVFY2pZQ0FBc2dBa0grLy8vL0Iwc05BU0FDRURNaEFFRUFFRE1oQVNBQVFYOUdEUUVnQVVGL1JnMEJJQUFnQVU4TkFTQUJJQUJySWdZZ0JFRTRhazBOQVF0QnZOTUFRYnpUQUNnQ0FDQUdhaUlCTmdJQVFjRFRBQ2dDQUNBQlNRUkFRY0RUQUNBQk5nSUFDd0pBQWtBQ1FFR2swQUFvQWdBaUFnUkFRY3pUQUNFQkEwQWdBQ0FCS0FJQUlnTWdBU2dDQkNJRmFrWU5BaUFCS0FJSUlnRU5BQXNNQWd0Qm5OQUFLQUlBSWdGQkFFY2dBQ0FCVDNGRkJFQkJuTkFBSUFBMkFnQUxRUUFoQVVIUTB3QWdCallDQUVITTB3QWdBRFlDQUVHczBBQkJmellDQUVHdzBBQkI1Tk1BS0FJQU5nSUFRZGpUQUVFQU5nSUFBMEFnQVVISTBBQnFJQUZCdk5BQWFpSUNOZ0lBSUFJZ0FVRzAwQUJxSWdNMkFnQWdBVUhBMEFCcUlBTTJBZ0FnQVVIUTBBQnFJQUZCeE5BQWFpSUROZ0lBSUFNZ0FqWUNBQ0FCUWRqUUFHb2dBVUhNMEFCcUlnSTJBZ0FnQWlBRE5nSUFJQUZCMU5BQWFpQUNOZ0lBSUFGQklHb2lBVUdBQWtjTkFBdEJlQ0FBYTBFUGNTSUJJQUJxSWdJZ0JrRTRheUlESUFGcklnRkJBWEkyQWdSQnFOQUFRZlRUQUNnQ0FEWUNBRUdZMEFBZ0FUWUNBRUdrMEFBZ0FqWUNBQ0FBSUFOcVFUZzJBZ1FNQWdzZ0FDQUNUUTBBSUFJZ0Ewa05BQ0FCS0FJTVFRaHhEUUJCZUNBQ2EwRVBjU0lBSUFKcUlnTkJtTkFBS0FJQUlBWnFJZ2NnQUdzaUFFRUJjallDQkNBQklBVWdCbW8yQWdSQnFOQUFRZlRUQUNnQ0FEWUNBRUdZMEFBZ0FEWUNBRUdrMEFBZ0F6WUNBQ0FDSUFkcVFUZzJBZ1FNQVFzZ0FFR2MwQUFvQWdCSkJFQkJuTkFBSUFBMkFnQUxJQUFnQm1vaEEwSE0wd0FoQVFKQUFrQUNRQU5BSUFNZ0FTZ0NBRWNFUUNBQktBSUlJZ0VOQVF3Q0N3c2dBUzBBREVFSWNVVU5BUXRCek5NQUlRRURRQ0FCS0FJQUlnTWdBazBFUUNBRElBRW9BZ1JxSWdVZ0Frc05Bd3NnQVNnQ0NDRUJEQUFMQUFzZ0FTQUFOZ0lBSUFFZ0FTZ0NCQ0FHYWpZQ0JDQUFRWGdnQUd0QkQzRnFJZ2tnQkVFRGNqWUNCQ0FEUVhnZ0EydEJEM0ZxSWdZZ0JDQUphaUlFYXlFQklBSWdCa1lFUUVHazBBQWdCRFlDQUVHWTBBQkJtTkFBS0FJQUlBRnFJZ0EyQWdBZ0JDQUFRUUZ5TmdJRURBZ0xRYURRQUNnQ0FDQUdSZ1JBUWFEUUFDQUVOZ0lBUVpUUUFFR1UwQUFvQWdBZ0FXb2lBRFlDQUNBRUlBQkJBWEkyQWdRZ0FDQUVhaUFBTmdJQURBZ0xJQVlvQWdRaUJVRURjVUVCUncwR0lBVkJlSEVoQ0NBRlFmOEJUUVJBSUFWQkEzWWhBeUFHS0FJSUlnQWdCaWdDRENJQ1JnUkFRWXpRQUVHTTBBQW9BZ0JCZmlBRGQzRTJBZ0FNQndzZ0FpQUFOZ0lJSUFBZ0FqWUNEQXdHQ3lBR0tBSVlJUWNnQmlBR0tBSU1JZ0JIQkVBZ0FDQUdLQUlJSWdJMkFnZ2dBaUFBTmdJTURBVUxJQVpCRkdvaUFpZ0NBQ0lGUlFSQUlBWW9BaEFpQlVVTkJDQUdRUkJxSVFJTEEwQWdBaUVESUFVaUFFRVVhaUlDS0FJQUlnVU5BQ0FBUVJCcUlRSWdBQ2dDRUNJRkRRQUxJQU5CQURZQ0FBd0VDMEY0SUFCclFROXhJZ0VnQUdvaUJ5QUdRVGhySWdNZ0FXc2lBVUVCY2pZQ0JDQUFJQU5xUVRnMkFnUWdBaUFGUVRjZ0JXdEJEM0ZxUVQ5cklnTWdBeUFDUVJCcVNSc2lBMEVqTmdJRVFhalFBRUgwMHdBb0FnQTJBZ0JCbU5BQUlBRTJBZ0JCcE5BQUlBYzJBZ0FnQTBFUWFrSFUwd0FwQWdBM0FnQWdBMEhNMHdBcEFnQTNBZ2hCMU5NQUlBTkJDR28yQWdCQjBOTUFJQVkyQWdCQnpOTUFJQUEyQWdCQjJOTUFRUUEyQWdBZ0EwRWthaUVCQTBBZ0FVRUhOZ0lBSUFVZ0FVRUVhaUlCU3cwQUN5QUNJQU5HRFFBZ0F5QURLQUlFUVg1eE5nSUVJQU1nQXlBQ2F5SUZOZ0lBSUFJZ0JVRUJjallDQkNBRlFmOEJUUVJBSUFWQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnRkJBU0FGUVFOMmRDSURjVVVFUUVHTTBBQWdBU0FEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRRWdCVUgvLy84SFRRUkFJQVZCSmlBRlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBUXNnQWlBQk5nSWNJQUpDQURjQ0VDQUJRUUowUWJ6U0FHb2hBRUdRMEFBb0FnQWlBMEVCSUFGMElnWnhSUVJBSUFBZ0FqWUNBRUdRMEFBZ0F5QUdjallDQUNBQ0lBQTJBaGdnQWlBQ05nSUlJQUlnQWpZQ0RBd0JDeUFGUVJrZ0FVRUJkbXRCQUNBQlFSOUhHM1FoQVNBQUtBSUFJUU1DUUFOQUlBTWlBQ2dDQkVGNGNTQUZSZzBCSUFGQkhYWWhBeUFCUVFGMElRRWdBQ0FEUVFSeGFrRVFhaUlHS0FJQUlnTU5BQXNnQmlBQ05nSUFJQUlnQURZQ0dDQUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBQW9BZ2dpQVNBQ05nSU1JQUFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXRCbU5BQUtBSUFJZ0VnQkUwTkFFR2swQUFvQWdBaUFDQUVhaUlDSUFFZ0JHc2lBVUVCY2pZQ0JFR1kwQUFnQVRZQ0FFR2swQUFnQWpZQ0FDQUFJQVJCQTNJMkFnUWdBRUVJYWlFQkRBZ0xRUUFoQVVIODB3QkJNRFlDQUF3SEMwRUFJUUFMSUFkRkRRQUNRQ0FHS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFaR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdCa1liYWlBQU5nSUFJQUJGRFFFTElBQWdCellDR0NBR0tBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFHUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUlhaUVCSUFZZ0NHb2lCaWdDQkNFRkN5QUdJQVZCZm5FMkFnUWdBU0FFYWlBQk5nSUFJQVFnQVVFQmNqWUNCQ0FCUWY4QlRRUkFJQUZCZUhGQnROQUFhaUVBQW45QmpOQUFLQUlBSWdKQkFTQUJRUU4yZENJQmNVVUVRRUdNMEFBZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElnRWdCRFlDRENBQUlBUTJBZ2dnQkNBQU5nSU1JQVFnQVRZQ0NBd0JDMEVmSVFVZ0FVSC8vLzhIVFFSQUlBRkJKaUFCUVFoMlp5SUFhM1pCQVhFZ0FFRUJkR3RCUG1vaEJRc2dCQ0FGTmdJY0lBUkNBRGNDRUNBRlFRSjBRYnpTQUdvaEFFR1EwQUFvQWdBaUFrRUJJQVYwSWdOeFJRUkFJQUFnQkRZQ0FFR1EwQUFnQWlBRGNqWUNBQ0FFSUFBMkFoZ2dCQ0FFTmdJSUlBUWdCRFlDREF3QkN5QUJRUmtnQlVFQmRtdEJBQ0FGUVI5SEczUWhCU0FBS0FJQUlRQUNRQU5BSUFBaUFpZ0NCRUY0Y1NBQlJnMEJJQVZCSFhZaEFDQUZRUUYwSVFVZ0FpQUFRUVJ4YWtFUWFpSURLQUlBSWdBTkFBc2dBeUFFTmdJQUlBUWdBallDR0NBRUlBUTJBZ3dnQkNBRU5nSUlEQUVMSUFJb0FnZ2lBQ0FFTmdJTUlBSWdCRFlDQ0NBRVFRQTJBaGdnQkNBQ05nSU1JQVFnQURZQ0NBc2dDVUVJYWlFQkRBSUxBa0FnQjBVTkFBSkFJQU1vQWh3aUFVRUNkRUc4MGdCcUlnSW9BZ0FnQTBZRVFDQUNJQUEyQWdBZ0FBMEJRWkRRQUNBSVFYNGdBWGR4SWdnMkFnQU1BZ3NnQjBFUVFSUWdCeWdDRUNBRFJodHFJQUEyQWdBZ0FFVU5BUXNnQUNBSE5nSVlJQU1vQWhBaUFRUkFJQUFnQVRZQ0VDQUJJQUEyQWhnTElBTkJGR29vQWdBaUFVVU5BQ0FBUVJScUlBRTJBZ0FnQVNBQU5nSVlDd0pBSUFWQkQwMEVRQ0FESUFRZ0JXb2lBRUVEY2pZQ0JDQUFJQU5xSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFESUFScUlnSWdCVUVCY2pZQ0JDQURJQVJCQTNJMkFnUWdBaUFGYWlBRk5nSUFJQVZCL3dGTkJFQWdCVUY0Y1VHMDBBQnFJUUFDZjBHTTBBQW9BZ0FpQVVFQklBVkJBM1owSWdWeFJRUkFRWXpRQUNBQklBVnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDSUFBMkFnd2dBaUFCTmdJSURBRUxRUjhoQVNBRlFmLy8vd2ROQkVBZ0JVRW1JQVZCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQkN5QUNJQUUyQWh3Z0FrSUFOd0lRSUFGQkFuUkJ2TklBYWlFQVFRRWdBWFFpQkNBSWNVVUVRQ0FBSUFJMkFnQkJrTkFBSUFRZ0NISTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUFRc2dCVUVaSUFGQkFYWnJRUUFnQVVFZlJ4dDBJUUVnQUNnQ0FDRUVBa0FEUUNBRUlnQW9BZ1JCZUhFZ0JVWU5BU0FCUVIxMklRUWdBVUVCZENFQklBQWdCRUVFY1dwQkVHb2lCaWdDQUNJRURRQUxJQVlnQWpZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lNSUFJZ0FqWUNDQXdCQ3lBQUtBSUlJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FrRUFOZ0lZSUFJZ0FEWUNEQ0FDSUFFMkFnZ0xJQU5CQ0dvaEFRd0JDd0pBSUFsRkRRQUNRQ0FBS0FJY0lnRkJBblJCdk5JQWFpSUNLQUlBSUFCR0JFQWdBaUFETmdJQUlBTU5BVUdRMEFBZ0MwRitJQUYzY1RZQ0FBd0NDeUFKUVJCQkZDQUpLQUlRSUFCR0cyb2dBellDQUNBRFJRMEJDeUFESUFrMkFoZ2dBQ2dDRUNJQkJFQWdBeUFCTmdJUUlBRWdBellDR0FzZ0FFRVVhaWdDQUNJQlJRMEFJQU5CRkdvZ0FUWUNBQ0FCSUFNMkFoZ0xBa0FnQlVFUFRRUkFJQUFnQkNBRmFpSUJRUU55TmdJRUlBQWdBV29pQVNBQktBSUVRUUZ5TmdJRURBRUxJQUFnQkdvaUJ5QUZRUUZ5TmdJRUlBQWdCRUVEY2pZQ0JDQUZJQWRxSUFVMkFnQWdDQVJBSUFoQmVIRkJ0TkFBYWlFQlFhRFFBQ2dDQUNFREFuOUJBU0FJUVFOMmRDSUNJQVp4UlFSQVFZelFBQ0FDSUFaeU5nSUFJQUVNQVFzZ0FTZ0NDQXNpQWlBRE5nSU1JQUVnQXpZQ0NDQURJQUUyQWd3Z0F5QUNOZ0lJQzBHZzBBQWdCellDQUVHVTBBQWdCVFlDQUFzZ0FFRUlhaUVCQ3lBS1FSQnFKQUFnQVF0REFDQUFSUVJBUHdCQkVIUVBDd0pBSUFCQi8vOERjUTBBSUFCQkFFZ05BQ0FBUVJCMlFBQWlBRUYvUmdSQVFmelRBRUV3TmdJQVFYOFBDeUFBUVJCMER3c0FDd3ZjUHlJQVFZQUlDd2tCQUFBQUFnQUFBQU1BUVpRSUN3VUVBQUFBQlFCQnBBZ0xDUVlBQUFBSEFBQUFDQUJCM0FnTGlpMUpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJSEYxWlhKNUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlltOWtlUUJEYjI1MFpXNTBMVXhsYm1kMGFDQnZkbVZ5Wm14dmR3QkRhSFZ1YXlCemFYcGxJRzkyWlhKbWJHOTNBRkpsYzNCdmJuTmxJRzkyWlhKbWJHOTNBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJJVkZSUUwzZ3VlQ0J5WlhGMVpYTjBBRWx1ZG1Gc2FXUWdiV1YwYUc5a0lHWnZjaUJTVkZOUUwzZ3VlQ0J5WlhGMVpYTjBBRVY0Y0dWamRHVmtJRk5QVlZKRFJTQnRaWFJvYjJRZ1ptOXlJRWxEUlM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHTm9ZWElnYVc0Z2RYSnNJR1p5WVdkdFpXNTBJSE4wWVhKMEFFVjRjR1ZqZEdWa0lHUnZkQUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM04wWVhSMWN3QkpiblpoYkdsa0lISmxjM0J2Ym5ObElITjBZWFIxY3dCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1ekFGVnpaWElnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNKbGMyVjBZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZhR1ZoWkdWeVlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZiV1Z6YzJGblpWOWlaV2RwYm1BZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNOMFlYUjFjMTlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDNabGNuTnBiMjVmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5MWNteGZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMmhsWVdSbGNsOTJZV3gxWlY5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyMWxjM05oWjJWZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXRaWFJvYjJSZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOW9aV0ZrWlhKZlptbGxiR1JmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmYm1GdFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVZXNWxlSEJsWTNSbFpDQmphR0Z5SUdsdUlIVnliQ0J6WlhKMlpYSUFTVzUyWVd4cFpDQm9aV0ZrWlhJZ2RtRnNkV1VnWTJoaGNnQkpiblpoYkdsa0lHaGxZV1JsY2lCbWFXVnNaQ0JqYUdGeUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmRtVnljMmx2YmdCSmJuWmhiR2xrSUcxcGJtOXlJSFpsY25OcGIyNEFTVzUyWVd4cFpDQnRZV3B2Y2lCMlpYSnphVzl1QUVWNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlIWmxjbk5wYjI0QVJYaHdaV04wWldRZ1ExSk1SaUJoWm5SbGNpQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ1NGUlVVQ0IyWlhKemFXOXVBRWx1ZG1Gc2FXUWdhR1ZoWkdWeUlIUnZhMlZ1QUZOd1lXNGdZMkZzYkdKaFkyc2daWEp5YjNJZ2FXNGdiMjVmZFhKc0FFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeWN5QnBiaUIxY213QVZXNWxlSEJsWTNSbFpDQnpkR0Z5ZENCamFHRnlJR2x1SUhWeWJBQkViM1ZpYkdVZ1FDQnBiaUIxY213QVJXMXdkSGtnUTI5dWRHVnVkQzFNWlc1bmRHZ0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnUTI5dWRHVnVkQzFNWlc1bmRHZ0FSSFZ3YkdsallYUmxJRU52Ym5SbGJuUXRUR1Z1WjNSb0FFbHVkbUZzYVdRZ1kyaGhjaUJwYmlCMWNtd2djR0YwYUFCRGIyNTBaVzUwTFV4bGJtZDBhQ0JqWVc0bmRDQmlaU0J3Y21WelpXNTBJSGRwZEdnZ1ZISmhibk5tWlhJdFJXNWpiMlJwYm1jQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ2MybDZaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMmhsWVdSbGNsOTJZV3gxWlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDkyWVd4MVpRQkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpJSFpoYkhWbEFFMXBjM05wYm1jZ1pYaHdaV04wWldRZ1RFWWdZV1owWlhJZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQ0JvWldGa1pYSWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWlNCMllXeDFaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhGMWIzUmxaQ0IyWVd4MVpRQlFZWFZ6WldRZ1lua2diMjVmYUdWaFpHVnljMTlqYjIxd2JHVjBaUUJKYm5aaGJHbGtJRVZQUmlCemRHRjBaUUJ2Ymw5eVpYTmxkQ0J3WVhWelpRQnZibDlqYUhWdWExOW9aV0ZrWlhJZ2NHRjFjMlVBYjI1ZmJXVnpjMkZuWlY5aVpXZHBiaUJ3WVhWelpRQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdVZ2NHRjFjMlVBYjI1ZmMzUmhkSFZ6WDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDNabGNuTnBiMjVmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmZFhKc1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyTm9kVzVyWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJobFlXUmxjbDkyWVd4MVpWOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOXRaWE56WVdkbFgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyMWxkR2h2WkY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5b1pXRmtaWEpmWm1sbGJHUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1VnY0dGMWMyVUFWVzVsZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCemRHRnlkQ0JzYVc1bEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDI1aGJXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ1WVcxbEFGQmhkWE5sSUc5dUlFTlBUazVGUTFRdlZYQm5jbUZrWlFCUVlYVnpaU0J2YmlCUVVra3ZWWEJuY21Ga1pRQkZlSEJsWTNSbFpDQklWRlJRTHpJZ1EyOXVibVZqZEdsdmJpQlFjbVZtWVdObEFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmJXVjBhRzlrQUVWNGNHVmpkR1ZrSUhOd1lXTmxJR0ZtZEdWeUlHMWxkR2h2WkFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJobFlXUmxjbDltYVdWc1pBQlFZWFZ6WldRQVNXNTJZV3hwWkNCM2IzSmtJR1Z1WTI5MWJuUmxjbVZrQUVsdWRtRnNhV1FnYldWMGFHOWtJR1Z1WTI5MWJuUmxjbVZrQUZWdVpYaHdaV04wWldRZ1kyaGhjaUJwYmlCMWNtd2djMk5vWlcxaEFGSmxjWFZsYzNRZ2FHRnpJR2x1ZG1Gc2FXUWdZRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5ZQUJUVjBsVVEwaGZVRkpQV0ZrQVZWTkZYMUJTVDFoWkFFMUxRVU5VU1ZaSlZGa0FWVTVRVWs5RFJWTlRRVUpNUlY5RlRsUkpWRmtBUTA5UVdRQk5UMVpGUkY5UVJWSk5RVTVGVGxSTVdRQlVUMDlmUlVGU1RGa0FUazlVU1VaWkFFWkJTVXhGUkY5RVJWQkZUa1JGVGtOWkFFSkJSRjlIUVZSRlYwRlpBRkJNUVZrQVVGVlVBRU5JUlVOTFQxVlVBRWRCVkVWWFFWbGZWRWxOUlU5VlZBQlNSVkZWUlZOVVgxUkpUVVZQVlZRQVRrVlVWMDlTUzE5RFQwNU9SVU5VWDFSSlRVVlBWVlFBUTA5T1RrVkRWRWxQVGw5VVNVMUZUMVZVQUV4UFIwbE9YMVJKVFVWUFZWUUFUa1ZVVjA5U1MxOVNSVUZFWDFSSlRVVlBWVlFBVUU5VFZBQk5TVk5FU1ZKRlExUkZSRjlTUlZGVlJWTlVBRU5NU1VWT1ZGOURURTlUUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMHhQUVVSZlFrRk1RVTVEUlVSZlVrVlJWVVZUVkFCQ1FVUmZVa1ZSVlVWVFZBQklWRlJRWDFKRlVWVkZVMVJmVTBWT1ZGOVVUMTlJVkZSUVUxOVFUMUpVQUZKRlVFOVNWQUJKVFY5QlgxUkZRVkJQVkFCU1JWTkZWRjlEVDA1VVJVNVVBRTVQWDBOUFRsUkZUbFFBVUVGU1ZFbEJURjlEVDA1VVJVNVVBRWhRUlY5SlRsWkJURWxFWDBOUFRsTlVRVTVVQUVoUVJWOURRbDlTUlZORlZBQkhSVlFBU0ZCRlgxTlVVa2xEVkFCRFQwNUdURWxEVkFCVVJVMVFUMUpCVWxsZlVrVkVTVkpGUTFRQVVFVlNUVUZPUlU1VVgxSkZSRWxTUlVOVUFFTlBUazVGUTFRQVRWVk1WRWxmVTFSQlZGVlRBRWhRUlY5SlRsWkJURWxFWDFOVVFWUlZVd0JVVDA5ZlRVRk9XVjlTUlZGVlJWTlVVd0JGUVZKTVdWOUlTVTVVVXdCVlRrRldRVWxNUVVKTVJWOUdUMUpmVEVWSFFVeGZVa1ZCVTA5T1V3QlBVRlJKVDA1VEFGTlhTVlJEU0VsT1IxOVFVazlVVDBOUFRGTUFWa0ZTU1VGT1ZGOUJURk5QWDA1RlIwOVVTVUZVUlZNQVRWVk1WRWxRVEVWZlEwaFBTVU5GVXdCSlRsUkZVazVCVEY5VFJWSldSVkpmUlZKU1QxSUFWMFZDWDFORlVsWkZVbDlWVGt0T1QxZE9YMFZTVWs5U0FGSkJTVXhIVlU1ZlJWSlNUMUlBU1VSRlRsUkpWRmxmVUZKUFZrbEVSVkpmUVZWVVNFVk9WRWxEUVZSSlQwNWZSVkpTVDFJQVUxTk1YME5GVWxSSlJrbERRVlJGWDBWU1VrOVNBRWxPVmtGTVNVUmZXRjlHVDFKWFFWSkVSVVJmUms5U0FGTkZWRjlRUVZKQlRVVlVSVklBUjBWVVgxQkJVa0ZOUlZSRlVnQklVRVZmVlZORlVnQlRSVVZmVDFSSVJWSUFTRkJGWDBOQ1gwTklWVTVMWDBoRlFVUkZVZ0JOUzBOQlRFVk9SRUZTQUZORlZGVlFBRmRGUWw5VFJWSldSVkpmU1ZOZlJFOVhUZ0JVUlVGU1JFOVhUZ0JJVUVWZlEweFBVMFZFWDBOUFRrNUZRMVJKVDA0QVNFVlZVa2xUVkVsRFgwVllVRWxTUVZSSlQwNEFSRWxUUTA5T1RrVkRWRVZFWDA5UVJWSkJWRWxQVGdCT1QwNWZRVlZVU0U5U1NWUkJWRWxXUlY5SlRrWlBVazFCVkVsUFRnQklVRVZmU1U1V1FVeEpSRjlXUlZKVFNVOU9BRWhRUlY5RFFsOU5SVk5UUVVkRlgwSkZSMGxPQUZOSlZFVmZTVk5mUmxKUFdrVk9BRWhRUlY5SlRsWkJURWxFWDBoRlFVUkZVbDlVVDB0RlRnQkpUbFpCVEVsRVgxUlBTMFZPQUVaUFVrSkpSRVJGVGdCRlRraEJUa05GWDFsUFZWSmZRMEZNVFFCSVVFVmZTVTVXUVV4SlJGOVZVa3dBUWt4UFEwdEZSRjlDV1Y5UVFWSkZUbFJCVEY5RFQwNVVVazlNQUUxTFEwOU1BRUZEVEFCSVVFVmZTVTVVUlZKT1FVd0FVa1ZSVlVWVFZGOUlSVUZFUlZKZlJrbEZURVJUWDFSUFQxOU1RVkpIUlY5VlRrOUdSa2xEU1VGTUFFaFFSVjlQU3dCVlRreEpUa3NBVlU1TVQwTkxBRkJTU1FCU1JWUlNXVjlYU1ZSSUFFaFFSVjlKVGxaQlRFbEVYME5QVGxSRlRsUmZURVZPUjFSSUFFaFFSVjlWVGtWWVVFVkRWRVZFWDBOUFRsUkZUbFJmVEVWT1IxUklBRVpNVlZOSUFGQlNUMUJRUVZSRFNBQk5MVk5GUVZKRFNBQlZVa2xmVkU5UFgweFBUa2NBVUZKUFEwVlRVMGxPUndCTlNWTkRSVXhNUVU1RlQxVlRYMUJGVWxOSlUxUkZUbFJmVjBGU1RrbE9Sd0JOU1ZORFJVeE1RVTVGVDFWVFgxZEJVazVKVGtjQVNGQkZYMGxPVmtGTVNVUmZWRkpCVGxOR1JWSmZSVTVEVDBSSlRrY0FSWGh3WldOMFpXUWdRMUpNUmdCSVVFVmZTVTVXUVV4SlJGOURTRlZPUzE5VFNWcEZBRTFQVmtVQVEwOU9WRWxPVlVVQVNGQkZYME5DWDFOVVFWUlZVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1UxOURUMDFRVEVWVVJRQklVRVZmUTBKZlZrVlNVMGxQVGw5RFQwMVFURVZVUlFCSVVFVmZRMEpmVlZKTVgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZTRVZCUkVWU1gxWkJURlZGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlEU0ZWT1MxOUZXRlJGVGxOSlQwNWZWa0ZNVlVWZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBOSVZVNUxYMFZZVkVWT1UwbFBUbDlPUVUxRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWTlRRVWRGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlOUlZSSVQwUmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwaEZRVVJGVWw5R1NVVk1SRjlEVDAxUVRFVlVSUUJFUlV4RlZFVUFTRkJGWDBsT1ZrRk1TVVJmUlU5R1gxTlVRVlJGQUVsT1ZrRk1TVVJmVTFOTVgwTkZVbFJKUmtsRFFWUkZBRkJCVlZORkFFNVBYMUpGVTFCUFRsTkZBRlZPVTFWUVVFOVNWRVZFWDAxRlJFbEJYMVJaVUVVQVIwOU9SUUJPVDFSZlFVTkRSVkJVUVVKTVJRQlRSVkpXU1VORlgxVk9RVlpCU1V4QlFreEZBRkpCVGtkRlgwNVBWRjlUUVZSSlUwWkpRVUpNUlFCUFVrbEhTVTVmU1ZOZlZVNVNSVUZEU0VGQ1RFVUFVa1ZUVUU5T1UwVmZTVk5mVTFSQlRFVUFVRlZTUjBVQVRVVlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJRQlNSVkZWUlZOVVgwaEZRVVJGVWw5VVQwOWZURUZTUjBVQVVFRlpURTlCUkY5VVQwOWZURUZTUjBVQVNVNVRWVVpHU1VOSlJVNVVYMU5VVDFKQlIwVUFTRkJGWDFCQlZWTkZSRjlWVUVkU1FVUkZBRWhRUlY5UVFWVlRSVVJmU0RKZlZWQkhVa0ZFUlFCVFQxVlNRMFVBUVU1T1QxVk9RMFVBVkZKQlEwVUFTRkJGWDFWT1JWaFFSVU5VUlVSZlUxQkJRMFVBUkVWVFExSkpRa1VBVlU1VFZVSlRRMUpKUWtVQVVrVkRUMUpFQUVoUVJWOUpUbFpCVEVsRVgwMUZWRWhQUkFCT1QxUmZSazlWVGtRQVVGSlBVRVpKVGtRQVZVNUNTVTVFQUZKRlFrbE9SQUJWVGtGVlZFaFBVa2xhUlVRQVRVVlVTRTlFWDA1UFZGOUJURXhQVjBWRUFFaFVWRkJmVmtWU1UwbFBUbDlPVDFSZlUxVlFVRTlTVkVWRUFFRk1Va1ZCUkZsZlVrVlFUMUpVUlVRQVFVTkRSVkJVUlVRQVRrOVVYMGxOVUV4RlRVVk9WRVZFQUV4UFQxQmZSRVZVUlVOVVJVUUFTRkJGWDBOU1gwVllVRVZEVkVWRUFFaFFSVjlNUmw5RldGQkZRMVJGUkFCRFVrVkJWRVZFQUVsTlgxVlRSVVFBU0ZCRlgxQkJWVk5GUkFCVVNVMUZUMVZVWDA5RFExVlNSVVFBVUVGWlRVVk9WRjlTUlZGVlNWSkZSQUJRVWtWRFQwNUVTVlJKVDA1ZlVrVlJWVWxTUlVRQVVGSlBXRmxmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFUa1ZVVjA5U1MxOUJWVlJJUlU1VVNVTkJWRWxQVGw5U1JWRlZTVkpGUkFCTVJVNUhWRWhmVWtWUlZVbFNSVVFBVTFOTVgwTkZVbFJKUmtsRFFWUkZYMUpGVVZWSlVrVkVBRlZRUjFKQlJFVmZVa1ZSVlVsU1JVUUFVRUZIUlY5RldGQkpVa1ZFQUZCU1JVTlBUa1JKVkVsUFRsOUdRVWxNUlVRQVJWaFFSVU5VUVZSSlQwNWZSa0ZKVEVWRUFGSkZWa0ZNU1VSQlZFbFBUbDlHUVVsTVJVUUFVMU5NWDBoQlRrUlRTRUZMUlY5R1FVbE1SVVFBVEU5RFMwVkVBRlJTUVU1VFJrOVNUVUZVU1U5T1gwRlFVRXhKUlVRQVRrOVVYMDFQUkVsR1NVVkVBRTVQVkY5RldGUkZUa1JGUkFCQ1FVNUVWMGxFVkVoZlRFbE5TVlJmUlZoRFJVVkVSVVFBVTBsVVJWOUpVMTlQVmtWU1RFOUJSRVZFQUVoRlFVUUFSWGh3WldOMFpXUWdTRlJVVUM4QUFGNFRBQUFtRXdBQU1CQUFBUEFYQUFDZEV3QUFGUklBQURrWEFBRHdFZ0FBQ2hBQUFIVVNBQUN0RWdBQWdoTUFBRThVQUFCL0VBQUFvQlVBQUNNVUFBQ0pFZ0FBaXhRQUFFMFZBQURVRVFBQXp4UUFBQkFZQUFESkZnQUEzQllBQU1FUkFBRGdGd0FBdXhRQUFIUVVBQUI4RlFBQTVSUUFBQWdYQUFBZkVBQUFaUlVBQUtNVUFBQW9GUUFBQWhVQUFKa1ZBQUFzRUFBQWl4a0FBRThQQUFEVURnQUFhaEFBQU00UUFBQUNGd0FBaVE0QUFHNFRBQUFjRXdBQVpoUUFBRllYQUFEQkV3QUF6Uk1BQUd3VEFBQm9Gd0FBWmhjQUFGOFhBQUFpRXdBQXpnOEFBR2tPQUFEWURnQUFZeFlBQU1zVEFBQ3FEZ0FBS0JjQUFDWVhBQURGRXdBQVhSWUFBT2dSQUFCbkV3QUFaUk1BQVBJV0FBQnpFd0FBSFJjQUFQa1dBQUR6RVFBQXp3NEFBTTRWQUFBTUVnQUFzeEVBQUtVUkFBQmhFQUFBTWhjQUFMc1RBRUg1TlFzQkFRQkJrRFlMNEFFQkFRSUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFCQi9UY0xBUUVBUVpFNEMxNENBd0lDQWdJQ0FBQUNBZ0FDQWdBQ0FnSUNBZ0lDQWdJQ0FBUUFBQUFBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ0FDQUVIOU9Rc0JBUUJCa1RvTFhnSUFBZ0lDQWdJQUFBSUNBQUlDQUFJQ0FnSUNBZ0lDQWdJQUF3QUVBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQUFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUNBQUlBUWZBN0N3MXNiM05sWldWd0xXRnNhWFpsQUVHSlBBc0JBUUJCb0R3TDRBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkJpVDRMQVFFQVFhQStDK2NCQVFFQkFRRUJBUUVCQVFFQkFnRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUZqYUhWdWEyVmtBRUd3d0FBTFh3RUJBQUVCQVFFQkFBQUJBUUFCQVFBQkFRRUJBUUVCQVFFQkFBQUFBQUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUVHUXdnQUxJV1ZqZEdsdmJtVnVkQzFzWlc1bmRHaHZibkp2ZUhrdFkyOXVibVZqZEdsdmJnQkJ3TUlBQ3kxeVlXNXpabVZ5TFdWdVkyOWthVzVuY0dkeVlXUmxEUW9OQ2cwS1UwME5DZzBLVkZSUUwwTkZMMVJUVUM4QVFmbkNBQXNGQVFJQUFRTUFRWkREQUF2Z0FRUUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFFSDV4QUFMQlFFQ0FBRURBRUdReFFBTDRBRUVBUUVGQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkIrY1lBQ3dRQkFBQUJBRUdSeHdBTDN3RUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFFSDZ5QUFMQkFFQUFBSUFRWkRKQUF0ZkF3UUFBQVFFQkFRRUJBUUVCQVFFQlFRRUJBUUVCQVFFQkFRRUJBQUVBQVlIQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRQUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUFBQVFBUWZyS0FBc0VBUUFBQVFCQmtNc0FDd0VCQUVHcXl3QUxRUUlBQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QUFBQUFBQUFNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUVINnpBQUxCQUVBQUFFQVFaRE5BQXNCQVFCQm1zMEFDd1lDQUFBQUFBSUFRYkhOQUFzNkF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0JCOE00QUM1WUJUazlWVGtORlJVTkxUMVZVVGtWRFZFVlVSVU5TU1VKRlRGVlRTRVZVUlVGRVUwVkJVa05JVWtkRlExUkpWa2xVV1V4RlRrUkJVbFpGVDFSSlJsbFFWRWxQVGxORFNGTkZRVmxUVkVGVVEwaEhSVTlTUkVsU1JVTlVUMUpVVWtOSVVFRlNRVTFGVkVWU1ZWSkRSVUpUUTFKSlFrVkJVa1JQVjA1QlEwVkpUa1JPUzBOTFZVSlRRMUpKUWtWSVZGUlFMMEZFVkZBdicsICdiYXNlNjQnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB9ysPC0GQMQ8LQdcxDwtBoi0PC0HUJw8LQeArDwtBnywPC0HrMQ8LQdUfDwtByjEPC0HeJQ8LQdQeDwtB9BwPC0GnMg8LQbEdDwtBoB0PC0G5MQ8LQbwwDwtBkiEPC0GzJg8LQeksDwtBrB4PC0HUKw8LQfcmDwtBgCYPC0GwIQ8LQf4eDwtBjSMPC0GJLQ8LQfciDwtBoDEPC0GuHw8LQcYlDwtB6B4PC0GTIg8LQcIvDwtBwx0PC0GLLA8LQeEdDwtBjS8PC0HqIQ8LQbQtDwtB0i8PC0HfMg8LQdIyDwtB8DAPC0GpIg8LQfkjDwtBmR4PC0G1LA8LQZswDwtBkjIPC0G2Kw8LQcIiDwtB+DIPC0GeJQ8LQdAiDwtBuh4PC0GBHg8LAAtB1iEhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBxhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9go2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7Ro2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBqhs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7RM2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBwhk2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlBQ2AhBBGCEECyAEC1kBAn8CQCAALQAoQQFGDQAgAC8BMiIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEwIgFBAnFFDQEMAgsgAC8BMCIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATIiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQd0BNgIcCwYAIAAQMguaLQELfyMAQRBrIgokAEGk0AAoAgAiCUUEQEHk0wAoAgAiBUUEQEHw0wBCfzcCAEHo0wBCgICEgICAwAA3AgBB5NMAIApBCGpBcHFB2KrVqgVzIgU2AgBB+NMAQQA2AgBByNMAQQA2AgALQczTAEGA1AQ2AgBBnNAAQYDUBDYCAEGw0AAgBTYCAEGs0ABBfzYCAEHQ0wBBgKwDNgIAA0AgAUHI0ABqIAFBvNAAaiICNgIAIAIgAUG00ABqIgM2AgAgAUHA0ABqIAM2AgAgAUHQ0ABqIAFBxNAAaiIDNgIAIAMgAjYCACABQdjQAGogAUHM0ABqIgI2AgAgAiADNgIAIAFB1NAAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNQEQcGrAzYCAEGo0ABB9NMAKAIANgIAQZjQAEHAqwM2AgBBpNAAQYjUBDYCAEHM/wdBODYCAEGI1AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYzQACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQbTQAGoiASAAQbzQAGooAgAiACgCCCIDRgRAQYzQACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GU0AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQbTQAGoiASACQbzQAGooAgAiAigCCCIDRgRAQYzQACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUG00ABqIQBBoNAAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBjNAAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGg0AAgBDYCAEGU0AAgBTYCAAwRC0GQ0AAoAgAiC0UNASALaEECdEG80gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZzQACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGQ0AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbzSAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEG80gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQZTQACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBnNAAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQZTQACgCACIDIARPBEBBoNAAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GU0AAgAjYCAEGg0AAgADYCACABQQhqIQEMDwtBmNAAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQaTQACAANgIAQZjQACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0Hk0wAoAgAEQEHs0wAoAgAMAQtB8NMAQn83AgBB6NMAQoCAhICAgMAANwIAQeTTACAKQQxqQXBxQdiq1aoFczYCAEH40wBBADYCAEHI0wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB/NMAQTA2AgAMDwsCQEHE0wAoAgAiAUUNAEG80wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB/NMAQTA2AgAMDwtByNMALQAAQQRxDQQCQAJAIAkEQEHM0wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDMiAEF/Rg0FIAIhBkHo0wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUHE0wAoAgAiAwRAQbzTACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhAzIgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhAzIQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHs0wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDNBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQMxoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQcjTAEHI0wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhAzIQBBABAzIQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbzTAEG80wAoAgAgBmoiATYCAEHA0wAoAgAgAUkEQEHA0wAgATYCAAsCQAJAAkBBpNAAKAIAIgIEQEHM0wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZzQACgCACIBQQBHIAAgAU9xRQRAQZzQACAANgIAC0EAIQFB0NMAIAY2AgBBzNMAIAA2AgBBrNAAQX82AgBBsNAAQeTTACgCADYCAEHY0wBBADYCAANAIAFByNAAaiABQbzQAGoiAjYCACACIAFBtNAAaiIDNgIAIAFBwNAAaiADNgIAIAFB0NAAaiABQcTQAGoiAzYCACADIAI2AgAgAUHY0ABqIAFBzNAAaiICNgIAIAIgAzYCACABQdTQAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQajQAEH00wAoAgA2AgBBmNAAIAE2AgBBpNAAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQZjQACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQajQAEH00wAoAgA2AgBBmNAAIAA2AgBBpNAAIAM2AgAgAiAHakE4NgIEDAELIABBnNAAKAIASQRAQZzQACAANgIACyAAIAZqIQNBzNMAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQczTACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBpNAAIAQ2AgBBmNAAQZjQACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0Gg0AAoAgAgBkYEQEGg0AAgBDYCAEGU0ABBlNAAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGM0ABBjNAAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGo0ABB9NMAKAIANgIAQZjQACABNgIAQaTQACAHNgIAIANBEGpB1NMAKQIANwIAIANBzNMAKQIANwIIQdTTACADQQhqNgIAQdDTACAGNgIAQczTACAANgIAQdjTAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQbTQAGohAAJ/QYzQACgCACIBQQEgBUEDdnQiA3FFBEBBjNAAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEG80gBqIQBBkNAAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBkNAAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQZjQACgCACIBIARNDQBBpNAAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBmNAAIAE2AgBBpNAAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB/NMAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbzSAGoiAygCACAGRgRAIAMgADYCACAADQFBkNAAQZDQACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQbTQAGohAAJ/QYzQACgCACICQQEgAUEDdnQiAXFFBEBBjNAAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEG80gBqIQBBkNAAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBkNAAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBvNIAaiICKAIAIANGBEAgAiAANgIAIAANAUGQ0AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBtNAAaiEAAn9BjNAAKAIAIgFBASAFQQN2dCIFcUUEQEGM0AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbzSAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQZDQACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbzSAGoiAigCACAARgRAIAIgAzYCACADDQFBkNAAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQbTQAGohAUGg0AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGM0AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBoNAAIAc2AgBBlNAAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEH80wBBMDYCAEF/DwsgAEEQdA8LAAsL3D8iAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==', 'base64')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUV4QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGxsaHR0cFxcbGxodHRwX3NpbWQtd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIuZnJvbSgnQUdGemJRRUFBQUFCSndkZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFKL2Z3QmdCSDkvZjM4QmYyQUFBR0FEZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBRUEyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF5MHNCUVlBQUFJQUFBQUFBQUFDQVFJQUFnSUNBQUFEQUFBQUFBTURBd01CQVFFQkFRRUJBUUVBQUFJQUFBQUVCUUZ3QVJJU0JRTUJBQUlHQ0FGL0FVR0ExQVFMQjlFRklnWnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFJR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUpHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQXZER3hzYUhSMGNGOWhiR3h2WXdBTEJtMWhiR3h2WXdBeEMyeHNhSFIwY0Y5bWNtVmxBQXdFWm5KbFpRQU1EMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU5GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FQRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJBV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFSRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBU0RHeHNhSFIwY0Y5eVpYTmxkQUFURG14c2FIUjBjRjlsZUdWamRYUmxBQlFVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZRMXNiR2gwZEhCZlptbHVhWE5vQUJZTWJHeG9kSFJ3WDNCaGRYTmxBQmNOYkd4b2RIUndYM0psYzNWdFpRQVlHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFaRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR2hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FiRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQndVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhSRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWVFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFmRW14c2FIUjBjRjl6ZEdGMGRYTmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSWRiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMnRsWlhCZllXeHBkbVVBSXlSc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmRISmhibk5tWlhKZlpXNWpiMlJwYm1jQUpCaHNiR2gwZEhCZmJXVnpjMkZuWlY5dVpXVmtjMTlsYjJZQUxna1hBUUJCQVFzUkFRSURCQVVLQmdjckxTd3FLU2dsSnlZSzc3TUNMQllBUVlqUUFDZ0NBQVJBQUF0QmlOQUFRUUUyQWdBTEZBQWdBQkF3SUFBZ0FqWUNPQ0FBSUFFNkFDZ0xGQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQXZFQUFMSGdFQmYwSEFBQkF5SWdFUU1DQUJRWUFJTmdJNElBRWdBRG9BS0NBQkM0OE1BUWQvQWtBZ0FFVU5BQ0FBUVFocklnRWdBRUVFYXlnQ0FDSUFRWGh4SWdScUlRVUNRQ0FBUVFGeERRQWdBRUVEY1VVTkFTQUJJQUVvQWdBaUFHc2lBVUdjMEFBb0FnQkpEUUVnQUNBRWFpRUVBa0FDUUVHZzBBQW9BZ0FnQVVjRVFDQUFRZjhCVFFSQUlBQkJBM1loQXlBQktBSUlJZ0FnQVNnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUJLQUlZSVFZZ0FTQUJLQUlNSWdCSEJFQWdBQ0FCS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFGQkZHb2lBeWdDQUNJQ1JRUkFJQUVvQWhBaUFrVU5BaUFCUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRktBSUVJZ0JCQTNGQkEwY05BaUFGSUFCQmZuRTJBZ1JCbE5BQUlBUTJBZ0FnQlNBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUJLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQUZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0FVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FCS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUJRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRlR3MEFJQVVvQWdRaUFFRUJjVVVOQUFKQUFrQUNRQUpBSUFCQkFuRkZCRUJCcE5BQUtBSUFJQVZHQkVCQnBOQUFJQUUyQWdCQm1OQUFRWmpRQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05Ca0dVMEFCQkFEWUNBRUdnMEFCQkFEWUNBQXdHQzBHZzBBQW9BZ0FnQlVZRVFFR2cwQUFnQVRZQ0FFR1UwQUJCbE5BQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdHQ3lBQVFYaHhJQVJxSVFRZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQlNnQ0NDSUFJQVVvQWd3aUFrWUVRRUdNMEFCQmpOQUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lBUndSQVFaelFBQ2dDQUJvZ0FDQUZLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQVZCRkdvaUF5Z0NBQ0lDUlFSQUlBVW9BaEFpQWtVTkFpQUZRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGSUFCQmZuRTJBZ1FnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FGS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFWR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBRktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFGUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05BRUdVMEFBZ0JEWUNBQXdCQ3lBRVFmOEJUUVJBSUFSQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FFUVFOMmRDSURjVVVFUUVHTTBBQWdBaUFEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0lnQVRZQ0RDQUFJQUUyQWdnZ0FTQUFOZ0lNSUFFZ0FqWUNDQXdCQzBFZklRSWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBZ3NnQVNBQ05nSWNJQUZDQURjQ0VDQUNRUUowUWJ6U0FHb2hBQUpBUVpEUUFDZ0NBQ0lEUVFFZ0FuUWlCM0ZGQkVBZ0FDQUJOZ0lBUVpEUUFDQURJQWR5TmdJQUlBRWdBRFlDR0NBQklBRTJBZ2dnQVNBQk5nSU1EQUVMSUFSQkdTQUNRUUYyYTBFQUlBSkJIMGNiZENFQ0lBQW9BZ0FoQUFKQUEwQWdBQ0lES0FJRVFYaHhJQVJHRFFFZ0FrRWRkaUVBSUFKQkFYUWhBaUFESUFCQkJIRnFRUkJxSWdjb0FnQWlBQTBBQ3lBSElBRTJBZ0FnQVNBRE5nSVlJQUVnQVRZQ0RDQUJJQUUyQWdnTUFRc2dBeWdDQ0NJQUlBRTJBZ3dnQXlBQk5nSUlJQUZCQURZQ0dDQUJJQU0yQWd3Z0FTQUFOZ0lJQzBHczBBQkJyTkFBS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFFBRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJBd0lBQWdCRFlDT0NBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBdTc0Z0VDQjM4RGZpQUJJQUpxSVFRQ1FDQUFJZ0lvQWd3aUFBMEFJQUlvQWdRRVFDQUNJQUUyQWdRTEl3QkJFR3NpQ0NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSW9BaHdpQTBFQmF3N2RBZG9CQWRrQkFnTUVCUVlIQ0FrS0N3d05EdGdCRHhEWEFSRVMxZ0VURkJVV0Z4Z1pHaHZnQWQ4QkhCMGUxUUVmSUNFaUl5UWwxQUVtSnlncEtpc3Mwd0hTQVMwdTBRSFFBUzh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJ0c0JSMGhKU3M4QnpnRkx6UUZNekFGTlRrOVFVVkpUVkZWV1YxaFpXbHRjWFY1ZllHRmlZMlJsWm1kb2FXcHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnl3SEtBYmdCeVFHNUFjZ0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnRUEzQUVMUVFBTXhnRUxRUTRNeFFFTFFRME14QUVMUVE4TXd3RUxRUkFNd2dFTFFSTU13UUVMUVJRTXdBRUxRUlVNdndFTFFSWU12Z0VMUVJnTXZRRUxRUmtNdkFFTFFSb011d0VMUVJzTXVnRUxRUndNdVFFTFFSME11QUVMUVFnTXR3RUxRUjRNdGdFTFFTQU10UUVMUVI4TXRBRUxRUWNNc3dFTFFTRU1zZ0VMUVNJTXNRRUxRU01Nc0FFTFFTUU1yd0VMUVJJTXJnRUxRUkVNclFFTFFTVU1yQUVMUVNZTXF3RUxRU2NNcWdFTFFTZ01xUUVMUWNNQkRLZ0JDMEVxREtjQkMwRXJES1lCQzBFc0RLVUJDMEV0REtRQkMwRXVES01CQzBFdkRLSUJDMEhFQVF5aEFRdEJNQXlnQVF0Qk5BeWZBUXRCREF5ZUFRdEJNUXlkQVF0Qk1neWNBUXRCTXd5YkFRdEJPUXlhQVF0Qk5ReVpBUXRCeFFFTW1BRUxRUXNNbHdFTFFUb01sZ0VMUVRZTWxRRUxRUW9NbEFFTFFUY01rd0VMUVRnTWtnRUxRVHdNa1FFTFFUc01rQUVMUVQwTWp3RUxRUWtNamdFTFFTa01qUUVMUVQ0TWpBRUxRVDhNaXdFTFFjQUFESW9CQzBIQkFBeUpBUXRCd2dBTWlBRUxRY01BREljQkMwSEVBQXlHQVF0QnhRQU1oUUVMUWNZQURJUUJDMEVYRElNQkMwSEhBQXlDQVF0QnlBQU1nUUVMUWNrQURJQUJDMEhLQUF4L0MwSExBQXgrQzBITkFBeDlDMEhNQUF4OEMwSE9BQXg3QzBIUEFBeDZDMEhRQUF4NUMwSFJBQXg0QzBIU0FBeDNDMEhUQUF4MkMwSFVBQXgxQzBIV0FBeDBDMEhWQUF4ekMwRUdESElMUWRjQURIRUxRUVVNY0F0QjJBQU1id3RCQkF4dUMwSFpBQXh0QzBIYUFBeHNDMEhiQUF4ckMwSGNBQXhxQzBFRERHa0xRZDBBREdnTFFkNEFER2NMUWQ4QURHWUxRZUVBREdVTFFlQUFER1FMUWVJQURHTUxRZU1BREdJTFFRSU1ZUXRCNUFBTVlBdEI1UUFNWHd0QjVnQU1YZ3RCNXdBTVhRdEI2QUFNWEF0QjZRQU1Xd3RCNmdBTVdndEI2d0FNV1F0QjdBQU1XQXRCN1FBTVZ3dEI3Z0FNVmd0Qjd3QU1WUXRCOEFBTVZBdEI4UUFNVXd0QjhnQU1VZ3RCOHdBTVVRdEI5QUFNVUF0QjlRQU1Ud3RCOWdBTVRndEI5d0FNVFF0QitBQU1UQXRCK1FBTVN3dEIrZ0FNU2d0Qit3QU1TUXRCL0FBTVNBdEIvUUFNUnd0Qi9nQU1SZ3RCL3dBTVJRdEJnQUVNUkF0QmdRRU1Rd3RCZ2dFTVFndEJnd0VNUVF0QmhBRU1RQXRCaFFFTVB3dEJoZ0VNUGd0Qmh3RU1QUXRCaUFFTVBBdEJpUUVNT3d0QmlnRU1PZ3RCaXdFTU9RdEJqQUVNT0F0QmpRRU1Od3RCamdFTU5ndEJqd0VNTlF0QmtBRU1OQXRCa1FFTU13dEJrZ0VNTWd0Qmt3RU1NUXRCbEFFTU1BdEJsUUVNTHd0QmxnRU1MZ3RCbHdFTUxRdEJtQUVNTEF0Qm1RRU1Ld3RCbWdFTUtndEJtd0VNS1F0Qm5BRU1LQXRCblFFTUp3dEJuZ0VNSmd0Qm53RU1KUXRCb0FFTUpBdEJvUUVNSXd0Qm9nRU1JZ3RCb3dFTUlRdEJwQUVNSUF0QnBRRU1Id3RCcGdFTUhndEJwd0VNSFF0QnFBRU1IQXRCcVFFTUd3dEJxZ0VNR2d0QnF3RU1HUXRCckFFTUdBdEJyUUVNRnd0QnJnRU1GZ3RCQVF3VkMwR3ZBUXdVQzBHd0FRd1RDMEd4QVF3U0MwR3pBUXdSQzBHeUFRd1FDMEcwQVF3UEMwRzFBUXdPQzBHMkFRd05DMEczQVF3TUMwRzRBUXdMQzBHNUFRd0tDMEc2QVF3SkMwRzdBUXdJQzBIR0FRd0hDMEc4QVF3R0MwRzlBUXdGQzBHK0FRd0VDMEcvQVF3REMwSEFBUXdDQzBIQ0FRd0JDMEhCQVFzaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUREc1lCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZEh5QWhJeVVtS0NvckxDOHdNVEl6TkRVMk56azZPenc5bEFOQVFrUkZSa2xMVGs5UVVWSlRWRlZXV0ZwYlhGMWVYMkJoWW1Oa1pXWm5hR3BzYjNCeGMzVjJlSGw2ZTN4L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY3NCekFITkFjNEJ6d0dLQTRrRGlBT0hBNFFEZ3dPQUEvc0MrZ0w1QXZnQzl3TDBBdk1DOGdMTEFzRUNzQUxaQVFzZ0FTQUVSdzN3QWtIZEFTRURETE1EQ3lBQklBUkhEY2dCUWNNQklRTU1zZ01MSUFFZ0JFY05lMEgzQUNFRERMRURDeUFCSUFSSERYQkI3d0FoQXd5d0F3c2dBU0FFUncxcFFlb0FJUU1NcndNTElBRWdCRWNOWlVIb0FDRURESzREQ3lBQklBUkhEV0pCNWdBaEF3eXRBd3NnQVNBRVJ3MGFRUmdoQXd5c0F3c2dBU0FFUncwVlFSSWhBd3lyQXdzZ0FTQUVSdzFDUWNVQUlRTU1xZ01MSUFFZ0JFY05ORUUvSVFNTXFRTUxJQUVnQkVjTk1rRThJUU1NcUFNTElBRWdCRWNOSzBFeElRTU1wd01MSUFJdEFDNUJBVVlObndNTXdRSUxRUUFoQUFKQUFrQUNRQ0FDTFFBcVJRMEFJQUl0QUN0RkRRQWdBaThCTUNJRFFRSnhSUTBCREFJTElBSXZBVEFpQTBFQmNVVU5BUXRCQVNFQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdWQjVBQnJRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRFFjQUFjUTBBUVFBaEFDQURRWWdFY1VHQUJFWU5BQ0FEUVNoeFFRQkhJUUFMSUFKQkFEc0JNQ0FDUVFBNkFDOGdBRVVOM3dJZ0FrSUFOd01nRE9BQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNNQVNBQVFSVkhEZDBDSUFKQkJEWUNIQ0FDSUFFMkFoUWdBa0d3R0RZQ0VDQUNRUlUyQWd4QkFDRURES1FEQ3lBQklBUkdCRUJCQmlFRERLUURDeUFCUVFGcUlRRkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBQTNaQWd3Y0N5QUNRZ0EzQXlCQkVpRURESWtEQ3lBQklBUkhEUlpCSFNFRERLRURDeUFCSUFSSEJFQWdBVUVCYWlFQlFSQWhBd3lJQXd0QkJ5RURES0FEQ3lBQ0lBSXBBeUFpQ2lBRUlBRnJyU0lMZlNJTVFnQWdDaUFNV2hzM0F5QWdDaUFMV0EzVUFrRUlJUU1NbndNTElBRWdCRWNFUUNBQ1FRazJBZ2dnQWlBQk5nSUVRUlFoQXd5R0F3dEJDU0VEREo0REN5QUNLUU1nUWdCU0RjY0JJQUlnQWk4Qk1FR0FBWEk3QVRBTVFnc2dBU0FFUncwL1FkQUFJUU1NbkFNTElBRWdCRVlFUUVFTElRTU1uQU1MSUFGQkFXb2hBVUVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVUNJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGM4Q0RNWUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzR0FTQUFRUlZIRGMwQ0lBSkJDellDSENBQ0lBRTJBaFFnQWtHQ0dUWUNFQ0FDUVJVMkFneEJBQ0VEREpvREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBNSUFCQkZVY055Z0lnQWtFYU5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1tUU1MUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKTUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjUUJJQUJCRlVjTnh3SWdBa0VMTmdJY0lBSWdBVFlDRkNBQ1FaRVhOZ0lRSUFKQkZUWUNERUVBSVFNTW1BTUxJQUVnQkVZRVFFRVBJUU1NbUFNTElBRXRBQUFpQUVFN1JnMEhJQUJCRFVjTnhBSWdBVUVCYWlFQkRNTUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzREFTQUFRUlZIRGNJQ0lBSkJEellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpZREN3TkFJQUV0QUFCQjhEVnFMUUFBSWdCQkFVY0VRQ0FBUVFKSERjRUNJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQlFRRnFJZ0VRTFNJQURjSUNETVVCQ3lBRUlBRkJBV29pQVVjTkFBdEJFaUVEREpVREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNGQVNBQVFSVkhEYjBDSUFKQkd6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESlFEQ3lBQklBUkdCRUJCRmlFRERKUURDeUFDUVFvMkFnZ2dBaUFCTmdJRVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSklJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY0lCSUFCQkZVY051UUlnQWtFVk5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1rd01MSUFFZ0JFY0VRQU5BSUFFdEFBQkI4RGRxTFFBQUlnQkJBa2NFUUFKQUlBQkJBV3NPQk1RQ3ZRSUF2Z0s5QWdzZ0FVRUJhaUVCUVFnaEF3ejhBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSVWhBd3lUQXd0QkZTRURESklEQ3dOQUlBRXRBQUJCOERscUxRQUFJZ0JCQWtjRVFDQUFRUUZyRGdURkFyY0N3d0s0QXJjQ0N5QUVJQUZCQVdvaUFVY05BQXRCR0NFRERKRURDeUFCSUFSSEJFQWdBa0VMTmdJSUlBSWdBVFlDQkVFSElRTU0rQUlMUVJraEF3eVFBd3NnQVVFQmFpRUJEQUlMSUFFZ0JFWUVRRUVhSVFNTWp3TUxBa0FnQVMwQUFFRU5hdzRVdFFHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndFQXZ3RUxRUUFoQXlBQ1FRQTJBaHdnQWtHdkN6WUNFQ0FDUVFJMkFnd2dBaUFCUVFGcU5nSVVESTREQ3lBQklBUkdCRUJCR3lFRERJNERDeUFCTFFBQUlnQkJPMGNFUUNBQVFRMUhEYkVDSUFGQkFXb2hBUXk2QVFzZ0FVRUJhaUVCQzBFaUlRTU04d0lMSUFFZ0JFWUVRRUVjSVFNTWpBTUxRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDN3UUxBQWdBQkFnTUVCUVlIMEFIUUFkQUIwQUhRQWRBQjBBRUlDUW9MREEzUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCRGc4UUVSSVQwQUVMUWdJaENnekFBZ3RDQXlFS0RMOENDMElFSVFvTXZnSUxRZ1VoQ2d5OUFndENCaUVLREx3Q0MwSUhJUW9NdXdJTFFnZ2hDZ3k2QWd0Q0NTRUtETGtDQzBJS0lRb011QUlMUWdzaENneTNBZ3RDRENFS0RMWUNDMElOSVFvTXRRSUxRZzRoQ2d5MEFndENEeUVLRExNQ0MwSUtJUW9Nc2dJTFFnc2hDZ3l4QWd0Q0RDRUtETEFDQzBJTklRb01yd0lMUWc0aENneXVBZ3RDRHlFS0RLMENDMElBSVFvQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OOEFDdndJQUFRSURCQVVHQjc0Q3ZnSytBcjRDdmdLK0FyNENDQWtLQ3d3TnZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQWc0UEVCRVNFNzRDQzBJQ0lRb012d0lMUWdNaENneStBZ3RDQkNFS0RMMENDMElGSVFvTXZBSUxRZ1loQ2d5N0FndENCeUVLRExvQ0MwSUlJUW9NdVFJTFFna2hDZ3k0QWd0Q0NpRUtETGNDQzBJTElRb010Z0lMUWd3aENneTFBZ3RDRFNFS0RMUUNDMElPSVFvTXN3SUxRZzhoQ2d5eUFndENDaUVLRExFQ0MwSUxJUW9Nc0FJTFFnd2hDZ3l2QWd0Q0RTRUtESzRDQzBJT0lRb01yUUlMUWc4aENneXNBZ3NnQWlBQ0tRTWdJZ29nQkNBQmE2MGlDMzBpREVJQUlBb2dERm9iTndNZ0lBb2dDMWdOcHdKQkh5RURESWtEQ3lBQklBUkhCRUFnQWtFSk5nSUlJQUlnQVRZQ0JFRWxJUU1NOEFJTFFTQWhBd3lJQXd0QkFTRUZJQUl2QVRBaUEwRUljVVVFUUNBQ0tRTWdRZ0JTSVFVTEFrQWdBaTBBTGdSQVFRRWhBQ0FDTFFBcFFRVkdEUUVnQTBIQUFIRkZJQVZ4UlEwQkMwRUFJUUFnQTBIQUFIRU5BRUVDSVFBZ0EwRUljUTBBSUFOQmdBUnhCRUFDUUNBQ0xRQW9RUUZIRFFBZ0FpMEFMVUVLY1EwQVFRVWhBQXdDQzBFRUlRQU1BUXNnQTBFZ2NVVUVRQUpBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BRUVFSVFBZ0EwRW9jVVVOQWlBRFFZZ0VjVUdBQkVZTkFndEJBQ0VBREFFTFFRQkJBeUFDS1FNZ1VCc2hBQXNnQUVFQmF3NEZ2Z0lBc0FFQnBBS2hBZ3RCRVNFRERPMENDeUFDUVFFNkFDOE1oQU1MSUFFZ0JFY05uUUpCSkNFRERJUURDeUFCSUFSSERSeEJ4Z0FoQXd5REF3dEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba1FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOSnlBQVFSVkhEWmdDSUFKQjBBQTJBaHdnQWlBQk5nSVVJQUpCa1JnMkFoQWdBa0VWTmdJTVFRQWhBd3lDQXdzZ0FTQUVSZ1JBUVNnaEF3eUNBd3RCQUNFRElBSkJBRFlDQkNBQ1FRdzJBZ2dnQWlBQklBRVFLaUlBUlEyVUFpQUNRU2MyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNEQXlCQXdzZ0FTQUVSZ1JBUVNraEF3eUJBd3NnQVMwQUFDSUFRU0JHRFJNZ0FFRUpSdzJWQWlBQlFRRnFJUUVNRkFzZ0FTQUVSd1JBSUFGQkFXb2hBUXdXQzBFcUlRTU0vd0lMSUFFZ0JFWUVRRUVySVFNTS93SUxJQUV0QUFBaUFFRUpSeUFBUVNCSGNRMlFBaUFDTFFBc1FRaEhEZDBDSUFKQkFEb0FMQXpkQWdzZ0FTQUVSZ1JBUVN3aEF3eitBZ3NnQVMwQUFFRUtSdzJPQWlBQlFRRnFJUUVNc0FFTElBRWdCRWNOaWdKQkx5RUREUHdDQ3dOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JJUUNpQUtJQW9RQ2hnSUxJQVFnQVVFQmFpSUJSdzBBQzBFeElRTU0rd0lMUVRJaEF5QUJJQVJHRGZvQ0lBSW9BZ0FpQUNBRUlBRnJhaUVISUFFZ0FHdEJBMm9oQmdKQUEwQWdBRUh3TzJvdEFBQWdBUzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FFRURSZ1JBUVFZaEFRemlBZ3NnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBYzJBZ0FNK3dJTElBSkJBRFlDQUF5R0FndEJNeUVESUFRZ0FTSUFSZzM1QWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFRaHFJUVlDUUFOQUlBRkI5RHRxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkNFWUVRRUVGSVFFTTRRSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUG9DQ3lBQ1FRQTJBZ0FnQUNFQkRJVUNDMEUwSVFNZ0JDQUJJZ0JHRGZnQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdKQUEwQWdBVUhRd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJCVVlFUUVFSElRRU00QUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBrQ0N5QUNRUUEyQWdBZ0FDRUJESVFDQ3lBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSZzBKRElFQ0N5QUVJQUZCQVdvaUFVY05BQXRCTUNFRERQZ0NDMEV3SVFNTTl3SUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CUDhCL2dIK0FmOEIvZ0VMSUFRZ0FVRUJhaUlCUncwQUMwRTRJUU1NOXdJTFFUZ2hBd3oyQWdzRFFDQUJMUUFBSWdCQklFY2dBRUVKUjNFTjlnRWdCQ0FCUVFGcUlnRkhEUUFMUVR3aEF3ejFBZ3NEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JQa0JCQVQ1QVFBTElBQkJMRVlOOVFFTUF3c2dCQ0FCUVFGcUlnRkhEUUFMUVQ4aEF3ejBBZ3RCd0FBaEF5QUJJQVJHRGZNQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUdBUUdzdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0Rkc0NJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUFFDQ3lBQ1FRQTJBZ0FMUVRZaEF3elpBZ3NnQVNBRVJnUkFRY0VBSVFNTThnSUxJQUpCRERZQ0NDQUNJQUUyQWdRZ0FpMEFMRUVCYXc0RSt3SHVBZXdCNndIVUFnc2dBVUVCYWlFQkRQb0JDeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVFNTTNBSUxJQUZCQVdvaEFVRXlJUU1NMndJTElBRkJBV29oQVVFeklRTU0yZ0lMRFA0QkN5QUVJQUZCQVdvaUFVY05BQXRCTlNFRERQQUNDMEUxSVFNTTd3SUxJQUVnQkVjRVFBTkFJQUV0QUFCQmdEeHFMUUFBUVFGSERmY0JJQVFnQVVFQmFpSUJSdzBBQzBFOUlRTU03d0lMUVQwaEF3enVBZ3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkFTQUFRUlZIRGVZQklBSkJ3Z0EyQWh3Z0FpQUJOZ0lVSUFKQjR4ZzJBaEFnQWtFVk5nSU1RUUFoQXd6dEFnc2dBVUVCYWlFQkMwRThJUU1NMGdJTElBRWdCRVlFUUVIQ0FDRURET3NDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXN3Q3pBTFJBc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1BZ0RNQWdzZ0JDQUJRUUZxSWdGSERRQUxRY0lBSVFNTTZ3SUxJQUZCQVdvaEFTQUNMUUF0UVFGeFJRMytBUXRCTENFREROQUNDeUFCSUFSSERkNEJRY1FBSVFNTTZBSUxBMEFnQVMwQUFFR1F3QUJxTFFBQVFRRkhEWndCSUFRZ0FVRUJhaUlCUncwQUMwSEZBQ0VERE9jQ0N5QUJMUUFBSWdCQklFWU4vZ0VnQUVFNlJ3M0FBaUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0FOM2dFTTNRRUxRY2NBSVFNZ0JDQUJJZ0JHRGVVQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkJrTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdndJZ0FVRUZSZzNDQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6bEFndEJ5QUFoQXlBRUlBRWlBRVlONUFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRUphaUVHQTBBZ0FVR1d3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzIrQWtFQ0lBRkJDVVlOd2dJYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPUUNDeUFCSUFSR0JFQkJ5UUFoQXd6a0Fnc0NRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlNEFhdzRIQUw4Q3Z3Sy9BcjhDdndJQnZ3SUxJQUZCQVdvaEFVRStJUU1NeXdJTElBRkJBV29oQVVFL0lRTU15Z0lMUWNvQUlRTWdCQ0FCSWdCR0RlSUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFR0lBQWdBV3RCQVdvaEJ3TkFJQUZCb01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZBSWdBVUVCUmcyK0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQmpZQ0FBemlBZ3RCeXdBaEF5QUVJQUVpQUVZTjRRSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVPYWlFR0EwQWdBVUdpd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyN0FpQUJRUTVHRGI0Q0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPRUNDMEhNQUNFRElBUWdBU0lBUmczZ0FpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUTlxSVFZRFFDQUJRY0RDQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRGJvQ1FRTWdBVUVQUmcyK0Fob2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFDSUFjMkFnQU00QUlMUWMwQUlRTWdCQ0FCSWdCR0RkOENJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCME1JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnVRSkJCQ0FCUVFWR0RiMENHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpmQWdzZ0FTQUVSZ1JBUWM0QUlRTU0zd0lMQWtBQ1FBSkFBa0FnQVMwQUFDSUFRU0J5SUFBZ0FFSEJBR3RCL3dGeFFScEpHMEgvQVhGQjR3QnJEaE1BdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0NBYndDdkFLOEFnSUR2QUlMSUFGQkFXb2hBVUhCQUNFRERNZ0NDeUFCUVFGcUlRRkJ3Z0FoQXd6SEFnc2dBVUVCYWlFQlFjTUFJUU1NeGdJTElBRkJBV29oQVVIRUFDRURETVVDQ3lBQklBUkhCRUFnQWtFTk5nSUlJQUlnQVRZQ0JFSEZBQ0VERE1VQ0MwSFBBQ0VERE4wQ0N3SkFBa0FnQVMwQUFFRUthdzRFQVpBQmtBRUFrQUVMSUFGQkFXb2hBUXRCS0NFRERNTUNDeUFCSUFSR0JFQkIwUUFoQXd6Y0Fnc2dBUzBBQUVFZ1J3MEFJQUZCQVdvaEFTQUNMUUF0UVFGeFJRM1FBUXRCRnlFRERNRUNDeUFCSUFSSERjc0JRZElBSVFNTTJRSUxRZE1BSVFNZ0FTQUVSZzNZQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRRnFJUVVEUUNBQkxRQUFJQUJCMXNJQWFpMEFBRWNOeHdFZ0FFRUJSZzNLQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCallDQUF6WUFnc2dBU0FFUmdSQVFkVUFJUU1NMkFJTElBRXRBQUJCQ2tjTndnRWdBVUVCYWlFQkRNb0JDeUFCSUFSR0JFQkIxZ0FoQXd6WEFnc0NRQUpBSUFFdEFBQkJDbXNPQkFEREFjTUJBY01CQ3lBQlFRRnFJUUVNeWdFTElBRkJBV29oQVVIS0FDRURETDBDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1BDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURiOEJRYzBBSVFNTXZBSUxJQUl0QUNsQklrWU56d0lNaVFFTElBUWdBU0lGUmdSQVFkc0FJUU1NMUFJTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBRkxRQUFRVEJyRGdyRkFjUUJBQUVDQXdRRkJnakRBUXRCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBMEVBSVFGQkFDRUdETDBCQzBFSklRTkJBU0VBUVFBaEFVRUFJUVlNdkFFTElBRWdCRVlFUUVIZEFDRURETk1DQ3lBQkxRQUFRUzVIRGJnQklBRkJBV29oQVF5SUFRc2dBU0FFUncyMkFVSGZBQ0VERE5FQ0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUhRQUNFRERMZ0NDMEhnQUNFREROQUNDMEhoQUNFRElBRWdCRVlOendJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQTBBZ0FTMEFBQ0FBUWVMQ0FHb3RBQUJIRGJFQklBQkJBMFlOc3dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXp3SUxRZUlBSVFNZ0FTQUVSZzNPQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlEUUNBQkxRQUFJQUJCNXNJQWFpMEFBRWNOc0FFZ0FFRUNSZzJ2QVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6T0FndEI0d0FoQXlBQklBUkdEYzBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ05BSUFFdEFBQWdBRUhwd2dCcUxRQUFSdzJ2QVNBQVFRTkdEYTBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRE0wQ0N5QUJJQVJHQkVCQjVRQWhBd3pOQWdzZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTnFnRkIxZ0FoQXd5ekFnc2dBU0FFUndSQUEwQWdBUzBBQUNJQVFTQkhCRUFDUUFKQUFrQWdBRUhJQUdzT0N3QUJzd0d6QWJNQnN3R3pBYk1Cc3dHekFRS3pBUXNnQVVFQmFpRUJRZElBSVFNTXR3SUxJQUZCQVdvaEFVSFRBQ0VERExZQ0N5QUJRUUZxSVFGQjFBQWhBd3kxQWdzZ0JDQUJRUUZxSWdGSERRQUxRZVFBSVFNTXpBSUxRZVFBSVFNTXl3SUxBMEFnQVMwQUFFSHd3Z0JxTFFBQUlnQkJBVWNFUUNBQVFRSnJEZ09uQWFZQnBRR2tBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFlWUFJUU1NeWdJTElBRkJBV29nQVNBRVJ3MENHa0huQUNFRERNa0NDd05BSUFFdEFBQkI4TVFBYWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdTaUFhRUJvQUVBbndFTFFkY0FJUU1Nc1FJTElBUWdBVUVCYWlJQlJ3MEFDMEhvQUNFRERNZ0NDeUFCSUFSR0JFQkI2UUFoQXd6SUFnc0NRQ0FCTFFBQUlnQkJDbXNPR3JjQm13R2JBYlFCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCcEFHYkFac0JBSmtCQ3lBQlFRRnFDeUVCUVFZaEF3eXRBZ3NEUUNBQkxRQUFRZkRHQUdvdEFBQkJBVWNOZlNBRUlBRkJBV29pQVVjTkFBdEI2Z0FoQXd6RkFnc2dBVUVCYWlBQklBUkhEUUlhUWVzQUlRTU14QUlMSUFFZ0JFWUVRRUhzQUNFRERNUUNDeUFCUVFGcURBRUxJQUVnQkVZRVFFSHRBQ0VERE1NQ0N5QUJRUUZxQ3lFQlFRUWhBd3lvQWdzZ0FTQUVSZ1JBUWU0QUlRTU13UUlMQWtBQ1FBSkFJQUV0QUFCQjhNZ0FhaTBBQUVFQmF3NEhrQUdQQVk0QkFId0JBbzBCQ3lBQlFRRnFJUUVNQ3dzZ0FVRUJhZ3lUQVF0QkFDRURJQUpCQURZQ0hDQUNRWnNTTmdJUUlBSkJCellDRENBQ0lBRkJBV28yQWhRTXdBSUxBa0FEUUNBQkxRQUFRZkRJQUdvdEFBQWlBRUVFUndSQUFrQUNRQ0FBUVFGckRnZVVBWk1Ca2dHTkFRQUVBWTBCQzBIYUFDRURES29DQ3lBQlFRRnFJUUZCM0FBaEF3eXBBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlOEFJUU1Nd0FJTElBRkJBV29Na1FFTElBUWdBU0lBUmdSQVFmQUFJUU1NdndJTElBQXRBQUJCTDBjTkFTQUFRUUZxSVFFTUJ3c2dCQ0FCSWdCR0JFQkI4UUFoQXd5K0Fnc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZDBBSVFNTXBRSUxJQUZCQ21zaUEwRVdTdzBBSUFBaEFVRUJJQU4wUVltQWdBSnhEZmtCQzBFQUlRTWdBa0VBTmdJY0lBSWdBRFlDRkNBQ1FZd2NOZ0lRSUFKQkJ6WUNEQXk4QWdzZ0FTQUVSd1JBSUFGQkFXb2hBVUhlQUNFRERLTUNDMEh5QUNFRERMc0NDeUFCSUFSR0JFQkI5QUFoQXd5N0Fnc0NRQ0FCTFFBQVFmRE1BR290QUFCQkFXc09BL2NCY3dDQ0FRdEI0UUFoQXd5aEFnc2dBU0FFUndSQUEwQWdBUzBBQUVId3lnQnFMUUFBSWdCQkEwY0VRQUpBSUFCQkFXc09BdmtCQUlVQkMwSGZBQ0VEREtNQ0N5QUVJQUZCQVdvaUFVY05BQXRCOHdBaEF3eTZBZ3RCOHdBaEF3eTVBZ3NnQVNBRVJ3UkFJQUpCRHpZQ0NDQUNJQUUyQWdSQjRBQWhBd3lnQWd0QjlRQWhBd3k0QWdzZ0FTQUVSZ1JBUWZZQUlRTU11QUlMSUFKQkR6WUNDQ0FDSUFFMkFnUUxRUU1oQXd5ZEFnc0RRQ0FCTFFBQVFTQkhEWTRDSUFRZ0FVRUJhaUlCUncwQUMwSDNBQ0VERExVQ0N5QUJJQVJHQkVCQitBQWhBd3kxQWdzZ0FTMEFBRUVnUncxNklBRkJBV29oQVF4YkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEWGdNZ0FJTElBRWdCRVlFUUVINkFDRURETE1DQ3lBQkxRQUFRY3dBUncxMElBRkJBV29oQVVFVERIWUxRZnNBSVFNZ0FTQUVSZzJ4QWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlEUUNBQkxRQUFJQUJCOE00QWFpMEFBRWNOY3lBQVFRVkdEWFVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNc1FJTElBRWdCRVlFUUVIOEFDRURETEVDQ3dKQUFrQWdBUzBBQUVIREFHc09EQUIwZEhSMGRIUjBkSFIwQVhRTElBRkJBV29oQVVIbUFDRURESmdDQ3lBQlFRRnFJUUZCNXdBaEF3eVhBZ3RCL1FBaEF5QUJJQVJHRGE4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERYSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURMQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFSQU1jd3RCL2dBaEF5QUJJQVJHRGE0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFmYk9BR290QUFCSERYRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFSWU1jZ3RCL3dBaEF5QUJJQVJHRGEwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFmek9BR290QUFCSERYQWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRVU1jUXNnQVNBRVJnUkFRWUFCSVFNTXJRSUxJQUV0QUFCQjJRQkhEVzRnQVVFQmFpRUJRUWdNY0FzZ0FTQUVSZ1JBUVlFQklRTU1yQUlMQWtBQ1FDQUJMUUFBUWM0QWF3NERBRzhCYndzZ0FVRUJhaUVCUWVzQUlRTU1rd0lMSUFGQkFXb2hBVUhzQUNFRERKSUNDeUFCSUFSR0JFQkJnZ0VoQXd5ckFnc0NRQUpBSUFFdEFBQkJ5QUJyRGdnQWJtNXVibTV1QVc0TElBRkJBV29oQVVIcUFDRURESklDQ3lBQlFRRnFJUUZCN1FBaEF3eVJBZ3RCZ3dFaEF5QUJJQVJHRGFrQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFZRFBBR290QUFCSERXd2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLb0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFRQU1iUXRCaEFFaEF5QUJJQVJHRGFnQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFZUFBBR290QUFCSERXc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLa0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFTTU1iQXNnQVNBRVJnUkFRWVVCSVFNTXFBSUxBa0FDUUNBQkxRQUFRY3dBYXc0SUFHdHJhMnRyYXdGckN5QUJRUUZxSVFGQjd3QWhBd3lQQWdzZ0FVRUJhaUVCUWZBQUlRTU1qZ0lMSUFFZ0JFWUVRRUdHQVNFRERLY0NDeUFCTFFBQVFjVUFSdzFvSUFGQkFXb2hBUXhnQzBHSEFTRURJQUVnQkVZTnBRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJpTThBYWkwQUFFY05hQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJMUXhwQzBHSUFTRURJQUVnQkVZTnBBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVJYWlFR0FrQURRQ0FCTFFBQUlBQkIwTThBYWkwQUFFY05aeUFBUVFoR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJLUXhvQ3lBQklBUkdCRUJCaVFFaEF3eWtBZ3RCQVNBQkxRQUFRZDhBUncxbkdpQUJRUUZxSVFFTVhndEJpZ0VoQXlBQklBUkdEYUlDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ05BSUFFdEFBQWdBRUdNendCcUxRQUFSdzFrSUFCQkFVWU4rZ0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNb2dJTFFZc0JJUU1nQVNBRVJnMmhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdPendCcUxRQUFSdzFrSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlpQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVDREdVTFFZd0JJUU1nQVNBRVJnMmdBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh3endCcUxRQUFSdzFqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXloQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVmREdRTFFZMEJJUU1nQVNBRVJnMmZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh5endCcUxRQUFSdzFpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlnQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVKREdNTElBRWdCRVlFUUVHT0FTRURESjhDQ3dKQUFrQWdBUzBBQUVISkFHc09Cd0JpWW1KaVlnRmlDeUFCUVFGcUlRRkIrQUFoQXd5R0Fnc2dBVUVCYWlFQlFma0FJUU1NaFFJTFFZOEJJUU1nQVNBRVJnMmRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdSendCcUxRQUFSdzFnSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXllQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVZREdFTFFaQUJJUU1nQVNBRVJnMmNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdYendCcUxRQUFSdzFmSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlkQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVYREdBTFFaRUJJUU1nQVNBRVJnMmJBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFacUlRWUNRQU5BSUFFdEFBQWdBRUdhendCcUxRQUFSdzFlSUFCQkJrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXljQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVWREY4TFFaSUJJUU1nQVNBRVJnMmFBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdoendCcUxRQUFSdzFkSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXliQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVlREY0TElBRWdCRVlFUUVHVEFTRURESm9DQ3lBQkxRQUFRY3dBUncxYklBRkJBV29oQVVFS0RGMExJQUVnQkVZRVFFR1VBU0VEREprQ0N3SkFBa0FnQVMwQUFFSEJBR3NPRHdCY1hGeGNYRnhjWEZ4Y1hGeGNBVndMSUFGQkFXb2hBVUgrQUNFRERJQUNDeUFCUVFGcUlRRkIvd0FoQXd6L0FRc2dBU0FFUmdSQVFaVUJJUU1NbUFJTEFrQUNRQ0FCTFFBQVFjRUFhdzREQUZzQld3c2dBVUVCYWlFQlFmMEFJUU1NL3dFTElBRkJBV29oQVVHQUFTRUREUDRCQzBHV0FTRURJQUVnQkVZTmxnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwODhBYWkwQUFFY05XU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJDd3hhQ3lBQklBUkdCRUJCbHdFaEF3eVdBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFTMXJEaU1BVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0Ylcxc0JXMXRiVzFzQ1cxdGJBMXNMSUFGQkFXb2hBVUg3QUNFRERQOEJDeUFCUVFGcUlRRkIvQUFoQXd6K0FRc2dBVUVCYWlFQlFZRUJJUU1NL1FFTElBRkJBV29oQVVHQ0FTRUREUHdCQzBHWUFTRURJQUVnQkVZTmxBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVFYWlFR0FrQURRQ0FCTFFBQUlBQkJxYzhBYWkwQUFFY05WeUFBUVFSR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHUXhZQzBHWkFTRURJQUVnQkVZTmt3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJyczhBYWkwQUFFY05WaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sQUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJCZ3hYQzBHYUFTRURJQUVnQkVZTmtnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0TThBYWkwQUFFY05WU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJIQXhXQzBHYkFTRURJQUVnQkVZTmtRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0czhBYWkwQUFFY05WQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJKd3hWQ3lBQklBUkdCRUJCbkFFaEF3eVJBZ3NDUUFKQUlBRXRBQUJCMUFCckRnSUFBVlFMSUFGQkFXb2hBVUdHQVNFRERQZ0JDeUFCUVFGcUlRRkJod0VoQXd6M0FRdEJuUUVoQXlBQklBUkdEWThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJqUEFHb3RBQUJIRFZJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREpBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNZTVV3dEJuZ0VoQXlBQklBUkdEWTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyUEFHb3RBQUJIRFZFZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFNTVVndEJud0VoQXlBQklBUkdEWTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFZBZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVF3TVVRdEJvQUVoQXlBQklBUkdEWXdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJ6UEFHb3RBQUJIRFU4Z0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREkwQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVEwTVVBc2dBU0FFUmdSQVFhRUJJUU1NakFJTEFrQUNRQ0FCTFFBQVFjWUFhdzRMQUU5UFQwOVBUMDlQVHdGUEN5QUJRUUZxSVFGQml3RWhBd3p6QVFzZ0FVRUJhaUVCUVl3QklRTU04Z0VMSUFFZ0JFWUVRRUdpQVNFRERJc0NDeUFCTFFBQVFkQUFSdzFNSUFGQkFXb2hBUXhHQ3lBQklBUkdCRUJCb3dFaEF3eUtBZ3NDUUFKQUlBRXRBQUJCeVFCckRnY0JUVTFOVFUwQVRRc2dBVUVCYWlFQlFZNEJJUU1NOFFFTElBRkJBV29oQVVFaURFMExRYVFCSVFNZ0FTQUVSZzJJQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIQXp3QnFMUUFBUncxTElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5SkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZERFd0xJQUVnQkVZRVFFR2xBU0VERElnQ0N3SkFBa0FnQVMwQUFFSFNBR3NPQXdCTEFVc0xJQUZCQVdvaEFVR1FBU0VERE84QkN5QUJRUUZxSVFGQkJBeExDeUFCSUFSR0JFQkJwZ0VoQXd5SEFnc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBVFUxTlRVMU5UVTFOVFFGTlRRSk5UUU5OVFFSTkN5QUJRUUZxSVFGQmlBRWhBd3p4QVFzZ0FVRUJhaUVCUVlrQklRTU04QUVMSUFGQkFXb2hBVUdLQVNFRERPOEJDeUFCUVFGcUlRRkJqd0VoQXd6dUFRc2dBVUVCYWlFQlFaRUJJUU1NN1FFTFFhY0JJUU1nQVNBRVJnMkZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh0endCcUxRQUFSdzFJSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlHQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVSREVrTFFhZ0JJUU1nQVNBRVJnMkVBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhDendCcUxRQUFSdzFISUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlGQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVzREVnTFFha0JJUU1nQVNBRVJnMkRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhGendCcUxRQUFSdzFHSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlFQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVyREVjTFFhb0JJUU1nQVNBRVJnMkNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhLendCcUxRQUFSdzFGSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlEQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVVREVZTElBRWdCRVlFUUVHckFTRURESUlDQ3dKQUFrQUNRQUpBSUFFdEFBQkJ3Z0JyRGc4QUFRSkhSMGRIUjBkSFIwZEhSd05IQ3lBQlFRRnFJUUZCa3dFaEF3enJBUXNnQVVFQmFpRUJRWlFCSVFNTTZnRUxJQUZCQVdvaEFVR1ZBU0VERE9rQkN5QUJRUUZxSVFGQmxnRWhBd3pvQVFzZ0FTQUVSZ1JBUWF3QklRTU1nUUlMSUFFdEFBQkJ4UUJIRFVJZ0FVRUJhaUVCREQwTFFhMEJJUU1nQVNBRVJnMy9BU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhOendCcUxRQUFSdzFDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlBQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVPREVNTElBRWdCRVlFUUVHdUFTRUREUDhCQ3lBQkxRQUFRZEFBUncxQUlBRkJBV29oQVVFbERFSUxRYThCSVFNZ0FTQUVSZzM5QVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRaHFJUVlDUUFOQUlBRXRBQUFnQUVIUXp3QnFMUUFBUncxQUlBQkJDRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6K0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFcURFRUxJQUVnQkVZRVFFR3dBU0VERFAwQkN3SkFBa0FnQVMwQUFFSFZBR3NPQ3dCQVFFQkFRRUJBUUVBQlFBc2dBVUVCYWlFQlFab0JJUU1NNUFFTElBRkJBV29oQVVHYkFTRURET01CQ3lBQklBUkdCRUJCc1FFaEF3ejhBUXNDUUFKQUlBRXRBQUJCd1FCckRoUUFQejgvUHo4L1B6OC9QejgvUHo4L1B6OC9BVDhMSUFGQkFXb2hBVUdaQVNFRERPTUJDeUFCUVFGcUlRRkJuQUVoQXd6aUFRdEJzZ0VoQXlBQklBUkdEZm9CSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRuUEFHb3RBQUJIRFQwZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBzQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNFTVBndEJzd0VoQXlBQklBUkdEZmtCSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWQzUEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBvQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVJvTVBRc2dBU0FFUmdSQVFiUUJJUU1NK1FFTEFrQUNRQUpBSUFFdEFBQkJ4UUJyRGhFQVBUMDlQVDA5UFQwOUFUMDlQVDA5QWowTElBRkJBV29oQVVHZEFTRURET0VCQ3lBQlFRRnFJUUZCbmdFaEF3emdBUXNnQVVFQmFpRUJRWjhCSVFNTTN3RUxRYlVCSVFNZ0FTQUVSZzMzQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIa3p3QnFMUUFBUncwNklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6NEFRc2dBa0VBTmdJQUlBWkJBV29oQVVFb0REc0xRYllCSVFNZ0FTQUVSZzMyQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIcXp3QnFMUUFBUncwNUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6M0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFSEREb0xJQUVnQkVZRVFFRzNBU0VERFBZQkN3SkFBa0FnQVMwQUFFSEZBR3NPRGdBNU9UazVPVGs1T1RrNU9Ua0JPUXNnQVVFQmFpRUJRYUVCSVFNTTNRRUxJQUZCQVdvaEFVR2lBU0VERE53QkMwRzRBU0VESUFFZ0JFWU45QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCN2M4QWFpMEFBRWNOTnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOVFFTElBSkJBRFlDQUNBR1FRRnFJUUZCRWd3NEMwRzVBU0VESUFFZ0JFWU44d0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOE04QWFpMEFBRWNOTmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOUFFTElBSkJBRFlDQUNBR1FRRnFJUUZCSUF3M0MwRzZBU0VESUFFZ0JFWU44Z0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOHM4QWFpMEFBRWNOTlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOHdFTElBSkJBRFlDQUNBR1FRRnFJUUZCRHd3MkN5QUJJQVJHQkVCQnV3RWhBd3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBTlRVMU5UVUJOUXNnQVVFQmFpRUJRYVVCSVFNTTJRRUxJQUZCQVdvaEFVR21BU0VERE5nQkMwRzhBU0VESUFFZ0JFWU44QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSGFpRUdBa0FEUUNBQkxRQUFJQUJCOU04QWFpMEFBRWNOTXlBQVFRZEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOFFFTElBSkJBRFlDQUNBR1FRRnFJUUZCR3d3MEN5QUJJQVJHQkVCQnZRRWhBd3p3QVFzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdBME5EUTBORFEwTkRRQk5EUTBORFEwQWpRTElBRkJBV29oQVVHa0FTRURETmdCQ3lBQlFRRnFJUUZCcHdFaEF3elhBUXNnQVVFQmFpRUJRYWdCSVFNTTFnRUxJQUVnQkVZRVFFRytBU0VERE84QkN5QUJMUUFBUWM0QVJ3MHdJQUZCQVdvaEFRd3NDeUFCSUFSR0JFQkJ2d0VoQXd6dUFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRY0VBYXc0VkFBRUNBejhFQlFZL1B6OEhDQWtLQ3o4TURRNFBQd3NnQVVFQmFpRUJRZWdBSVFNTTR3RUxJQUZCQVdvaEFVSHBBQ0VERE9JQkN5QUJRUUZxSVFGQjdnQWhBd3poQVFzZ0FVRUJhaUVCUWZJQUlRTU00QUVMSUFGQkFXb2hBVUh6QUNFREROOEJDeUFCUVFGcUlRRkI5Z0FoQXd6ZUFRc2dBVUVCYWlFQlFmY0FJUU1NM1FFTElBRkJBV29oQVVINkFDRURETndCQ3lBQlFRRnFJUUZCZ3dFaEF3emJBUXNnQVVFQmFpRUJRWVFCSVFNTTJnRUxJQUZCQVdvaEFVR0ZBU0VERE5rQkN5QUJRUUZxSVFGQmtnRWhBd3pZQVFzZ0FVRUJhaUVCUVpnQklRTU0xd0VMSUFGQkFXb2hBVUdnQVNFREROWUJDeUFCUVFGcUlRRkJvd0VoQXd6VkFRc2dBVUVCYWlFQlFhb0JJUU1NMUFFTElBRWdCRWNFUUNBQ1FSQTJBZ2dnQWlBQk5nSUVRYXNCSVFNTTFBRUxRY0FCSVFNTTdBRUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUkwSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFY0Z0FFRVZSdzBISUFKQjBRQTJBaHdnQWlBQk5nSVVJQUpCc0JjMkFoQWdBa0VWTmdJTVFRQWhBd3pyQVFzZ0FVRUJhaUFCSUFSSERRZ2FRY0lCSVFNTTZnRUxBMEFDUUNBQkxRQUFRUXByRGdRSUFBQUxBQXNnQkNBQlFRRnFJZ0ZIRFFBTFFjTUJJUU1NNlFFTElBRWdCRWNFUUNBQ1FSRTJBZ2dnQWlBQk5nSUVRUUVoQXd6UUFRdEJ4QUVoQXd6b0FRc2dBU0FFUmdSQVFjVUJJUU1NNkFFTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCS0NnQUtBc2dBVUVCYWd3SkN5QUJRUUZxREFVTElBRWdCRVlFUUVIR0FTRURET2NCQ3dKQUFrQWdBUzBBQUVFS2F3NFhBUXNMQVFzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dBTEN5QUJRUUZxSVFFTFFiQUJJUU1NelFFTElBRWdCRVlFUUVISUFTRURET1lCQ3lBQkxRQUFRU0JIRFFrZ0FrRUFPd0V5SUFGQkFXb2hBVUd6QVNFRERNd0JDd05BSUFFaEFBSkFJQUVnQkVjRVFDQUJMUUFBUVRCclFmOEJjU0lEUVFwSkRRRU1Kd3RCeHdFaEF3em1BUXNDUUNBQ0x3RXlJZ0ZCbVROTERRQWdBaUFCUVFwc0lnVTdBVElnQlVIKy93TnhJQU5CLy84RGMwc05BQ0FBUVFGcUlRRWdBaUFESUFWcUlnTTdBVElnQTBILy93TnhRZWdIU1EwQkN3dEJBQ0VESUFKQkFEWUNIQ0FDUWNFSk5nSVFJQUpCRFRZQ0RDQUNJQUJCQVdvMkFoUU01QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0h3RERZQ0VDQUNRUnMyQWd4QkFDRURET01CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDWWlBQTBCSUFGQkFXb0xJUUZCclFFaEF3eklBUXNnQWtIQkFUWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVRUUFoQXd6Z0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFtSWdBTkFTQUJRUUZxQ3lFQlFhNEJJUU1NeFFFTElBSkJ3Z0UyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkVFQUlRTU0zUUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dYQ3pZQ0VDQUNRUTAyQWd4QkFDRURETndCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNHhBMkFoQWdBa0VKTmdJTVFRQWhBd3piQVFzZ0FrRUNPZ0FvREt3QkMwRUFJUU1nQWtFQU5nSWNJQUpCcndzMkFoQWdBa0VDTmdJTUlBSWdBVUVCYWpZQ0ZBelpBUXRCQWlFRERMOEJDMEVOSVFNTXZnRUxRU1loQXd5OUFRdEJGU0VEREx3QkMwRVdJUU1NdXdFTFFSZ2hBd3k2QVF0QkhDRURETGtCQzBFZElRTU11QUVMUVNBaEF3eTNBUXRCSVNFRERMWUJDMEVqSVFNTXRRRUxRY1lBSVFNTXRBRUxRUzRoQXd5ekFRdEJQU0VERExJQkMwSExBQ0VERExFQkMwSE9BQ0VERExBQkMwSFlBQ0VEREs4QkMwSFpBQ0VEREs0QkMwSGJBQ0VEREswQkMwSHhBQ0VEREt3QkMwSDBBQ0VEREtzQkMwR05BU0VEREtvQkMwR1hBU0VEREtrQkMwR3BBU0VEREtnQkMwR3ZBU0VEREtjQkMwR3hBU0VEREtZQkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4UnMyQWhBZ0FrRUdOZ0lNREwwQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNRTE9nQXBJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSnlJQVJRUkFRZVVBSVFNTW93RUxJQUpCK1FBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU11d0VMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3eTdBUXNnQWtINEFEWUNIQ0FDSUFFMkFoUWdBa0hLR0RZQ0VDQUNRUlUyQWd4QkFDRURETG9CQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCamhzMkFoQWdBa0VHTmdJTVFRQWhBd3k1QVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWY0Uk5nSVFJQUpCQnpZQ0RFRUFJUU1NdUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHTUhEWUNFQ0FDUVFjMkFneEJBQ0VERExjQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnd3ODJBaEFnQWtFSE5nSU1RUUFoQXd5MkFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjTVBOZ0lRSUFKQkJ6WUNERUVBSVFNTXRRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMFJJQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU10QUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBnSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc3dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwaUlBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNnRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRME9JQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zUUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBkSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc0FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZklBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXJ3RUxJQUJCUDBjTkFTQUJRUUZxQ3lFQlFRVWhBd3lVQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDlFallDRUNBQ1FRYzJBZ3dNckFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIY0NEWUNFQ0FDUVFjMkFneEJBQ0VEREtzQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkJ5QUNRZVVBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLb0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5GaUFDUWRNQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2tCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOR0NBQ1FkSUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtnQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhnbzJBaEFnQWtFSE5nSU1RUUFoQXd5bkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRTWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eW1BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUklnQWtIVEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lsQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJRZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5a0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWpBUXRCMVFBaEF3eUpBUXNnQUVFVlJ3UkFJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrRzVEVFlDRUNBQ1FSbzJBZ3hCQUNFRERLSUJDeUFDUWVRQU5nSWNJQUlnQVRZQ0ZDQUNRZU1YTmdJUUlBSkJGVFlDREVFQUlRTU1vUUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIM0NUWUNFQ0FDUVFnMkFnd01vQUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1VFaFJnMERJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2JDallDRUNBQ1FRZzJBZ3hCQUNFRERKOEJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCa0RNMkFoQWdBa0VJTmdJTURKMEJDeUFDUVFBMkFnQWdCa0VCYWlFQklBSXRBQ2xCSTBrTkFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjB3azJBaEFnQWtFSU5nSU1RUUFoQXd5Y0FRdEIwUUFoQXd5Q0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQUlnQURvQUtpQUJRUUZxSVFGQnp3QWhBd3lDQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW9JZ0JGRFlZQklBSkIzZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTW1nRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMkdBU0FDUWR3QU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURESmtCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1od0VMSUFKQjJnQTJBaHdnQWlBRk5nSVVJQUlnQURZQ0RBeVlBUXRCQUNFQlFRRWhBd3NnQWlBRE9nQXJJQVZCQVdvaEF3SkFBa0FDUUNBQ0xRQXRRUkJ4RFFBQ1FBSkFBa0FnQWkwQUtnNERBUUFDQkFzZ0JrVU5Bd3dDQ3lBQURRRU1BZ3NnQVVVTkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBeEFvSWdCRkJFQWdBeUVCREFJTElBSkIyQUEyQWh3Z0FpQUROZ0lVSUFJZ0FEWUNERUVBSVFNTW1BRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQU1RS0NJQVJRUkFJQU1oQVF5SEFRc2dBa0haQURZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3eVhBUXRCekFBaEF3eDlDeUFBUVJWSEJFQWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaUU5OZ0lRSUFKQklUWUNERUVBSVFNTWxnRUxJQUpCMXdBMkFod2dBaUFCTmdJVUlBSkJ5UmMyQWhBZ0FrRVZOZ0lNUVFBaEF3eVZBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHQUVUWUNFQ0FDUVFrMkFnd01sQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBBSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Na3dFTFFja0FJUU1NZVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNFb05nSVFJQUpCQnpZQ0RDQUNRUUEyQWdCQkFDRURESkVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREpBQkMwSElBQ0VEREhZTElBSkJBRFlDQUNBRklRRUxJQUpCZ0JJN0FTb2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5BUXRCeHdBaEF3eHpDeUFBUVJWR0JFQWdBa0hSQURZQ0hDQUNJQUUyQWhRZ0FrSGpGellDRUNBQ1FSVTJBZ3hCQUNFRERJd0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJrTk5nSVFJQUpCR2pZQ0RBeUxBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHZ0dUWUNFQ0FDUVI0MkFnd01pZ0VMSUFFdEFBQkJPa1lFUUNBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdCRkRRRWdBa0hEQURZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURJb0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJFUk5nSVFJQUpCQ2pZQ0RBeUpBUXNnQVVFQmFpRUJRVHNoQXd4dkN5QUNRY01BTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWh3RUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEE0MkFoQWdBa0VjTmdJTURJWUJDeUFDSUFJdkFUQkJFSEk3QVRBTVpnc0NRQ0FDTHdFd0lnQkJDSEZGRFFBZ0FpMEFLRUVCUncwQUlBSXRBQzFCQ0hGRkRRTUxJQUlnQUVIMyt3TnhRWUFFY2pzQk1Bd0VDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFMUlRTU1iZ3NnQWlrRElDSUtRcG16NXN5WnMrYk1HVllOQVNBQ0lBcENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBSWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCT1NFRERJVUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FVRUJhaUlCRUNvaUFBME1ESGNMUVRraEF3eURBUXNnQWkwQU1FRWdjUTBHUWNVQklRTU1hUXRCQUNFRElBSkJBRFlDQkNBQ0lBRWdBUkFxSWdCRkRRUWdBa0U2TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWdRRUxJQUl0QUNoQkFVY05BQ0FDTFFBdFFRaHhSUTBCQzBFM0lRTU1aZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBQkVBZ0FrRTdOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZndzZ0FVRUJhaUVCREc0TElBSkJDRG9BTEF3RUN5QUJRUUZxSVFFTWJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hrRWpZQ0VDQUNRUVEyQWd3TWV3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTFzSUFKQk56WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIb0xJQUlnQWk4Qk1FRWdjanNCTUF0Qk1DRURERjhMSUFKQk5qWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIY0xJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0FYSTdBVEFnQUNFQkRBRUxJQUlnQWk4Qk1FRUljanNCTUNBQUlRRUxRVGtoQXd4Y0N5QUNRUUE2QUN3TFFUUWhBd3hhQ3lBQklBUkdCRUJCTFNFRERITUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEV0SVFNTWRBc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTBDSUFKQkxEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURITUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FTMEFBRUVOUmdSQUlBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQWkwQUxVRUJjUVJBUWNRQklRTU1XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBRFFFTVpRdEJMeUVEREZjTElBSkJMallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERzhMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhCUTJBaEFnQWtFRE5nSU1ERzRMUVFFaEF3SkFBa0FDUUFKQUlBSXRBQ3hCQldzT0JBTUJBZ0FFQ3lBQ0lBSXZBVEJCQ0hJN0FUQU1Bd3RCQWlFRERBRUxRUVFoQXdzZ0FrRUJPZ0FzSUFJZ0FpOEJNQ0FEY2pzQk1BdEJLaUVEREZNTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0UTgyQWhBZ0FrRUtOZ0lNREdzTFFRRWhBd0pBQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUUpyRGdjRkJBUURBUUlBQkFzZ0FpQUNMd0V3UVFoeU93RXdEQU1MUVFJaEF3d0JDMEVFSVFNTElBSkJBVG9BTENBQ0lBSXZBVEFnQTNJN0FUQUxRU3NoQXd4U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYXNTTmdJUUlBSkJDellDREF4cUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjBOTmdJUUlBSkJIVFlDREF4cEN5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERVZ2dCQ0FCUVFGcUlnRkhEUUFMUVNVaEF3eHBDMEVsSVFNTWFBc2dBaTBBTFVFQmNRUkFRY01CSVFNTVR3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtTSUFCRUFnQWtFbU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1hQXNnQVVFQmFpRUJERndMSUFGQkFXb2hBU0FDTHdFd0lnQkJnQUZ4QkVCQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5CaUFBUVJWSERSOGdBa0VGTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVp3c0NRQ0FBUWFBRWNVR2dCRWNOQUNBQ0xRQXRRUUp4RFFCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1dFellDRUNBQ1FRUTJBZ3dNWndzZ0FnSi9JQUl2QVRCQkZIRkJGRVlFUUVFQklBSXRBQ2hCQVVZTkFSb2dBaThCTWtIbEFFWU1BUXNnQWkwQUtVRUZSZ3M2QUM1QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FpUWlBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FBSkFBa0FDUUFKQUlBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QUNRUUU2QUM0TElBSWdBaThCTUVIQUFISTdBVEFMUVNjaEF3eFBDeUFDUVNNMkFod2dBaUFCTmdJVUlBSkJwUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eG5DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWRVTE5nSVFJQUpCRVRZQ0RBeG1DMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFFFTFFRNGhBd3hMQ3lBQVFSVkdCRUFnQWtFQ05nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1aQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01Zd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHcUhEWUNFQ0FDUVE4MkFnd01ZZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRWdDcWRxSWdFUUt5SUFSUTBBSUFKQkJUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHRUxRUThoQXd4SEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4ZkMwSUJJUW9MSUFGQkFXb2hBUUpBSUFJcEF5QWlDMEwvLy8vLy8vLy8vdzlZQkVBZ0FpQUxRZ1NHSUFxRU53TWdEQUVMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnJRazJBaEFnQWtFTU5nSU1ERjRMUVNRaEF3eEVDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGNDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREZJTElBSkJGellDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FSWTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhiQzBFZklRTU1RUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFMU0lBUlFSQUlBRkJBV29oQVF4UUN5QUNRUlEyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4WUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRVROZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNV0F0QkhpRURERDRMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhndzJBaEFnQWtFak5nSU1ERllMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTVRnc2dBa0VSTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVZRc2dBa0VRTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3dNVkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEdERFlDRUNBQ1FTTTJBZ3dNVXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEFGVFlDRUNBQ1FRSTJBZ3dNVWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRQ1FDQUNJQUFnQVJBdElnQkZCRUFnQVVFQmFpRUJEQUVMSUFKQkRqWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERklMUVJzaEF3dzRDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNZTU5nSVFJQUpCSXpZQ0RBeFFDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQ3dpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VOTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVVBdEJHaUVERERZTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJtZzgyQWhBZ0FrRWlOZ0lNREU0TElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FRdzJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhPQzBFWklRTU1OQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01UQXNnQUVFVlJ3UkFRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCZ3d3MkFoQWdBa0VUTmdJTURFd0xJQUpCQ2pZQ0hDQUNJQUUyQWhRZ0FrSGtGallDRUNBQ1FSVTJBZ3hCQUNFRERFc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQklBcW5haUlCRUNzaUFBUkFJQUpCQnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREVzTFFSTWhBd3d4Q3lBQVFSVkhCRUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01TZ3NnQWtFZU5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTlFTQUFRUlZHQkVBZ0FrRUROZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNU0F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNUnd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNUmdzZ0FrRUFPZ0F2SUFJdEFDMUJCSEZGRFQ4TElBSkJBRG9BTHlBQ1FRRTZBRFJCQUNFRERDc0xRUUFoQXlBQ1FRQTJBaHdnQWtIa0VUWUNFQ0FDUVFjMkFnd2dBaUFCUVFGcU5nSVVERU1MQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCM1FFaEF3eERDd0pBQWtBZ0FpMEFORUVCUncwQVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSllJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQUpCM0FFMkFod2dBaUFCTmdJVUlBSkIxUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eEVDMEhCQVNFRERDb0xJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHBDellDRUNBQ1FSODJBZ3hCQUNFRERFSUxBa0FDUUNBQ0xRQW9RUUZyRGdJRUFRQUxRY0FCSVFNTUtRdEJ1UUVoQXd3b0N5QUNRUUk2QUM5QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FnQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVUVRRUhDQVNFRERDZ0xJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnBBdzJBaEFnQWtFUU5nSU1RUUFoQXd4QkN5QUNRZHNCTmdJY0lBSWdBVFlDRkNBQ1Fmb1dOZ0lRSUFKQkZUWUNERUVBSVFNTVFBc2dBU0FFUmdSQVFkb0JJUU1NUUFzZ0FTMEFBRUhJQUVZTkFTQUNRUUU2QUNnTFFhd0JJUU1NSlF0QnZ3RWhBd3drQ3lBQklBUkhCRUFnQWtFUU5nSUlJQUlnQVRZQ0JFRytBU0VERENRTFFka0JJUU1NUEFzZ0FTQUVSZ1JBUWRnQklRTU1QQXNnQVMwQUFFSElBRWNOQkNBQlFRRnFJUUZCdlFFaEF3d2lDeUFCSUFSR0JFQkIxd0VoQXd3N0N3SkFBa0FnQVMwQUFFSEZBR3NPRUFBRkJRVUZCUVVGQlFVRkJRVUZCUUVGQ3lBQlFRRnFJUUZCdXdFaEF3d2lDeUFCUVFGcUlRRkJ2QUVoQXd3aEMwSFdBU0VESUFFZ0JFWU5PU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdEMEFCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc2Q3lBQ0tBSUVJUUFnQWtJQU53TUFJQUlnQUNBR1FRRnFJZ0VRSnlJQVJRUkFRY1lCSVFNTUlRc2dBa0hWQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzVDMEhVQVNFRElBRWdCRVlOT0NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHQjBBQnFMUUFBUncwQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NUN5QUNRWUVFT3dFb0lBSW9BZ1FoQUNBQ1FnQTNBd0FnQWlBQUlBWkJBV29pQVJBbklnQU5Bd3dDQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjJCczJBaEFnQWtFSU5nSU1ERFlMUWJvQklRTU1IQXNnQWtIVEFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3cwQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd3ekMwSGtBQ0VEREJrTElBSkIrQUEyQWh3Z0FpQUJOZ0lVSUFKQnloZzJBaEFnQWtFVk5nSU1RUUFoQXd3eEMwSFNBU0VESUFRZ0FTSUFSZzB3SUFRZ0FXc2dBaWdDQUNJQmFpRUZJQUFnQVd0QkJHb2hCZ0pBQTBBZ0FDMEFBQ0FCUWZ6UEFHb3RBQUJIRFFFZ0FVRUVSZzBESUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUZOZ0lBRERFTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtHUU16WUNFQ0FDUVFnMkFnd2dBa0VBTmdJQVFRQWhBd3d3Q3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFRzNBU0VEREJjTFFkRUJJUU1NTHdzZ0FrRUFOZ0lBSUFaQkFXb2hBUXRCdUFFaEF3d1VDeUFCSUFSR0JFQkIwQUVoQXd3dEN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBaUFBT2dBcUlBRkJBV29oQVVHMkFTRUREQlFMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBVSUFKQnp3RTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEFzZ0FTQUVSZ1JBUWM0QklRTU1MQXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVklBSkJ6UUUyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBdEJ0UUVoQXd3U0N5QUVJQUVpQlVZRVFFSE1BU0VERENzTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFVdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFRFFRQWhBVUVBSVFZTUFndEJDU0VEUVFFaEFFRUFJUUZCQUNFR0RBRUxRUUFoQVVFQklRTUxJQUlnQXpvQUt5QUZRUUZxSVFNQ1FBSkFJQUl0QUMxQkVIRU5BQUpBQWtBQ1FDQUNMUUFxRGdNQkFBSUVDeUFHUlEwRERBSUxJQUFOQVF3Q0N5QUJSUTBCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1Bd3NnQWtISkFUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3d0Q3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1HQXNnQWtIS0FUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3dzQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1GZ3NnQWtITEFUWUNIQ0FDSUFVMkFoUWdBaUFBTmdJTURDc0xRYlFCSVFNTUVRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BandpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dVRFRZQ0VDQUNRU0UyQWd4QkFDRUREQ3NMUWJJQklRTU1FUXNnQWtISUFUWUNIQ0FDSUFFMkFoUWdBa0hKRnpZQ0VDQUNRUlUyQWd4QkFDRUREQ2tMSUFKQkFEWUNBQ0FHUVFGcUlRRkI5UUFoQXd3UEN5QUNMUUFwUVFWR0JFQkI0d0FoQXd3UEMwSGlBQ0VEREE0TElBQWhBU0FDUVFBMkFnQUxJQUpCQURvQUxFRUpJUU1NREFzZ0FrRUFOZ0lBSUFkQkFXb2hBVUhBQUNFRERBc0xRUUVMT2dBc0lBSkJBRFlDQUNBR1FRRnFJUUVMUVNraEF3d0lDMEU0SVFNTUJ3c0NRQ0FCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QlBpRUREQ0VMUVQ0aEF3d2dDd3NnQWtFQU9nQXNEQUVMUVFzaEF3d0VDMEU2SVFNTUF3c2dBVUVCYWlFQlFTMGhBd3dDQ3lBQ0lBRTZBQ3dnQWtFQU5nSUFJQVpCQVdvaEFVRU1JUU1NQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVLSVFNTUFBc0FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1hDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1dDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1ZDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1VDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1RDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1NDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd1BDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd09DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNBU05nSVFJQUpCQ3pZQ0RBd05DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpVSk5nSVFJQUpCQ3pZQ0RBd01DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVFUE5nSVFJQUpCQ2pZQ0RBd0xDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZzUE5nSVFJQUpCQ2pZQ0RBd0tDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZFWk5nSVFJQUpCQWpZQ0RBd0pDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNRVU5nSVFJQUpCQWpZQ0RBd0lDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZJVk5nSVFJQUpCQWpZQ0RBd0hDeUFDUVFJMkFod2dBaUFCTmdJVUlBSkJuQm8yQWhBZ0FrRVdOZ0lNUVFBaEF3d0dDMEVCSVFNTUJRdEIxQUFoQXlBQklBUkdEUVFnQ0VFSWFpRUpJQUlvQWdBaEJRSkFBa0FnQVNBRVJ3UkFJQVZCMk1JQWFpRUhJQVFnQldvZ0FXc2hBQ0FGUVg5elFRcHFJZ1VnQVdvaEJnTkFJQUV0QUFBZ0J5MEFBRWNFUUVFQ0lRY01Bd3NnQlVVRVFFRUFJUWNnQmlFQkRBTUxJQVZCQVdzaEJTQUhRUUZxSVFjZ0JDQUJRUUZxSWdGSERRQUxJQUFoQlNBRUlRRUxJQWxCQVRZQ0FDQUNJQVUyQWdBTUFRc2dBa0VBTmdJQUlBa2dCellDQUFzZ0NTQUJOZ0lFSUFnb0Fnd2hBQ0FJS0FJSURnTUJCQUlBQ3dBTElBSkJBRFlDSENBQ1FiVWFOZ0lRSUFKQkZ6WUNEQ0FDSUFCQkFXbzJBaFJCQUNFRERBSUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrSEtHallDRUNBQ1FRazJBZ3hCQUNFRERBRUxJQUVnQkVZRVFFRWlJUU1NQVFzZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVoSVFNTElBaEJFR29rQUNBRFJRUkFJQUlvQWd3aEFBd0JDeUFDSUFNMkFoeEJBQ0VBSUFJb0FnUWlBVVVOQUNBQ0lBRWdCQ0FDS0FJSUVRRUFJZ0ZGRFFBZ0FpQUVOZ0lVSUFJZ0FUWUNEQ0FCSVFBTElBQUx2Z0lCQW44Z0FFRUFPZ0FBSUFCQjNBQnFJZ0ZCQVd0QkFEb0FBQ0FBUVFBNkFBSWdBRUVBT2dBQklBRkJBMnRCQURvQUFDQUJRUUpyUVFBNkFBQWdBRUVBT2dBRElBRkJCR3RCQURvQUFFRUFJQUJyUVFOeElnRWdBR29pQUVFQU5nSUFRZHdBSUFGclFYeHhJZ0lnQUdvaUFVRUVhMEVBTmdJQUFrQWdBa0VKU1EwQUlBQkJBRFlDQ0NBQVFRQTJBZ1FnQVVFSWEwRUFOZ0lBSUFGQkRHdEJBRFlDQUNBQ1FSbEpEUUFnQUVFQU5nSVlJQUJCQURZQ0ZDQUFRUUEyQWhBZ0FFRUFOZ0lNSUFGQkVHdEJBRFlDQUNBQlFSUnJRUUEyQWdBZ0FVRVlhMEVBTmdJQUlBRkJIR3RCQURZQ0FDQUNJQUJCQkhGQkdISWlBbXNpQVVFZ1NRMEFJQUFnQW1vaEFBTkFJQUJDQURjREdDQUFRZ0EzQXhBZ0FFSUFOd01JSUFCQ0FEY0RBQ0FBUVNCcUlRQWdBVUVnYXlJQlFSOUxEUUFMQ3d0V0FRRi9Ba0FnQUNnQ0RBMEFBa0FDUUFKQUFrQWdBQzBBTHc0REFRQURBZ3NnQUNnQ09DSUJSUTBBSUFFb0Fpd2lBVVVOQUNBQUlBRVJBQUFpQVEwREMwRUFEd3NBQ3lBQVFjTVdOZ0lRUVE0aEFRc2dBUXNhQUNBQUtBSU1SUVJBSUFCQjBSczJBaEFnQUVFVk5nSU1Dd3NVQUNBQUtBSU1RUlZHQkVBZ0FFRUFOZ0lNQ3dzVUFDQUFLQUlNUVJaR0JFQWdBRUVBTmdJTUN3c0hBQ0FBS0FJTUN3Y0FJQUFvQWhBTENRQWdBQ0FCTmdJUUN3Y0FJQUFvQWhRTEZ3QWdBRUVrVHdSQUFBc2dBRUVDZEVHZ00yb29BZ0FMRndBZ0FFRXVUd1JBQUFzZ0FFRUNkRUd3Tkdvb0FnQUx2d2tCQVg5QjZ5Z2hBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjVBQnJEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhoSnc4TFFhUWhEd3RCeXl3UEMwSCtNUThMUWNBa0R3dEJxeVFQQzBHTktBOExRZUltRHd0QmdEQVBDMEc1THc4TFFkY2tEd3RCN3g4UEMwSGhIdzhMUWZvZkR3dEI4aUFQQzBHb0x3OExRYTR5RHd0QmlEQVBDMEhzSnc4TFFZSWlEd3RCamgwUEMwSFFMZzhMUWNvakR3dEJ4VElQQzBIZkhBOExRZEljRHd0QnhDQVBDMEhYSUE4TFFhSWZEd3RCN1M0UEMwR3JNQThMUWRRbER3dEJ6QzRQQzBINkxnOExRZndyRHd0QjBqQVBDMEh4SFE4TFFic2dEd3RCOXlzUEMwR1FNUThMUWRjeER3dEJvaTBQQzBIVUp3OExRZUFyRHd0Qm55d1BDMEhyTVE4TFFkVWZEd3RCeWpFUEMwSGVKUThMUWRRZUR3dEI5QndQQzBHbk1nOExRYkVkRHd0Qm9CMFBDMEc1TVE4TFFid3dEd3RCa2lFUEMwR3pKZzhMUWVrc0R3dEJyQjRQQzBIVUt3OExRZmNtRHd0QmdDWVBDMEd3SVE4TFFmNGVEd3RCalNNUEMwR0pMUThMUWZjaUR3dEJvREVQQzBHdUh3OExRY1lsRHd0QjZCNFBDMEdUSWc4TFFjSXZEd3RCd3gwUEMwR0xMQThMUWVFZER3dEJqUzhQQzBIcUlROExRYlF0RHd0QjBpOFBDMEhmTWc4TFFkSXlEd3RCOERBUEMwR3BJZzhMUWZrakR3dEJtUjRQQzBHMUxBOExRWnN3RHd0QmtqSVBDMEcyS3c4TFFjSWlEd3RCK0RJUEMwR2VKUThMUWRBaUR3dEJ1aDRQQzBHQkhnOExBQXRCMWlFaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ4aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z28yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Um8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJxaHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Uk0yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ3aGsyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsQlEyQWhCQkdDRUVDeUFFQzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXdJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1DSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3R6QUNBQVFSQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVRCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUVNCcS9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0RBQ0FBUWQwQk5nSWNDd1lBSUFBUU1ndWFMUUVMZnlNQVFSQnJJZ29rQUVHazBBQW9BZ0FpQ1VVRVFFSGswd0FvQWdBaUJVVUVRRUh3MHdCQ2Z6Y0NBRUhvMHdCQ2dJQ0VnSUNBd0FBM0FnQkI1Tk1BSUFwQkNHcEJjSEZCMktyVnFnVnpJZ1UyQWdCQitOTUFRUUEyQWdCQnlOTUFRUUEyQWdBTFFjelRBRUdBMUFRMkFnQkJuTkFBUVlEVUJEWUNBRUd3MEFBZ0JUWUNBRUdzMEFCQmZ6WUNBRUhRMHdCQmdLd0ROZ0lBQTBBZ0FVSEkwQUJxSUFGQnZOQUFhaUlDTmdJQUlBSWdBVUcwMEFCcUlnTTJBZ0FnQVVIQTBBQnFJQU0yQWdBZ0FVSFEwQUJxSUFGQnhOQUFhaUlETmdJQUlBTWdBallDQUNBQlFkalFBR29nQVVITTBBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQjFOQUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCak5RRVFjR3JBellDQUVHbzBBQkI5Tk1BS0FJQU5nSUFRWmpRQUVIQXF3TTJBZ0JCcE5BQVFZalVCRFlDQUVITS93ZEJPRFlDQUVHSTFBUWhDUXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZXdCVFFSQVFZelFBQ2dDQUNJR1FSQWdBRUVUYWtGd2NTQUFRUXRKR3lJRVFRTjJJZ0IySWdGQkEzRUVRQUpBSUFGQkFYRWdBSEpCQVhNaUFrRURkQ0lBUWJUUUFHb2lBU0FBUWJ6UUFHb29BZ0FpQUNnQ0NDSURSZ1JBUVl6UUFDQUdRWDRnQW5keE5nSUFEQUVMSUFFZ0F6WUNDQ0FESUFFMkFnd0xJQUJCQ0dvaEFTQUFJQUpCQTNRaUFrRURjallDQkNBQUlBSnFJZ0FnQUNnQ0JFRUJjallDQkF3UkMwR1UwQUFvQWdBaUNDQUVUdzBCSUFFRVFBSkFRUUlnQUhRaUFrRUFJQUpyY2lBQklBQjBjV2dpQUVFRGRDSUNRYlRRQUdvaUFTQUNRYnpRQUdvb0FnQWlBaWdDQ0NJRFJnUkFRWXpRQUNBR1FYNGdBSGR4SWdZMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBaUFFUVFOeU5nSUVJQUJCQTNRaUFDQUVheUVGSUFBZ0Ftb2dCVFlDQUNBQ0lBUnFJZ1FnQlVFQmNqWUNCQ0FJQkVBZ0NFRjRjVUcwMEFCcUlRQkJvTkFBS0FJQUlRTUNmMEVCSUFoQkEzWjBJZ0VnQm5GRkJFQkJqTkFBSUFFZ0JuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBTTJBZ3dnQUNBRE5nSUlJQU1nQURZQ0RDQURJQUUyQWdnTElBSkJDR29oQVVHZzBBQWdCRFlDQUVHVTBBQWdCVFlDQUF3UkMwR1EwQUFvQWdBaUMwVU5BU0FMYUVFQ2RFRzgwZ0JxS0FJQUlnQW9BZ1JCZUhFZ0JHc2hCU0FBSVFJRFFBSkFJQUlvQWhBaUFVVUVRQ0FDUVJScUtBSUFJZ0ZGRFFFTElBRW9BZ1JCZUhFZ0JHc2lBeUFGU1NFQ0lBTWdCU0FDR3lFRklBRWdBQ0FDR3lFQUlBRWhBZ3dCQ3dzZ0FDZ0NHQ0VKSUFBb0Fnd2lBeUFBUndSQVFaelFBQ2dDQUJvZ0F5QUFLQUlJSWdFMkFnZ2dBU0FETmdJTURCQUxJQUJCRkdvaUFpZ0NBQ0lCUlFSQUlBQW9BaEFpQVVVTkF5QUFRUkJxSVFJTEEwQWdBaUVISUFFaUEwRVVhaUlDS0FJQUlnRU5BQ0FEUVJCcUlRSWdBeWdDRUNJQkRRQUxJQWRCQURZQ0FBd1BDMEYvSVFRZ0FFRy9mMHNOQUNBQVFSTnFJZ0ZCY0hFaEJFR1EwQUFvQWdBaUNFVU5BRUVBSUFScklRVUNRQUpBQWtBQ2YwRUFJQVJCZ0FKSkRRQWFRUjhnQkVILy8vOEhTdzBBR2lBRVFTWWdBVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxQ3lJR1FRSjBRYnpTQUdvb0FnQWlBa1VFUUVFQUlRRkJBQ0VEREFFTFFRQWhBU0FFUVJrZ0JrRUJkbXRCQUNBR1FSOUhHM1FoQUVFQUlRTURRQUpBSUFJb0FnUkJlSEVnQkdzaUJ5QUZUdzBBSUFJaEF5QUhJZ1VOQUVFQUlRVWdBaUVCREFNTElBRWdBa0VVYWlnQ0FDSUhJQWNnQWlBQVFSMTJRUVJ4YWtFUWFpZ0NBQ0lDUmhzZ0FTQUhHeUVCSUFCQkFYUWhBQ0FDRFFBTEN5QUJJQU55UlFSQVFRQWhBMEVDSUFaMElnQkJBQ0FBYTNJZ0NIRWlBRVVOQXlBQWFFRUNkRUc4MGdCcUtBSUFJUUVMSUFGRkRRRUxBMEFnQVNnQ0JFRjRjU0FFYXlJQ0lBVkpJUUFnQWlBRklBQWJJUVVnQVNBRElBQWJJUU1nQVNnQ0VDSUFCSDhnQUFVZ0FVRVVhaWdDQUFzaUFRMEFDd3NnQTBVTkFDQUZRWlRRQUNnQ0FDQUVhMDhOQUNBREtBSVlJUWNnQXlBREtBSU1JZ0JIQkVCQm5OQUFLQUlBR2lBQUlBTW9BZ2dpQVRZQ0NDQUJJQUEyQWd3TURnc2dBMEVVYWlJQ0tBSUFJZ0ZGQkVBZ0F5Z0NFQ0lCUlEwRElBTkJFR29oQWdzRFFDQUNJUVlnQVNJQVFSUnFJZ0lvQWdBaUFRMEFJQUJCRUdvaEFpQUFLQUlRSWdFTkFBc2dCa0VBTmdJQURBMExRWlRRQUNnQ0FDSURJQVJQQkVCQm9OQUFLQUlBSVFFQ1FDQURJQVJySWdKQkVFOEVRQ0FCSUFScUlnQWdBa0VCY2pZQ0JDQUJJQU5xSUFJMkFnQWdBU0FFUVFOeU5nSUVEQUVMSUFFZ0EwRURjallDQkNBQklBTnFJZ0FnQUNnQ0JFRUJjallDQkVFQUlRQkJBQ0VDQzBHVTBBQWdBallDQUVHZzBBQWdBRFlDQUNBQlFRaHFJUUVNRHd0Qm1OQUFLQUlBSWdNZ0JFc0VRQ0FFSUFscUlnQWdBeUFFYXlJQlFRRnlOZ0lFUWFUUUFDQUFOZ0lBUVpqUUFDQUJOZ0lBSUFrZ0JFRURjallDQkNBSlFRaHFJUUVNRHd0QkFDRUJJQVFDZjBIazB3QW9BZ0FFUUVIczB3QW9BZ0FNQVF0QjhOTUFRbjgzQWdCQjZOTUFRb0NBaElDQWdNQUFOd0lBUWVUVEFDQUtRUXhxUVhCeFFkaXExYW9GY3pZQ0FFSDQwd0JCQURZQ0FFSEkwd0JCQURZQ0FFR0FnQVFMSWdBZ0JFSEhBR29pQldvaUJrRUFJQUJySWdkeElnSlBCRUJCL05NQVFUQTJBZ0FNRHdzQ1FFSEUwd0FvQWdBaUFVVU5BRUc4MHdBb0FnQWlDQ0FDYWlFQUlBQWdBVTBnQUNBSVMzRU5BRUVBSVFGQi9OTUFRVEEyQWdBTUR3dEJ5Tk1BTFFBQVFRUnhEUVFDUUFKQUlBa0VRRUhNMHdBaEFRTkFJQUVvQWdBaUFDQUpUUVJBSUFBZ0FTZ0NCR29nQ1VzTkF3c2dBU2dDQ0NJQkRRQUxDMEVBRURNaUFFRi9SZzBGSUFJaEJrSG8wd0FvQWdBaUFVRUJheUlESUFCeEJFQWdBaUFBYXlBQUlBTnFRUUFnQVd0eGFpRUdDeUFFSUFaUERRVWdCa0grLy8vL0Iwc05CVUhFMHdBb0FnQWlBd1JBUWJ6VEFDZ0NBQ0lISUFacUlRRWdBU0FIVFEwR0lBRWdBMHNOQmdzZ0JoQXpJZ0VnQUVjTkFRd0hDeUFHSUFOcklBZHhJZ1pCL3YvLy93ZExEUVFnQmhBeklRQWdBQ0FCS0FJQUlBRW9BZ1JxUmcwRElBQWhBUXNDUUNBR0lBUkJ5QUJxVHcwQUlBRkJmMFlOQUVIczB3QW9BZ0FpQUNBRklBWnJha0VBSUFCcmNTSUFRZjcvLy84SFN3UkFJQUVoQUF3SEN5QUFFRE5CZjBjRVFDQUFJQVpxSVFZZ0FTRUFEQWNMUVFBZ0Jtc1FNeG9NQkFzZ0FTSUFRWDlIRFFVTUF3dEJBQ0VEREF3TFFRQWhBQXdLQ3lBQVFYOUhEUUlMUWNqVEFFSEkwd0FvQWdCQkJISTJBZ0FMSUFKQi92Ly8vd2RMRFFFZ0FoQXpJUUJCQUJBeklRRWdBRUYvUmcwQklBRkJmMFlOQVNBQUlBRlBEUUVnQVNBQWF5SUdJQVJCT0dwTkRRRUxRYnpUQUVHODB3QW9BZ0FnQm1vaUFUWUNBRUhBMHdBb0FnQWdBVWtFUUVIQTB3QWdBVFlDQUFzQ1FBSkFBa0JCcE5BQUtBSUFJZ0lFUUVITTB3QWhBUU5BSUFBZ0FTZ0NBQ0lESUFFb0FnUWlCV3BHRFFJZ0FTZ0NDQ0lCRFFBTERBSUxRWnpRQUNnQ0FDSUJRUUJISUFBZ0FVOXhSUVJBUVp6UUFDQUFOZ0lBQzBFQUlRRkIwTk1BSUFZMkFnQkJ6Tk1BSUFBMkFnQkJyTkFBUVg4MkFnQkJzTkFBUWVUVEFDZ0NBRFlDQUVIWTB3QkJBRFlDQUFOQUlBRkJ5TkFBYWlBQlFielFBR29pQWpZQ0FDQUNJQUZCdE5BQWFpSUROZ0lBSUFGQndOQUFhaUFETmdJQUlBRkIwTkFBYWlBQlFjVFFBR29pQXpZQ0FDQURJQUkyQWdBZ0FVSFkwQUJxSUFGQnpOQUFhaUlDTmdJQUlBSWdBellDQUNBQlFkVFFBR29nQWpZQ0FDQUJRU0JxSWdGQmdBSkhEUUFMUVhnZ0FHdEJEM0VpQVNBQWFpSUNJQVpCT0dzaUF5QUJheUlCUVFGeU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUUyQWdCQnBOQUFJQUkyQWdBZ0FDQURha0U0TmdJRURBSUxJQUFnQWswTkFDQUNJQU5KRFFBZ0FTZ0NERUVJY1EwQVFYZ2dBbXRCRDNFaUFDQUNhaUlEUVpqUUFDZ0NBQ0FHYWlJSElBQnJJZ0JCQVhJMkFnUWdBU0FGSUFacU5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUEyQWdCQnBOQUFJQU0yQWdBZ0FpQUhha0U0TmdJRURBRUxJQUJCbk5BQUtBSUFTUVJBUVp6UUFDQUFOZ0lBQ3lBQUlBWnFJUU5Cek5NQUlRRUNRQUpBQWtBRFFDQURJQUVvQWdCSEJFQWdBU2dDQ0NJQkRRRU1BZ3NMSUFFdEFBeEJDSEZGRFFFTFFjelRBQ0VCQTBBZ0FTZ0NBQ0lESUFKTkJFQWdBeUFCS0FJRWFpSUZJQUpMRFFNTElBRW9BZ2doQVF3QUN3QUxJQUVnQURZQ0FDQUJJQUVvQWdRZ0JtbzJBZ1FnQUVGNElBQnJRUTl4YWlJSklBUkJBM0kyQWdRZ0EwRjRJQU5yUVE5eGFpSUdJQVFnQ1dvaUJHc2hBU0FDSUFaR0JFQkJwTkFBSUFRMkFnQkJtTkFBUVpqUUFDZ0NBQ0FCYWlJQU5nSUFJQVFnQUVFQmNqWUNCQXdJQzBHZzBBQW9BZ0FnQmtZRVFFR2cwQUFnQkRZQ0FFR1UwQUJCbE5BQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVJQUFnQkdvZ0FEWUNBQXdJQ3lBR0tBSUVJZ1ZCQTNGQkFVY05CaUFGUVhoeElRZ2dCVUgvQVUwRVFDQUZRUU4ySVFNZ0JpZ0NDQ0lBSUFZb0Fnd2lBa1lFUUVHTTBBQkJqTkFBS0FJQVFYNGdBM2R4TmdJQURBY0xJQUlnQURZQ0NDQUFJQUkyQWd3TUJnc2dCaWdDR0NFSElBWWdCaWdDRENJQVJ3UkFJQUFnQmlnQ0NDSUNOZ0lJSUFJZ0FEWUNEQXdGQ3lBR1FSUnFJZ0lvQWdBaUJVVUVRQ0FHS0FJUUlnVkZEUVFnQmtFUWFpRUNDd05BSUFJaEF5QUZJZ0JCRkdvaUFpZ0NBQ0lGRFFBZ0FFRVFhaUVDSUFBb0FoQWlCUTBBQ3lBRFFRQTJBZ0FNQkF0QmVDQUFhMEVQY1NJQklBQnFJZ2NnQmtFNGF5SURJQUZySWdGQkFYSTJBZ1FnQUNBRGFrRTROZ0lFSUFJZ0JVRTNJQVZyUVE5eGFrRS9heUlESUFNZ0FrRVFha2tiSWdOQkl6WUNCRUdvMEFCQjlOTUFLQUlBTmdJQVFaalFBQ0FCTmdJQVFhVFFBQ0FITmdJQUlBTkJFR3BCMU5NQUtRSUFOd0lBSUFOQnpOTUFLUUlBTndJSVFkVFRBQ0FEUVFocU5nSUFRZERUQUNBR05nSUFRY3pUQUNBQU5nSUFRZGpUQUVFQU5nSUFJQU5CSkdvaEFRTkFJQUZCQnpZQ0FDQUZJQUZCQkdvaUFVc05BQXNnQWlBRFJnMEFJQU1nQXlnQ0JFRitjVFlDQkNBRElBTWdBbXNpQlRZQ0FDQUNJQVZCQVhJMkFnUWdCVUgvQVUwRVFDQUZRWGh4UWJUUUFHb2hBQUovUVl6UUFDZ0NBQ0lCUVFFZ0JVRURkblFpQTNGRkJFQkJqTkFBSUFFZ0EzSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBSTJBZ3dnQUNBQ05nSUlJQUlnQURZQ0RDQUNJQUUyQWdnTUFRdEJIeUVCSUFWQi8vLy9CMDBFUUNBRlFTWWdCVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFFTElBSWdBVFlDSENBQ1FnQTNBaEFnQVVFQ2RFRzgwZ0JxSVFCQmtOQUFLQUlBSWdOQkFTQUJkQ0lHY1VVRVFDQUFJQUkyQWdCQmtOQUFJQU1nQm5JMkFnQWdBaUFBTmdJWUlBSWdBallDQ0NBQ0lBSTJBZ3dNQVFzZ0JVRVpJQUZCQVhaclFRQWdBVUVmUnh0MElRRWdBQ2dDQUNFREFrQURRQ0FESWdBb0FnUkJlSEVnQlVZTkFTQUJRUjEySVFNZ0FVRUJkQ0VCSUFBZ0EwRUVjV3BCRUdvaUJpZ0NBQ0lERFFBTElBWWdBallDQUNBQ0lBQTJBaGdnQWlBQ05nSU1JQUlnQWpZQ0NBd0JDeUFBS0FJSUlnRWdBallDRENBQUlBSTJBZ2dnQWtFQU5nSVlJQUlnQURZQ0RDQUNJQUUyQWdnTFFaalFBQ2dDQUNJQklBUk5EUUJCcE5BQUtBSUFJZ0FnQkdvaUFpQUJJQVJySWdGQkFYSTJBZ1JCbU5BQUlBRTJBZ0JCcE5BQUlBSTJBZ0FnQUNBRVFRTnlOZ0lFSUFCQkNHb2hBUXdJQzBFQUlRRkIvTk1BUVRBMkFnQU1Cd3RCQUNFQUN5QUhSUTBBQWtBZ0JpZ0NIQ0lDUVFKMFFielNBR29pQXlnQ0FDQUdSZ1JBSUFNZ0FEWUNBQ0FBRFFGQmtOQUFRWkRRQUNnQ0FFRitJQUozY1RZQ0FBd0NDeUFIUVJCQkZDQUhLQUlRSUFaR0cyb2dBRFlDQUNBQVJRMEJDeUFBSUFjMkFoZ2dCaWdDRUNJQ0JFQWdBQ0FDTmdJUUlBSWdBRFlDR0FzZ0JrRVVhaWdDQUNJQ1JRMEFJQUJCRkdvZ0FqWUNBQ0FDSUFBMkFoZ0xJQUVnQ0dvaEFTQUdJQWhxSWdZb0FnUWhCUXNnQmlBRlFYNXhOZ0lFSUFFZ0JHb2dBVFlDQUNBRUlBRkJBWEkyQWdRZ0FVSC9BVTBFUUNBQlFYaHhRYlRRQUdvaEFBSi9RWXpRQUNnQ0FDSUNRUUVnQVVFRGRuUWlBWEZGQkVCQmpOQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUlCSUFRMkFnd2dBQ0FFTmdJSUlBUWdBRFlDRENBRUlBRTJBZ2dNQVF0Qkh5RUZJQUZCLy8vL0IwMEVRQ0FCUVNZZ0FVRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUVVMSUFRZ0JUWUNIQ0FFUWdBM0FoQWdCVUVDZEVHODBnQnFJUUJCa05BQUtBSUFJZ0pCQVNBRmRDSURjVVVFUUNBQUlBUTJBZ0JCa05BQUlBSWdBM0kyQWdBZ0JDQUFOZ0lZSUFRZ0JEWUNDQ0FFSUFRMkFnd01BUXNnQVVFWklBVkJBWFpyUVFBZ0JVRWZSeHQwSVFVZ0FDZ0NBQ0VBQWtBRFFDQUFJZ0lvQWdSQmVIRWdBVVlOQVNBRlFSMTJJUUFnQlVFQmRDRUZJQUlnQUVFRWNXcEJFR29pQXlnQ0FDSUFEUUFMSUFNZ0JEWUNBQ0FFSUFJMkFoZ2dCQ0FFTmdJTUlBUWdCRFlDQ0F3QkN5QUNLQUlJSWdBZ0JEWUNEQ0FDSUFRMkFnZ2dCRUVBTmdJWUlBUWdBallDRENBRUlBQTJBZ2dMSUFsQkNHb2hBUXdDQ3dKQUlBZEZEUUFDUUNBREtBSWNJZ0ZCQW5SQnZOSUFhaUlDS0FJQUlBTkdCRUFnQWlBQU5nSUFJQUFOQVVHUTBBQWdDRUYrSUFGM2NTSUlOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdBMFliYWlBQU5nSUFJQUJGRFFFTElBQWdCellDR0NBREtBSVFJZ0VFUUNBQUlBRTJBaEFnQVNBQU5nSVlDeUFEUVJScUtBSUFJZ0ZGRFFBZ0FFRVVhaUFCTmdJQUlBRWdBRFlDR0FzQ1FDQUZRUTlOQkVBZ0F5QUVJQVZxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUVhaUlDSUFWQkFYSTJBZ1FnQXlBRVFRTnlOZ0lFSUFJZ0JXb2dCVFlDQUNBRlFmOEJUUVJBSUFWQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnRkJBU0FGUVFOMmRDSUZjVVVFUUVHTTBBQWdBU0FGY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRRWdCVUgvLy84SFRRUkFJQVZCSmlBRlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBUXNnQWlBQk5nSWNJQUpDQURjQ0VDQUJRUUowUWJ6U0FHb2hBRUVCSUFGMElnUWdDSEZGQkVBZ0FDQUNOZ0lBUVpEUUFDQUVJQWh5TmdJQUlBSWdBRFlDR0NBQ0lBSTJBZ2dnQWlBQ05nSU1EQUVMSUFWQkdTQUJRUUYyYTBFQUlBRkJIMGNiZENFQklBQW9BZ0FoQkFKQUEwQWdCQ0lBS0FJRVFYaHhJQVZHRFFFZ0FVRWRkaUVFSUFGQkFYUWhBU0FBSUFSQkJIRnFRUkJxSWdZb0FnQWlCQTBBQ3lBR0lBSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0RDQUNJQUkyQWdnTUFRc2dBQ2dDQ0NJQklBSTJBZ3dnQUNBQ05nSUlJQUpCQURZQ0dDQUNJQUEyQWd3Z0FpQUJOZ0lJQ3lBRFFRaHFJUUVNQVFzQ1FDQUpSUTBBQWtBZ0FDZ0NIQ0lCUVFKMFFielNBR29pQWlnQ0FDQUFSZ1JBSUFJZ0F6WUNBQ0FERFFGQmtOQUFJQXRCZmlBQmQzRTJBZ0FNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUFSaHRxSUFNMkFnQWdBMFVOQVFzZ0F5QUpOZ0lZSUFBb0FoQWlBUVJBSUFNZ0FUWUNFQ0FCSUFNMkFoZ0xJQUJCRkdvb0FnQWlBVVVOQUNBRFFSUnFJQUUyQWdBZ0FTQUROZ0lZQ3dKQUlBVkJEMDBFUUNBQUlBUWdCV29pQVVFRGNqWUNCQ0FBSUFGcUlnRWdBU2dDQkVFQmNqWUNCQXdCQ3lBQUlBUnFJZ2NnQlVFQmNqWUNCQ0FBSUFSQkEzSTJBZ1FnQlNBSGFpQUZOZ0lBSUFnRVFDQUlRWGh4UWJUUUFHb2hBVUdnMEFBb0FnQWhBd0ovUVFFZ0NFRURkblFpQWlBR2NVVUVRRUdNMEFBZ0FpQUdjallDQUNBQkRBRUxJQUVvQWdnTElnSWdBellDRENBQklBTTJBZ2dnQXlBQk5nSU1JQU1nQWpZQ0NBdEJvTkFBSUFjMkFnQkJsTkFBSUFVMkFnQUxJQUJCQ0dvaEFRc2dDa0VRYWlRQUlBRUxRd0FnQUVVRVFEOEFRUkIwRHdzQ1FDQUFRZi8vQTNFTkFDQUFRUUJJRFFBZ0FFRVFka0FBSWdCQmYwWUVRRUg4MHdCQk1EWUNBRUYvRHdzZ0FFRVFkQThMQUFzTDNEOGlBRUdBQ0FzSkFRQUFBQUlBQUFBREFFR1VDQXNGQkFBQUFBVUFRYVFJQ3drR0FBQUFCd0FBQUFnQVFkd0lDNG90U1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCeGRXVnllUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMkp2WkhrQVEyOXVkR1Z1ZEMxTVpXNW5kR2dnYjNabGNtWnNiM2NBUTJoMWJtc2djMmw2WlNCdmRtVnlabXh2ZHdCU1pYTndiMjV6WlNCdmRtVnlabXh2ZHdCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1NGUlVVQzk0TG5nZ2NtVnhkV1Z6ZEFCSmJuWmhiR2xrSUcxbGRHaHZaQ0JtYjNJZ1VsUlRVQzk0TG5nZ2NtVnhkV1Z6ZEFCRmVIQmxZM1JsWkNCVFQxVlNRMFVnYldWMGFHOWtJR1p2Y2lCSlEwVXZlQzU0SUhKbGNYVmxjM1FBU1c1MllXeHBaQ0JqYUdGeUlHbHVJSFZ5YkNCbWNtRm5iV1Z1ZENCemRHRnlkQUJGZUhCbFkzUmxaQ0JrYjNRQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5emRHRjBkWE1BU1c1MllXeHBaQ0J5WlhOd2IyNXpaU0J6ZEdGMGRYTUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjd0JWYzJWeUlHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXlaWE5sZEdBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyTm9kVzVyWDJobFlXUmxjbUFnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDIxbGMzTmhaMlZmWW1WbmFXNWdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOXpkR0YwZFhOZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZkWEpzWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5b1pXRmtaWEpmZG1Gc2RXVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWMGFHOWtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYUdWaFpHVnlYMlpwWld4a1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBRlZ1Wlhod1pXTjBaV1FnWTJoaGNpQnBiaUIxY213Z2MyVnlkbVZ5QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFpoYkhWbElHTm9ZWElBU1c1MllXeHBaQ0JvWldGa1pYSWdabWxsYkdRZ1kyaGhjZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1psY25OcGIyNEFTVzUyWVd4cFpDQnRhVzV2Y2lCMlpYSnphVzl1QUVsdWRtRnNhV1FnYldGcWIzSWdkbVZ5YzJsdmJnQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUIyWlhKemFXOXVBRVY0Y0dWamRHVmtJRU5TVEVZZ1lXWjBaWElnZG1WeWMybHZiZ0JKYm5aaGJHbGtJRWhVVkZBZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUdobFlXUmxjaUIwYjJ0bGJnQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgzVnliQUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjbk1nYVc0Z2RYSnNBRlZ1Wlhod1pXTjBaV1FnYzNSaGNuUWdZMmhoY2lCcGJpQjFjbXdBUkc5MVlteGxJRUFnYVc0Z2RYSnNBRVZ0Y0hSNUlFTnZiblJsYm5RdFRHVnVaM1JvQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlFTnZiblJsYm5RdFRHVnVaM1JvQUVSMWNHeHBZMkYwWlNCRGIyNTBaVzUwTFV4bGJtZDBhQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhCaGRHZ0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ1kyRnVKM1FnWW1VZ2NISmxjMlZ1ZENCM2FYUm9JRlJ5WVc1elptVnlMVVZ1WTI5a2FXNW5BRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJSE5wZW1VQVUzQmhiaUJqWVd4c1ltRmpheUJsY25KdmNpQnBiaUJ2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmRtRnNkV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCMllXeDFaUUJOYVhOemFXNW5JR1Y0Y0dWamRHVmtJRXhHSUdGbWRHVnlJR2hsWVdSbGNpQjJZV3gxWlFCSmJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBZ2FHVmhaR1Z5SUhaaGJIVmxBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnlJR2x1SUdOb2RXNXJJR1Y0ZEdWdWMybHZibk1nY1hWdmRHVWdkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QnhkVzkwWldRZ2RtRnNkV1VBVUdGMWMyVmtJR0o1SUc5dVgyaGxZV1JsY25OZlkyOXRjR3hsZEdVQVNXNTJZV3hwWkNCRlQwWWdjM1JoZEdVQWIyNWZjbVZ6WlhRZ2NHRjFjMlVBYjI1ZlkyaDFibXRmYUdWaFpHVnlJSEJoZFhObEFHOXVYMjFsYzNOaFoyVmZZbVZuYVc0Z2NHRjFjMlVBYjI1ZlkyaDFibXRmWlhoMFpXNXphVzl1WDNaaGJIVmxJSEJoZFhObEFHOXVYM04wWVhSMWMxOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOTJaWEp6YVc5dVgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzVnliRjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlqYUhWdWExOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYldWemMyRm5aVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVWdjR0YxYzJVQWIyNWZhR1ZoWkdWeVgyWnBaV3hrWDJOdmJYQnNaWFJsSUhCaGRYTmxBRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbElIQmhkWE5sQUZWdVpYaHdaV04wWldRZ2MzQmhZMlVnWVdaMFpYSWdjM1JoY25RZ2JHbHVaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOXVZVzFsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2JtRnRaUUJRWVhWelpTQnZiaUJEVDA1T1JVTlVMMVZ3WjNKaFpHVUFVR0YxYzJVZ2IyNGdVRkpKTDFWd1ozSmhaR1VBUlhod1pXTjBaV1FnU0ZSVVVDOHlJRU52Ym01bFkzUnBiMjRnVUhKbFptRmpaUUJUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYMjFsZEdodlpBQkZlSEJsWTNSbFpDQnpjR0ZqWlNCaFpuUmxjaUJ0WlhSb2IyUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZlptbGxiR1FBVUdGMWMyVmtBRWx1ZG1Gc2FXUWdkMjl5WkNCbGJtTnZkVzUwWlhKbFpBQkpiblpoYkdsa0lHMWxkR2h2WkNCbGJtTnZkVzUwWlhKbFpBQlZibVY0Y0dWamRHVmtJR05vWVhJZ2FXNGdkWEpzSUhOamFHVnRZUUJTWlhGMVpYTjBJR2hoY3lCcGJuWmhiR2xrSUdCVWNtRnVjMlpsY2kxRmJtTnZaR2x1WjJBQVUxZEpWRU5JWDFCU1QxaFpBRlZUUlY5UVVrOVlXUUJOUzBGRFZFbFdTVlJaQUZWT1VGSlBRMFZUVTBGQ1RFVmZSVTVVU1ZSWkFFTlBVRmtBVFU5V1JVUmZVRVZTVFVGT1JVNVVURmtBVkU5UFgwVkJVa3haQUU1UFZFbEdXUUJHUVVsTVJVUmZSRVZRUlU1RVJVNURXUUJDUVVSZlIwRlVSVmRCV1FCUVRFRlpBRkJWVkFCRFNFVkRTMDlWVkFCSFFWUkZWMEZaWDFSSlRVVlBWVlFBVWtWUlZVVlRWRjlVU1UxRlQxVlVBRTVGVkZkUFVrdGZRMDlPVGtWRFZGOVVTVTFGVDFWVUFFTlBUazVGUTFSSlQwNWZWRWxOUlU5VlZBQk1UMGRKVGw5VVNVMUZUMVZVQUU1RlZGZFBVa3RmVWtWQlJGOVVTVTFGVDFWVUFGQlBVMVFBVFVsVFJFbFNSVU5VUlVSZlVrVlJWVVZUVkFCRFRFbEZUbFJmUTB4UFUwVkVYMUpGVVZWRlUxUUFRMHhKUlU1VVgwTk1UMU5GUkY5TVQwRkVYMEpCVEVGT1EwVkVYMUpGVVZWRlUxUUFRa0ZFWDFKRlVWVkZVMVFBU0ZSVVVGOVNSVkZWUlZOVVgxTkZUbFJmVkU5ZlNGUlVVRk5mVUU5U1ZBQlNSVkJQVWxRQVNVMWZRVjlVUlVGUVQxUUFVa1ZUUlZSZlEwOU9WRVZPVkFCT1QxOURUMDVVUlU1VUFGQkJVbFJKUVV4ZlEwOU9WRVZPVkFCSVVFVmZTVTVXUVV4SlJGOURUMDVUVkVGT1ZBQklVRVZmUTBKZlVrVlRSVlFBUjBWVUFFaFFSVjlUVkZKSlExUUFRMDlPUmt4SlExUUFWRVZOVUU5U1FWSlpYMUpGUkVsU1JVTlVBRkJGVWsxQlRrVk9WRjlTUlVSSlVrVkRWQUJEVDA1T1JVTlVBRTFWVEZSSlgxTlVRVlJWVXdCSVVFVmZTVTVXUVV4SlJGOVRWRUZVVlZNQVZFOVBYMDFCVGxsZlVrVlJWVVZUVkZNQVJVRlNURmxmU0VsT1ZGTUFWVTVCVmtGSlRFRkNURVZmUms5U1gweEZSMEZNWDFKRlFWTlBUbE1BVDFCVVNVOU9Vd0JUVjBsVVEwaEpUa2RmVUZKUFZFOURUMHhUQUZaQlVrbEJUbFJmUVV4VFQxOU9SVWRQVkVsQlZFVlRBRTFWVEZSSlVFeEZYME5JVDBsRFJWTUFTVTVVUlZKT1FVeGZVMFZTVmtWU1gwVlNVazlTQUZkRlFsOVRSVkpXUlZKZlZVNUxUazlYVGw5RlVsSlBVZ0JTUVVsTVIxVk9YMFZTVWs5U0FFbEVSVTVVU1ZSWlgxQlNUMVpKUkVWU1gwRlZWRWhGVGxSSlEwRlVTVTlPWDBWU1VrOVNBRk5UVEY5RFJWSlVTVVpKUTBGVVJWOUZVbEpQVWdCSlRsWkJURWxFWDFoZlJrOVNWMEZTUkVWRVgwWlBVZ0JUUlZSZlVFRlNRVTFGVkVWU0FFZEZWRjlRUVZKQlRVVlVSVklBU0ZCRlgxVlRSVklBVTBWRlgwOVVTRVZTQUVoUVJWOURRbDlEU0ZWT1MxOUlSVUZFUlZJQVRVdERRVXhGVGtSQlVnQlRSVlJWVUFCWFJVSmZVMFZTVmtWU1gwbFRYMFJQVjA0QVZFVkJVa1JQVjA0QVNGQkZYME5NVDFORlJGOURUMDVPUlVOVVNVOU9BRWhGVlZKSlUxUkpRMTlGV0ZCSlVrRlVTVTlPQUVSSlUwTlBUazVGUTFSRlJGOVBVRVZTUVZSSlQwNEFUazlPWDBGVlZFaFBVa2xVUVZSSlZrVmZTVTVHVDFKTlFWUkpUMDRBU0ZCRlgwbE9Wa0ZNU1VSZlZrVlNVMGxQVGdCSVVFVmZRMEpmVFVWVFUwRkhSVjlDUlVkSlRnQlRTVlJGWDBsVFgwWlNUMXBGVGdCSVVFVmZTVTVXUVV4SlJGOUlSVUZFUlZKZlZFOUxSVTRBU1U1V1FVeEpSRjlVVDB0RlRnQkdUMUpDU1VSRVJVNEFSVTVJUVU1RFJWOVpUMVZTWDBOQlRFMEFTRkJGWDBsT1ZrRk1TVVJmVlZKTUFFSk1UME5MUlVSZlFsbGZVRUZTUlU1VVFVeGZRMDlPVkZKUFRBQk5TME5QVEFCQlEwd0FTRkJGWDBsT1ZFVlNUa0ZNQUZKRlVWVkZVMVJmU0VWQlJFVlNYMFpKUlV4RVUxOVVUMDlmVEVGU1IwVmZWVTVQUmtaSlEwbEJUQUJJVUVWZlQwc0FWVTVNU1U1TEFGVk9URTlEU3dCUVVra0FVa1ZVVWxsZlYwbFVTQUJJVUVWZlNVNVdRVXhKUkY5RFQwNVVSVTVVWDB4RlRrZFVTQUJJVUVWZlZVNUZXRkJGUTFSRlJGOURUMDVVUlU1VVgweEZUa2RVU0FCR1RGVlRTQUJRVWs5UVVFRlVRMGdBVFMxVFJVRlNRMGdBVlZKSlgxUlBUMTlNVDA1SEFGQlNUME5GVTFOSlRrY0FUVWxUUTBWTVRFRk9SVTlWVTE5UVJWSlRTVk5VUlU1VVgxZEJVazVKVGtjQVRVbFRRMFZNVEVGT1JVOVZVMTlYUVZKT1NVNUhBRWhRUlY5SlRsWkJURWxFWDFSU1FVNVRSa1ZTWDBWT1EwOUVTVTVIQUVWNGNHVmpkR1ZrSUVOU1RFWUFTRkJGWDBsT1ZrRk1TVVJmUTBoVlRrdGZVMGxhUlFCTlQxWkZBRU5QVGxSSlRsVkZBRWhRUlY5RFFsOVRWRUZVVlZOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbE5mUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMVpGVWxOSlQwNWZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gxVlNURjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlEwOU5VRXhGVkVVQVNGQkZYME5DWDBoRlFVUkZVbDlXUVV4VlJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlEwaFZUa3RmUlZoVVJVNVRTVTlPWDFaQlRGVkZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RldGUkZUbE5KVDA1ZlRrRk5SVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZUVVZUVTBGSFJWOURUMDFRVEVWVVJRQklVRVZmUTBKZlRVVlVTRTlFWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlJUlVGRVJWSmZSa2xGVEVSZlEwOU5VRXhGVkVVQVJFVk1SVlJGQUVoUVJWOUpUbFpCVEVsRVgwVlBSbDlUVkVGVVJRQkpUbFpCVEVsRVgxTlRURjlEUlZKVVNVWkpRMEZVUlFCUVFWVlRSUUJPVDE5U1JWTlFUMDVUUlFCVlRsTlZVRkJQVWxSRlJGOU5SVVJKUVY5VVdWQkZBRWRQVGtVQVRrOVVYMEZEUTBWUVZFRkNURVVBVTBWU1ZrbERSVjlWVGtGV1FVbE1RVUpNUlFCU1FVNUhSVjlPVDFSZlUwRlVTVk5HU1VGQ1RFVUFUMUpKUjBsT1gwbFRYMVZPVWtWQlEwaEJRa3hGQUZKRlUxQlBUbE5GWDBsVFgxTlVRVXhGQUZCVlVrZEZBRTFGVWtkRkFGSkZVVlZGVTFSZlNFVkJSRVZTWDBaSlJVeEVVMTlVVDA5ZlRFRlNSMFVBVWtWUlZVVlRWRjlJUlVGRVJWSmZWRTlQWDB4QlVrZEZBRkJCV1V4UFFVUmZWRTlQWDB4QlVrZEZBRWxPVTFWR1JrbERTVVZPVkY5VFZFOVNRVWRGQUVoUVJWOVFRVlZUUlVSZlZWQkhVa0ZFUlFCSVVFVmZVRUZWVTBWRVgwZ3lYMVZRUjFKQlJFVUFVMDlWVWtORkFFRk9UazlWVGtORkFGUlNRVU5GQUVoUVJWOVZUa1ZZVUVWRFZFVkVYMU5RUVVORkFFUkZVME5TU1VKRkFGVk9VMVZDVTBOU1NVSkZBRkpGUTA5U1JBQklVRVZmU1U1V1FVeEpSRjlOUlZSSVQwUUFUazlVWDBaUFZVNUVBRkJTVDFCR1NVNUVBRlZPUWtsT1JBQlNSVUpKVGtRQVZVNUJWVlJJVDFKSldrVkVBRTFGVkVoUFJGOU9UMVJmUVV4TVQxZEZSQUJJVkZSUVgxWkZVbE5KVDA1ZlRrOVVYMU5WVUZCUFVsUkZSQUJCVEZKRlFVUlpYMUpGVUU5U1ZFVkVBRUZEUTBWUVZFVkVBRTVQVkY5SlRWQk1SVTFGVGxSRlJBQk1UMDlRWDBSRlZFVkRWRVZFQUVoUVJWOURVbDlGV0ZCRlExUkZSQUJJVUVWZlRFWmZSVmhRUlVOVVJVUUFRMUpGUVZSRlJBQkpUVjlWVTBWRUFFaFFSVjlRUVZWVFJVUUFWRWxOUlU5VlZGOVBRME5WVWtWRUFGQkJXVTFGVGxSZlVrVlJWVWxTUlVRQVVGSkZRMDlPUkVsVVNVOU9YMUpGVVZWSlVrVkVBRkJTVDFoWlgwRlZWRWhGVGxSSlEwRlVTVTlPWDFKRlVWVkpVa1ZFQUU1RlZGZFBVa3RmUVZWVVNFVk9WRWxEUVZSSlQwNWZVa1ZSVlVsU1JVUUFURVZPUjFSSVgxSkZVVlZKVWtWRUFGTlRURjlEUlZKVVNVWkpRMEZVUlY5U1JWRlZTVkpGUkFCVlVFZFNRVVJGWDFKRlVWVkpVa1ZFQUZCQlIwVmZSVmhRU1ZKRlJBQlFVa1ZEVDA1RVNWUkpUMDVmUmtGSlRFVkVBRVZZVUVWRFZFRlVTVTlPWDBaQlNVeEZSQUJTUlZaQlRFbEVRVlJKVDA1ZlJrRkpURVZFQUZOVFRGOUlRVTVFVTBoQlMwVmZSa0ZKVEVWRUFFeFBRMHRGUkFCVVVrRk9VMFpQVWsxQlZFbFBUbDlCVUZCTVNVVkVBRTVQVkY5TlQwUkpSa2xGUkFCT1QxUmZSVmhVUlU1RVJVUUFRa0ZPUkZkSlJGUklYMHhKVFVsVVgwVllRMFZGUkVWRUFGTkpWRVZmU1ZOZlQxWkZVa3hQUVVSRlJBQklSVUZFQUVWNGNHVmpkR1ZrSUVoVVZGQXZBQUJlRXdBQUpoTUFBREFRQUFEd0Z3QUFuUk1BQUJVU0FBQTVGd0FBOEJJQUFBb1FBQUIxRWdBQXJSSUFBSUlUQUFCUEZBQUFmeEFBQUtBVkFBQWpGQUFBaVJJQUFJc1VBQUJORlFBQTFCRUFBTThVQUFBUUdBQUF5UllBQU53V0FBREJFUUFBNEJjQUFMc1VBQUIwRkFBQWZCVUFBT1VVQUFBSUZ3QUFIeEFBQUdVVkFBQ2pGQUFBS0JVQUFBSVZBQUNaRlFBQUxCQUFBSXNaQUFCUER3QUExQTRBQUdvUUFBRE9FQUFBQWhjQUFJa09BQUJ1RXdBQUhCTUFBR1lVQUFCV0Z3QUF3Uk1BQU0wVEFBQnNFd0FBYUJjQUFHWVhBQUJmRndBQUloTUFBTTRQQUFCcERnQUEyQTRBQUdNV0FBRExFd0FBcWc0QUFDZ1hBQUFtRndBQXhSTUFBRjBXQUFEb0VRQUFaeE1BQUdVVEFBRHlGZ0FBY3hNQUFCMFhBQUQ1RmdBQTh4RUFBTThPQUFET0ZRQUFEQklBQUxNUkFBQ2xFUUFBWVJBQUFESVhBQUM3RXdCQitUVUxBUUVBUVpBMkMrQUJBUUVDQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFRZjAzQ3dFQkFFR1JPQXRlQWdNQ0FnSUNBZ0FBQWdJQUFnSUFBZ0lDQWdJQ0FnSUNBZ0FFQUFBQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJQUFnQkIvVGtMQVFFQVFaRTZDMTRDQUFJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQU1BQkFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FFSHdPd3NOYkc5elpXVmxjQzFoYkdsMlpRQkJpVHdMQVFFQVFhQThDK0FCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUVlrK0N3RUJBRUdnUGd2bkFRRUJBUUVCQVFFQkFRRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQlkyaDFibXRsWkFCQnNNQUFDMThCQVFBQkFRRUJBUUFBQVFFQUFRRUFBUUVCQVFFQkFRRUJBUUFBQUFBQUFBQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQkJrTUlBQ3lGbFkzUnBiMjVsYm5RdGJHVnVaM1JvYjI1eWIzaDVMV052Ym01bFkzUnBiMjRBUWNEQ0FBc3RjbUZ1YzJabGNpMWxibU52WkdsdVozQm5jbUZrWlEwS0RRb05DbE5ORFFvTkNsUlVVQzlEUlM5VVUxQXZBRUg1d2dBTEJRRUNBQUVEQUVHUXd3QUw0QUVFQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK2NRQUN3VUJBZ0FCQXdCQmtNVUFDK0FCQkFFQkJRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUWZuR0FBc0VBUUFBQVFCQmtjY0FDOThCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK3NnQUN3UUJBQUFDQUVHUXlRQUxYd01FQUFBRUJBUUVCQVFFQkFRRUJBVUVCQVFFQkFRRUJBUUVCQVFBQkFBR0J3UUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVBQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFBQUFBRUFFSDZ5Z0FMQkFFQUFBRUFRWkRMQUFzQkFRQkJxc3NBQzBFQ0FBQUFBQUFBQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01BQUFBQUFBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3QkIrc3dBQ3dRQkFBQUJBRUdRelFBTEFRRUFRWnJOQUFzR0FnQUFBQUFDQUVHeHpRQUxPZ01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQVFmRE9BQXVXQVU1UFZVNURSVVZEUzA5VlZFNUZRMVJGVkVWRFVrbENSVXhWVTBoRlZFVkJSRk5GUVZKRFNGSkhSVU5VU1ZaSlZGbE1SVTVFUVZKV1JVOVVTVVpaVUZSSlQwNVRRMGhUUlVGWlUxUkJWRU5JUjBWUFVrUkpVa1ZEVkU5U1ZGSkRTRkJCVWtGTlJWUkZVbFZTUTBWQ1UwTlNTVUpGUVZKRVQxZE9RVU5GU1U1RVRrdERTMVZDVTBOU1NVSkZTRlJVVUM5QlJGUlFMdz09JywgJ2Jhc2U2NCcpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnVtVG9NYXAgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbnVtVG9NYXAob2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5lbnVtVG9NYXAgPSBlbnVtVG9NYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(ssr)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(ssr)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(ssr)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(ssr)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(ssr)/./node_modules/undici/lib/mock/pluralizer.js\")\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\")\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts?.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, dispatcher)\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const client = this[kClients].get(origin)\n    if (client) {\n      return client\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGdGQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBYTtBQUN0QyxRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDL0QsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBMEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWM7QUFDekMscUNBQXFDLG1CQUFPLENBQUMsZ0hBQWtDOztBQUUvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLHFCQUFxQjtBQUMvRixpQkFBaUIsU0FBUztBQUMxQjs7QUFFQSxpQ0FBaUMsb0VBQW9FLElBQUk7QUFDekc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxlQUFlOztBQUV4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ2xpZW50cyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9hZ2VudCcpXG5jb25zdCB7XG4gIGtBZ2VudCxcbiAga01vY2tBZ2VudFNldCxcbiAga01vY2tBZ2VudEdldCxcbiAga0Rpc3BhdGNoZXMsXG4gIGtJc01vY2tBY3RpdmUsXG4gIGtOZXRDb25uZWN0LFxuICBrR2V0TmV0Q29ubmVjdCxcbiAga09wdGlvbnMsXG4gIGtGYWN0b3J5XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgTW9ja0NsaWVudCA9IHJlcXVpcmUoJy4vbW9jay1jbGllbnQnKVxuY29uc3QgTW9ja1Bvb2wgPSByZXF1aXJlKCcuL21vY2stcG9vbCcpXG5jb25zdCB7IG1hdGNoVmFsdWUsIGJ1aWxkTW9ja09wdGlvbnMgfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBVbmRpY2lFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvZGlzcGF0Y2hlcicpXG5jb25zdCBQbHVyYWxpemVyID0gcmVxdWlyZSgnLi9wbHVyYWxpemVyJylcbmNvbnN0IFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlcicpXG5cbmNsYXNzIE1vY2tBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB0aGlzW2tJc01vY2tBY3RpdmVdID0gdHJ1ZVxuXG4gICAgLy8gSW5zdGFudGlhdGUgQWdlbnQgYW5kIGVuY2Fwc3VsYXRlXG4gICAgaWYgKChvcHRzPy5hZ2VudCAmJiB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuICAgIGNvbnN0IGFnZW50ID0gb3B0cz8uYWdlbnQgPyBvcHRzLmFnZW50IDogbmV3IEFnZW50KG9wdHMpXG4gICAgdGhpc1trQWdlbnRdID0gYWdlbnRcblxuICAgIHRoaXNba0NsaWVudHNdID0gYWdlbnRba0NsaWVudHNdXG4gICAgdGhpc1trT3B0aW9uc10gPSBidWlsZE1vY2tPcHRpb25zKG9wdHMpXG4gIH1cblxuICBnZXQgKG9yaWdpbikge1xuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trTW9ja0FnZW50R2V0XShvcmlnaW4pXG5cbiAgICBpZiAoIWRpc3BhdGNoZXIpIHtcbiAgICAgIGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICB9XG4gICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgLy8gQ2FsbCBNb2NrQWdlbnQuZ2V0IHRvIHBlcmZvcm0gYWRkaXRpb25hbCBzZXR1cCBiZWZvcmUgZGlzcGF0Y2hpbmcgYXMgbm9ybWFsXG4gICAgdGhpcy5nZXQob3B0cy5vcmlnaW4pXG4gICAgcmV0dXJuIHRoaXNba0FnZW50XS5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgY2xvc2UgKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgdGhpc1trQ2xpZW50c10uY2xlYXIoKVxuICB9XG5cbiAgZGVhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IGZhbHNlXG4gIH1cblxuICBhY3RpdmF0ZSAoKSB7XG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcbiAgfVxuXG4gIGVuYWJsZU5ldENvbm5lY3QgKG1hdGNoZXIpIHtcbiAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nIHx8IG1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXNba05ldENvbm5lY3RdKSkge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XS5wdXNoKG1hdGNoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IFttYXRjaGVyXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2tOZXRDb25uZWN0XSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdVbnN1cHBvcnRlZCBtYXRjaGVyLiBNdXN0IGJlIG9uZSBvZiBTdHJpbmd8RnVuY3Rpb258UmVnRXhwLicpXG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZU5ldENvbm5lY3QgKCkge1xuICAgIHRoaXNba05ldENvbm5lY3RdID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gYnlwYXNzIGlzc3VlcyBjYXVzZWQgYnkgdXNpbmcgZ2xvYmFsIHN5bWJvbHMgLSBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNDQ3XG4gIGdldCBpc01vY2tBY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzW2tJc01vY2tBY3RpdmVdXG4gIH1cblxuICBba01vY2tBZ2VudFNldF0gKG9yaWdpbiwgZGlzcGF0Y2hlcikge1xuICAgIHRoaXNba0NsaWVudHNdLnNldChvcmlnaW4sIGRpc3BhdGNoZXIpXG4gIH1cblxuICBba0ZhY3RvcnldIChvcmlnaW4pIHtcbiAgICBjb25zdCBtb2NrT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBhZ2VudDogdGhpcyB9LCB0aGlzW2tPcHRpb25zXSlcbiAgICByZXR1cm4gdGhpc1trT3B0aW9uc10gJiYgdGhpc1trT3B0aW9uc10uY29ubmVjdGlvbnMgPT09IDFcbiAgICAgID8gbmV3IE1vY2tDbGllbnQob3JpZ2luLCBtb2NrT3B0aW9ucylcbiAgICAgIDogbmV3IE1vY2tQb29sKG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gIH1cblxuICBba01vY2tBZ2VudEdldF0gKG9yaWdpbikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIHdlIGNhbiBpbW1lZGlhdGVseSBmaW5kIGl0XG4gICAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50c10uZ2V0KG9yaWdpbilcbiAgICBpZiAoY2xpZW50KSB7XG4gICAgICByZXR1cm4gY2xpZW50XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9yaWdpbiBpcyBub3QgYSBzdHJpbmcgY3JlYXRlIGEgZHVtbXkgcGFyZW50IHBvb2wgYW5kIHJldHVybiB0byB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0oJ2h0dHA6Ly9sb2NhbGhvc3Q6OTk5OScpXG4gICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgbWF0Y2gsIGNyZWF0ZSBhIHBvb2wgYW5kIGFzc2lnbiB0aGUgc2FtZSBkaXNwYXRjaGVzXG4gICAgZm9yIChjb25zdCBba2V5TWF0Y2hlciwgbm9uRXhwbGljaXREaXNwYXRjaGVyXSBvZiBBcnJheS5mcm9tKHRoaXNba0NsaWVudHNdKSkge1xuICAgICAgaWYgKG5vbkV4cGxpY2l0RGlzcGF0Y2hlciAmJiB0eXBlb2Yga2V5TWF0Y2hlciAhPT0gJ3N0cmluZycgJiYgbWF0Y2hWYWx1ZShrZXlNYXRjaGVyLCBvcmlnaW4pKSB7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSB0aGlzW2tGYWN0b3J5XShvcmlnaW4pXG4gICAgICAgIHRoaXNba01vY2tBZ2VudFNldF0ob3JpZ2luLCBkaXNwYXRjaGVyKVxuICAgICAgICBkaXNwYXRjaGVyW2tEaXNwYXRjaGVzXSA9IG5vbkV4cGxpY2l0RGlzcGF0Y2hlcltrRGlzcGF0Y2hlc11cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBba0dldE5ldENvbm5lY3RdICgpIHtcbiAgICByZXR1cm4gdGhpc1trTmV0Q29ubmVjdF1cbiAgfVxuXG4gIHBlbmRpbmdJbnRlcmNlcHRvcnMgKCkge1xuICAgIGNvbnN0IG1vY2tBZ2VudENsaWVudHMgPSB0aGlzW2tDbGllbnRzXVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20obW9ja0FnZW50Q2xpZW50cy5lbnRyaWVzKCkpXG4gICAgICAuZmxhdE1hcCgoW29yaWdpbiwgc2NvcGVdKSA9PiBzY29wZVtrRGlzcGF0Y2hlc10ubWFwKGRpc3BhdGNoID0+ICh7IC4uLmRpc3BhdGNoLCBvcmlnaW4gfSkpKVxuICAgICAgLmZpbHRlcigoeyBwZW5kaW5nIH0pID0+IHBlbmRpbmcpXG4gIH1cblxuICBhc3NlcnROb1BlbmRpbmdJbnRlcmNlcHRvcnMgKHsgcGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlciA9IG5ldyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyKCkgfSA9IHt9KSB7XG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ0ludGVyY2VwdG9ycygpXG5cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBsdXJhbGl6ZXIgPSBuZXcgUGx1cmFsaXplcignaW50ZXJjZXB0b3InLCAnaW50ZXJjZXB0b3JzJykucGx1cmFsaXplKHBlbmRpbmcubGVuZ3RoKVxuXG4gICAgdGhyb3cgbmV3IFVuZGljaUVycm9yKGBcbiR7cGx1cmFsaXplci5jb3VudH0gJHtwbHVyYWxpemVyLm5vdW59ICR7cGx1cmFsaXplci5pc30gcGVuZGluZzpcblxuJHtwZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyLmZvcm1hdChwZW5kaW5nKX1cbmAudHJpbSgpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0FnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(ssr)/./node_modules/undici/lib/dispatcher/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtGQUFzQjtBQUM3QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFpQjtBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLWNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2NsaWVudCcpXG5jb25zdCB7IGJ1aWxkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga0Nsb3NlLFxuICBrT3JpZ2luYWxDbG9zZSxcbiAga09yaWdpbixcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtDb25uZWN0ZWRcbn0gPSByZXF1aXJlKCcuL21vY2stc3ltYm9scycpXG5jb25zdCB7IE1vY2tJbnRlcmNlcHRvciB9ID0gcmVxdWlyZSgnLi9tb2NrLWludGVyY2VwdG9yJylcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuXG4vKipcbiAqIE1vY2tDbGllbnQgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgQ2xpZW50IHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tDbGllbnQgZXh0ZW5kcyBDbGllbnQge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMVxuICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaFxuICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKVxuICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV1cbiAgfVxuXG4gIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBiYXNlIGludGVyY2VwdG9yIGZvciBtb2NraW5nIHJlcGxpZXMgZnJvbSB1bmRpY2kuXG4gICAqL1xuICBpbnRlcmNlcHQgKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrQ2xpZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, MockNotMatchedError)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY2xhc3MgTW9ja05vdE1hdGNoZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1vY2tOb3RNYXRjaGVkRXJyb3IpXG4gICAgdGhpcy5uYW1lID0gJ01vY2tOb3RNYXRjaGVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIHJlcXVlc3QgZG9lcyBub3QgbWF0Y2ggYW55IHJlZ2lzdGVyZWQgbW9jayBkaXNwYXRjaGVzJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfTU9DS19FUlJfTU9DS19OT1RfTUFUQ0hFRCdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTW9ja05vdE1hdGNoZWRFcnJvclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = buildURL(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData ({ statusCode, data, responseOptions }) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (replyParameters) {\n    if (typeof replyParameters.statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyOptionsCallbackOrStatusCode) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyOptionsCallbackOrStatusCode(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object' || resolvedData === null) {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const replyParameters = { data: '', responseOptions: {}, ...resolvedData }\n        this.validateReplyParameters(replyParameters)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(replyParameters)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const replyParameters = {\n      statusCode: replyOptionsCallbackOrStatusCode,\n      data: arguments[1] === undefined ? '' : arguments[1],\n      responseOptions: arguments[2] === undefined ? {} : arguments[2]\n    }\n    this.validateReplyParameters(replyParameters)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(replyParameters)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBLG1EQUFtRCx3Q0FBd0M7QUFDM0Ysc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU87QUFDNUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2staW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZ2V0UmVzcG9uc2VEYXRhLCBidWlsZEtleSwgYWRkTW9ja0Rpc3BhdGNoIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga0Rpc3BhdGNoS2V5LFxuICBrRGVmYXVsdEhlYWRlcnMsXG4gIGtEZWZhdWx0VHJhaWxlcnMsXG4gIGtDb250ZW50TGVuZ3RoLFxuICBrTW9ja0Rpc3BhdGNoXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3QgeyBidWlsZFVSTCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBzY29wZSBBUEkgZm9yIGFuIGludGVyY2VwdG9yIHJlcGx5XG4gKi9cbmNsYXNzIE1vY2tTY29wZSB7XG4gIGNvbnN0cnVjdG9yIChtb2NrRGlzcGF0Y2gpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdID0gbW9ja0Rpc3BhdGNoXG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgYSByZXBseSBieSBhIHNldCBhbW91bnQgaW4gbXMuXG4gICAqL1xuICBkZWxheSAod2FpdEluTXMpIHtcbiAgICBpZiAodHlwZW9mIHdhaXRJbk1zICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih3YWl0SW5NcykgfHwgd2FpdEluTXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd3YWl0SW5NcyBtdXN0IGJlIGEgdmFsaWQgaW50ZWdlciA+IDAnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tEaXNwYXRjaF0uZGVsYXkgPSB3YWl0SW5Nc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZGVmaW5lZCByZXBseSwgbmV2ZXIgbWFyayBhcyBjb25zdW1lZC5cbiAgICovXG4gIHBlcnNpc3QgKCkge1xuICAgIHRoaXNba01vY2tEaXNwYXRjaF0ucGVyc2lzdCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93IG9uZSB0byBkZWZpbmUgYSByZXBseSBmb3IgYSBzZXQgYW1vdW50IG9mIG1hdGNoaW5nIHJlcXVlc3RzLlxuICAgKi9cbiAgdGltZXMgKHJlcGVhdFRpbWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBlYXRUaW1lcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIocmVwZWF0VGltZXMpIHx8IHJlcGVhdFRpbWVzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwZWF0VGltZXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnRpbWVzID0gcmVwZWF0VGltZXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmNlcHRvciBmb3IgYSBNb2NrXG4gKi9cbmNsYXNzIE1vY2tJbnRlcmNlcHRvciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2NrRGlzcGF0Y2hlcykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLnBhdGggbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICB9XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xMjQ1XG4gICAgLy8gQXMgcGVyIFJGQyAzOTg2LCBjbGllbnRzIGFyZSBub3Qgc3VwcG9zZWQgdG8gc2VuZCBVUklcbiAgICAvLyBmcmFnbWVudHMgdG8gc2VydmVycyB3aGVuIHRoZXkgcmV0cmlldmUgYSBkb2N1bWVudCxcbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChvcHRzLnF1ZXJ5KSB7XG4gICAgICAgIG9wdHMucGF0aCA9IGJ1aWxkVVJMKG9wdHMucGF0aCwgb3B0cy5xdWVyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1hdGNoZXMgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvYmxvYi9tYWluL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMjTDE4MTFcbiAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gbmV3IFVSTChvcHRzLnBhdGgsICdkYXRhOi8vJylcbiAgICAgICAgb3B0cy5wYXRoID0gcGFyc2VkVVJMLnBhdGhuYW1lICsgcGFyc2VkVVJMLnNlYXJjaFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMubWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0cy5tZXRob2QgPSBvcHRzLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgdGhpc1trRGlzcGF0Y2hLZXldID0gYnVpbGRLZXkob3B0cylcbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IG1vY2tEaXNwYXRjaGVzXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0ge31cbiAgICB0aGlzW2tEZWZhdWx0VHJhaWxlcnNdID0ge31cbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IGZhbHNlXG4gIH1cblxuICBjcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEgKHsgc3RhdHVzQ29kZSwgZGF0YSwgcmVzcG9uc2VPcHRpb25zIH0pIHtcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoZGF0YSlcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gdGhpc1trQ29udGVudExlbmd0aF0gPyB7ICdjb250ZW50LWxlbmd0aCc6IHJlc3BvbnNlRGF0YS5sZW5ndGggfSA6IHt9XG4gICAgY29uc3QgaGVhZGVycyA9IHsgLi4udGhpc1trRGVmYXVsdEhlYWRlcnNdLCAuLi5jb250ZW50TGVuZ3RoLCAuLi5yZXNwb25zZU9wdGlvbnMuaGVhZGVycyB9XG4gICAgY29uc3QgdHJhaWxlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRUcmFpbGVyc10sIC4uLnJlc3BvbnNlT3B0aW9ucy50cmFpbGVycyB9XG5cbiAgICByZXR1cm4geyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycyB9XG4gIH1cblxuICB2YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyAocmVwbHlQYXJhbWV0ZXJzKSB7XG4gICAgaWYgKHR5cGVvZiByZXBseVBhcmFtZXRlcnMuc3RhdHVzQ29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc3RhdHVzQ29kZSBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcGx5UGFyYW1ldGVycy5yZXNwb25zZU9wdGlvbnMgIT09ICdvYmplY3QnIHx8IHJlcGx5UGFyYW1ldGVycy5yZXNwb25zZU9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVzcG9uc2VPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCByZXBseS5cbiAgICovXG4gIHJlcGx5IChyZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZSkge1xuICAgIC8vIFZhbHVlcyBvZiByZXBseSBhcmVuJ3QgYXZhaWxhYmxlIHJpZ2h0IG5vdyBhcyB0aGV5XG4gICAgLy8gY2FuIG9ubHkgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIHJlcGx5IGNhbGxiYWNrIGlzIGludm9rZWQuXG4gICAgaWYgKHR5cGVvZiByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UnbGwgZmlyc3Qgd3JhcCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgaW4gYW5vdGhlciBmdW5jdGlvbixcbiAgICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBwcm9wZXJseSByZXNvbHZlIHRoZSBkYXRhIGZyb20gdGhlIGNhbGxiYWNrXG4gICAgICAvLyB3aGVuIGludm9rZWQuXG4gICAgICBjb25zdCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjayA9IChvcHRzKSA9PiB7XG4gICAgICAgIC8vIE91ciByZXBseSBvcHRpb25zIGNhbGxiYWNrIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIgZm9yIHN0YXR1c0NvZGUsIGRhdGEgYW5kIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkRGF0YSA9IHJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlKG9wdHMpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgaW4gdGhlIHJpZ2h0IGZvcm1hdFxuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVkRGF0YSAhPT0gJ29iamVjdCcgfHwgcmVzb2x2ZWREYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdyZXBseSBvcHRpb25zIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIG9iamVjdCcpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXBseVBhcmFtZXRlcnMgPSB7IGRhdGE6ICcnLCByZXNwb25zZU9wdGlvbnM6IHt9LCAuLi5yZXNvbHZlZERhdGEgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHJlcGx5UGFyYW1ldGVycylcbiAgICAgICAgLy8gU2luY2UgdGhlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgaW1tZWRpYXRlbHkgd2UgcmV0dXJuIHRoZW1cbiAgICAgICAgLy8gZnJvbSB0aGlzIGhpZ2hlciBvcmRlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGhpcy5jcmVhdGVNb2NrU2NvcGVEaXNwYXRjaERhdGEocmVwbHlQYXJhbWV0ZXJzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB1c3VhbCBkaXNwYXRjaCBkYXRhLCBidXQgdGhpcyB0aW1lIHNldCB0aGUgZGF0YSBwYXJhbWV0ZXIgdG8gZnVuY3Rpb24gdGhhdCB3aWxsIGV2ZW50dWFsbHkgcHJvdmlkZSBkYXRhLlxuICAgICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHdyYXBwZWREZWZhdWx0c0NhbGxiYWNrKVxuICAgICAgcmV0dXJuIG5ldyBNb2NrU2NvcGUobmV3TW9ja0Rpc3BhdGNoKVxuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYXZlIGVpdGhlciBvbmUgb3IgdGhyZWUgcGFyYW1ldGVycywgaWYgd2UgZ2V0IGhlcmUsXG4gICAgLy8gd2Ugc2hvdWxkIGhhdmUgMS0zIHBhcmFtZXRlcnMuIFNvIHdlIHNwcmVhZCB0aGUgYXJndW1lbnRzIG9mXG4gICAgLy8gdGhpcyBmdW5jdGlvbiB0byBvYnRhaW4gdGhlIHBhcmFtZXRlcnMsIHNpbmNlIHJlcGx5RGF0YSB3aWxsIGFsd2F5c1xuICAgIC8vIGp1c3QgYmUgdGhlIHN0YXR1c0NvZGUuXG4gICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0ge1xuICAgICAgc3RhdHVzQ29kZTogcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUsXG4gICAgICBkYXRhOiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcnIDogYXJndW1lbnRzWzFdLFxuICAgICAgcmVzcG9uc2VPcHRpb25zOiBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdXG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVSZXBseVBhcmFtZXRlcnMocmVwbHlQYXJhbWV0ZXJzKVxuXG4gICAgLy8gU2VuZCBpbi1hbHJlYWR5IHByb3ZpZGVkIGRhdGEgbGlrZSB1c3VhbFxuICAgIGNvbnN0IGRpc3BhdGNoRGF0YSA9IHRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgZGlzcGF0Y2hEYXRhKVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2NrIGFuIHVuZGljaSByZXF1ZXN0IHdpdGggYSBkZWZpbmVkIGVycm9yLlxuICAgKi9cbiAgcmVwbHlXaXRoRXJyb3IgKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZXJyb3IgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG5cbiAgICBjb25zdCBuZXdNb2NrRGlzcGF0Y2ggPSBhZGRNb2NrRGlzcGF0Y2godGhpc1trRGlzcGF0Y2hlc10sIHRoaXNba0Rpc3BhdGNoS2V5XSwgeyBlcnJvciB9KVxuICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCByZXBseSBoZWFkZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlIZWFkZXJzIChoZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBoZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdEhlYWRlcnNdID0gaGVhZGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgdHJhaWxlcnMgb24gdGhlIGludGVyY2VwdG9yIGZvciBzdWJzZXF1ZW50IHJlcGxpZXNcbiAgICovXG4gIGRlZmF1bHRSZXBseVRyYWlsZXJzICh0cmFpbGVycykge1xuICAgIGlmICh0eXBlb2YgdHJhaWxlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3RyYWlsZXJzIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHRyYWlsZXJzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcmVwbHkgY29udGVudCBsZW5ndGggaGVhZGVyIGZvciByZXBsaWVzIG9uIHRoZSBpbnRlcmNlcHRvclxuICAgKi9cbiAgcmVwbHlDb250ZW50TGVuZ3RoICgpIHtcbiAgICB0aGlzW2tDb250ZW50TGVuZ3RoXSA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLk1vY2tJbnRlcmNlcHRvciA9IE1vY2tJbnRlcmNlcHRvclxubW9kdWxlLmV4cG9ydHMuTW9ja1Njb3BlID0gTW9ja1Njb3BlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(ssr)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(ssr)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(ssr)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(ssr)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDekMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUIsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLG9GQUFvQjtBQUN4RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekMsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1wb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL3Bvb2wnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrUG9vbCBwcm92aWRlcyBhbiBBUEkgdGhhdCBleHRlbmRzIHRoZSBQb29sIHRvIGluZmx1ZW5jZSB0aGUgbW9ja0Rpc3BhdGNoZXMuXG4gKi9cbmNsYXNzIE1vY2tQb29sIGV4dGVuZHMgUG9vbCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIG9wdHMpIHtcbiAgICBzdXBlcihvcmlnaW4sIG9wdHMpXG5cbiAgICBpZiAoIW9wdHMgfHwgIW9wdHMuYWdlbnQgfHwgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgb3B0cy5hZ2VudCBtdXN0IGltcGxlbWVudCBBZ2VudCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0FnZW50XSA9IG9wdHMuYWdlbnRcbiAgICB0aGlzW2tPcmlnaW5dID0gb3JpZ2luXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBbXVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAxXG4gICAgdGhpc1trT3JpZ2luYWxEaXNwYXRjaF0gPSB0aGlzLmRpc3BhdGNoXG4gICAgdGhpc1trT3JpZ2luYWxDbG9zZV0gPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBidWlsZE1vY2tEaXNwYXRjaC5jYWxsKHRoaXMpXG4gICAgdGhpcy5jbG9zZSA9IHRoaXNba0Nsb3NlXVxuICB9XG5cbiAgZ2V0IFtTeW1ib2xzLmtDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29ubmVjdGVkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIGJhc2UgaW50ZXJjZXB0b3IgZm9yIG1vY2tpbmcgcmVwbGllcyBmcm9tIHVuZGljaS5cbiAgICovXG4gIGludGVyY2VwdCAob3B0cykge1xuICAgIHJldHVybiBuZXcgTW9ja0ludGVyY2VwdG9yKG9wdHMsIHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHByb21pc2lmeSh0aGlzW2tPcmlnaW5hbENsb3NlXSkoKVxuICAgIHRoaXNba0Nvbm5lY3RlZF0gPSAwXG4gICAgdGhpc1trTW9ja0FnZW50XVtTeW1ib2xzLmtDbGllbnRzXS5kZWxldGUodGhpc1trT3JpZ2luXSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLXN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQWdlbnQ6IFN5bWJvbCgnYWdlbnQnKSxcbiAga09wdGlvbnM6IFN5bWJvbCgnb3B0aW9ucycpLFxuICBrRmFjdG9yeTogU3ltYm9sKCdmYWN0b3J5JyksXG4gIGtEaXNwYXRjaGVzOiBTeW1ib2woJ2Rpc3BhdGNoZXMnKSxcbiAga0Rpc3BhdGNoS2V5OiBTeW1ib2woJ2Rpc3BhdGNoIGtleScpLFxuICBrRGVmYXVsdEhlYWRlcnM6IFN5bWJvbCgnZGVmYXVsdCBoZWFkZXJzJyksXG4gIGtEZWZhdWx0VHJhaWxlcnM6IFN5bWJvbCgnZGVmYXVsdCB0cmFpbGVycycpLFxuICBrQ29udGVudExlbmd0aDogU3ltYm9sKCdjb250ZW50IGxlbmd0aCcpLFxuICBrTW9ja0FnZW50OiBTeW1ib2woJ21vY2sgYWdlbnQnKSxcbiAga01vY2tBZ2VudFNldDogU3ltYm9sKCdtb2NrIGFnZW50IHNldCcpLFxuICBrTW9ja0FnZW50R2V0OiBTeW1ib2woJ21vY2sgYWdlbnQgZ2V0JyksXG4gIGtNb2NrRGlzcGF0Y2g6IFN5bWJvbCgnbW9jayBkaXNwYXRjaCcpLFxuICBrQ2xvc2U6IFN5bWJvbCgnY2xvc2UnKSxcbiAga09yaWdpbmFsQ2xvc2U6IFN5bWJvbCgnb3JpZ2luYWwgYWdlbnQgY2xvc2UnKSxcbiAga09yaWdpbjogU3ltYm9sKCdvcmlnaW4nKSxcbiAga0lzTW9ja0FjdGl2ZTogU3ltYm9sKCdpcyBtb2NrIGFjdGl2ZScpLFxuICBrTmV0Q29ubmVjdDogU3ltYm9sKCduZXQgY29ubmVjdCcpLFxuICBrR2V0TmV0Q29ubmVjdDogU3ltYm9sKCdnZXQgbmV0IGNvbm5lY3QnKSxcbiAga0Nvbm5lY3RlZDogU3ltYm9sKCdjb25uZWN0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(ssr)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"(ssr)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst {\n  types: {\n    isPromise\n  }\n} = __webpack_require__(/*! node:util */ \"node:util\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLGtFQUFjO0FBQzNDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLCtEQUErRDtBQUMxRSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxVQUFVO0FBQ3RCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFVBQVUsMEJBQTBCLE1BQU07QUFDakc7QUFDQSx5RUFBeUUsYUFBYTtBQUN0Rjs7QUFFQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0EsMkVBQTJFLFdBQVcsYUFBYSxhQUFhO0FBQ2hIOztBQUVBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQSx5RUFBeUUsU0FBUyxhQUFhLGFBQWE7QUFDNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsUUFBUSxhQUFhLGFBQWE7QUFDOUc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixtREFBbUQsaUJBQWlCLElBQUk7QUFDeEUsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEMseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQSxNQUFNO0FBQ04sdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsVUFBVSxRQUFRLDRDQUE0QyxtQkFBbUI7QUFDakYsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsaUNBQWlDLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxjQUFjLGlDQUFpQyxRQUFRO0FBQ3BHO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE1vY2tOb3RNYXRjaGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4vbW9jay1lcnJvcnMnKVxuY29uc3Qge1xuICBrRGlzcGF0Y2hlcyxcbiAga01vY2tBZ2VudCxcbiAga09yaWdpbmFsRGlzcGF0Y2gsXG4gIGtPcmlnaW4sXG4gIGtHZXROZXRDb25uZWN0XG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBidWlsZFVSTCB9ID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgU1RBVFVTX0NPREVTIH0gPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3Qge1xuICB0eXBlczoge1xuICAgIGlzUHJvbWlzZVxuICB9XG59ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuZnVuY3Rpb24gbWF0Y2hWYWx1ZSAobWF0Y2gsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1hdGNoID09PSB2YWx1ZVxuICB9XG4gIGlmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBtYXRjaC50ZXN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF0Y2godmFsdWUpID09PSB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGxvd2VyQ2FzZUVudHJpZXMgKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhoZWFkZXJzKS5tYXAoKFtoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBbaGVhZGVyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLCBoZWFkZXJWYWx1ZV1cbiAgICB9KVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2luZGV4JykuSGVhZGVyc3xzdHJpbmdbXXxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEhlYWRlckJ5TmFtZSAoaGVhZGVycywga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBpZiAoaGVhZGVyc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSBrZXkudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gaGVhZGVyc1tpICsgMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlcnMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGhlYWRlcnMuZ2V0KGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKVtrZXkudG9Mb2NhbGVMb3dlckNhc2UoKV1cbiAgfVxufVxuXG4vKiogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVycyAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzRnJvbUFycmF5IChoZWFkZXJzKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gIGNvbnN0IGNsb25lID0gaGVhZGVycy5zbGljZSgpXG4gIGNvbnN0IGVudHJpZXMgPSBbXVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2xvbmUubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgZW50cmllcy5wdXNoKFtjbG9uZVtpbmRleF0sIGNsb25lW2luZGV4ICsgMV1dKVxuICB9XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcylcbn1cblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJzIChtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpIHtcbiAgaWYgKHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7IC8vIGZldGNoIEhlYWRlcnNMaXN0XG4gICAgICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzRnJvbUFycmF5KGhlYWRlcnMpXG4gICAgfVxuICAgIHJldHVybiBtb2NrRGlzcGF0Y2guaGVhZGVycyhoZWFkZXJzID8gbG93ZXJDYXNlRW50cmllcyhoZWFkZXJzKSA6IHt9KVxuICB9XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodHlwZW9mIGhlYWRlcnMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBtb2NrRGlzcGF0Y2guaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgW21hdGNoSGVhZGVyTmFtZSwgbWF0Y2hIZWFkZXJWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobW9ja0Rpc3BhdGNoLmhlYWRlcnMpKSB7XG4gICAgY29uc3QgaGVhZGVyVmFsdWUgPSBnZXRIZWFkZXJCeU5hbWUoaGVhZGVycywgbWF0Y2hIZWFkZXJOYW1lKVxuXG4gICAgaWYgKCFtYXRjaFZhbHVlKG1hdGNoSGVhZGVyVmFsdWUsIGhlYWRlclZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhZmVVcmwgKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCc/JylcblxuICBpZiAocGF0aFNlZ21lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBjb25zdCBxcCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aFNlZ21lbnRzLnBvcCgpKVxuICBxcC5zb3J0KClcbiAgcmV0dXJuIFsuLi5wYXRoU2VnbWVudHMsIHFwLnRvU3RyaW5nKCldLmpvaW4oJz8nKVxufVxuXG5mdW5jdGlvbiBtYXRjaEtleSAobW9ja0Rpc3BhdGNoLCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycyB9KSB7XG4gIGNvbnN0IHBhdGhNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLnBhdGgsIHBhdGgpXG4gIGNvbnN0IG1ldGhvZE1hdGNoID0gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2gubWV0aG9kLCBtZXRob2QpXG4gIGNvbnN0IGJvZHlNYXRjaCA9IHR5cGVvZiBtb2NrRGlzcGF0Y2guYm9keSAhPT0gJ3VuZGVmaW5lZCcgPyBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5ib2R5LCBib2R5KSA6IHRydWVcbiAgY29uc3QgaGVhZGVyc01hdGNoID0gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwgaGVhZGVycylcbiAgcmV0dXJuIHBhdGhNYXRjaCAmJiBtZXRob2RNYXRjaCAmJiBib2R5TWF0Y2ggJiYgaGVhZGVyc01hdGNoXG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YSAoZGF0YSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YS50b1N0cmluZygpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TW9ja0Rpc3BhdGNoIChtb2NrRGlzcGF0Y2hlcywga2V5KSB7XG4gIGNvbnN0IGJhc2VQYXRoID0ga2V5LnF1ZXJ5ID8gYnVpbGRVUkwoa2V5LnBhdGgsIGtleS5xdWVyeSkgOiBrZXkucGF0aFxuICBjb25zdCByZXNvbHZlZFBhdGggPSB0eXBlb2YgYmFzZVBhdGggPT09ICdzdHJpbmcnID8gc2FmZVVybChiYXNlUGF0aCkgOiBiYXNlUGF0aFxuXG4gIC8vIE1hdGNoIHBhdGhcbiAgbGV0IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBjb25zdW1lZCB9KSA9PiAhY29uc3VtZWQpLmZpbHRlcigoeyBwYXRoIH0pID0+IG1hdGNoVmFsdWUoc2FmZVVybChwYXRoKSwgcmVzb2x2ZWRQYXRoKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBtZXRob2RcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBtZXRob2QgfSkgPT4gbWF0Y2hWYWx1ZShtZXRob2QsIGtleS5tZXRob2QpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBtZXRob2QgJyR7a2V5Lm1ldGhvZH0nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggYm9keVxuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKCh7IGJvZHkgfSkgPT4gdHlwZW9mIGJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShib2R5LCBrZXkuYm9keSkgOiB0cnVlKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBNb2NrTm90TWF0Y2hlZEVycm9yKGBNb2NrIGRpc3BhdGNoIG5vdCBtYXRjaGVkIGZvciBib2R5ICcke2tleS5ib2R5fScgb24gcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICAvLyBNYXRjaCBoZWFkZXJzXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKG1vY2tEaXNwYXRjaCkgPT4gbWF0Y2hIZWFkZXJzKG1vY2tEaXNwYXRjaCwga2V5LmhlYWRlcnMpKVxuICBpZiAobWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0eXBlb2Yga2V5LmhlYWRlcnMgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkoa2V5LmhlYWRlcnMpIDoga2V5LmhlYWRlcnNcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgaGVhZGVycyAnJHtoZWFkZXJzfScgb24gcGF0aCAnJHtyZXNvbHZlZFBhdGh9J2ApXG4gIH1cblxuICByZXR1cm4gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzWzBdXG59XG5cbmZ1bmN0aW9uIGFkZE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSwgZGF0YSkge1xuICBjb25zdCBiYXNlRGF0YSA9IHsgdGltZXNJbnZva2VkOiAwLCB0aW1lczogMSwgcGVyc2lzdDogZmFsc2UsIGNvbnN1bWVkOiBmYWxzZSB9XG4gIGNvbnN0IHJlcGx5RGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nID8geyBjYWxsYmFjazogZGF0YSB9IDogeyAuLi5kYXRhIH1cbiAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0geyAuLi5iYXNlRGF0YSwgLi4ua2V5LCBwZW5kaW5nOiB0cnVlLCBkYXRhOiB7IGVycm9yOiBudWxsLCAuLi5yZXBseURhdGEgfSB9XG4gIG1vY2tEaXNwYXRjaGVzLnB1c2gobmV3TW9ja0Rpc3BhdGNoKVxuICByZXR1cm4gbmV3TW9ja0Rpc3BhdGNoXG59XG5cbmZ1bmN0aW9uIGRlbGV0ZU1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBpbmRleCA9IG1vY2tEaXNwYXRjaGVzLmZpbmRJbmRleChkaXNwYXRjaCA9PiB7XG4gICAgaWYgKCFkaXNwYXRjaC5jb25zdW1lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBtYXRjaEtleShkaXNwYXRjaCwga2V5KVxuICB9KVxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbW9ja0Rpc3BhdGNoZXMuc3BsaWNlKGluZGV4LCAxKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkS2V5IChvcHRzKSB7XG4gIGNvbnN0IHsgcGF0aCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzLCBxdWVyeSB9ID0gb3B0c1xuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbiAgICBxdWVyeVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5VmFsdWVzIChkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV1cbiAgICBjb25zdCBuYW1lID0gQnVmZmVyLmZyb20oYCR7a2V5fWApXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5hbWUsIEJ1ZmZlci5mcm9tKGAke3ZhbHVlW2pdfWApKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZX1gKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNDb2RlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXR1c1RleHQgKHN0YXR1c0NvZGUpIHtcbiAgcmV0dXJuIFNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXSB8fCAndW5rbm93bidcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVzcG9uc2UgKGJvZHkpIHtcbiAgY29uc3QgYnVmZmVycyA9IFtdXG4gIGZvciBhd2FpdCAoY29uc3QgZGF0YSBvZiBib2R5KSB7XG4gICAgYnVmZmVycy5wdXNoKGRhdGEpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYnVmZmVycykudG9TdHJpbmcoJ3V0ZjgnKVxufVxuXG4vKipcbiAqIE1vY2sgZGlzcGF0Y2ggZnVuY3Rpb24gdXNlZCB0byBzaW11bGF0ZSB1bmRpY2kgZGlzcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBtb2NrRGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgLy8gR2V0IG1vY2sgZGlzcGF0Y2ggZnJvbSBidWlsdCBrZXlcbiAgY29uc3Qga2V5ID0gYnVpbGRLZXkob3B0cylcbiAgY29uc3QgbW9ja0Rpc3BhdGNoID0gZ2V0TW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG5cbiAgbW9ja0Rpc3BhdGNoLnRpbWVzSW52b2tlZCsrXG5cbiAgLy8gSGVyZSdzIHdoZXJlIHdlIHJlc29sdmUgYSBjYWxsYmFjayBpZiBhIGNhbGxiYWNrIGlzIHByZXNlbnQgZm9yIHRoZSBkaXNwYXRjaCBkYXRhLlxuICBpZiAobW9ja0Rpc3BhdGNoLmRhdGEuY2FsbGJhY2spIHtcbiAgICBtb2NrRGlzcGF0Y2guZGF0YSA9IHsgLi4ubW9ja0Rpc3BhdGNoLmRhdGEsIC4uLm1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKG9wdHMpIH1cbiAgfVxuXG4gIC8vIFBhcnNlIG1vY2tEaXNwYXRjaCBkYXRhXG4gIGNvbnN0IHsgZGF0YTogeyBzdGF0dXNDb2RlLCBkYXRhLCBoZWFkZXJzLCB0cmFpbGVycywgZXJyb3IgfSwgZGVsYXksIHBlcnNpc3QgfSA9IG1vY2tEaXNwYXRjaFxuICBjb25zdCB7IHRpbWVzSW52b2tlZCwgdGltZXMgfSA9IG1vY2tEaXNwYXRjaFxuXG4gIC8vIElmIGl0J3MgdXNlZCB1cCBhbmQgbm90IHBlcnNpc3RlbnQsIG1hcmsgYXMgY29uc3VtZWRcbiAgbW9ja0Rpc3BhdGNoLmNvbnN1bWVkID0gIXBlcnNpc3QgJiYgdGltZXNJbnZva2VkID49IHRpbWVzXG4gIG1vY2tEaXNwYXRjaC5wZW5kaW5nID0gdGltZXNJbnZva2VkIDwgdGltZXNcblxuICAvLyBJZiBzcGVjaWZpZWQsIHRyaWdnZXIgZGlzcGF0Y2ggZXJyb3JcbiAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCBrZXkpXG4gICAgaGFuZGxlci5vbkVycm9yKGVycm9yKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIHJlcXVlc3Qgd2l0aCBhIGRlbGF5IGlmIG5lY2Vzc2FyeVxuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICAgIH0sIGRlbGF5KVxuICB9IGVsc2Uge1xuICAgIGhhbmRsZVJlcGx5KHRoaXNba0Rpc3BhdGNoZXNdKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVwbHkgKG1vY2tEaXNwYXRjaGVzLCBfZGF0YSA9IGRhdGEpIHtcbiAgICAvLyBmZXRjaCdzIEhlYWRlcnNMaXN0IGlzIGEgMUQgc3RyaW5nIGFycmF5XG4gICAgY29uc3Qgb3B0c0hlYWRlcnMgPSBBcnJheS5pc0FycmF5KG9wdHMuaGVhZGVycylcbiAgICAgID8gYnVpbGRIZWFkZXJzRnJvbUFycmF5KG9wdHMuaGVhZGVycylcbiAgICAgIDogb3B0cy5oZWFkZXJzXG4gICAgY29uc3QgYm9keSA9IHR5cGVvZiBfZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBfZGF0YSh7IC4uLm9wdHMsIGhlYWRlcnM6IG9wdHNIZWFkZXJzIH0pXG4gICAgICA6IF9kYXRhXG5cbiAgICAvLyB1dGlsLnR5cGVzLmlzUHJvbWlzZSBpcyBsaWtlbHkgbmVlZGVkIGZvciBqZXN0LlxuICAgIGlmIChpc1Byb21pc2UoYm9keSkpIHtcbiAgICAgIC8vIElmIGhhbmRsZVJlcGx5IGlzIGFzeW5jaHJvbm91cywgdGhyb3dpbmcgYW4gZXJyb3JcbiAgICAgIC8vIGluIHRoZSBjYWxsYmFjayB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSwgcmF0aGVyIHRoYW5cbiAgICAgIC8vIHN5bmNocm9ub3VzbHkgdGhyb3cgdGhlIGVycm9yLCB3aGljaCBicmVha3Mgc29tZSB0ZXN0cy5cbiAgICAgIC8vIFJhdGhlciwgd2Ugd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHJlc29sdmUgaWYgaXQgaXMgYVxuICAgICAgLy8gcHJvbWlzZSwgYW5kIHRoZW4gcmUtcnVuIGhhbmRsZVJlcGx5IHdpdGggdGhlIG5ldyBib2R5LlxuICAgICAgYm9keS50aGVuKChuZXdEYXRhKSA9PiBoYW5kbGVSZXBseShtb2NrRGlzcGF0Y2hlcywgbmV3RGF0YSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBnZXRSZXNwb25zZURhdGEoYm9keSlcbiAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyhoZWFkZXJzKVxuICAgIGNvbnN0IHJlc3BvbnNlVHJhaWxlcnMgPSBnZW5lcmF0ZUtleVZhbHVlcyh0cmFpbGVycylcblxuICAgIGhhbmRsZXIub25Db25uZWN0Py4oZXJyID0+IGhhbmRsZXIub25FcnJvcihlcnIpLCBudWxsKVxuICAgIGhhbmRsZXIub25IZWFkZXJzPy4oc3RhdHVzQ29kZSwgcmVzcG9uc2VIZWFkZXJzLCByZXN1bWUsIGdldFN0YXR1c1RleHQoc3RhdHVzQ29kZSkpXG4gICAgaGFuZGxlci5vbkRhdGE/LihCdWZmZXIuZnJvbShyZXNwb25zZURhdGEpKVxuICAgIGhhbmRsZXIub25Db21wbGV0ZT8uKHJlc3BvbnNlVHJhaWxlcnMpXG4gICAgZGVsZXRlTW9ja0Rpc3BhdGNoKG1vY2tEaXNwYXRjaGVzLCBrZXkpXG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWUgKCkge31cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBidWlsZE1vY2tEaXNwYXRjaCAoKSB7XG4gIGNvbnN0IGFnZW50ID0gdGhpc1trTW9ja0FnZW50XVxuICBjb25zdCBvcmlnaW4gPSB0aGlzW2tPcmlnaW5dXG4gIGNvbnN0IG9yaWdpbmFsRGlzcGF0Y2ggPSB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXVxuXG4gIHJldHVybiBmdW5jdGlvbiBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmIChhZ2VudC5pc01vY2tBY3RpdmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vY2tEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNb2NrTm90TWF0Y2hlZEVycm9yKSB7XG4gICAgICAgICAgY29uc3QgbmV0Q29ubmVjdCA9IGFnZW50W2tHZXROZXRDb25uZWN0XSgpXG4gICAgICAgICAgaWYgKG5ldENvbm5lY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBkaXNhYmxlZClgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2tOZXRDb25uZWN0KG5ldENvbm5lY3QsIG9yaWdpbikpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgJHtlcnJvci5tZXNzYWdlfTogc3Vic2VxdWVudCByZXF1ZXN0IHRvIG9yaWdpbiAke29yaWdpbn0gd2FzIG5vdCBhbGxvd2VkIChuZXQuY29ubmVjdCBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBvcmlnaW4pYClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOZXRDb25uZWN0IChuZXRDb25uZWN0LCBvcmlnaW4pIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChvcmlnaW4pXG4gIGlmIChuZXRDb25uZWN0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5ldENvbm5lY3QpICYmIG5ldENvbm5lY3Quc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hWYWx1ZShtYXRjaGVyLCB1cmwuaG9zdCkpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrT3B0aW9ucyAob3B0cykge1xuICBpZiAob3B0cykge1xuICAgIGNvbnN0IHsgYWdlbnQsIC4uLm1vY2tPcHRpb25zIH0gPSBvcHRzXG4gICAgcmV0dXJuIG1vY2tPcHRpb25zXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlc3BvbnNlRGF0YSxcbiAgZ2V0TW9ja0Rpc3BhdGNoLFxuICBhZGRNb2NrRGlzcGF0Y2gsXG4gIGRlbGV0ZU1vY2tEaXNwYXRjaCxcbiAgYnVpbGRLZXksXG4gIGdlbmVyYXRlS2V5VmFsdWVzLFxuICBtYXRjaFZhbHVlLFxuICBnZXRSZXNwb25zZSxcbiAgZ2V0U3RhdHVzVGV4dCxcbiAgbW9ja0Rpc3BhdGNoLFxuICBidWlsZE1vY2tEaXNwYXRjaCxcbiAgY2hlY2tOZXRDb25uZWN0LFxuICBidWlsZE1vY2tPcHRpb25zLFxuICBnZXRIZWFkZXJCeU5hbWUsXG4gIGJ1aWxkSGVhZGVyc0Zyb21BcnJheVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\")\n\nconst PERSISTENT = process.versions.icu ? '✅' : 'Y '\nconst NOT_PERSISTENT = process.versions.icu ? '❌' : 'N '\n\n/**\n * Gets the output of `console.table(…)` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0NBQWM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCLFlBQVksd0NBQXdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXHBlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgQ29uc29sZSB9ID0gcmVxdWlyZSgnbm9kZTpjb25zb2xlJylcblxuY29uc3QgUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KchScgOiAnWSAnXG5jb25zdCBOT1RfUEVSU0lTVEVOVCA9IHByb2Nlc3MudmVyc2lvbnMuaWN1ID8gJ+KdjCcgOiAnTiAnXG5cbi8qKlxuICogR2V0cyB0aGUgb3V0cHV0IG9mIGBjb25zb2xlLnRhYmxlKOKApilgIGFzIGEgc3RyaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoeyBkaXNhYmxlQ29sb3JzIH0gPSB7fSkge1xuICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSh7XG4gICAgICB0cmFuc2Zvcm0gKGNodW5rLCBfZW5jLCBjYikge1xuICAgICAgICBjYihudWxsLCBjaHVuaylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgQ29uc29sZSh7XG4gICAgICBzdGRvdXQ6IHRoaXMudHJhbnNmb3JtLFxuICAgICAgaW5zcGVjdE9wdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiAhZGlzYWJsZUNvbG9ycyAmJiAhcHJvY2Vzcy5lbnYuQ0lcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZm9ybWF0IChwZW5kaW5nSW50ZXJjZXB0b3JzKSB7XG4gICAgY29uc3Qgd2l0aFByZXR0eUhlYWRlcnMgPSBwZW5kaW5nSW50ZXJjZXB0b3JzLm1hcChcbiAgICAgICh7IG1ldGhvZCwgcGF0aCwgZGF0YTogeyBzdGF0dXNDb2RlIH0sIHBlcnNpc3QsIHRpbWVzLCB0aW1lc0ludm9rZWQsIG9yaWdpbiB9KSA9PiAoe1xuICAgICAgICBNZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgT3JpZ2luOiBvcmlnaW4sXG4gICAgICAgIFBhdGg6IHBhdGgsXG4gICAgICAgICdTdGF0dXMgY29kZSc6IHN0YXR1c0NvZGUsXG4gICAgICAgIFBlcnNpc3RlbnQ6IHBlcnNpc3QgPyBQRVJTSVNURU5UIDogTk9UX1BFUlNJU1RFTlQsXG4gICAgICAgIEludm9jYXRpb25zOiB0aW1lc0ludm9rZWQsXG4gICAgICAgIFJlbWFpbmluZzogcGVyc2lzdCA/IEluZmluaXR5IDogdGltZXMgLSB0aW1lc0ludm9rZWRcbiAgICAgIH0pKVxuXG4gICAgdGhpcy5sb2dnZXIudGFibGUod2l0aFByZXR0eUhlYWRlcnMpXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWQoKS50b1N0cmluZygpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst singulars = {\n  pronoun: 'it',\n  is: 'is',\n  was: 'was',\n  this: 'this'\n}\n\nconst plurals = {\n  pronoun: 'they',\n  is: 'are',\n  was: 'were',\n  this: 'these'\n}\n\nmodule.exports = class Pluralizer {\n  constructor (singular, plural) {\n    this.singular = singular\n    this.plural = plural\n  }\n\n  pluralize (count) {\n    const one = count === 1\n    const keys = one ? singulars : plurals\n    const noun = one ? this.singular : this.plural\n    return { ...keys, count, noun }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxwbHVyYWxpemVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzaW5ndWxhcnMgPSB7XG4gIHByb25vdW46ICdpdCcsXG4gIGlzOiAnaXMnLFxuICB3YXM6ICd3YXMnLFxuICB0aGlzOiAndGhpcydcbn1cblxuY29uc3QgcGx1cmFscyA9IHtcbiAgcHJvbm91bjogJ3RoZXknLFxuICBpczogJ2FyZScsXG4gIHdhczogJ3dlcmUnLFxuICB0aGlzOiAndGhlc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGx1cmFsaXplciB7XG4gIGNvbnN0cnVjdG9yIChzaW5ndWxhciwgcGx1cmFsKSB7XG4gICAgdGhpcy5zaW5ndWxhciA9IHNpbmd1bGFyXG4gICAgdGhpcy5wbHVyYWwgPSBwbHVyYWxcbiAgfVxuXG4gIHBsdXJhbGl6ZSAoY291bnQpIHtcbiAgICBjb25zdCBvbmUgPSBjb3VudCA9PT0gMVxuICAgIGNvbnN0IGtleXMgPSBvbmUgPyBzaW5ndWxhcnMgOiBwbHVyYWxzXG4gICAgY29uc3Qgbm91biA9IG9uZSA/IHRoaXMuc2luZ3VsYXIgOiB0aGlzLnBsdXJhbFxuICAgIHJldHVybiB7IC4uLmtleXMsIGNvdW50LCBub3VuIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst TICK_MS = 499\n\nlet fastNow = Date.now()\nlet fastNowTimeout\n\nconst fastTimers = []\n\nfunction onTimeout () {\n  fastNow = Date.now()\n\n  let len = fastTimers.length\n  let idx = 0\n  while (idx < len) {\n    const timer = fastTimers[idx]\n\n    if (timer.state === 0) {\n      timer.state = fastNow + timer.delay - TICK_MS\n    } else if (timer.state > 0 && fastNow >= timer.state) {\n      timer.state = -1\n      timer.callback(timer.opaque)\n    }\n\n    if (timer.state === -1) {\n      timer.state = -2\n      if (idx !== len - 1) {\n        fastTimers[idx] = fastTimers.pop()\n      } else {\n        fastTimers.pop()\n      }\n      len -= 1\n    } else {\n      idx += 1\n    }\n  }\n\n  if (fastTimers.length > 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  if (fastNowTimeout?.refresh) {\n    fastNowTimeout.refresh()\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTimeout, TICK_MS)\n    if (fastNowTimeout.unref) {\n      fastNowTimeout.unref()\n    }\n  }\n}\n\nclass Timeout {\n  constructor (callback, delay, opaque) {\n    this.callback = callback\n    this.delay = delay\n    this.opaque = opaque\n\n    //  -2 not in timer list\n    //  -1 in timer list but inactive\n    //   0 in timer list waiting for time\n    // > 0 in timer list waiting for time to expire\n    this.state = -2\n\n    this.refresh()\n  }\n\n  refresh () {\n    if (this.state === -2) {\n      fastTimers.push(this)\n      if (!fastNowTimeout || fastTimers.length === 1) {\n        refreshTimeout()\n      }\n    }\n\n    this.state = 0\n  }\n\n  clear () {\n    this.state = -1\n  }\n}\n\nmodule.exports = {\n  setTimeout (callback, delay, opaque) {\n    return delay <= 1e3\n      ? setTimeout(callback, delay, opaque)\n      : new Timeout(callback, delay, opaque)\n  },\n  clearTimeout (timeout) {\n    if (timeout instanceof Timeout) {\n      timeout.clear()\n    } else {\n      clearTimeout(timeout)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHV0aWxcXHRpbWVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgVElDS19NUyA9IDQ5OVxuXG5sZXQgZmFzdE5vdyA9IERhdGUubm93KClcbmxldCBmYXN0Tm93VGltZW91dFxuXG5jb25zdCBmYXN0VGltZXJzID0gW11cblxuZnVuY3Rpb24gb25UaW1lb3V0ICgpIHtcbiAgZmFzdE5vdyA9IERhdGUubm93KClcblxuICBsZXQgbGVuID0gZmFzdFRpbWVycy5sZW5ndGhcbiAgbGV0IGlkeCA9IDBcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGNvbnN0IHRpbWVyID0gZmFzdFRpbWVyc1tpZHhdXG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IDApIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gZmFzdE5vdyArIHRpbWVyLmRlbGF5IC0gVElDS19NU1xuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhdGUgPiAwICYmIGZhc3ROb3cgPj0gdGltZXIuc3RhdGUpIHtcbiAgICAgIHRpbWVyLnN0YXRlID0gLTFcbiAgICAgIHRpbWVyLmNhbGxiYWNrKHRpbWVyLm9wYXF1ZSlcbiAgICB9XG5cbiAgICBpZiAodGltZXIuc3RhdGUgPT09IC0xKSB7XG4gICAgICB0aW1lci5zdGF0ZSA9IC0yXG4gICAgICBpZiAoaWR4ICE9PSBsZW4gLSAxKSB7XG4gICAgICAgIGZhc3RUaW1lcnNbaWR4XSA9IGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhc3RUaW1lcnMucG9wKClcbiAgICAgIH1cbiAgICAgIGxlbiAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGlkeCArPSAxXG4gICAgfVxuICB9XG5cbiAgaWYgKGZhc3RUaW1lcnMubGVuZ3RoID4gMCkge1xuICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWZyZXNoVGltZW91dCAoKSB7XG4gIGlmIChmYXN0Tm93VGltZW91dD8ucmVmcmVzaCkge1xuICAgIGZhc3ROb3dUaW1lb3V0LnJlZnJlc2goKVxuICB9IGVsc2Uge1xuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCBUSUNLX01TKVxuICAgIGlmIChmYXN0Tm93VGltZW91dC51bnJlZikge1xuICAgICAgZmFzdE5vd1RpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBUaW1lb3V0IHtcbiAgY29uc3RydWN0b3IgKGNhbGxiYWNrLCBkZWxheSwgb3BhcXVlKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5kZWxheSA9IGRlbGF5XG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWVcblxuICAgIC8vICAtMiBub3QgaW4gdGltZXIgbGlzdFxuICAgIC8vICAtMSBpbiB0aW1lciBsaXN0IGJ1dCBpbmFjdGl2ZVxuICAgIC8vICAgMCBpbiB0aW1lciBsaXN0IHdhaXRpbmcgZm9yIHRpbWVcbiAgICAvLyA+IDAgaW4gdGltZXIgbGlzdCB3YWl0aW5nIGZvciB0aW1lIHRvIGV4cGlyZVxuICAgIHRoaXMuc3RhdGUgPSAtMlxuXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgfVxuXG4gIHJlZnJlc2ggKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAtMikge1xuICAgICAgZmFzdFRpbWVycy5wdXNoKHRoaXMpXG4gICAgICBpZiAoIWZhc3ROb3dUaW1lb3V0IHx8IGZhc3RUaW1lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gMFxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXMuc3RhdGUgPSAtMVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRUaW1lb3V0IChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSkge1xuICAgIHJldHVybiBkZWxheSA8PSAxZTNcbiAgICAgID8gc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXksIG9wYXF1ZSlcbiAgICAgIDogbmV3IFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5LCBvcGFxdWUpXG4gIH0sXG4gIGNsZWFyVGltZW91dCAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0IGluc3RhbmNlb2YgVGltZW91dCkge1xuICAgICAgdGltZW91dC5jbGVhcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\")\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cache/util.js\")\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Response, cloneResponse, fromInnerResponse } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { Request, fromInnerRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { kState } = __webpack_require__(/*! ../fetch/symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(response, 'immutable')\n\n      responseList.push(responseObject.clone())\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUMxQyxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDdEQsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLDZDQUE2QyxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ2xGLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDaEUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDN0MsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDN0MsUUFBUSw0REFBNEQsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQzdGLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsK0NBQStDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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Q0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNhY2hlXFxjYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB1cmxFcXVhbHMsIGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBSZXNwb25zZSwgY2xvbmVSZXNwb25zZSwgZnJvbUlubmVyUmVzcG9uc2UgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3Jlc3BvbnNlJylcbmNvbnN0IHsgUmVxdWVzdCwgZnJvbUlubmVyUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvc3ltYm9scycpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IHVybElzSHR0cEh0dHBzU2NoZW1lLCBjcmVhdGVEZWZlcnJlZFByb21pc2UsIHJlYWRBbGxCeXRlcyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLWNhY2hlLWJhdGNoLW9wZXJhdGlvblxuICogQHR5cGVkZWYge09iamVjdH0gQ2FjaGVCYXRjaE9wZXJhdGlvblxuICogQHByb3BlcnR5IHsnZGVsZXRlJyB8ICdwdXQnfSB0eXBlXG4gKiBAcHJvcGVydHkge2FueX0gcmVxdWVzdFxuICogQHByb3BlcnR5IHthbnl9IHJlc3BvbnNlXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlcXVlc3QtcmVzcG9uc2UtbGlzdFxuICogQHR5cGVkZWYge1thbnksIGFueV1bXX0gcmVxdWVzdFJlc3BvbnNlTGlzdFxuICovXG5cbmNsYXNzIENhY2hlIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZWxldmFudC1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAgICogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cblxuICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGFyZ3VtZW50c1sxXVxuICB9XG5cbiAgYXN5bmMgbWF0Y2ggKHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLm1hdGNoJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIGNvbnN0IHAgPSB0aGlzLiNpbnRlcm5hbE1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMsIDEpXG5cbiAgICBpZiAocC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiBwWzBdXG4gIH1cblxuICBhc3luYyBtYXRjaEFsbCAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUubWF0Y2hBbGwnXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbE1hdGNoQWxsKHJlcXVlc3QsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBhZGQgKHJlcXVlc3QpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5hZGQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG5cbiAgICAvLyAxLlxuICAgIGNvbnN0IHJlcXVlc3RzID0gW3JlcXVlc3RdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlc3BvbnNlQXJyYXlQcm9taXNlID0gdGhpcy5hZGRBbGwocmVxdWVzdHMpXG5cbiAgICAvLyAzLlxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZUFycmF5UHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgYWRkQWxsIChyZXF1ZXN0cykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmFkZEFsbCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdXG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgIC8vIDMuXG4gICAgZm9yIChsZXQgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICBhcmd1bWVudDogJ0FyZ3VtZW50IDEnLFxuICAgICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCBpcyBub3QgYWxsb3dlZCddXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuXG4gICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDMuMVxuICAgICAgY29uc3QgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAvLyAzLjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpIHx8IHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVC4nXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICAvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIGZldGNoaW5nPltdfSAqL1xuICAgIGNvbnN0IGZldGNoQ29udHJvbGxlcnMgPSBbXVxuXG4gICAgLy8gNS5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcbiAgICAgIC8vIDUuMVxuICAgICAgY29uc3QgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cblxuICAgICAgLy8gNS4yXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHIudXJsKSkge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGh0dHAvcyBzY2hlbWUuJ1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjRcbiAgICAgIHIuaW5pdGlhdG9yID0gJ2ZldGNoJ1xuICAgICAgci5kZXN0aW5hdGlvbiA9ICdzdWJyZXNvdXJjZSdcblxuICAgICAgLy8gNS41XG4gICAgICByZXF1ZXN0TGlzdC5wdXNoKHIpXG5cbiAgICAgIC8vIDUuNlxuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgICAgLy8gNS43XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLnB1c2goZmV0Y2hpbmcoe1xuICAgICAgICByZXF1ZXN0OiByLFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyB8fCByZXNwb25zZS5zdGF0dXMgPT09IDIwNiB8fCByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID4gMjk5KSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuYWRkQWxsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGFuIGludmFsaWQgc3RhdHVzIGNvZGUgb3IgdGhlIHJlcXVlc3QgZmFpbGVkLidcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkgeyAvLyAyLlxuICAgICAgICAgICAgLy8gMi4xXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAgICAgICAvLyAyLjJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZSBvZiBmaWVsZFZhbHVlcykge1xuICAgICAgICAgICAgICAvLyAyLjIuMVxuICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdCh3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgdmFyeSBmaWVsZCB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9KSlcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IChyZXNwb25zZSkge1xuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3QobmV3IERPTUV4Y2VwdGlvbignYWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyLlxuICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KSlcblxuICAgICAgLy8gNS44XG4gICAgICByZXNwb25zZVByb21pc2VzLnB1c2gocmVzcG9uc2VQcm9taXNlLnByb21pc2UpXG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICBjb25zdCBwID0gUHJvbWlzZS5hbGwocmVzcG9uc2VQcm9taXNlcylcblxuICAgIC8vIDcuXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgcFxuXG4gICAgLy8gNy4xXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvLyA3LjJcbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyA3LjNcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgLy8gNy4zLjFcbiAgICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgdHlwZTogJ3B1dCcsIC8vIDcuMy4yXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RMaXN0W2luZGV4XSwgLy8gNy4zLjNcbiAgICAgICAgcmVzcG9uc2UgLy8gNy4zLjRcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbikgLy8gNy4zLjVcblxuICAgICAgaW5kZXgrKyAvLyA3LjMuNlxuICAgIH1cblxuICAgIC8vIDcuNVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyA3LjYuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyA3LjYuMlxuICAgIHRyeSB7XG4gICAgICB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICAvLyA3LjYuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDcuNi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNy42LjMuMlxuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVqZWN0KGVycm9yRGF0YSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNy43XG4gICAgcmV0dXJuIGNhY2hlSm9iUHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICBhc3luYyBwdXQgKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUucHV0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIHJlc3BvbnNlID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UocmVzcG9uc2UsIHByZWZpeCwgJ3Jlc3BvbnNlJylcblxuICAgIC8vIDEuXG4gICAgbGV0IGlubmVyUmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpbm5lclJlcXVlc3QgPSByZXF1ZXN0W2tTdGF0ZV1cbiAgICB9IGVsc2UgeyAvLyAzLlxuICAgICAgaW5uZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgIH1cblxuICAgIC8vIDQuXG4gICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShpbm5lclJlcXVlc3QudXJsKSB8fCBpbm5lclJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ0V4cGVjdGVkIGFuIGh0dHAvcyBzY2hlbWUgd2hlbiBtZXRob2QgaXMgbm90IEdFVCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICBjb25zdCBpbm5lclJlc3BvbnNlID0gcmVzcG9uc2Vba1N0YXRlXVxuXG4gICAgLy8gNi5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ0dvdCAyMDYgc3RhdHVzJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA3LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd2YXJ5JykpIHtcbiAgICAgIC8vIDcuMS5cbiAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMoaW5uZXJSZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3ZhcnknKSlcblxuICAgICAgLy8gNy4yLlxuICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgIC8vIDcuMi4xXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdHb3QgKiB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgJiYgKGlzRGlzdHVyYmVkKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pIHx8IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0ubG9ja2VkKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc3BvbnNlIGJvZHkgaXMgbG9ja2VkIG9yIGRpc3R1cmJlZCdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gOS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UoaW5uZXJSZXNwb25zZSlcblxuICAgIC8vIDEwLlxuICAgIGNvbnN0IGJvZHlSZWFkUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxMS5cbiAgICBpZiAoaW5uZXJSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDExLjFcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW1cblxuICAgICAgLy8gMTEuMlxuICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgICAgIC8vIDExLjNcbiAgICAgIHJlYWRBbGxCeXRlcyhyZWFkZXIpLnRoZW4oYm9keVJlYWRQcm9taXNlLnJlc29sdmUsIGJvZHlSZWFkUHJvbWlzZS5yZWplY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHlSZWFkUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICB9XG5cbiAgICAvLyAxMi5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb25bXX0gKi9cbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDEzLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbn0gKi9cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICB0eXBlOiAncHV0JywgLy8gMTQuXG4gICAgICByZXF1ZXN0OiBpbm5lclJlcXVlc3QsIC8vIDE1LlxuICAgICAgcmVzcG9uc2U6IGNsb25lZFJlc3BvbnNlIC8vIDE2LlxuICAgIH1cblxuICAgIC8vIDE3LlxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICAvLyAxOS5cbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IGJvZHlSZWFkUHJvbWlzZS5wcm9taXNlXG5cbiAgICBpZiAoY2xvbmVkUmVzcG9uc2UuYm9keSAhPSBudWxsKSB7XG4gICAgICBjbG9uZWRSZXNwb25zZS5ib2R5LnNvdXJjZSA9IGJ5dGVzXG4gICAgfVxuXG4gICAgLy8gMTkuMVxuICAgIGNvbnN0IGNhY2hlSm9iUHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgICAvLyAxOS4yLjFcbiAgICBsZXQgZXJyb3JEYXRhID0gbnVsbFxuXG4gICAgLy8gMTkuMi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDE5LjIuM1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIC8vIDE5LjIuMy4xXG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH0gZWxzZSB7IC8vIDE5LjIuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZSAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUuZGVsZXRlJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZXF1ZXN0fVxuICAgICAqL1xuICAgIGxldCByID0gbnVsbFxuXG4gICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKVxuXG4gICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgcmVxdWVzdDogcixcbiAgICAgIG9wdGlvbnNcbiAgICB9XG5cbiAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKVxuXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG4gICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0UmVzcG9uc2VzID0gdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSghIXJlcXVlc3RSZXNwb25zZXM/Lmxlbmd0aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNkb20tY2FjaGUta2V5c1xuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxyZWFkb25seSBSZXF1ZXN0W10+fVxuICAgKi9cbiAgYXN5bmMga2V5cyAocmVxdWVzdCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUua2V5cydcblxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMob3B0aW9ucywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICAvLyAxLlxuICAgIGxldCByID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAyLjFcbiAgICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAvLyAyLjEuMVxuICAgICAgICByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgICAgLy8gMi4xLjJcbiAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHsgLy8gMi4yXG4gICAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVxdWVzdHMgPSBbXVxuXG4gICAgLy8gNS4yXG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gNS4yLjFcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCkge1xuICAgICAgICAvLyA1LjIuMS4xXG4gICAgICAgIHJlcXVlc3RzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzBdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIC8vIDUuMy4yLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS40XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gNS40LjFcbiAgICAgIGNvbnN0IHJlcXVlc3RMaXN0ID0gW11cblxuICAgICAgLy8gNS40LjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICBjb25zdCByZXF1ZXN0T2JqZWN0ID0gZnJvbUlubmVyUmVxdWVzdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwsXG4gICAgICAgICAgJ2ltbXV0YWJsZSdcbiAgICAgICAgKVxuICAgICAgICAvLyA1LjQuMi4xXG4gICAgICAgIHJlcXVlc3RMaXN0LnB1c2gocmVxdWVzdE9iamVjdClcbiAgICAgIH1cblxuICAgICAgLy8gNS40LjNcbiAgICAgIHByb21pc2UucmVzb2x2ZShPYmplY3QuZnJlZXplKHJlcXVlc3RMaXN0KSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2JhdGNoLWNhY2hlLW9wZXJhdGlvbnMtYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2JhdGNoQ2FjaGVPcGVyYXRpb25zIChvcGVyYXRpb25zKSB7XG4gICAgLy8gMS5cbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgLy8gMi5cbiAgICBjb25zdCBiYWNrdXBDYWNoZSA9IFsuLi5jYWNoZV1cblxuICAgIC8vIDMuXG4gICAgY29uc3QgYWRkZWRJdGVtcyA9IFtdXG5cbiAgICAvLyA0LjFcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIHRyeSB7XG4gICAgICAvLyA0LjJcbiAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgLy8gNC4yLjFcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlICE9PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24udHlwZSAhPT0gJ3B1dCcpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ29wZXJhdGlvbiB0eXBlIGRvZXMgbm90IG1hdGNoIFwiZGVsZXRlXCIgb3IgXCJwdXRcIidcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjJcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSAnZGVsZXRlJyAmJiBvcGVyYXRpb24ucmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnZGVsZXRlIG9wZXJhdGlvbiBzaG91bGQgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjNcbiAgICAgICAgaWYgKHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zLCBhZGRlZEl0ZW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCc/Pz8nLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4yLjRcbiAgICAgICAgbGV0IHJlcXVlc3RSZXNwb25zZXNcblxuICAgICAgICAvLyA0LjIuNVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgLy8gNC4yLjUuMVxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ub3B0aW9ucylcblxuICAgICAgICAgIC8vIFRPRE86IHRoZSBzcGVjIGlzIHdyb25nLCB0aGlzIGlzIG5lZWRlZCB0byBwYXNzIFdQVHNcbiAgICAgICAgICBpZiAocmVxdWVzdFJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi41LjJcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBjYWNoZS5pbmRleE9mKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgICAgICAgIGFzc2VydChpZHggIT09IC0xKVxuXG4gICAgICAgICAgICAvLyA0LjIuNS4yLjFcbiAgICAgICAgICAgIGNhY2hlLnNwbGljZShpZHgsIDEpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSAncHV0JykgeyAvLyA0LjIuNlxuICAgICAgICAgIC8vIDQuMi42LjFcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLnJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3B1dCBvcGVyYXRpb24gc2hvdWxkIGhhdmUgYW4gYXNzb2NpYXRlZCByZXNwb25zZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuMlxuICAgICAgICAgIGNvbnN0IHIgPSBvcGVyYXRpb24ucmVxdWVzdFxuXG4gICAgICAgICAgLy8gNC4yLjYuM1xuICAgICAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdleHBlY3RlZCBodHRwIG9yIGh0dHBzIHNjaGVtZSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNFxuICAgICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ25vdCBnZXQgbWV0aG9kJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi41XG4gICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ29wdGlvbnMgbXVzdCBub3QgYmUgZGVmaW5lZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjYuNlxuICAgICAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKG9wZXJhdGlvbi5yZXF1ZXN0KVxuXG4gICAgICAgICAgLy8gNC4yLjYuN1xuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi42LjcuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi44XG4gICAgICAgICAgY2FjaGUucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG5cbiAgICAgICAgICAvLyA0LjIuNi4xMFxuICAgICAgICAgIGFkZGVkSXRlbXMucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuN1xuICAgICAgICByZXN1bHRMaXN0LnB1c2goW29wZXJhdGlvbi5yZXF1ZXN0LCBvcGVyYXRpb24ucmVzcG9uc2VdKVxuICAgICAgfVxuXG4gICAgICAvLyA0LjNcbiAgICAgIHJldHVybiByZXN1bHRMaXN0XG4gICAgfSBjYXRjaCAoZSkgeyAvLyA1LlxuICAgICAgLy8gNS4xXG4gICAgICB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QubGVuZ3RoID0gMFxuXG4gICAgICAvLyA1LjJcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCA9IGJhY2t1cENhY2hlXG5cbiAgICAgIC8vIDUuM1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNxdWVyeS1jYWNoZVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gdGFyZ2V0U3RvcmFnZVxuICAgKiBAcmV0dXJucyB7cmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNxdWVyeUNhY2hlIChyZXF1ZXN0UXVlcnksIG9wdGlvbnMsIHRhcmdldFN0b3JhZ2UpIHtcbiAgICAvKiogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9ICovXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdXG5cbiAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0U3RvcmFnZSA/PyB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3RcblxuICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IFtjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZV0gPSByZXF1ZXN0UmVzcG9uc2VcbiAgICAgIGlmICh0aGlzLiNyZXF1ZXN0TWF0Y2hlc0NhY2hlZEl0ZW0ocmVxdWVzdFF1ZXJ5LCBjYWNoZWRSZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHJlcXVlc3RSZXNwb25zZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3JlcXVlc3QtbWF0Y2hlcy1jYWNoZWQtaXRlbS1hbGdvcml0aG1cbiAgICogQHBhcmFtIHthbnl9IHJlcXVlc3RRdWVyeVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFxuICAgKiBAcGFyYW0ge2FueSB8IG51bGx9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zIHwgdW5kZWZpbmVkfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbSAocmVxdWVzdFF1ZXJ5LCByZXF1ZXN0LCByZXNwb25zZSA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiAob3B0aW9ucz8uaWdub3JlTWV0aG9kID09PSBmYWxzZSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyAgIHJldHVybiBmYWxzZVxuICAgIC8vIH1cblxuICAgIGNvbnN0IHF1ZXJ5VVJMID0gbmV3IFVSTChyZXF1ZXN0UXVlcnkudXJsKVxuXG4gICAgY29uc3QgY2FjaGVkVVJMID0gbmV3IFVSTChyZXF1ZXN0LnVybClcblxuICAgIGlmIChvcHRpb25zPy5pZ25vcmVTZWFyY2gpIHtcbiAgICAgIGNhY2hlZFVSTC5zZWFyY2ggPSAnJ1xuXG4gICAgICBxdWVyeVVSTC5zZWFyY2ggPSAnJ1xuICAgIH1cblxuICAgIGlmICghdXJsRXF1YWxzKHF1ZXJ5VVJMLCBjYWNoZWRVUkwsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICByZXNwb25zZSA9PSBudWxsIHx8XG4gICAgICBvcHRpb25zPy5pZ25vcmVWYXJ5IHx8XG4gICAgICAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkVmFsdWVzKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1ZXN0VmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuICAgICAgY29uc3QgcXVlcnlWYWx1ZSA9IHJlcXVlc3RRdWVyeS5oZWFkZXJzTGlzdC5nZXQoZmllbGRWYWx1ZSlcblxuICAgICAgLy8gSWYgb25lIGhhcyB0aGUgaGVhZGVyIGFuZCB0aGUgb3RoZXIgZG9lc24ndCwgb3Igb25lIGhhc1xuICAgICAgLy8gYSBkaWZmZXJlbnQgdmFsdWUgdGhhbiB0aGUgb3RoZXIsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHJlcXVlc3RWYWx1ZSAhPT0gcXVlcnlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgI2ludGVybmFsTWF0Y2hBbGwgKHJlcXVlc3QsIG9wdGlvbnMsIG1heFJlc3BvbnNlcyA9IEluZmluaXR5KSB7XG4gICAgLy8gMS5cbiAgICBsZXQgciA9IG51bGxcblxuICAgIC8vIDIuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAyLjIuMVxuICAgICAgICByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuXG4gICAgLy8gNS4xXG4gICAgY29uc3QgcmVzcG9uc2VzID0gW11cblxuICAgIC8vIDUuMlxuICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDUuMi4xXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiB0aGlzLiNyZWxldmFudFJlcXVlc3RSZXNwb25zZUxpc3QpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIDUuM1xuICAgICAgLy8gNS4zLjFcbiAgICAgIGNvbnN0IHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNxdWVyeUNhY2hlKHIsIG9wdGlvbnMpXG5cbiAgICAgIC8vIDUuMy4yXG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RSZXNwb25zZSBvZiByZXF1ZXN0UmVzcG9uc2VzKSB7XG4gICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlcXVlc3RSZXNwb25zZVsxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICAvLyBXZSBkb24ndCBpbXBsZW1lbnQgQ09ScyBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvb3Agb3ZlciB0aGUgcmVzcG9uc2VzLCB5YXkhXG5cbiAgICAvLyA1LjUuMVxuICAgIGNvbnN0IHJlc3BvbnNlTGlzdCA9IFtdXG5cbiAgICAvLyA1LjUuMlxuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA1LjUuMi4xXG4gICAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKHJlc3BvbnNlLCAnaW1tdXRhYmxlJylcblxuICAgICAgcmVzcG9uc2VMaXN0LnB1c2gocmVzcG9uc2VPYmplY3QuY2xvbmUoKSlcblxuICAgICAgaWYgKHJlc3BvbnNlTGlzdC5sZW5ndGggPj0gbWF4UmVzcG9uc2VzKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNi5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXNwb25zZUxpc3QpXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGUucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1hdGNoOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBtYXRjaEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWRkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGRBbGw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHB1dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5jb25zdCBjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyA9IFtcbiAge1xuICAgIGtleTogJ2lnbm9yZVNlYXJjaCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZU1ldGhvZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2lnbm9yZVZhcnknLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuQ2FjaGVRdWVyeU9wdGlvbnMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihjYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycylcblxud2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uY2FjaGVRdWVyeU9wdGlvbkNvbnZlcnRlcnMsXG4gIHtcbiAgICBrZXk6ICdjYWNoZU5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihSZXNwb25zZSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPFJlcXVlc3RJbmZvPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mb1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/cache/symbols.js\")\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(ssr)/./node_modules/undici/lib/web/cache/cache.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match')\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.open'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDMUMsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUztBQUNuQyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcY2FjaGVzdG9yYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IENhY2hlIH0gPSByZXF1aXJlKCcuL2NhY2hlJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBDYWNoZVN0b3JhZ2Uge1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlbGV2YW50LW5hbWUtdG8tY2FjaGUtbWFwXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBpbXBvcnQoJy4vY2FjaGUnKS5yZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI2NhY2hlcyA9IG5ldyBNYXAoKVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICE9PSBrQ29uc3RydWN0KSB7XG4gICAgICB3ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yKClcbiAgICB9XG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0NhY2hlU3RvcmFnZS5tYXRjaCcpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdClcbiAgICBvcHRpb25zID0gd2ViaWRsLmNvbnZlcnRlcnMuTXVsdGlDYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zKVxuXG4gICAgLy8gMS5cbiAgICBpZiAob3B0aW9ucy5jYWNoZU5hbWUgIT0gbnVsbCkge1xuICAgICAgLy8gMS4xLjEuMVxuICAgICAgaWYgKHRoaXMuI2NhY2hlcy5oYXMob3B0aW9ucy5jYWNoZU5hbWUpKSB7XG4gICAgICAgIC8vIDEuMS4xLjEuMVxuICAgICAgICBjb25zdCBjYWNoZUxpc3QgPSB0aGlzLiNjYWNoZXMuZ2V0KG9wdGlvbnMuY2FjaGVOYW1lKVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZUxpc3QpXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhY2hlLm1hdGNoKHJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gMi5cbiAgICAgIC8vIDIuMlxuICAgICAgZm9yIChjb25zdCBjYWNoZUxpc3Qgb2YgdGhpcy4jY2FjaGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICAvLyAyLjIuMS4yXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcblxuICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtaGFzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBoYXMgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2UuaGFzJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIC8vIDIuMS4xXG4gICAgLy8gMi4yXG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlcy5oYXMoY2FjaGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZXN0b3JhZ2Utb3BlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlPn1cbiAgICovXG4gIGFzeW5jIG9wZW4gKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2Uub3BlbidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICAvLyAyLjFcbiAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpKSB7XG4gICAgICAvLyBhd2FpdCBjYWNoZXMub3BlbigndjEnKSAhPT0gYXdhaXQgY2FjaGVzLm9wZW4oJ3YxJylcblxuICAgICAgLy8gMi4xLjFcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jY2FjaGVzLmdldChjYWNoZU5hbWUpXG5cbiAgICAgIC8vIDIuMS4xLjFcbiAgICAgIHJldHVybiBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGUpXG4gICAgfVxuXG4gICAgLy8gMi4yXG4gICAgY29uc3QgY2FjaGUgPSBbXVxuXG4gICAgLy8gMi4zXG4gICAgdGhpcy4jY2FjaGVzLnNldChjYWNoZU5hbWUsIGNhY2hlKVxuXG4gICAgLy8gMi40XG4gICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgKi9cbiAgYXN5bmMgZGVsZXRlIChjYWNoZU5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGVTdG9yYWdlLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNhY2hlTmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhjYWNoZU5hbWUsIHByZWZpeCwgJ2NhY2hlTmFtZScpXG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1rZXlzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn1cbiAgICovXG4gIGFzeW5jIGtleXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIC8vIDIuMVxuICAgIGNvbnN0IGtleXMgPSB0aGlzLiNjYWNoZXMua2V5cygpXG5cbiAgICAvLyAyLjJcbiAgICByZXR1cm4gWy4uLmtleXNdXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2FjaGVTdG9yYWdlLnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2FjaGVTdG9yYWdlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBrZXlzOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGVTdG9yYWdlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/symbols.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  kConstruct: (__webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\").kConstruct)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLGNBQWMsNkdBQXdDO0FBQ3REIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtDb25zdHJ1Y3Q6IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpLmtDb25zdHJ1Y3Rcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction getFieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (isValidHeaderName(value)) {\n      values.push(value)\n    }\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  getFieldValues\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWU7O0FBRXJEO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNhY2hlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFVSTFNlcmlhbGl6ZXIgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgaXNWYWxpZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1lcXVhbHNcbiAqIEBwYXJhbSB7VVJMfSBBXG4gKiBAcGFyYW0ge1VSTH0gQlxuICogQHBhcmFtIHtib29sZWFuIHwgdW5kZWZpbmVkfSBleGNsdWRlRnJhZ21lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB1cmxFcXVhbHMgKEEsIEIsIGV4Y2x1ZGVGcmFnbWVudCA9IGZhbHNlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRBID0gVVJMU2VyaWFsaXplcihBLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgY29uc3Qgc2VyaWFsaXplZEIgPSBVUkxTZXJpYWxpemVyKEIsIGV4Y2x1ZGVGcmFnbWVudClcblxuICByZXR1cm4gc2VyaWFsaXplZEEgPT09IHNlcmlhbGl6ZWRCXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi82OTRkMjBkMTM0Y2I1NTNkOGQ4OWU1NTAwYjkxNDgwMTJiMWJhMjk5L2NvbnRlbnQvYnJvd3Nlci9jYWNoZV9zdG9yYWdlL2NhY2hlX3N0b3JhZ2VfY2FjaGUuY2MjTDI2MC1MMjYyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWVzIChoZWFkZXIpIHtcbiAgYXNzZXJ0KGhlYWRlciAhPT0gbnVsbClcblxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIGZvciAobGV0IHZhbHVlIG9mIGhlYWRlci5zcGxpdCgnLCcpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAgIGlmIChpc1ZhbGlkSGVhZGVyTmFtZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVybEVxdWFscyxcbiAgZ2V0RmllbGRWYWx1ZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29va2llLXN0b3JlLyNjb29raWUtbWF4aW11bS1hdHRyaWJ1dGUtdmFsdWUtc2l6ZVxuY29uc3QgbWF4QXR0cmlidXRlVmFsdWVTaXplID0gMTAyNFxuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tbmFtZS12YWx1ZS1wYWlyLXNpemVcbmNvbnN0IG1heE5hbWVWYWx1ZVBhaXJTaXplID0gNDA5NlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF4QXR0cmlidXRlVmFsdWVTaXplLFxuICBtYXhOYW1lVmFsdWVQYWlyU2l6ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/undici/lib/web/cookies/parse.js\")\nconst { stringify } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\")\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getCookies')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookie = headers.get('cookie')\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const prefix = 'deleteCookie'\n  webidl.argumentLengthCheck(arguments, 2, prefix)\n\n  name = webidl.converters.DOMString(name, prefix, 'name')\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getSetCookies')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookies = headers.getSetCookie()\n\n  if (!cookies) {\n    return []\n  }\n\n  return cookies.map((pair) => parseSetCookie(pair))\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, 'setCookie')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('Set-Cookie', str)\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: () => new Array(0)\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMscUVBQVM7QUFDNUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUTtBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFOUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLFVBQVU7QUFDeEI7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsZUFBZTs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQ0FBZ0MsWUFBWTtBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdDQUF3QyxlQUFlOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsZUFBZTs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGVBQWU7O0FBRXZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY29va2llc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGFyc2VTZXRDb29raWUgfSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzdHJpbmdpZnkgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgSGVhZGVycyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29va2llXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKiBAcHJvcGVydHkge0RhdGV8bnVtYmVyfHVuZGVmaW5lZH0gZXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ8dW5kZWZpbmVkfSBtYXhBZ2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gZG9tYWluXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHBhdGhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IHNlY3VyZVxuICogQHByb3BlcnR5IHtib29sZWFufHVuZGVmaW5lZH0gaHR0cE9ubHlcbiAqIEBwcm9wZXJ0eSB7J1N0cmljdCd8J0xheCd8J05vbmUnfSBzYW1lU2l0ZVxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdW5wYXJzZWRcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2V0Q29va2llcycpXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgY29va2llID0gaGVhZGVycy5nZXQoJ2Nvb2tpZScpXG4gIGNvbnN0IG91dCA9IHt9XG5cbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmb3IgKGNvbnN0IHBpZWNlIG9mIGNvb2tpZS5zcGxpdCgnOycpKSB7XG4gICAgY29uc3QgW25hbWUsIC4uLnZhbHVlXSA9IHBpZWNlLnNwbGl0KCc9JylcblxuICAgIG91dFtuYW1lLnRyaW0oKV0gPSB2YWx1ZS5qb2luKCc9JylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3sgcGF0aD86IHN0cmluZywgZG9tYWluPzogc3RyaW5nIH18dW5kZWZpbmVkfSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVsZXRlQ29va2llIChoZWFkZXJzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IHByZWZpeCA9ICdkZWxldGVDb29raWUnXG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gIGF0dHJpYnV0ZXMgPSB3ZWJpZGwuY29udmVydGVycy5EZWxldGVDb29raWVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpXG5cbiAgLy8gTWF0Y2hlcyBiZWhhdmlvciBvZlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvYmxvYi82MzgyN2IxNjMzMGI4MjQ4OWEwNDYxNDAyN2MzM2I3OTA0ZTA4YmU1L2h0dHAvY29va2llLnRzI0wyNzhcbiAgc2V0Q29va2llKGhlYWRlcnMsIHtcbiAgICBuYW1lLFxuICAgIHZhbHVlOiAnJyxcbiAgICBleHBpcmVzOiBuZXcgRGF0ZSgwKSxcbiAgICAuLi5hdHRyaWJ1dGVzXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7Q29va2llW119XG4gKi9cbmZ1bmN0aW9uIGdldFNldENvb2tpZXMgKGhlYWRlcnMpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2V0U2V0Q29va2llcycpXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29uc3QgY29va2llcyA9IGhlYWRlcnMuZ2V0U2V0Q29va2llKClcblxuICBpZiAoIWNvb2tpZXMpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHJldHVybiBjb29raWVzLm1hcCgocGFpcikgPT4gcGFyc2VTZXRDb29raWUocGFpcikpXG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge0Nvb2tpZX0gY29va2llXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gc2V0Q29va2llIChoZWFkZXJzLCBjb29raWUpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnc2V0Q29va2llJylcblxuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb29raWUgPSB3ZWJpZGwuY29udmVydGVycy5Db29raWUoY29va2llKVxuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShjb29raWUpXG5cbiAgaWYgKHN0cikge1xuICAgIGhlYWRlcnMuYXBwZW5kKCdTZXQtQ29va2llJywgc3RyKVxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkRlbGV0ZUNvb2tpZUF0dHJpYnV0ZXMgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3BhdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdkb21haW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5Db29raWUgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBrZXk6ICduYW1lJ1xuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAga2V5OiAndmFsdWUnXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcigodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10odmFsdWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSlcbiAgICB9KSxcbiAgICBrZXk6ICdleHBpcmVzJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzWydsb25nIGxvbmcnXSksXG4gICAga2V5OiAnbWF4QWdlJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAnZG9tYWluJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAncGF0aCcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ib29sZWFuKSxcbiAgICBrZXk6ICdzZWN1cmUnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiksXG4gICAga2V5OiAnaHR0cE9ubHknLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAga2V5OiAnc2FtZVNpdGUnLFxuICAgIGFsbG93ZWRWYWx1ZXM6IFsnU3RyaWN0JywgJ0xheCcsICdOb25lJ11cbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAndW5wYXJzZWQnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IEFycmF5KDApXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb29raWVzLFxuICBkZWxldGVDb29raWUsXG4gIGdldFNldENvb2tpZXMsXG4gIHNldENvb2tpZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/cookies/constants.js\")\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDhDQUE4QyxFQUFFLG1CQUFPLENBQUMsNkVBQWE7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFRO0FBQy9DLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDeEUsZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRCx3QkFBd0I7QUFDeEI7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQ0FBaUM7QUFDakMsdUJBQXVCOztBQUV2Qix1REFBdUQ7QUFDdkQ7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLDJDQUEyQztBQUMzQztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSx5Q0FBeUMsY0FBYyxHQUFHLGVBQWU7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFxwYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhOYW1lVmFsdWVQYWlyU2l6ZSwgbWF4QXR0cmlidXRlVmFsdWVTaXplIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGlzQ1RMRXhjbHVkaW5nSHRhYiB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUGFyc2VzIHRoZSBmaWVsZC12YWx1ZSBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXIgc3RyaW5nLlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40XG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gKiBAcmV0dXJucyBpZiB0aGUgaGVhZGVyIGlzIGludmFsaWQsIG51bGwgd2lsbCBiZSByZXR1cm5lZFxuICovXG5mdW5jdGlvbiBwYXJzZVNldENvb2tpZSAoaGVhZGVyKSB7XG4gIC8vIDEuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4MDAtMDggLyAleDBBLTFGIC8gJXg3RlxuICAvLyAgICBjaGFyYWN0ZXIgKENUTCBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBIVEFCKTogQWJvcnQgdGhlc2Ugc3RlcHMgYW5kXG4gIC8vICAgIGlnbm9yZSB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgZW50aXJlbHkuXG4gIGlmIChpc0NUTEV4Y2x1ZGluZ0h0YWIoaGVhZGVyKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgbmFtZVZhbHVlUGFpciA9ICcnXG4gIGxldCB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICBsZXQgbmFtZSA9ICcnXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMi4gSWYgdGhlIHNldC1jb29raWUtc3RyaW5nIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGhlYWRlci5pbmNsdWRlcygnOycpKSB7XG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sXG4gICAgLy8gICAgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIiksIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBjb25zaXN0IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIHNldC1jb29raWUtc3RyaW5nXG4gICAgLy8gICAgKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgbmFtZVZhbHVlUGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgaGVhZGVyLCBwb3NpdGlvbilcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSBoZWFkZXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24pXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gVGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgY29uc2lzdHMgb2YgYWxsIHRoZSBjaGFyYWN0ZXJzXG4gICAgLy8gICAgY29udGFpbmVkIGluIHRoZSBzZXQtY29va2llLXN0cmluZywgYW5kIHRoZSB1bnBhcnNlZC1cbiAgICAvLyAgICBhdHRyaWJ1dGVzIGlzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgbmFtZVZhbHVlUGFpciA9IGhlYWRlclxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIG5hbWUtdmFsdWUtcGFpciBzdHJpbmcgbGFja3MgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyLCB0aGVuXG4gIC8vICAgIHRoZSBuYW1lIHN0cmluZyBpcyBlbXB0eSwgYW5kIHRoZSB2YWx1ZSBzdHJpbmcgaXMgdGhlIHZhbHVlIG9mXG4gIC8vICAgIG5hbWUtdmFsdWUtcGFpci5cbiAgaWYgKCFuYW1lVmFsdWVQYWlyLmluY2x1ZGVzKCc9JykpIHtcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJcbiAgfSBlbHNlIHtcbiAgICAvLyAgICBPdGhlcndpc2UsIHRoZSBuYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyB1cCB0bywgYnV0XG4gICAgLy8gICAgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKSBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5XG4gICAgLy8gICAgZW1wdHkpIHZhbHVlIHN0cmluZyBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3RcbiAgICAvLyAgICAleDNEIChcIj1cIikgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG4gICAgbmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgbmFtZVZhbHVlUGFpcixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpci5zbGljZShwb3NpdGlvbi5wb3NpdGlvbiArIDEpXG4gIH1cblxuICAvLyA0LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgbmFtZVxuICAvLyAgICBzdHJpbmcgYW5kIHRoZSB2YWx1ZSBzdHJpbmcuXG4gIG5hbWUgPSBuYW1lLnRyaW0oKVxuICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gIC8vIDUuIElmIHRoZSBzdW0gb2YgdGhlIGxlbmd0aHMgb2YgdGhlIG5hbWUgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nXG4gIC8vICAgIGlzIG1vcmUgdGhhbiA0MDk2IG9jdGV0cywgYWJvcnQgdGhlc2Ugc3RlcHMgYW5kIGlnbm9yZSB0aGUgc2V0LVxuICAvLyAgICBjb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAobmFtZS5sZW5ndGggKyB2YWx1ZS5sZW5ndGggPiBtYXhOYW1lVmFsdWVQYWlyU2l6ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyA2LiBUaGUgY29va2llLW5hbWUgaXMgdGhlIG5hbWUgc3RyaW5nLCBhbmQgdGhlIGNvb2tpZS12YWx1ZSBpcyB0aGVcbiAgLy8gICAgdmFsdWUgc3RyaW5nLlxuICByZXR1cm4ge1xuICAgIG5hbWUsIHZhbHVlLCAuLi5wYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlbWFpbmluZyBhdHRyaWJ1dGVzIG9mIGEgc2V0LWNvb2tpZSBoZWFkZXJcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IHVucGFyc2VkQXR0cmlidXRlc1xuICogQHBhcmFtIHtbT2JqZWN0LjxzdHJpbmcsIHVua25vd24+XT17fX0gY29va2llQXR0cmlidXRlTGlzdFxuICovXG5mdW5jdGlvbiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyAodW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0ID0ge30pIHtcbiAgLy8gMS4gSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mXG4gIC8vICAgIHRoZXNlIHN0ZXBzLlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb29raWVBdHRyaWJ1dGVMaXN0XG4gIH1cblxuICAvLyAyLiBEaXNjYXJkIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgKHdoaWNoXG4gIC8vICAgIHdpbGwgYmUgYSAleDNCIChcIjtcIikgY2hhcmFjdGVyKS5cbiAgYXNzZXJ0KHVucGFyc2VkQXR0cmlidXRlc1swXSA9PT0gJzsnKVxuICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSB1bnBhcnNlZEF0dHJpYnV0ZXMuc2xpY2UoMSlcblxuICBsZXQgY29va2llQXYgPSAnJ1xuXG4gIC8vIDMuIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuICAvLyAgICBjaGFyYWN0ZXI6XG4gIGlmICh1bnBhcnNlZEF0dHJpYnV0ZXMuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIENvbnN1bWUgdGhlIGNoYXJhY3RlcnMgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgIGNvb2tpZUF2ID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnOycsXG4gICAgICB1bnBhcnNlZEF0dHJpYnV0ZXMsXG4gICAgICB7IHBvc2l0aW9uOiAwIH1cbiAgICApXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKGNvb2tpZUF2Lmxlbmd0aClcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBDb25zdW1lIHRoZSByZW1haW5kZXIgb2YgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMuXG4gICAgY29va2llQXYgPSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAgICB1bnBhcnNlZEF0dHJpYnV0ZXMgPSAnJ1xuICB9XG5cbiAgLy8gTGV0IHRoZSBjb29raWUtYXYgc3RyaW5nIGJlIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGluIHRoaXMgc3RlcC5cblxuICBsZXQgYXR0cmlidXRlTmFtZSA9ICcnXG4gIGxldCBhdHRyaWJ1dGVWYWx1ZSA9ICcnXG5cbiAgLy8gNC4gSWYgdGhlIGNvb2tpZS1hdiBzdHJpbmcgY29udGFpbnMgYSAleDNEIChcIj1cIikgY2hhcmFjdGVyOlxuICBpZiAoY29va2llQXYuaW5jbHVkZXMoJz0nKSkge1xuICAgIC8vIDEuIFRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS1uYW1lIHN0cmluZyBjb25zaXN0cyBvZiB0aGVcbiAgICAvLyAgICBjaGFyYWN0ZXJzIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3RlciwgYW5kIHRoZSAocG9zc2libHkgZW1wdHkpIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmdcbiAgICAvLyAgICBjb25zaXN0cyBvZiB0aGUgY2hhcmFjdGVycyBhZnRlciB0aGUgZmlyc3QgJXgzRCAoXCI9XCIpXG4gICAgLy8gICAgY2hhcmFjdGVyLlxuICAgIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAnPScsXG4gICAgICBjb29raWVBdixcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICAgIGF0dHJpYnV0ZVZhbHVlID0gY29va2llQXYuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGVudGlyZSBjb29raWUtYXZcbiAgICAvLyAgICBzdHJpbmcsIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZyBpcyBlbXB0eS5cbiAgICBhdHRyaWJ1dGVOYW1lID0gY29va2llQXZcbiAgfVxuXG4gIC8vIDUuIFJlbW92ZSBhbnkgbGVhZGluZyBvciB0cmFpbGluZyBXU1AgY2hhcmFjdGVycyBmcm9tIHRoZSBhdHRyaWJ1dGUtXG4gIC8vICAgIG5hbWUgc3RyaW5nIGFuZCB0aGUgYXR0cmlidXRlLXZhbHVlIHN0cmluZy5cbiAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudHJpbSgpXG4gIGF0dHJpYnV0ZVZhbHVlID0gYXR0cmlidXRlVmFsdWUudHJpbSgpXG5cbiAgLy8gNi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBsb25nZXIgdGhhbiAxMDI0IG9jdGV0cywgaWdub3JlIHRoZVxuICAvLyAgICBjb29raWUtYXYgc3RyaW5nIGFuZCByZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICBpZiAoYXR0cmlidXRlVmFsdWUubGVuZ3RoID4gbWF4QXR0cmlidXRlVmFsdWVTaXplKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdClcbiAgfVxuXG4gIC8vIDcuIFByb2Nlc3MgdGhlIGF0dHJpYnV0ZS1uYW1lIGFuZCBhdHRyaWJ1dGUtdmFsdWUgYWNjb3JkaW5nIHRvIHRoZVxuICAvLyAgICByZXF1aXJlbWVudHMgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy4gIChOb3RpY2UgdGhhdFxuICAvLyAgICBhdHRyaWJ1dGVzIHdpdGggdW5yZWNvZ25pemVkIGF0dHJpYnV0ZS1uYW1lcyBhcmUgaWdub3JlZC4pXG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjFcbiAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmdcbiAgLy8gXCJFeHBpcmVzXCIsIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG4gIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnZXhwaXJlcycpIHtcbiAgICAvLyAxLiBMZXQgdGhlIGV4cGlyeS10aW1lIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgYXR0cmlidXRlLXZhbHVlXG4gICAgLy8gICAgYXMgY29va2llLWRhdGUgKHNlZSBTZWN0aW9uIDUuMS4xKS5cbiAgICBjb25zdCBleHBpcnlUaW1lID0gbmV3IERhdGUoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyAyLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmVcbiAgICAvLyAgICB0aGUgY29va2llLWF2LlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5leHBpcmVzID0gZXhwaXJ5VGltZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdtYXgtYWdlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuMlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiTWF4LVxuICAgIC8vIEFnZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCBhIERJR0lUIG9yIGFcbiAgICAvLyAgICBcIi1cIiBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGNvbnN0IGNoYXJDb2RlID0gYXR0cmlidXRlVmFsdWUuY2hhckNvZGVBdCgwKVxuXG4gICAgaWYgKChjaGFyQ29kZSA8IDQ4IHx8IGNoYXJDb2RlID4gNTcpICYmIGF0dHJpYnV0ZVZhbHVlWzBdICE9PSAnLScpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYSBub24tRElHSVRcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGlnbm9yZSB0aGUgY29va2llLWF2LlxuICAgIGlmICghL15cXGQrJC8udGVzdChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGRlbHRhLXNlY29uZHMgYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlci5cbiAgICBjb25zdCBkZWx0YVNlY29uZHMgPSBOdW1iZXIoYXR0cmlidXRlVmFsdWUpXG5cbiAgICAvLyA0LiBMZXQgY29va2llLWFnZS1saW1pdCBiZSB0aGUgbWF4aW11bSBhZ2Ugb2YgdGhlIGNvb2tpZSAod2hpY2hcbiAgICAvLyAgICBTSE9VTEQgYmUgNDAwIGRheXMgb3IgbGVzcywgc2VlIFNlY3Rpb24gNC4xLjIuMikuXG5cbiAgICAvLyA1LiBTZXQgZGVsdGEtc2Vjb25kcyB0byB0aGUgc21hbGxlciBvZiBpdHMgcHJlc2VudCB2YWx1ZSBhbmQgY29va2llLVxuICAgIC8vICAgIGFnZS1saW1pdC5cbiAgICAvLyBkZWx0YVNlY29uZHMgPSBNYXRoLm1pbihkZWx0YVNlY29uZHMgKiAxMDAwLCBtYXhFeHBpcmVzTXMpXG5cbiAgICAvLyA2LiBJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS1cbiAgICAvLyAgICB0aW1lIGJlIHRoZSBlYXJsaWVzdCByZXByZXNlbnRhYmxlIGRhdGUgYW5kIHRpbWUuICBPdGhlcndpc2UsIGxldFxuICAgIC8vICAgIHRoZSBleHBpcnktdGltZSBiZSB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lIHBsdXMgZGVsdGEtc2Vjb25kc1xuICAgIC8vICAgIHNlY29uZHMuXG4gICAgLy8gY29uc3QgZXhwaXJ5VGltZSA9IGRlbHRhU2Vjb25kcyA8PSAwID8gRGF0ZS5ub3coKSA6IERhdGUubm93KCkgKyBkZWx0YVNlY29uZHNcblxuICAgIC8vIDcuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgTWF4LUFnZSBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGV4cGlyeS10aW1lLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QubWF4QWdlID0gZGVsdGFTZWNvbmRzXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2RvbWFpbicpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjNcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIkRvbWFpblwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBMZXQgY29va2llLWRvbWFpbiBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlxuICAgIGxldCBjb29raWVEb21haW4gPSBhdHRyaWJ1dGVWYWx1ZVxuXG4gICAgLy8gMi4gSWYgY29va2llLWRvbWFpbiBzdGFydHMgd2l0aCAleDJFIChcIi5cIiksIGxldCBjb29raWUtZG9tYWluIGJlXG4gICAgLy8gICAgY29va2llLWRvbWFpbiB3aXRob3V0IGl0cyBsZWFkaW5nICV4MkUgKFwiLlwiKS5cbiAgICBpZiAoY29va2llRG9tYWluWzBdID09PSAnLicpIHtcbiAgICAgIGNvb2tpZURvbWFpbiA9IGNvb2tpZURvbWFpbi5zbGljZSgxKVxuICAgIH1cblxuICAgIC8vIDMuIENvbnZlcnQgdGhlIGNvb2tpZS1kb21haW4gdG8gbG93ZXIgY2FzZS5cbiAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4udG9Mb3dlckNhc2UoKVxuXG4gICAgLy8gNC4gQXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0IHdpdGggYW5cbiAgICAvLyAgICBhdHRyaWJ1dGUtbmFtZSBvZiBEb21haW4gYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtZG9tYWluLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZG9tYWluID0gY29va2llRG9tYWluXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3BhdGgnKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC40XG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJQYXRoXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGVcbiAgICAvLyAgICBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90ICV4MkYgKFwiL1wiKTpcbiAgICBsZXQgY29va2llUGF0aCA9ICcnXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy8nKSB7XG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGRlZmF1bHQtcGF0aC5cbiAgICAgIGNvb2tpZVBhdGggPSAnLydcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyAxLiBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICAgIGNvb2tpZVBhdGggPSBhdHRyaWJ1dGVWYWx1ZVxuICAgIH1cblxuICAgIC8vIDIuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgUGF0aCBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mIGNvb2tpZS1wYXRoLlxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QucGF0aCA9IGNvb2tpZVBhdGhcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnc2VjdXJlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNVxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiU2VjdXJlXCIsXG4gICAgLy8gdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3RcbiAgICAvLyB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIFNlY3VyZSBhbmQgYW4gZW1wdHkgYXR0cmlidXRlLXZhbHVlLlxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zZWN1cmUgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2h0dHBvbmx5Jykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNlxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJIdHRwT25seVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1cbiAgICAvLyBhdHRyaWJ1dGUtbGlzdCB3aXRoIGFuIGF0dHJpYnV0ZS1uYW1lIG9mIEh0dHBPbmx5IGFuZCBhbiBlbXB0eVxuICAgIC8vIGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuaHR0cE9ubHkgPSB0cnVlXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NhbWVzaXRlJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuN1xuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gICAgLy8gXCJTYW1lU2l0ZVwiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzOlxuXG4gICAgLy8gMS4gTGV0IGVuZm9yY2VtZW50IGJlIFwiRGVmYXVsdFwiLlxuICAgIGxldCBlbmZvcmNlbWVudCA9ICdEZWZhdWx0J1xuXG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UgPSBhdHRyaWJ1dGVWYWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgLy8gMi4gSWYgY29va2llLWF2J3MgYXR0cmlidXRlLXZhbHVlIGlzIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3JcbiAgICAvLyAgICBcIk5vbmVcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTm9uZVwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbm9uZScpKSB7XG4gICAgICBlbmZvcmNlbWVudCA9ICdOb25lJ1xuICAgIH1cblxuICAgIC8vIDMuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJTdHJpY3RcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiU3RyaWN0XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdzdHJpY3QnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnU3RyaWN0J1xuICAgIH1cblxuICAgIC8vIDQuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJMYXhcIiwgc2V0IGVuZm9yY2VtZW50IHRvIFwiTGF4XCIuXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlLmluY2x1ZGVzKCdsYXgnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTGF4J1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgXCJTYW1lU2l0ZVwiIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2ZcbiAgICAvLyAgICBlbmZvcmNlbWVudC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnNhbWVTaXRlID0gZW5mb3JjZW1lbnRcbiAgfSBlbHNlIHtcbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnVucGFyc2VkID8/PSBbXVxuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZC5wdXNoKGAke2F0dHJpYnV0ZU5hbWV9PSR7YXR0cmlidXRlVmFsdWV9YClcbiAgfVxuXG4gIC8vIDguIFJldHVybiB0byBTdGVwIDEgb2YgdGhpcyBhbGdvcml0aG0uXG4gIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVNldENvb2tpZSxcbiAgcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction isCTLExcludingHtab (value) {\n  for (let i = 0; i < value.length; ++i) {\n    const code = value.charCodeAt(i)\n\n    if (\n      (code >= 0x00 && code <= 0x08) ||\n      (code >= 0x0A && code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (let i = 0; i < name.length; ++i) {\n    const code = name.charCodeAt(i)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31), SP and HT\n      code > 0x7E || // exclude non-ascii and DEL\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x3C || // <\n      code === 0x3E || // >\n      code === 0x40 || // @\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x3A || // :\n      code === 0x5C || // \\\n      code === 0x2F || // /\n      code === 0x5B || // [\n      code === 0x5D || // ]\n      code === 0x3F || // ?\n      code === 0x3D || // =\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  let len = value.length\n  let i = 0\n\n  // if the value is wrapped in DQUOTE\n  if (value[0] === '\"') {\n    if (len === 1 || value[len - 1] !== '\"') {\n      throw new Error('Invalid cookie value')\n    }\n    --len\n    ++i\n  }\n\n  while (i < len) {\n    const code = value.charCodeAt(i++)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code > 0x7E || // non-ascii and DEL (127)\n      code === 0x22 || // \"\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x5C // \\\n    ) {\n      throw new Error('Invalid cookie value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (let i = 0; i < path.length; ++i) {\n    const code = path.charCodeAt(i)\n\n    if (\n      code < 0x20 || // exclude CTLs (0-31)\n      code === 0x7F || // DEL\n      code === 0x3B // ;\n    ) {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\nconst IMFDays = [\n  'Sun', 'Mon', 'Tue', 'Wed',\n  'Thu', 'Fri', 'Sat'\n]\n\nconst IMFMonths = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  validateCookieName,\n  validateCookiePath,\n  validateCookieValue,\n  toIMFDate,\n  stringify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKLElBQUk7O0FBRUosOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwwQkFBMEIsSUFBSSxxQ0FBcUMsRUFBRSwrQkFBK0IsRUFBRSx1QkFBdUIsRUFBRSxxQ0FBcUMsR0FBRyx1Q0FBdUMsR0FBRyx3Q0FBd0M7QUFDclE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWSxHQUFHLGFBQWE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVcsR0FBRyxnQkFBZ0I7QUFDOUM7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNvb2tpZXNcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDVExFeGNsdWRpbmdIdGFiICh2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIChjb2RlID49IDB4MDAgJiYgY29kZSA8PSAweDA4KSB8fFxuICAgICAgKGNvZGUgPj0gMHgwQSAmJiBjb2RlIDw9IDB4MUYpIHx8XG4gICAgICBjb2RlID09PSAweDdGXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gQ0hBUiAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNoYXJhY3RlciAob2N0ZXRzIDAgLSAxMjcpPlxuIHRva2VuICAgICAgICAgID0gMSo8YW55IENIQVIgZXhjZXB0IENUTHMgb3Igc2VwYXJhdG9ycz5cbiBzZXBhcmF0b3JzICAgICA9IFwiKFwiIHwgXCIpXCIgfCBcIjxcIiB8IFwiPlwiIHwgXCJAXCJcbiAgICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAgICAgICAgICAgICAgICB8IFwiL1wiIHwgXCJbXCIgfCBcIl1cIiB8IFwiP1wiIHwgXCI9XCJcbiAgICAgICAgICAgICAgICB8IFwie1wiIHwgXCJ9XCIgfCBTUCB8IEhUXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU5hbWUgKG5hbWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IG5hbWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKSwgU1AgYW5kIEhUXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBleGNsdWRlIG5vbi1hc2NpaSBhbmQgREVMXG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgzQyB8fCAvLyA8XG4gICAgICBjb2RlID09PSAweDNFIHx8IC8vID5cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHg1QyB8fCAvLyBcXFxuICAgICAgY29kZSA9PT0gMHgyRiB8fCAvLyAvXG4gICAgICBjb2RlID09PSAweDVCIHx8IC8vIFtcbiAgICAgIGNvZGUgPT09IDB4NUQgfHwgLy8gXVxuICAgICAgY29kZSA9PT0gMHgzRiB8fCAvLyA/XG4gICAgICBjb2RlID09PSAweDNEIHx8IC8vID1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIG5hbWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiBjb29raWUtdmFsdWUgICAgICA9ICpjb29raWUtb2N0ZXQgLyAoIERRVU9URSAqY29va2llLW9jdGV0IERRVU9URSApXG4gY29va2llLW9jdGV0ICAgICAgPSAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgICAgICAgICAgICA7IFVTLUFTQ0lJIGNoYXJhY3RlcnMgZXhjbHVkaW5nIENUTHMsXG4gICAgICAgICAgICAgICAgICAgICAgIDsgd2hpdGVzcGFjZSBEUVVPVEUsIGNvbW1hLCBzZW1pY29sb24sXG4gICAgICAgICAgICAgICAgICAgICAgIDsgYW5kIGJhY2tzbGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llVmFsdWUgKHZhbHVlKSB7XG4gIGxldCBsZW4gPSB2YWx1ZS5sZW5ndGhcbiAgbGV0IGkgPSAwXG5cbiAgLy8gaWYgdGhlIHZhbHVlIGlzIHdyYXBwZWQgaW4gRFFVT1RFXG4gIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgIGlmIChsZW4gPT09IDEgfHwgdmFsdWVbbGVuIC0gMV0gIT09ICdcIicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgICAtLWxlblxuICAgICsraVxuICB9XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKyspXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMSB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID4gMHg3RSB8fCAvLyBub24tYXNjaWkgYW5kIERFTCAoMTI3KVxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4NUMgLy8gXFxcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgdmFsdWUnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHBhdGgtdmFsdWUgICAgICAgID0gPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIFwiO1wiPlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVQYXRoIChwYXRoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIwIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSlcbiAgICAgIGNvZGUgPT09IDB4N0YgfHwgLy8gREVMXG4gICAgICBjb2RlID09PSAweDNCIC8vIDtcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgcGF0aCcpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSSBoYXZlIG5vIGlkZWEgd2h5IHRoZXNlIHZhbHVlcyBhcmVuJ3QgYWxsb3dlZCB0byBiZSBob25lc3QsXG4gKiBidXQgRGVubyB0ZXN0cyB0aGVzZS4gLSBLaGFmcmFcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVEb21haW4gKGRvbWFpbikge1xuICBpZiAoXG4gICAgZG9tYWluLnN0YXJ0c1dpdGgoJy0nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLicpIHx8XG4gICAgZG9tYWluLmVuZHNXaXRoKCctJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBkb21haW4nKVxuICB9XG59XG5cbmNvbnN0IElNRkRheXMgPSBbXG4gICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLFxuICAnVGh1JywgJ0ZyaScsICdTYXQnXG5dXG5cbmNvbnN0IElNRk1vbnRocyA9IFtcbiAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ1xuXVxuXG5jb25zdCBJTUZQYWRkZWROdW1iZXJzID0gQXJyYXkoNjEpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMxI3NlY3Rpb24tNy4xLjEuMVxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGF0ZVxuICBJTUYtZml4ZGF0ZSAgPSBkYXktbmFtZSBcIixcIiBTUCBkYXRlMSBTUCB0aW1lLW9mLWRheSBTUCBHTVRcbiAgOyBmaXhlZCBsZW5ndGgvem9uZS9jYXBpdGFsaXphdGlvbiBzdWJzZXQgb2YgdGhlIGZvcm1hdFxuICA7IHNlZSBTZWN0aW9uIDMuMyBvZiBbUkZDNTMyMl1cblxuICBkYXktbmFtZSAgICAgPSAleDRELjZGLjZFIDsgXCJNb25cIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0Ljc1LjY1IDsgXCJUdWVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU3LjY1LjY0IDsgXCJXZWRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDU0LjY4Ljc1IDsgXCJUaHVcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDQ2LjcyLjY5IDsgXCJGcmlcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjYxLjc0IDsgXCJTYXRcIiwgY2FzZS1zZW5zaXRpdmVcbiAgICAgICAgICAgICAgLyAleDUzLjc1LjZFIDsgXCJTdW5cIiwgY2FzZS1zZW5zaXRpdmVcbiAgZGF0ZTEgICAgICAgID0gZGF5IFNQIG1vbnRoIFNQIHllYXJcbiAgICAgICAgICAgICAgICAgIDsgZS5nLiwgMDIgSnVuIDE5ODJcblxuICBkYXkgICAgICAgICAgPSAyRElHSVRcbiAgbW9udGggICAgICAgID0gJXg0QS42MS42RSA7IFwiSmFuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni42NS42MiA7IFwiRmViXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43MiA7IFwiTWFyXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43MC43MiA7IFwiQXByXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RC42MS43OSA7IFwiTWF5XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42RSA7IFwiSnVuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0QS43NS42QyA7IFwiSnVsXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0MS43NS42NyA7IFwiQXVnXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42NS43MCA7IFwiU2VwXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ri42My43NCA7IFwiT2N0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0RS42Ri43NiA7IFwiTm92XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0NC42NS42MyA7IFwiRGVjXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIHllYXIgICAgICAgICA9IDRESUdJVFxuXG4gIEdNVCAgICAgICAgICA9ICV4NDcuNEQuNTQgOyBcIkdNVFwiLCBjYXNlLXNlbnNpdGl2ZVxuXG4gIHRpbWUtb2YtZGF5ICA9IGhvdXIgXCI6XCIgbWludXRlIFwiOlwiIHNlY29uZFxuICAgICAgICAgICAgICA7IDAwOjAwOjAwIC0gMjM6NTk6NjAgKGxlYXAgc2Vjb25kKVxuXG4gIGhvdXIgICAgICAgICA9IDJESUdJVFxuICBtaW51dGUgICAgICAgPSAyRElHSVRcbiAgc2Vjb25kICAgICAgID0gMkRJR0lUXG4gKi9cbmZ1bmN0aW9uIHRvSU1GRGF0ZSAoZGF0ZSkge1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdudW1iZXInKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gIH1cblxuICByZXR1cm4gYCR7SU1GRGF5c1tkYXRlLmdldFVUQ0RheSgpXX0sICR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ0RhdGUoKV19ICR7SU1GTW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV19ICR7ZGF0ZS5nZXRVVENGdWxsWWVhcigpfSAke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENIb3VycygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDTWludXRlcygpXX06JHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDU2Vjb25kcygpXX0gR01UYFxufVxuXG4vKipcbiBtYXgtYWdlLWF2ICAgICAgICA9IFwiTWF4LUFnZT1cIiBub24temVyby1kaWdpdCAqRElHSVRcbiAgICAgICAgICAgICAgICAgICAgICAgOyBJbiBwcmFjdGljZSwgYm90aCBleHBpcmVzLWF2IGFuZCBtYXgtYWdlLWF2XG4gICAgICAgICAgICAgICAgICAgICAgIDsgYXJlIGxpbWl0ZWQgdG8gZGF0ZXMgcmVwcmVzZW50YWJsZSBieSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgOyB1c2VyIGFnZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1heEFnZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZU1heEFnZSAobWF4QWdlKSB7XG4gIGlmIChtYXhBZ2UgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBtYXgtYWdlJylcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzYyNjUjc2VjdGlvbi00LjEuMVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db29raWV9IGNvb2tpZVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKGNvb2tpZSkge1xuICBpZiAoY29va2llLm5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhbGlkYXRlQ29va2llTmFtZShjb29raWUubmFtZSlcbiAgdmFsaWRhdGVDb29raWVWYWx1ZShjb29raWUudmFsdWUpXG5cbiAgY29uc3Qgb3V0ID0gW2Ake2Nvb2tpZS5uYW1lfT0ke2Nvb2tpZS52YWx1ZX1gXVxuXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLWNvb2tpZS1wcmVmaXhlcy0wMCNzZWN0aW9uLTMuMVxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjJcbiAgaWYgKGNvb2tpZS5uYW1lLnN0YXJ0c1dpdGgoJ19fU2VjdXJlLScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgfVxuXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX0hvc3QtJykpIHtcbiAgICBjb29raWUuc2VjdXJlID0gdHJ1ZVxuICAgIGNvb2tpZS5kb21haW4gPSBudWxsXG4gICAgY29va2llLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmIChjb29raWUuc2VjdXJlKSB7XG4gICAgb3V0LnB1c2goJ1NlY3VyZScpXG4gIH1cblxuICBpZiAoY29va2llLmh0dHBPbmx5KSB7XG4gICAgb3V0LnB1c2goJ0h0dHBPbmx5JylcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29va2llLm1heEFnZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZU1heEFnZShjb29raWUubWF4QWdlKVxuICAgIG91dC5wdXNoKGBNYXgtQWdlPSR7Y29va2llLm1heEFnZX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICB2YWxpZGF0ZUNvb2tpZURvbWFpbihjb29raWUuZG9tYWluKVxuICAgIG91dC5wdXNoKGBEb21haW49JHtjb29raWUuZG9tYWlufWApXG4gIH1cblxuICBpZiAoY29va2llLnBhdGgpIHtcbiAgICB2YWxpZGF0ZUNvb2tpZVBhdGgoY29va2llLnBhdGgpXG4gICAgb3V0LnB1c2goYFBhdGg9JHtjb29raWUucGF0aH1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5leHBpcmVzICYmIGNvb2tpZS5leHBpcmVzLnRvU3RyaW5nKCkgIT09ICdJbnZhbGlkIERhdGUnKSB7XG4gICAgb3V0LnB1c2goYEV4cGlyZXM9JHt0b0lNRkRhdGUoY29va2llLmV4cGlyZXMpfWApXG4gIH1cblxuICBpZiAoY29va2llLnNhbWVTaXRlKSB7XG4gICAgb3V0LnB1c2goYFNhbWVTaXRlPSR7Y29va2llLnNhbWVTaXRlfWApXG4gIH1cblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgY29va2llLnVucGFyc2VkKSB7XG4gICAgaWYgKCFwYXJ0LmluY2x1ZGVzKCc9JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bnBhcnNlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgW2tleSwgLi4udmFsdWVdID0gcGFydC5zcGxpdCgnPScpXG5cbiAgICBvdXQucHVzaChgJHtrZXkudHJpbSgpfT0ke3ZhbHVlLmpvaW4oJz0nKX1gKVxuICB9XG5cbiAgcmV0dXJuIG91dC5qb2luKCc7ICcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0NUTEV4Y2x1ZGluZ0h0YWIsXG4gIHZhbGlkYXRlQ29va2llTmFtZSxcbiAgdmFsaWRhdGVDb29raWVQYXRoLFxuICB2YWxpZGF0ZUNvb2tpZVZhbHVlLFxuICB0b0lNRkRhdGUsXG4gIHN0cmluZ2lmeVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\")\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state = null\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsdUVBQVE7O0FBRTlEO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsVUFBVTtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZXZlbnRzb3VyY2VcXGV2ZW50c291cmNlLXN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGlzQVNDSUlOdW1iZXIsIGlzVmFsaWRMYXN0RXZlbnRJZCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyW119IEJPTVxuICovXG5jb25zdCBCT00gPSBbMHhFRiwgMHhCQiwgMHhCRl1cbi8qKlxuICogQHR5cGUgezEwfSBMRlxuICovXG5jb25zdCBMRiA9IDB4MEFcbi8qKlxuICogQHR5cGUgezEzfSBDUlxuICovXG5jb25zdCBDUiA9IDB4MERcbi8qKlxuICogQHR5cGUgezU4fSBDT0xPTlxuICovXG5jb25zdCBDT0xPTiA9IDB4M0Fcbi8qKlxuICogQHR5cGUgezMyfSBTUEFDRVxuICovXG5jb25zdCBTUEFDRSA9IDB4MjBcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudF0gVGhlIGV2ZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RhdGFdIFRoZSBkYXRhIG9mIHRoZSBtZXNzYWdlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gQSB1bmlxdWUgSUQgZm9yIHRoZSBldmVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmV0cnldIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgZXZlbnRTb3VyY2VTZXR0aW5nc1xuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYXN0RXZlbnRJZCBUaGUgbGFzdCBldmVudCBJRCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWNvbm5lY3Rpb25UaW1lIFRoZSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cbmNsYXNzIEV2ZW50U291cmNlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgc3RhdGUgPSBudWxsXG5cbiAgLyoqXG4gICAqIExlYWRpbmcgYnl0ZS1vcmRlci1tYXJrIGNoZWNrLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNoZWNrQk9NID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGNybGZDaGVjayA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZXZlbnRFbmRDaGVjayA9IGZhbHNlXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAqL1xuICBidWZmZXIgPSBudWxsXG5cbiAgcG9zID0gMFxuXG4gIGV2ZW50ID0ge1xuICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICBldmVudDogdW5kZWZpbmVkLFxuICAgIGlkOiB1bmRlZmluZWQsXG4gICAgcmV0cnk6IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7ZXZlbnRTb3VyY2VTZXR0aW5nc30gb3B0aW9ucy5ldmVudFNvdXJjZVNldHRpbmdzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnB1c2hdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gRW5hYmxlIG9iamVjdCBtb2RlIGFzIEV2ZW50U291cmNlU3RyZWFtIGVtaXRzIG9iamVjdHMgb2Ygc2hhcGVcbiAgICAvLyBFdmVudFNvdXJjZVN0cmVhbUV2ZW50XG4gICAgb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgPSB0cnVlXG5cbiAgICBzdXBlcihvcHRpb25zKVxuXG4gICAgdGhpcy5zdGF0ZSA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTZXR0aW5ncyB8fCB7fVxuICAgIGlmIChvcHRpb25zLnB1c2gpIHtcbiAgICAgIHRoaXMucHVzaCA9IG9wdGlvbnMucHVzaFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9lbmNvZGluZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF90cmFuc2Zvcm0gKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgdGhlIGNodW5rIGluIHRoZSBidWZmZXIsIGFzIHRoZSBkYXRhIG1pZ2h0IG5vdCBiZSBjb21wbGV0ZSB3aGlsZVxuICAgIC8vIHByb2Nlc3NpbmcgaXRcbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gaGFuZGxlXG4gICAgLy8gaW5jb21pbmcgY2h1bmtzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjYzMFxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZmZlciwgY2h1bmtdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IGNodW5rXG4gICAgfVxuXG4gICAgLy8gU3RyaXAgbGVhZGluZyBieXRlLW9yZGVyLW1hcmsgaWYgd2Ugb3BlbmVkIHRoZSBzdHJlYW0gYW5kIHN0YXJ0ZWRcbiAgICAvLyB0aGUgcHJvY2Vzc2luZyBvZiB0aGUgaW5jb21pbmcgZGF0YVxuICAgIGlmICh0aGlzLmNoZWNrQk9NKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGJ5dGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcywgd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcblxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgb25seSBjb250YWlucyBvbmUgYnl0ZSBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0d28gYnl0ZXMgYXJlIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCB0d28gYnl0ZXNcbiAgICAgICAgICAvLyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhLCBiZWNhdXNlIHRoZSB0aGlyZCBieXRlXG4gICAgICAgICAgICAvLyBpcyBuZWVkZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHRoZSBCT00gb3Igbm90XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IHRocmVlIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdGhyZWVcbiAgICAgICAgICAvLyBieXRlcyBvZiB0aGUgQk9NXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMV0gPT09IEJPTVsxXSAmJlxuICAgICAgICAgICAgdGhpcy5idWZmZXJbMl0gPT09IEJPTVsyXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIGNhbiBkcm9wIHRoZSBidWZmZXJlZCBkYXRhLCBhcyBpdCBpcyBvbmx5IHRoZSBCT01cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgICAvLyBCT00gYW55bW9yZVxuICAgICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAgIC8vIEF3YWl0IG1vcmUgZGF0YVxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGl0IGlzIG5vdCB0aGUgQk9NLCB3ZSBjYW4gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZGF0YVxuICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBsb25nZXIgdGhhbiAzIGJ5dGVzLCBzbyB3ZSBjYW4gZHJvcCB0aGUgQk9NIGlmIGl0IGlzXG4gICAgICAgICAgLy8gcHJlc2VudFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgQk9NIGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSgzKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aGUgY2hlY2tCT00gZmxhZyB0byBmYWxzZSBhcyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciB0aGVcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGxpbmUgZW5kZWQgd2l0aCBhbiBlbmQtb2YtbGluZSwgd2UgbmVlZCB0byBjaGVja1xuICAgICAgLy8gaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFsc28gYW4gZW5kLW9mLWxpbmUuXG4gICAgICBpZiAodGhpcy5ldmVudEVuZENoZWNrKSB7XG4gICAgICAgIC8vIElmIHRoZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYW4gZW5kLW9mLWxpbmUsIHRoZW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIGlzIGZpbmlzaGVkIGFuZCB3ZSBjYW4gcHJvY2VzcyBpdFxuXG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkIGFuZCByZW1vdmUgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyLlxuICAgICAgICBpZiAodGhpcy5jcmxmQ2hlY2spIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQsIHdlIGNhbiByZW1vdmUgaXRcbiAgICAgICAgICAvLyBmcm9tIHRoZSBidWZmZXIgYW5kIHJlc2V0IHRoZSBjcmxmQ2hlY2sgZmxhZ1xuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBsaW5lIGZlZWQgaXMgbm90IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAvLyBldmVudC4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW5cbiAgICAgICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlciB0byBkZXRlcm1pbmUgaWYgdGhlIGV2ZW50IGlzXG4gICAgICAgICAgICAvLyBmaW5pc2hlZC4gV2Ugc2ltcGx5IGNvbnRpbnVlIHRoZSBsb29wIHRvIGNoZWNrIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXIuXG5cbiAgICAgICAgICAgIC8vIEFzIHdlIHJlbW92ZWQgdGhlIGxpbmUgZmVlZCBmcm9tIHRoZSBidWZmZXIgYW5kIHNldCB0aGVcbiAgICAgICAgICAgIC8vIGNybGZDaGVjayBmbGFnIHRvIGZhbHNlLCB3ZSBiYXNpY2FsbHkgZG9uJ3QgbWFrZSBhbnlcbiAgICAgICAgICAgIC8vIGRpc3RpbmN0aW9uIGJldHdlZW4gYSBsaW5lIGZlZWQgYW5kIGEgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gTEYgfHwgdGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBDUikge1xuICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNhcnJpYWdlIHJldHVybiwgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgICAvLyBuZXh0IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGZyb20gdGhlXG4gICAgICAgICAgLy8gYnVmZmVyXG4gICAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgKyAxKVxuICAgICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZXZlbnQuZXZlbnQgfHwgdGhpcy5ldmVudC5pZCB8fCB0aGlzLmV2ZW50LnJldHJ5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFdmVudCh0aGlzLmV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNsZWFyRXZlbnQoKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIG5vdCBhbiBlbmQtb2YtbGluZSwgdGhlbiB0aGUgZXZlbnRcbiAgICAgICAgLy8gaXMgbm90IGZpbmlzaGVkIGFuZCB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBldmVudEVuZENoZWNrIGZsYWdcbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gZmFsc2VcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB3ZSBjYW4gcHJvY2VzcyB0aGVcbiAgICAgIC8vIGxpbmVcbiAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHNldCB0aGUgY3JsZkNoZWNrIGZsYWcgdG8gdHJ1ZSwgYXMgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWRcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCB3ZSBjYW4gcHJvY2VzcyB0aGUgbGluZSBhcyB3ZSByZWFjaGVkIGFuXG4gICAgICAgIC8vIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICB0aGlzLnBhcnNlTGluZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvcyksIHRoaXMuZXZlbnQpXG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBhcyB3ZSByZW1vdmVkIHRoZSBwcm9jZXNzZWQgbGluZSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgdGhpcy5wb3MgPSAwXG4gICAgICAgIC8vIEEgbGluZSB3YXMgcHJvY2Vzc2VkIGFuZCB0aGlzIGNvdWxkIGJlIHRoZSBlbmQgb2YgdGhlIGV2ZW50LiBXZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGxpbmUgaXMgZW1wdHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAvLyBmaW5pc2hlZC5cbiAgICAgICAgdGhpcy5ldmVudEVuZENoZWNrID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcysrXG4gICAgfVxuXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBsaW5lXG4gICAqIEBwYXJhbSB7RXZlbnRTdHJlYW1FdmVudH0gZXZlbnRcbiAgICovXG4gIHBhcnNlTGluZSAobGluZSwgZXZlbnQpIHtcbiAgICAvLyBJZiB0aGUgbGluZSBpcyBlbXB0eSAoYSBibGFuayBsaW5lKVxuICAgIC8vIERpc3BhdGNoIHRoZSBldmVudCwgYXMgZGVmaW5lZCBiZWxvdy5cbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgX3RyYW5zZm9ybSBtZXRob2RcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICAvLyBJZ25vcmUgdGhlIGxpbmUuXG4gICAgY29uc3QgY29sb25Qb3NpdGlvbiA9IGxpbmUuaW5kZXhPZihDT0xPTilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gJydcbiAgICBsZXQgdmFsdWUgPSAnJ1xuXG4gICAgLy8gSWYgdGhlIGxpbmUgY29udGFpbnMgYSBVKzAwM0EgQ09MT04gY2hhcmFjdGVyICg6KVxuICAgIGlmIChjb2xvblBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgLy8gQ29sbGVjdCB0aGUgY2hhcmFjdGVycyBvbiB0aGUgbGluZSBiZWZvcmUgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCBmaWVsZCBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHRoZXJlIGlzIGEgbW9yZSBwZXJmb3JtYW50IHdheSB0byBleHRyYWN0IHRoZVxuICAgICAgLy8gZmllbGRcbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICAgIGZpZWxkID0gbGluZS5zdWJhcnJheSgwLCBjb2xvblBvc2l0aW9uKS50b1N0cmluZygndXRmOCcpXG5cbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYWZ0ZXIgdGhlIGZpcnN0IFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KSwgYW5kIGxldCB2YWx1ZSBiZSB0aGF0IHN0cmluZy5cbiAgICAgIC8vIElmIHZhbHVlIHN0YXJ0cyB3aXRoIGEgVSswMDIwIFNQQUNFIGNoYXJhY3RlciwgcmVtb3ZlIGl0IGZyb20gdmFsdWUuXG4gICAgICBsZXQgdmFsdWVTdGFydCA9IGNvbG9uUG9zaXRpb24gKyAxXG4gICAgICBpZiAobGluZVt2YWx1ZVN0YXJ0XSA9PT0gU1BBQ0UpIHtcbiAgICAgICAgKyt2YWx1ZVN0YXJ0XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIHZhbHVlXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICB2YWx1ZSA9IGxpbmUuc3ViYXJyYXkodmFsdWVTdGFydCkudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzdHJpbmcgaXMgbm90IGVtcHR5IGJ1dCBkb2VzIG5vdCBjb250YWluIGEgVSswMDNBIENPTE9OXG4gICAgICAvLyBjaGFyYWN0ZXIgKDopXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhlIGZpZWxkIHVzaW5nIHRoZSBzdGVwcyBkZXNjcmliZWQgYmVsb3csIHVzaW5nIHRoZSB3aG9sZVxuICAgICAgLy8gbGluZSBhcyB0aGUgZmllbGQgbmFtZSwgYW5kIHRoZSBlbXB0eSBzdHJpbmcgYXMgdGhlIGZpZWxkIHZhbHVlLlxuICAgICAgZmllbGQgPSBsaW5lLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgIHZhbHVlID0gJydcbiAgICB9XG5cbiAgICAvLyBNb2RpZnkgdGhlIGV2ZW50IHdpdGggdGhlIGZpZWxkIG5hbWUgYW5kIHZhbHVlLiBUaGUgdmFsdWUgaXMgYWxzb1xuICAgIC8vIGRlY29kZWQgYXMgVVRGLThcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgaWYgKGV2ZW50W2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gKz0gYFxcbiR7dmFsdWV9YFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdyZXRyeSc6XG4gICAgICAgIGlmIChpc0FTQ0lJTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2lkJzpcbiAgICAgICAgaWYgKGlzVmFsaWRMYXN0RXZlbnRJZCh2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50U291cmNlU3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRXZlbnQgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJldHJ5ICYmIGlzQVNDSUlOdW1iZXIoZXZlbnQucmV0cnkpKSB7XG4gICAgICB0aGlzLnN0YXRlLnJlY29ubmVjdGlvblRpbWUgPSBwYXJzZUludChldmVudC5yZXRyeSwgMTApXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmlkICYmIGlzVmFsaWRMYXN0RXZlbnRJZChldmVudC5pZCkpIHtcbiAgICAgIHRoaXMuc3RhdGUubGFzdEV2ZW50SWQgPSBldmVudC5pZFxuICAgIH1cblxuICAgIC8vIG9ubHkgZGlzcGF0Y2ggZXZlbnQsIHdoZW4gZGF0YSBpcyBwcm92aWRlZFxuICAgIGlmIChldmVudC5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGV2ZW50LmV2ZW50IHx8ICdtZXNzYWdlJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgbGFzdEV2ZW50SWQ6IHRoaXMuc3RhdGUubGFzdEV2ZW50SWQsXG4gICAgICAgICAgb3JpZ2luOiB0aGlzLnN0YXRlLm9yaWdpblxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyRXZlbnQgKCkge1xuICAgIHRoaXMuZXZlbnQgPSB7XG4gICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEV2ZW50U291cmNlU3RyZWFtXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(ssr)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\")\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { delay } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/eventsource/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @enum\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url = null\n  #withCredentials = false\n\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: defaultReconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {0|1|2}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (isNetworkError(response)) {\n        this.dispatchEvent(new Event('error'))\n        this.close()\n      }\n\n      this.#reconnect()\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */\n  async #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    await delay(this.#state.reconnectionTime)\n\n    // 5. Queue a task to run the following steps:\n\n    //   1. If the EventSource object's readyState attribute is not set to\n    //      CONNECTING, then return.\n    if (this.#readyState !== CONNECTING) return\n\n    //   2. Let request be the EventSource object's request.\n    //   3. If the EventSource object's last event ID string is not the empty\n    //      string, then:\n    //      1. Let lastEventIDValue be the EventSource object's last event ID\n    //         string, encoded as UTF-8.\n    //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n    //         list.\n    if (this.#state.lastEventId.length) {\n      this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n    }\n\n    //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n    this.#connect()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ3ZDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsNEVBQWlCO0FBQzVDLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDNUQsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hFLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDdEQsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUTtBQUNsQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsNENBQTRDOztBQUV4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxldmVudHNvdXJjZVxcZXZlbnRzb3VyY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgZmV0Y2hpbmcgfSA9IHJlcXVpcmUoJy4uL2ZldGNoJylcbmNvbnN0IHsgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IEV2ZW50U291cmNlU3RyZWFtIH0gPSByZXF1aXJlKCcuL2V2ZW50c291cmNlLXN0cmVhbScpXG5jb25zdCB7IHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi4vd2Vic29ja2V0L2V2ZW50cycpXG5jb25zdCB7IGlzTmV0d29ya0Vycm9yIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXNwb25zZScpXG5jb25zdCB7IGRlbGF5IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxubGV0IGV4cGVyaW1lbnRhbFdhcm5lZCA9IGZhbHNlXG5cbi8qKlxuICogQSByZWNvbm5lY3Rpb24gdGltZSwgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIG11c3QgaW5pdGlhbGx5IGJlIGFuIGltcGxlbWVudGF0aW9uLWRlZmluZWQgdmFsdWUsXG4gKiBwcm9iYWJseSBpbiB0aGUgcmVnaW9uIG9mIGEgZmV3IHNlY29uZHMuXG4gKlxuICogSW4gQ29tcGFyaXNvbjpcbiAqIC0gQ2hyb21lIHVzZXMgMzAwMG1zLlxuICogLSBEZW5vIHVzZXMgNTAwMG1zLlxuICpcbiAqIEB0eXBlIHszMDAwfVxuICovXG5jb25zdCBkZWZhdWx0UmVjb25uZWN0aW9uVGltZSA9IDMwMDBcblxuLyoqXG4gKiBUaGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gKiBAZW51bVxuICogQHJlYWRvbmx5XG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI2RvbS1ldmVudHNvdXJjZS1yZWFkeXN0YXRlLWRldlxuICovXG5cbi8qKlxuICogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCB5ZXQgYmVlbiBlc3RhYmxpc2hlZCwgb3IgaXQgd2FzIGNsb3NlZCBhbmQgdGhlIHVzZXJcbiAqIGFnZW50IGlzIHJlY29ubmVjdGluZy5cbiAqIEB0eXBlIHswfVxuICovXG5jb25zdCBDT05ORUNUSU5HID0gMFxuXG4vKipcbiAqIFRoZSB1c2VyIGFnZW50IGhhcyBhbiBvcGVuIGNvbm5lY3Rpb24gYW5kIGlzIGRpc3BhdGNoaW5nIGV2ZW50cyBhcyBpdFxuICogcmVjZWl2ZXMgdGhlbS5cbiAqIEB0eXBlIHsxfVxuICovXG5jb25zdCBPUEVOID0gMVxuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIGlzIG5vdCBvcGVuLCBhbmQgdGhlIHVzZXIgYWdlbnQgaXMgbm90IHRyeWluZyB0byByZWNvbm5lY3QuXG4gKiBAdHlwZSB7Mn1cbiAqL1xuY29uc3QgQ0xPU0VEID0gMlxuXG4vKipcbiAqIFJlcXVlc3RzIGZvciB0aGUgZWxlbWVudCB3aWxsIGhhdmUgdGhlaXIgbW9kZSBzZXQgdG8gXCJjb3JzXCIgYW5kIHRoZWlyIGNyZWRlbnRpYWxzIG1vZGUgc2V0IHRvIFwic2FtZS1vcmlnaW5cIi5cbiAqIEB0eXBlIHsnYW5vbnltb3VzJ31cbiAqL1xuY29uc3QgQU5PTllNT1VTID0gJ2Fub255bW91cydcblxuLyoqXG4gKiBSZXF1ZXN0cyBmb3IgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wiIGFuZCB0aGVpciBjcmVkZW50aWFscyBtb2RlIHNldCB0byBcImluY2x1ZGVcIi5cbiAqIEB0eXBlIHsndXNlLWNyZWRlbnRpYWxzJ31cbiAqL1xuY29uc3QgVVNFX0NSRURFTlRJQUxTID0gJ3VzZS1jcmVkZW50aWFscydcblxuLyoqXG4gKiBUaGUgRXZlbnRTb3VyY2UgaW50ZXJmYWNlIGlzIHVzZWQgdG8gcmVjZWl2ZSBzZXJ2ZXItc2VudCBldmVudHMuIEl0XG4gKiBjb25uZWN0cyB0byBhIHNlcnZlciBvdmVyIEhUVFAgYW5kIHJlY2VpdmVzIGV2ZW50cyBpbiB0ZXh0L2V2ZW50LXN0cmVhbVxuICogZm9ybWF0IHdpdGhvdXQgY2xvc2luZyB0aGUgY29ubmVjdGlvbi5cbiAqIEBleHRlbmRzIHtFdmVudFRhcmdldH1cbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc2VydmVyLXNlbnQtZXZlbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBFdmVudFNvdXJjZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgI2V2ZW50cyA9IHtcbiAgICBvcGVuOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIG1lc3NhZ2U6IG51bGxcbiAgfVxuXG4gICN1cmwgPSBudWxsXG4gICN3aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuXG4gICNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICNyZXF1ZXN0ID0gbnVsbFxuICAjY29udHJvbGxlciA9IG51bGxcblxuICAjZGlzcGF0Y2hlclxuXG4gIC8qKlxuICAgKiBAdHlwZSB7aW1wb3J0KCcuL2V2ZW50c291cmNlLXN0cmVhbScpLmV2ZW50U291cmNlU2V0dGluZ3N9XG4gICAqL1xuICAjc3RhdGVcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZUluaXR9IFtldmVudFNvdXJjZUluaXREaWN0XVxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3RoZS1ldmVudHNvdXJjZS1pbnRlcmZhY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIGV2ZW50U291cmNlSW5pdERpY3QgPSB7fSkge1xuICAgIC8vIDEuIExldCBldiBiZSBhIG5ldyBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgc3VwZXIoKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0V2ZW50U291cmNlIGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgaWYgKCFleHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICAgIGV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ0V2ZW50U291cmNlIGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgICAgY29kZTogJ1VORElDSS1FUydcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybCwgcHJlZml4LCAndXJsJylcbiAgICBldmVudFNvdXJjZUluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdChldmVudFNvdXJjZUluaXREaWN0LCBwcmVmaXgsICdldmVudFNvdXJjZUluaXREaWN0JylcblxuICAgIHRoaXMuI2Rpc3BhdGNoZXIgPSBldmVudFNvdXJjZUluaXREaWN0LmRpc3BhdGNoZXJcbiAgICB0aGlzLiNzdGF0ZSA9IHtcbiAgICAgIGxhc3RFdmVudElkOiAnJyxcbiAgICAgIHJlY29ubmVjdGlvblRpbWU6IGRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHNldHRpbmdzIGJlIGV2J3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0LlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNlbnZpcm9ubWVudC1zZXR0aW5ncy1vYmplY3RcbiAgICBjb25zdCBzZXR0aW5ncyA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3RcblxuICAgIGxldCB1cmxSZWNvcmRcblxuICAgIHRyeSB7XG4gICAgICAvLyAzLiBMZXQgdXJsUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgZW5jb2RpbmctcGFyc2luZyBhIFVSTCBnaXZlbiB1cmwsIHJlbGF0aXZlIHRvIHNldHRpbmdzLlxuICAgICAgdXJsUmVjb3JkID0gbmV3IFVSTCh1cmwsIHNldHRpbmdzLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpXG4gICAgICB0aGlzLiNzdGF0ZS5vcmlnaW4gPSB1cmxSZWNvcmQub3JpZ2luXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gNC4gSWYgdXJsUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihlLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDUuIFNldCBldidzIHVybCB0byB1cmxSZWNvcmQuXG4gICAgdGhpcy4jdXJsID0gdXJsUmVjb3JkLmhyZWZcblxuICAgIC8vIDYuIExldCBjb3JzQXR0cmlidXRlU3RhdGUgYmUgQW5vbnltb3VzLlxuICAgIGxldCBjb3JzQXR0cmlidXRlU3RhdGUgPSBBTk9OWU1PVVNcblxuICAgIC8vIDcuIElmIHRoZSB2YWx1ZSBvZiBldmVudFNvdXJjZUluaXREaWN0J3Mgd2l0aENyZWRlbnRpYWxzIG1lbWJlciBpcyB0cnVlLFxuICAgIC8vIHRoZW4gc2V0IGNvcnNBdHRyaWJ1dGVTdGF0ZSB0byBVc2UgQ3JlZGVudGlhbHMgYW5kIHNldCBldidzXG4gICAgLy8gd2l0aENyZWRlbnRpYWxzIGF0dHJpYnV0ZSB0byB0cnVlLlxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0LndpdGhDcmVkZW50aWFscykge1xuICAgICAgY29yc0F0dHJpYnV0ZVN0YXRlID0gVVNFX0NSRURFTlRJQUxTXG4gICAgICB0aGlzLiN3aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gOC4gTGV0IHJlcXVlc3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIHBvdGVudGlhbC1DT1JTIHJlcXVlc3QgZ2l2ZW5cbiAgICAvLyB1cmxSZWNvcmQsIHRoZSBlbXB0eSBzdHJpbmcsIGFuZCBjb3JzQXR0cmlidXRlU3RhdGUuXG4gICAgY29uc3QgaW5pdFJlcXVlc3QgPSB7XG4gICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICBrZWVwYWxpdmU6IHRydWUsXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3VybHMtYW5kLWZldGNoaW5nLmh0bWwjY29ycy1zZXR0aW5ncy1hdHRyaWJ1dGVzXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBjcmVkZW50aWFsczogY29yc0F0dHJpYnV0ZVN0YXRlID09PSAnYW5vbnltb3VzJ1xuICAgICAgICA/ICdzYW1lLW9yaWdpbidcbiAgICAgICAgOiAnb21pdCcsXG4gICAgICByZWZlcnJlcjogJ25vLXJlZmVycmVyJ1xuICAgIH1cblxuICAgIC8vIDkuIFNldCByZXF1ZXN0J3MgY2xpZW50IHRvIHNldHRpbmdzLlxuICAgIGluaXRSZXF1ZXN0LmNsaWVudCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3RcblxuICAgIC8vIDEwLiBVc2VyIGFnZW50cyBtYXkgc2V0IChgQWNjZXB0YCwgYHRleHQvZXZlbnQtc3RyZWFtYCkgaW4gcmVxdWVzdCdzIGhlYWRlciBsaXN0LlxuICAgIGluaXRSZXF1ZXN0LmhlYWRlcnNMaXN0ID0gW1snYWNjZXB0JywgeyBuYW1lOiAnYWNjZXB0JywgdmFsdWU6ICd0ZXh0L2V2ZW50LXN0cmVhbScgfV1dXG5cbiAgICAvLyAxMS4gU2V0IHJlcXVlc3QncyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgICBpbml0UmVxdWVzdC5jYWNoZSA9ICduby1zdG9yZSdcblxuICAgIC8vIDEyLiBTZXQgcmVxdWVzdCdzIGluaXRpYXRvciB0eXBlIHRvIFwib3RoZXJcIi5cbiAgICBpbml0UmVxdWVzdC5pbml0aWF0b3IgPSAnb3RoZXInXG5cbiAgICBpbml0UmVxdWVzdC51cmxMaXN0ID0gW25ldyBVUkwodGhpcy4jdXJsKV1cblxuICAgIC8vIDEzLiBTZXQgZXYncyByZXF1ZXN0IHRvIHJlcXVlc3QuXG4gICAgdGhpcy4jcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KGluaXRSZXF1ZXN0KVxuXG4gICAgdGhpcy4jY29ubmVjdCgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhpcyBFdmVudFNvdXJjZSBvYmplY3QncyBjb25uZWN0aW9uLiBJdCBjYW4gaGF2ZSB0aGVcbiAgICogdmFsdWVzIGRlc2NyaWJlZCBiZWxvdy5cbiAgICogQHJldHVybnMgezB8MXwyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZHlTdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFVSTCBwcm92aWRpbmcgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsICgpIHtcbiAgICByZXR1cm4gdGhpcy4jdXJsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBFdmVudFNvdXJjZSBvYmplY3Qgd2FzXG4gICAqIGluc3RhbnRpYXRlZCB3aXRoIENPUlMgY3JlZGVudGlhbHMgc2V0ICh0cnVlKSwgb3Igbm90IChmYWxzZSwgdGhlIGRlZmF1bHQpLlxuICAgKi9cbiAgZ2V0IHdpdGhDcmVkZW50aWFscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3dpdGhDcmVkZW50aWFsc1xuICB9XG5cbiAgI2Nvbm5lY3QgKCkge1xuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSBDTE9TRUQpIHJldHVyblxuXG4gICAgdGhpcy4jcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcblxuICAgIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgICAgcmVxdWVzdDogdGhpcy4jcmVxdWVzdCxcbiAgICAgIGRpc3BhdGNoZXI6IHRoaXMuI2Rpc3BhdGNoZXJcbiAgICB9XG5cbiAgICAvLyAxNC4gTGV0IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keSBnaXZlbiByZXNwb25zZSByZXMgYmUgdGhlIGZvbGxvd2luZyBzdGVwOiBpZiByZXMgaXMgbm90IGEgbmV0d29yayBlcnJvciwgdGhlbiByZWVzdGFibGlzaCB0aGUgY29ubmVjdGlvbi5cbiAgICBjb25zdCBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3JlY29ubmVjdCgpXG4gICAgfVxuXG4gICAgLy8gMTUuIEZldGNoIHJlcXVlc3QsIHdpdGggcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5IHNldCB0byBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHkuLi5cbiAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSBwcm9jZXNzRXZlbnRTb3VyY2VFbmRPZkJvZHlcblxuICAgIC8vIGFuZCBwcm9jZXNzUmVzcG9uc2Ugc2V0IHRvIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ2l2ZW4gcmVzcG9uc2UgcmVzOlxuICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgLy8gMS4gSWYgcmVzIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuXG4gICAgICBpZiAoaXNOZXR3b3JrRXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICAgIC8vIDEuIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIGZhaWwgdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50XG4gICAgICAgIC8vIG11c3QgcXVldWUgYSB0YXNrIHdoaWNoLCBpZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIGFcbiAgICAgICAgLy8gdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUQsIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIENMT1NFRFxuICAgICAgICAvLyBhbmQgZmlyZXMgYW4gZXZlbnQgbmFtZWQgZXJyb3IgYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC4gT25jZSB0aGVcbiAgICAgICAgLy8gdXNlciBhZ2VudCBoYXMgZmFpbGVkIHRoZSBjb25uZWN0aW9uLCBpdCBkb2VzIG5vdCBhdHRlbXB0IHRvXG4gICAgICAgIC8vIHJlY29ubmVjdC5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgcmVzIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiByZWVzdGFibGlzaCB0aGVcbiAgICAgICAgICAvLyBjb25uZWN0aW9uLCB1bmxlc3MgdGhlIHVzZXIgYWdlbnQga25vd3MgdGhhdCB0byBiZSBmdXRpbGUsIGluXG4gICAgICAgICAgLy8gd2hpY2ggY2FzZSB0aGUgdXNlciBhZ2VudCBtYXkgZmFpbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNyZWNvbm5lY3QoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgcmVzJ3Mgc3RhdHVzIGlzIG5vdCAyMDAsIG9yIGlmIHJlcydzIGBDb250ZW50LVR5cGVgXG4gICAgICAvLyBpcyBub3QgYHRleHQvZXZlbnQtc3RyZWFtYCwgdGhlbiBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ2NvbnRlbnQtdHlwZScsIHRydWUpXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IGNvbnRlbnRUeXBlICE9PSBudWxsID8gcGFyc2VNSU1FVHlwZShjb250ZW50VHlwZSkgOiAnZmFpbHVyZSdcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlVmFsaWQgPSBtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlLmVzc2VuY2UgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbSdcbiAgICAgIGlmIChcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAyMDAgfHxcbiAgICAgICAgY29udGVudFR5cGVWYWxpZCA9PT0gZmFsc2VcbiAgICAgICkge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYW5ub3VuY2UgdGhlIGNvbm5lY3Rpb24gYW5kIGludGVycHJldCByZXMncyBib2R5XG4gICAgICAvLyBsaW5lIGJ5IGxpbmUuXG5cbiAgICAgIC8vIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIGFubm91bmNlIHRoZSBjb25uZWN0aW9uLCB0aGUgdXNlciBhZ2VudFxuICAgICAgLy8gbXVzdCBxdWV1ZSBhIHRhc2sgd2hpY2gsIGlmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYVxuICAgICAgLy8gdmFsdWUgb3RoZXIgdGhhbiBDTE9TRUQsIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvIE9QRU5cbiAgICAgIC8vIGFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBvcGVuIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NzZS1wcm9jZXNzaW5nLW1vZGVsXG4gICAgICB0aGlzLiNyZWFkeVN0YXRlID0gT1BFTlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKVxuXG4gICAgICAvLyBJZiByZWRpcmVjdGVkIHRvIGEgZGlmZmVyZW50IG9yaWdpbiwgc2V0IHRoZSBvcmlnaW4gdG8gdGhlIG5ldyBvcmlnaW4uXG4gICAgICB0aGlzLiNzdGF0ZS5vcmlnaW4gPSByZXNwb25zZS51cmxMaXN0W3Jlc3BvbnNlLnVybExpc3QubGVuZ3RoIC0gMV0ub3JpZ2luXG5cbiAgICAgIGNvbnN0IGV2ZW50U291cmNlU3RyZWFtID0gbmV3IEV2ZW50U291cmNlU3RyZWFtKHtcbiAgICAgICAgZXZlbnRTb3VyY2VTZXR0aW5nczogdGhpcy4jc3RhdGUsXG4gICAgICAgIHB1c2g6IChldmVudCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVGYXN0TWVzc2FnZUV2ZW50KFxuICAgICAgICAgICAgZXZlbnQudHlwZSxcbiAgICAgICAgICAgIGV2ZW50Lm9wdGlvbnNcbiAgICAgICAgICApKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBwaXBlbGluZShyZXNwb25zZS5ib2R5LnN0cmVhbSxcbiAgICAgICAgZXZlbnRTb3VyY2VTdHJlYW0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVycm9yPy5hYm9ydGVkID09PSBmYWxzZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNjb250cm9sbGVyID0gZmV0Y2hpbmcoZmV0Y2hQYXJhbXMpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNzc2UtcHJvY2Vzc2luZy1tb2RlbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jICNyZWNvbm5lY3QgKCkge1xuICAgIC8vIFdoZW4gYSB1c2VyIGFnZW50IGlzIHRvIHJlZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uLCB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgLy8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHMuIFRoZXNlIHN0ZXBzIGFyZSBydW4gaW4gcGFyYWxsZWwsIG5vdCBhcyBwYXJ0IG9mXG4gICAgLy8gYSB0YXNrLiAoVGhlIHRhc2tzIHRoYXQgaXQgcXVldWVzLCBvZiBjb3Vyc2UsIGFyZSBydW4gbGlrZSBub3JtYWwgdGFza3NcbiAgICAvLyBhbmQgbm90IHRoZW1zZWx2ZXMgaW4gcGFyYWxsZWwuKVxuXG4gICAgLy8gMS4gUXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuXG4gICAgLy8gICAxLiBJZiB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgc2V0IHRvIENMT1NFRCwgYWJvcnQgdGhlIHRhc2suXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG5cbiAgICAvLyAgIDIuIFNldCB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ09OTkVDVElORy5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICAgLy8gICAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIGVycm9yIGF0IHRoZSBFdmVudFNvdXJjZSBvYmplY3QuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSlcblxuICAgIC8vIDIuIFdhaXQgYSBkZWxheSBlcXVhbCB0byB0aGUgcmVjb25uZWN0aW9uIHRpbWUgb2YgdGhlIGV2ZW50IHNvdXJjZS5cbiAgICBhd2FpdCBkZWxheSh0aGlzLiNzdGF0ZS5yZWNvbm5lY3Rpb25UaW1lKVxuXG4gICAgLy8gNS4gUXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuXG4gICAgLy8gICAxLiBJZiB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgaXMgbm90IHNldCB0b1xuICAgIC8vICAgICAgQ09OTkVDVElORywgdGhlbiByZXR1cm4uXG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgIT09IENPTk5FQ1RJTkcpIHJldHVyblxuXG4gICAgLy8gICAyLiBMZXQgcmVxdWVzdCBiZSB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgcmVxdWVzdC5cbiAgICAvLyAgIDMuIElmIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyBsYXN0IGV2ZW50IElEIHN0cmluZyBpcyBub3QgdGhlIGVtcHR5XG4gICAgLy8gICAgICBzdHJpbmcsIHRoZW46XG4gICAgLy8gICAgICAxLiBMZXQgbGFzdEV2ZW50SURWYWx1ZSBiZSB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0J3MgbGFzdCBldmVudCBJRFxuICAgIC8vICAgICAgICAgc3RyaW5nLCBlbmNvZGVkIGFzIFVURi04LlxuICAgIC8vICAgICAgMi4gU2V0IChgTGFzdC1FdmVudC1JRGAsIGxhc3RFdmVudElEVmFsdWUpIGluIHJlcXVlc3QncyBoZWFkZXJcbiAgICAvLyAgICAgICAgIGxpc3QuXG4gICAgaWYgKHRoaXMuI3N0YXRlLmxhc3RFdmVudElkLmxlbmd0aCkge1xuICAgICAgdGhpcy4jcmVxdWVzdC5oZWFkZXJzTGlzdC5zZXQoJ2xhc3QtZXZlbnQtaWQnLCB0aGlzLiNzdGF0ZS5sYXN0RXZlbnRJZCwgdHJ1ZSlcbiAgICB9XG5cbiAgICAvLyAgIDQuIEZldGNoIHJlcXVlc3QgYW5kIHByb2Nlc3MgdGhlIHJlc3BvbnNlIG9idGFpbmVkIGluIHRoaXMgZmFzaGlvbiwgaWYgYW55LCBhcyBkZXNjcmliZWQgZWFybGllciBpbiB0aGlzIHNlY3Rpb24uXG4gICAgdGhpcy4jY29ubmVjdCgpXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLCBpZiBhbnksIGFuZCBzZXRzIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0b1xuICAgKiBDTE9TRUQuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXZlbnRTb3VyY2UpXG5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ0xPU0VEXG4gICAgdGhpcy4jY29udHJvbGxlci5hYm9ydCgpXG4gICAgdGhpcy4jcmVxdWVzdCA9IG51bGxcbiAgfVxuXG4gIGdldCBvbm9wZW4gKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMub3BlblxuICB9XG5cbiAgc2V0IG9ub3BlbiAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm9wZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuI2V2ZW50cy5vcGVuKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25tZXNzYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm1lc3NhZ2VcbiAgfVxuXG4gIHNldCBvbm1lc3NhZ2UgKGZuKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50cy5tZXNzYWdlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLiNldmVudHMubWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMuZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIGlmICh0aGlzLiNldmVudHMuZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLiNldmVudHMuZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBDT05ORUNUSU5HOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ09OTkVDVElORyxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1BFTjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IE9QRU4sXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIENMT1NFRDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IENMT1NFRCxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZSwgY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycylcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLnByb3RvdHlwZSwgY29uc3RhbnRzUHJvcGVydHlEZXNjcmlwdG9ycylcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UucHJvdG90eXBlLCB7XG4gIGNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ub3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB3aXRoQ3JlZGVudGlhbHM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkV2ZW50U291cmNlSW5pdERpY3QgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICd3aXRoQ3JlZGVudGlhbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJywgLy8gdW5kaWNpIG9ubHlcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRXZlbnRTb3VyY2UsXG4gIGRlZmF1bHRSZWNvbm5lY3Rpb25UaW1lXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidLastEventId (value) {\n  // LastEventId should not contain U+0000 NULL\n  return value.indexOf('\\u0000') === -1\n}\n\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isASCIINumber (value) {\n  if (value.length === 0) return false\n  for (let i = 0; i < value.length; i++) {\n    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false\n  }\n  return true\n}\n\n// https://github.com/nodejs/undici/issues/2664\nfunction delay (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms).unref()\n  })\n}\n\nmodule.exports = {\n  isValidLastEventId,\n  isASCIINumber,\n  delay\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZXZlbnRzb3VyY2VcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIExhc3RFdmVudElkLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZExhc3RFdmVudElkICh2YWx1ZSkge1xuICAvLyBMYXN0RXZlbnRJZCBzaG91bGQgbm90IGNvbnRhaW4gVSswMDAwIE5VTExcbiAgcmV0dXJuIHZhbHVlLmluZGV4T2YoJ1xcdTAwMDAnKSA9PT0gLTFcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgYmFzZSAxMCBkaWdpdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUlOdW1iZXIgKHZhbHVlKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoaSkgPCAweDMwIHx8IHZhbHVlLmNoYXJDb2RlQXQoaSkgPiAweDM5KSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjY2NFxuZnVuY3Rpb24gZGVsYXkgKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpLnVucmVmKClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzVmFsaWRMYXN0RXZlbnRJZCxcbiAgaXNBU0NJSU51bWJlcixcbiAgZGVsYXlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isErrored } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\")\n\nconst textEncoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    const chunk = textEncoder.encode(`--${boundary}--`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(this)\n\n        // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 2. If that fails for some reason, then throw a TypeError.\n              if (parsed === 'failure') {\n                throw new TypeError('Failed to parse body as FormData.')\n              }\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              fd[kState] = parsed\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in this’s relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function consumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object[kState].body)) {\n    throw new TypeError('Body is unusable: Body has already been read')\n  }\n\n  throwIfAborted(object[kState])\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (body) {\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse[kState].headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDekMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQy9DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx3Q0FBaUI7QUFDbkQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQ25ELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyx1RkFBbUI7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3RELDhDQUE4QztBQUM5QyxJQUFJO0FB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGJvZHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQmxvYkxpa2UsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGV4dHJhY3RNaW1lVHlwZSxcbiAgdXRmOERlY29kZUJ5dGVzXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzRXJyb3JlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEtcGFyc2VyJylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5aW5pdC1leHRyYWN0XG5mdW5jdGlvbiBleHRyYWN0Qm9keSAob2JqZWN0LCBrZWVwYWxpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgc3RyZWFtIGJlIG51bGwuXG4gIGxldCBzdHJlYW0gPSBudWxsXG5cbiAgLy8gMi4gSWYgb2JqZWN0IGlzIGEgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCB0aGVuIHNldCBzdHJlYW0gdG8gb2JqZWN0LlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICBzdHJlYW0gPSBvYmplY3RcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyAzLiBPdGhlcndpc2UsIGlmIG9iamVjdCBpcyBhIEJsb2Igb2JqZWN0LCBzZXQgc3RyZWFtIHRvIHRoZVxuICAgIC8vICAgIHJlc3VsdCBvZiBydW5uaW5nIG9iamVjdOKAmXMgZ2V0IHN0cmVhbS5cbiAgICBzdHJlYW0gPSBvYmplY3Quc3RyZWFtKClcbiAgfSBlbHNlIHtcbiAgICAvLyA0LiBPdGhlcndpc2UsIHNldCBzdHJlYW0gdG8gYSBuZXcgUmVhZGFibGVTdHJlYW0gb2JqZWN0LCBhbmQgc2V0XG4gICAgLy8gICAgdXAgc3RyZWFtIHdpdGggYnl0ZSByZWFkaW5nIHN1cHBvcnQuXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB0ZXh0RW5jb2Rlci5lbmNvZGUoc291cmNlKSA6IHNvdXJjZVxuXG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiByZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIpKVxuICAgICAgfSxcbiAgICAgIHN0YXJ0ICgpIHt9LFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pXG4gIH1cblxuICAvLyA1LiBBc3NlcnQ6IHN0cmVhbSBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdC5cbiAgYXNzZXJ0KGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkpXG5cbiAgLy8gNi4gTGV0IGFjdGlvbiBiZSBudWxsLlxuICBsZXQgYWN0aW9uID0gbnVsbFxuXG4gIC8vIDcuIExldCBzb3VyY2UgYmUgbnVsbC5cbiAgbGV0IHNvdXJjZSA9IG51bGxcblxuICAvLyA4LiBMZXQgbGVuZ3RoIGJlIG51bGwuXG4gIGxldCBsZW5ndGggPSBudWxsXG5cbiAgLy8gOS4gTGV0IHR5cGUgYmUgbnVsbC5cbiAgbGV0IHR5cGUgPSBudWxsXG5cbiAgLy8gMTAuIFN3aXRjaCBvbiBvYmplY3Q6XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNldCBzb3VyY2UgdG8gdGhlIFVURi04IGVuY29kaW5nIG9mIG9iamVjdC5cbiAgICAvLyBOb3RlOiBzZXR0aW5nIHNvdXJjZSB0byBhIFVpbnQ4QXJyYXkgaGVyZSBicmVha3Mgc29tZSBtb2NraW5nIGFzc3VtcHRpb25zLlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgLy8gU2V0IHR5cGUgdG8gYHRleHQvcGxhaW47Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVVJMU2VhcmNoUGFyYW1zXG5cbiAgICAvLyBzcGVjIHNheXMgdG8gcnVuIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBvbiBib2R5Lmxpc3RcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGluIE5vZGUuanMgYXMgYXBhcnQgb2YgYW4gVVJMU2VhcmNoUGFyYW1zIGluc3RhbmNlIHRvU3RyaW5nIG1ldGhvZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0w0OTBcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZTQ2YzY4MGJmMmIyMTFiYmQ1MmNmOTU5Y2ExN2VlOThjN2Y2NTdmNS9saWIvaW50ZXJuYWwvdXJsLmpzI0wxMTAwXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIHNlcmlhbGl6ZXIgd2l0aCBvYmplY3TigJlzIGxpc3QuXG4gICAgc291cmNlID0gb2JqZWN0LnRvU3RyaW5nKClcblxuICAgIC8vIFNldCB0eXBlIHRvIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOGAuXG4gICAgdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCdcbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3Quc2xpY2UoKSlcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge1xuICAgIC8vIEJ1ZmZlclNvdXJjZS9BcnJheUJ1ZmZlclZpZXdcblxuICAgIC8vIFNldCBzb3VyY2UgdG8gYSBjb3B5IG9mIHRoZSBieXRlcyBoZWxkIGJ5IG9iamVjdC5cbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShvYmplY3QuYnVmZmVyLnNsaWNlKG9iamVjdC5ieXRlT2Zmc2V0LCBvYmplY3QuYnl0ZU9mZnNldCArIG9iamVjdC5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKG9iamVjdCkpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGAtLS0tZm9ybWRhdGEtdW5kaWNpLTAke2Ake01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTEpfWAucGFkU3RhcnQoMTEsICcwJyl9YFxuICAgIGNvbnN0IHByZWZpeCA9IGAtLSR7Ym91bmRhcnl9XFxyXFxuQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhYFxuXG4gICAgLyohIGZvcm1kYXRhLXBvbHlmaWxsLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL1xuICAgIGNvbnN0IGVzY2FwZSA9IChzdHIpID0+XG4gICAgICBzdHIucmVwbGFjZSgvXFxuL2csICclMEEnKS5yZXBsYWNlKC9cXHIvZywgJyUwRCcpLnJlcGxhY2UoL1wiL2csICclMjInKVxuICAgIGNvbnN0IG5vcm1hbGl6ZUxpbmVmZWVkcyA9ICh2YWx1ZSkgPT4gdmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJ1xcclxcbicpXG5cbiAgICAvLyBTZXQgYWN0aW9uIHRvIHRoaXMgc3RlcDogcnVuIHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhXG4gICAgLy8gZW5jb2RpbmcgYWxnb3JpdGhtLCB3aXRoIG9iamVjdOKAmXMgZW50cnkgbGlzdCBhbmQgVVRGLTguXG4gICAgLy8gLSBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgYm9keSBpcyBpbW11dGFibGUgYW5kIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXJ3b3Jkc1xuICAgIC8vIC0gVGhhdCB0aGUgY29udGVudC1sZW5ndGggaXMgY2FsY3VsYXRlZCBpbiBhZHZhbmNlLlxuICAgIC8vIC0gQW5kIHRoYXQgYWxsIHBhcnRzIGFyZSBwcmUtZW5jb2RlZCBhbmQgcmVhZHkgdG8gYmUgc2VudC5cblxuICAgIGNvbnN0IGJsb2JQYXJ0cyA9IFtdXG4gICAgY29uc3Qgcm4gPSBuZXcgVWludDhBcnJheShbMTMsIDEwXSkgLy8gJ1xcclxcbidcbiAgICBsZW5ndGggPSAwXG4gICAgbGV0IGhhc1Vua25vd25TaXplVmFsdWUgPSBmYWxzZVxuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIG9iamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUocHJlZml4ICtcbiAgICAgICAgICBgOyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgIGBcXHJcXG5cXHJcXG4ke25vcm1hbGl6ZUxpbmVmZWVkcyh2YWx1ZSl9XFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShgJHtwcmVmaXh9OyBuYW1lPVwiJHtlc2NhcGUobm9ybWFsaXplTGluZWZlZWRzKG5hbWUpKX1cImAgK1xuICAgICAgICAgICh2YWx1ZS5uYW1lID8gYDsgZmlsZW5hbWU9XCIke2VzY2FwZSh2YWx1ZS5uYW1lKX1cImAgOiAnJykgKyAnXFxyXFxuJyArXG4gICAgICAgICAgYENvbnRlbnQtVHlwZTogJHtcbiAgICAgICAgICAgIHZhbHVlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuYClcbiAgICAgICAgYmxvYlBhcnRzLnB1c2goY2h1bmssIHZhbHVlLCBybilcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGxlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoICsgdmFsdWUuc2l6ZSArIHJuLmJ5dGVMZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXNVbmtub3duU2l6ZVZhbHVlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLWApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWBcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdC1zYWZlbHktZXh0cmFjdFxuZnVuY3Rpb24gc2FmZWx5RXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChib2R5KSB7XG4gIC8vIFRvIGNsb25lIGEgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jbG9uZVxuXG4gIC8vIDEuIExldCDCqyBvdXQxLCBvdXQyIMK7IGJlIHRoZSByZXN1bHQgb2YgdGVlaW5nIGJvZHnigJlzIHN0cmVhbS5cbiAgY29uc3QgW291dDEsIG91dDJdID0gYm9keS5zdHJlYW0udGVlKClcblxuICAvLyAyLiBTZXQgYm9keeKAmXMgc3RyZWFtIHRvIG91dDEuXG4gIGJvZHkuc3RyZWFtID0gb3V0MVxuXG4gIC8vIDMuIFJldHVybiBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIG91dDIgYW5kIG90aGVyIG1lbWJlcnMgYXJlIGNvcGllZCBmcm9tIGJvZHkuXG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBvdXQyLFxuICAgIGxlbmd0aDogYm9keS5sZW5ndGgsXG4gICAgc291cmNlOiBib2R5LnNvdXJjZVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SWZBYm9ydGVkIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvZHlNaXhpbk1ldGhvZHMgKGluc3RhbmNlKSB7XG4gIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgYmxvYiAoKSB7XG4gICAgICAvLyBUaGUgYmxvYigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIEJsb2Igd2hvc2VcbiAgICAgIC8vIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgd2hvc2UgdHlwZSBhdHRyaWJ1dGUgaXMgdGhpc+KAmXNcbiAgICAgIC8vIE1JTUUgdHlwZS5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCAoYnl0ZXMpID0+IHtcbiAgICAgICAgbGV0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKHRoaXMpXG5cbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSAnJ1xuICAgICAgICB9IGVsc2UgaWYgKG1pbWVUeXBlKSB7XG4gICAgICAgICAgbWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGUobWltZVR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gYSBCbG9iIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcyBhbmQgdHlwZSBhdHRyaWJ1dGVcbiAgICAgICAgLy8gaXMgbWltZVR5cGUuXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYXJyYXlCdWZmZXIgKCkge1xuICAgICAgLy8gVGhlIGFycmF5QnVmZmVyKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdFxuICAgICAgLy8gb2YgcnVubmluZyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgIC8vIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyXG4gICAgICAvLyB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgdGV4dCAoKSB7XG4gICAgICAvLyBUaGUgdGV4dCgpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgICAgLy8gY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgVVRGLTggZGVjb2RlLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIHV0ZjhEZWNvZGVCeXRlcywgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGpzb24gKCkge1xuICAgICAgLy8gVGhlIGpzb24oKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHBhcnNlIEpTT04gZnJvbSBieXRlcy5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCBwYXJzZUpTT05Gcm9tQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBmb3JtRGF0YSAoKSB7XG4gICAgICAvLyBUaGUgZm9ybURhdGEoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcCBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6XG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIDEuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGdldCB0aGUgTUlNRSB0eXBlIHdpdGggdGhpcy5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBib2R5TWltZVR5cGUodGhpcylcblxuICAgICAgICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBub24tbnVsbCwgdGhlbiBzd2l0Y2ggb24gbWltZVR5cGXigJlzIGVzc2VuY2UgYW5kIHJ1blxuICAgICAgICAvLyAgICB0aGUgY29ycmVzcG9uZGluZyBzdGVwczpcbiAgICAgICAgaWYgKG1pbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChtaW1lVHlwZS5lc3NlbmNlKSB7XG4gICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzoge1xuICAgICAgICAgICAgICAvLyAxLiAuLi4gW2xvbmcgc3RlcF1cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIodmFsdWUsIG1pbWVUeXBlKVxuXG4gICAgICAgICAgICAgIC8vIDIuIElmIHRoYXQgZmFpbHMgZm9yIHNvbWUgcmVhc29uLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICAgICAgICBpZiAocGFyc2VkID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYm9keSBhcyBGb3JtRGF0YS4nKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMy4gUmV0dXJuIGEgbmV3IEZvcm1EYXRhIG9iamVjdCwgYXBwZW5kaW5nIGVhY2ggZW50cnksXG4gICAgICAgICAgICAgIC8vICAgIHJlc3VsdGluZyBmcm9tIHRoZSBwYXJzaW5nIG9wZXJhdGlvbiwgdG8gaXRzIGVudHJ5IGxpc3QuXG4gICAgICAgICAgICAgIGNvbnN0IGZkID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgICAgICAgZmRba1N0YXRlXSA9IHBhcnNlZFxuXG4gICAgICAgICAgICAgIHJldHVybiBmZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzoge1xuICAgICAgICAgICAgICAvLyAxLiBMZXQgZW50cmllcyBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYnl0ZXMuXG4gICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHZhbHVlLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgICAgICAgLy8gMi4gSWYgZW50cmllcyBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3Qgd2hvc2UgZW50cnkgbGlzdCBpcyBlbnRyaWVzLlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG5cbiAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBUaHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ29udGVudC1UeXBlIHdhcyBub3Qgb25lIG9mIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIG9yIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIuJ1xuICAgICAgICApXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgYnl0ZXMgKCkge1xuICAgICAgLy8gVGhlIGJ5dGVzKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIGNvbnN1bWUgYm9keVxuICAgICAgLy8gd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gdGhlXG4gICAgICAvLyByZXN1bHQgb2YgY3JlYXRpbmcgYSBVaW50OEFycmF5IGZyb20gYnl0ZXMgaW4gdGhpc+KAmXMgcmVsZXZhbnQgcmVhbG0uXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcylcbiAgICAgIH0sIGluc3RhbmNlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2RzXG59XG5cbmZ1bmN0aW9uIG1peGluQm9keSAocHJvdG90eXBlKSB7XG4gIE9iamVjdC5hc3NpZ24ocHJvdG90eXBlLnByb3RvdHlwZSwgYm9keU1peGluTWV0aG9kcyhwcm90b3R5cGUpKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqIEBwYXJhbSB7UmVzcG9uc2V8UmVxdWVzdH0gb2JqZWN0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdW5rbm93bn0gY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IGluc3RhbmNlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVCb2R5IChvYmplY3QsIGNvbnZlcnRCeXRlc1RvSlNWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgd2ViaWRsLmJyYW5kQ2hlY2sob2JqZWN0LCBpbnN0YW5jZSlcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgdW51c2FibGUsIHRoZW4gcmV0dXJuIGEgcHJvbWlzZSByZWplY3RlZFxuICAvLyAgICB3aXRoIGEgVHlwZUVycm9yLlxuICBpZiAoYm9keVVudXNhYmxlKG9iamVjdFtrU3RhdGVdLmJvZHkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBpcyB1bnVzYWJsZTogQm9keSBoYXMgYWxyZWFkeSBiZWVuIHJlYWQnKVxuICB9XG5cbiAgdGhyb3dJZkFib3J0ZWQob2JqZWN0W2tTdGF0ZV0pXG5cbiAgLy8gMi4gTGV0IHByb21pc2UgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgZ2l2ZW4gZXJyb3IgYmUgdG8gcmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IChlcnJvcikgPT4gcHJvbWlzZS5yZWplY3QoZXJyb3IpXG5cbiAgLy8gNC4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgZGF0YSBiZSB0byByZXNvbHZlXG4gIC8vICAgIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gIC8vICAgIHdpdGggZGF0YS4gSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHNcbiAgLy8gICAgd2l0aCB0aGF0IGV4Y2VwdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRCeXRlc1RvSlNWYWx1ZShkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN0ZXBzKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gNS4gSWYgb2JqZWN04oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHN1Y2Nlc3NTdGVwcyB3aXRoIGFuXG4gIC8vICAgIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIGlmIChvYmplY3Rba1N0YXRlXS5ib2R5ID09IG51bGwpIHtcbiAgICBzdWNjZXNzU3RlcHMoQnVmZmVyLmFsbG9jVW5zYWZlKDApKVxuICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgZnVsbHkgcmVhZCBvYmplY3TigJlzIGJvZHkgZ2l2ZW4gc3VjY2Vzc1N0ZXBzLFxuICAvLyAgICBlcnJvclN0ZXBzLCBhbmQgb2JqZWN04oCZcyByZWxldmFudCBnbG9iYWwgb2JqZWN0LlxuICBhd2FpdCBmdWxseVJlYWRCb2R5KG9iamVjdFtrU3RhdGVdLmJvZHksIHN1Y2Nlc3NTdGVwcywgZXJyb3JTdGVwcylcblxuICAvLyA3LiBSZXR1cm4gcHJvbWlzZS5cbiAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS11bnVzYWJsZVxuZnVuY3Rpb24gYm9keVVudXNhYmxlIChib2R5KSB7XG4gIC8vIEFuIG9iamVjdCBpbmNsdWRpbmcgdGhlIEJvZHkgaW50ZXJmYWNlIG1peGluIGlzXG4gIC8vIHNhaWQgdG8gYmUgdW51c2FibGUgaWYgaXRzIGJvZHkgaXMgbm9uLW51bGwgYW5kXG4gIC8vIGl0cyBib2R54oCZcyBzdHJlYW0gaXMgZGlzdHVyYmVkIG9yIGxvY2tlZC5cbiAgcmV0dXJuIGJvZHkgIT0gbnVsbCAmJiAoYm9keS5zdHJlYW0ubG9ja2VkIHx8IHV0aWwuaXNEaXN0dXJiZWQoYm9keS5zdHJlYW0pKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3BhcnNlLWpzb24tYnl0ZXMtdG8tYS1qYXZhc2NyaXB0LXZhbHVlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSlNPTkZyb21CeXRlcyAoYnl0ZXMpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodXRmOERlY29kZUJ5dGVzKGJ5dGVzKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9yZXNwb25zZScpLlJlc3BvbnNlfGltcG9ydCgnLi9yZXF1ZXN0JykuUmVxdWVzdH0gcmVxdWVzdE9yUmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYm9keU1pbWVUeXBlIChyZXF1ZXN0T3JSZXNwb25zZSkge1xuICAvLyAxLiBMZXQgaGVhZGVycyBiZSBudWxsLlxuICAvLyAyLiBJZiByZXF1ZXN0T3JSZXNwb25zZSBpcyBhIFJlcXVlc3Qgb2JqZWN0LCB0aGVuIHNldCBoZWFkZXJzIHRvIHJlcXVlc3RPclJlc3BvbnNl4oCZcyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBzZXQgaGVhZGVycyB0byByZXF1ZXN0T3JSZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvKiogQHR5cGUge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9ICovXG4gIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0T3JSZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0XG5cbiAgLy8gNC4gTGV0IG1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBhIE1JTUUgdHlwZSBmcm9tIGhlYWRlcnMuXG4gIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKGhlYWRlcnMpXG5cbiAgLy8gNS4gSWYgbWltZVR5cGUgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKG1pbWVUeXBlID09PSAnZmFpbHVyZScpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4dHJhY3RCb2R5LFxuICBzYWZlbHlFeHRyYWN0Qm9keSxcbiAgY2xvbmVCb2R5LFxuICBtaXhpbkJvZHlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst corsSafeListedMethods = ['GET', 'HEAD', 'POST']\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods)\n\nconst nullBodyStatus = [101, 204, 205, 304]\n\nconst redirectStatus = [301, 302, 303, 307, 308]\nconst redirectStatusSet = new Set(redirectStatus)\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '4190', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6679',\n  '6697', '10080'\n]\n\nconst badPortsSet = new Set(badPorts)\n\n// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\nconst referrerPolicy = [\n  '',\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n]\nconst referrerPolicySet = new Set(referrerPolicy)\n\nconst requestRedirect = ['follow', 'manual', 'error']\n\nconst safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']\nconst safeMethodsSet = new Set(safeMethods)\n\nconst requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']\n\nconst requestCredentials = ['omit', 'same-origin', 'include']\n\nconst requestCache = [\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n]\n\n// https://fetch.spec.whatwg.org/#request-body-header-name\nconst requestBodyHeader = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n]\n\n// https://fetch.spec.whatwg.org/#enumdef-requestduplex\nconst requestDuplex = [\n  'half'\n]\n\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']\nconst forbiddenMethodsSet = new Set(forbiddenMethods)\n\nconst subresource = [\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n]\nconst subresourceSet = new Set(subresource)\n\nmodule.exports = {\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex,\n  subresourceSet,\n  badPortsSet,\n  redirectStatusSet,\n  corsSafeListedMethodsSet,\n  safeMethodsSet,\n  forbiddenMethodsSet,\n  referrerPolicySet\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvcnNTYWZlTGlzdGVkTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnUE9TVCddXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQgPSBuZXcgU2V0KGNvcnNTYWZlTGlzdGVkTWV0aG9kcylcblxuY29uc3QgbnVsbEJvZHlTdGF0dXMgPSBbMTAxLCAyMDQsIDIwNSwgMzA0XVxuXG5jb25zdCByZWRpcmVjdFN0YXR1cyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cbmNvbnN0IHJlZGlyZWN0U3RhdHVzU2V0ID0gbmV3IFNldChyZWRpcmVjdFN0YXR1cylcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2Jsb2NrLWJhZC1wb3J0XG5jb25zdCBiYWRQb3J0cyA9IFtcbiAgJzEnLCAnNycsICc5JywgJzExJywgJzEzJywgJzE1JywgJzE3JywgJzE5JywgJzIwJywgJzIxJywgJzIyJywgJzIzJywgJzI1JywgJzM3JywgJzQyJywgJzQzJywgJzUzJywgJzY5JywgJzc3JywgJzc5JyxcbiAgJzg3JywgJzk1JywgJzEwMScsICcxMDInLCAnMTAzJywgJzEwNCcsICcxMDknLCAnMTEwJywgJzExMScsICcxMTMnLCAnMTE1JywgJzExNycsICcxMTknLCAnMTIzJywgJzEzNScsICcxMzcnLFxuICAnMTM5JywgJzE0MycsICcxNjEnLCAnMTc5JywgJzM4OScsICc0MjcnLCAnNDY1JywgJzUxMicsICc1MTMnLCAnNTE0JywgJzUxNScsICc1MjYnLCAnNTMwJywgJzUzMScsICc1MzInLFxuICAnNTQwJywgJzU0OCcsICc1NTQnLCAnNTU2JywgJzU2MycsICc1ODcnLCAnNjAxJywgJzYzNicsICc5ODknLCAnOTkwJywgJzk5MycsICc5OTUnLCAnMTcxOScsICcxNzIwJywgJzE3MjMnLFxuICAnMjA0OScsICczNjU5JywgJzQwNDUnLCAnNDE5MCcsICc1MDYwJywgJzUwNjEnLCAnNjAwMCcsICc2NTY2JywgJzY2NjUnLCAnNjY2NicsICc2NjY3JywgJzY2NjgnLCAnNjY2OScsICc2Njc5JyxcbiAgJzY2OTcnLCAnMTAwODAnXG5dXG5cbmNvbnN0IGJhZFBvcnRzU2V0ID0gbmV3IFNldChiYWRQb3J0cylcblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1yZWZlcnJlci1wb2xpY3kvI3JlZmVycmVyLXBvbGljaWVzXG5jb25zdCByZWZlcnJlclBvbGljeSA9IFtcbiAgJycsXG4gICduby1yZWZlcnJlcicsXG4gICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICdzYW1lLW9yaWdpbicsXG4gICdvcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbicsXG4gICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLFxuICAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICd1bnNhZmUtdXJsJ1xuXVxuY29uc3QgcmVmZXJyZXJQb2xpY3lTZXQgPSBuZXcgU2V0KHJlZmVycmVyUG9saWN5KVxuXG5jb25zdCByZXF1ZXN0UmVkaXJlY3QgPSBbJ2ZvbGxvdycsICdtYW51YWwnLCAnZXJyb3InXVxuXG5jb25zdCBzYWZlTWV0aG9kcyA9IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddXG5jb25zdCBzYWZlTWV0aG9kc1NldCA9IG5ldyBTZXQoc2FmZU1ldGhvZHMpXG5cbmNvbnN0IHJlcXVlc3RNb2RlID0gWyduYXZpZ2F0ZScsICdzYW1lLW9yaWdpbicsICduby1jb3JzJywgJ2NvcnMnXVxuXG5jb25zdCByZXF1ZXN0Q3JlZGVudGlhbHMgPSBbJ29taXQnLCAnc2FtZS1vcmlnaW4nLCAnaW5jbHVkZSddXG5cbmNvbnN0IHJlcXVlc3RDYWNoZSA9IFtcbiAgJ2RlZmF1bHQnLFxuICAnbm8tc3RvcmUnLFxuICAncmVsb2FkJyxcbiAgJ25vLWNhY2hlJyxcbiAgJ2ZvcmNlLWNhY2hlJyxcbiAgJ29ubHktaWYtY2FjaGVkJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1ib2R5LWhlYWRlci1uYW1lXG5jb25zdCByZXF1ZXN0Qm9keUhlYWRlciA9IFtcbiAgJ2NvbnRlbnQtZW5jb2RpbmcnLFxuICAnY29udGVudC1sYW5ndWFnZScsXG4gICdjb250ZW50LWxvY2F0aW9uJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAyMVxuICAvLyAnQ29udGVudC1MZW5ndGgnIGlzIGEgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCB3aGljaCBpcyB0eXBpY2FsbHlcbiAgLy8gcmVtb3ZlZCBpbiB0aGUgSGVhZGVycyBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdW5kaWNpIGRvZXNuJ3RcbiAgLy8gZmlsdGVyIG91dCBoZWFkZXJzLCBzbyB3ZSBhZGQgaXQgaGVyZS5cbiAgJ2NvbnRlbnQtbGVuZ3RoJ1xuXVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZW51bWRlZi1yZXF1ZXN0ZHVwbGV4XG5jb25zdCByZXF1ZXN0RHVwbGV4ID0gW1xuICAnaGFsZidcbl1cblxuLy8gaHR0cDovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZm9yYmlkZGVuLW1ldGhvZFxuY29uc3QgZm9yYmlkZGVuTWV0aG9kcyA9IFsnQ09OTkVDVCcsICdUUkFDRScsICdUUkFDSyddXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzU2V0ID0gbmV3IFNldChmb3JiaWRkZW5NZXRob2RzKVxuXG5jb25zdCBzdWJyZXNvdXJjZSA9IFtcbiAgJ2F1ZGlvJyxcbiAgJ2F1ZGlvd29ya2xldCcsXG4gICdmb250JyxcbiAgJ2ltYWdlJyxcbiAgJ21hbmlmZXN0JyxcbiAgJ3BhaW50d29ya2xldCcsXG4gICdzY3JpcHQnLFxuICAnc3R5bGUnLFxuICAndHJhY2snLFxuICAndmlkZW8nLFxuICAneHNsdCcsXG4gICcnXG5dXG5jb25zdCBzdWJyZXNvdXJjZVNldCA9IG5ldyBTZXQoc3VicmVzb3VyY2UpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdWJyZXNvdXJjZSxcbiAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVkaXJlY3RTdGF0dXMsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzLFxuICBiYWRQb3J0cyxcbiAgcmVxdWVzdER1cGxleCxcbiAgc3VicmVzb3VyY2VTZXQsXG4gIGJhZFBvcnRzU2V0LFxuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICBzYWZlTWV0aG9kc1NldCxcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgcmVmZXJyZXJQb2xpY3lTZXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  // 2. For each byte byte in input:\n  for (let i = 0; i < length; ++i) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')  // eslint-disable-line\n\n  let dataLength = data.length\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */\nfunction isASCIIWhitespace (char) {\n  // \"\\r\\n\\t\\f \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''; let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeType’s essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeType’s essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeChars,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLFNBQVMsR0FBRztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGRhdGEtdXJsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9UT0tFTl9DT0RFUE9JTlRTID0gL15bISMkJSYnKitcXC0uXl98fkEtWmEtejAtOV0rJC9cbmNvbnN0IEhUVFBfV0hJVEVTUEFDRV9SRUdFWCA9IC9bXFx1MDAwQVxcdTAwMERcXHUwMDA5XFx1MDAyMF0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNvbnN0IEFTQ0lJX1dISVRFU1BBQ0VfUkVQTEFDRV9SRUdFWCA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBDXFx1MDAwRFxcdTAwMjBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1xdW90ZWQtc3RyaW5nLXRva2VuLWNvZGUtcG9pbnRcbiAqL1xuY29uc3QgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUyA9IC9eW1xcdTAwMDlcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdKyQvIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXByb2Nlc3NvclxuLyoqIEBwYXJhbSB7VVJMfSBkYXRhVVJMICovXG5mdW5jdGlvbiBkYXRhVVJMUHJvY2Vzc29yIChkYXRhVVJMKSB7XG4gIC8vIDEuIEFzc2VydDogZGF0YVVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiLlxuICBhc3NlcnQoZGF0YVVSTC5wcm90b2NvbCA9PT0gJ2RhdGE6JylcblxuICAvLyAyLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBVUkxcbiAgLy8gc2VyaWFsaXplciBvbiBkYXRhVVJMIHdpdGggZXhjbHVkZSBmcmFnbWVudFxuICAvLyBzZXQgdG8gdHJ1ZS5cbiAgbGV0IGlucHV0ID0gVVJMU2VyaWFsaXplcihkYXRhVVJMLCB0cnVlKVxuXG4gIC8vIDMuIFJlbW92ZSB0aGUgbGVhZGluZyBcImRhdGE6XCIgc3RyaW5nIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gaW5wdXQuc2xpY2UoNSlcblxuICAvLyA0LiBMZXQgcG9zaXRpb24gcG9pbnQgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDUuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAvLyBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgZXF1YWxcbiAgLy8gdG8gVSswMDJDICgsKSwgZ2l2ZW4gcG9zaXRpb24uXG4gIGxldCBtaW1lVHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICcsJyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gNi4gU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZVxuICAvLyBmcm9tIG1pbWVUeXBlLlxuICAvLyBVbmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogd2UgbmVlZCB0byBzdG9yZSB0aGVcbiAgLy8gbGVuZ3RoIGJlY2F1c2UgaWYgdGhlIG1pbWV0eXBlIGhhcyBzcGFjZXMgcmVtb3ZlZCxcbiAgLy8gdGhlIHdyb25nIGFtb3VudCB3aWxsIGJlIHNsaWNlZCBmcm9tIHRoZSBpbnB1dCBpblxuICAvLyBzdGVwICM5XG4gIGNvbnN0IG1pbWVUeXBlTGVuZ3RoID0gbWltZVR5cGUubGVuZ3RoXG4gIG1pbWVUeXBlID0gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlKG1pbWVUeXBlLCB0cnVlLCB0cnVlKVxuXG4gIC8vIDcuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlblxuICAvLyByZXR1cm4gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gOC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gOS4gTGV0IGVuY29kZWRCb2R5IGJlIHRoZSByZW1haW5kZXIgb2YgaW5wdXQuXG4gIGNvbnN0IGVuY29kZWRCb2R5ID0gaW5wdXQuc2xpY2UobWltZVR5cGVMZW5ndGggKyAxKVxuXG4gIC8vIDEwLiBMZXQgYm9keSBiZSB0aGUgcGVyY2VudC1kZWNvZGluZyBvZiBlbmNvZGVkQm9keS5cbiAgbGV0IGJvZHkgPSBzdHJpbmdQZXJjZW50RGVjb2RlKGVuY29kZWRCb2R5KVxuXG4gIC8vIDExLiBJZiBtaW1lVHlwZSBlbmRzIHdpdGggVSswMDNCICg7KSwgZm9sbG93ZWQgYnlcbiAgLy8gemVybyBvciBtb3JlIFUrMDAyMCBTUEFDRSwgZm9sbG93ZWQgYnkgYW4gQVNDSUlcbiAgLy8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgXCJiYXNlNjRcIiwgdGhlbjpcbiAgaWYgKC87KFxcdTAwMjApezAsfWJhc2U2NCQvaS50ZXN0KG1pbWVUeXBlKSkge1xuICAgIC8vIDEuIExldCBzdHJpbmdCb2R5IGJlIHRoZSBpc29tb3JwaGljIGRlY29kZSBvZiBib2R5LlxuICAgIGNvbnN0IHN0cmluZ0JvZHkgPSBpc29tb3JwaGljRGVjb2RlKGJvZHkpXG5cbiAgICAvLyAyLiBTZXQgYm9keSB0byB0aGUgZm9yZ2l2aW5nLWJhc2U2NCBkZWNvZGUgb2ZcbiAgICAvLyBzdHJpbmdCb2R5LlxuICAgIGJvZHkgPSBmb3JnaXZpbmdCYXNlNjQoc3RyaW5nQm9keSlcblxuICAgIC8vIDMuIElmIGJvZHkgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoYm9keSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNC4gUmVtb3ZlIHRoZSBsYXN0IDYgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnNsaWNlKDAsIC02KVxuXG4gICAgLy8gNS4gUmVtb3ZlIHRyYWlsaW5nIFUrMDAyMCBTUEFDRSBjb2RlIHBvaW50cyBmcm9tIG1pbWVUeXBlLFxuICAgIC8vIGlmIGFueS5cbiAgICBtaW1lVHlwZSA9IG1pbWVUeXBlLnJlcGxhY2UoLyhcXHUwMDIwKSskLywgJycpXG5cbiAgICAvLyA2LiBSZW1vdmUgdGhlIGxhc3QgVSswMDNCICg7KSBjb2RlIHBvaW50IGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtMSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBtaW1lVHlwZSBzdGFydHMgd2l0aCBVKzAwM0IgKDspLCB0aGVuIHByZXBlbmRcbiAgLy8gXCJ0ZXh0L3BsYWluXCIgdG8gbWltZVR5cGUuXG4gIGlmIChtaW1lVHlwZS5zdGFydHNXaXRoKCc7JykpIHtcbiAgICBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJyArIG1pbWVUeXBlXG4gIH1cblxuICAvLyAxMy4gTGV0IG1pbWVUeXBlUmVjb3JkIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAvLyBtaW1lVHlwZS5cbiAgbGV0IG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZShtaW1lVHlwZSlcblxuICAvLyAxNC4gSWYgbWltZVR5cGVSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgLy8gbWltZVR5cGVSZWNvcmQgdG8gdGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJLlxuICBpZiAobWltZVR5cGVSZWNvcmQgPT09ICdmYWlsdXJlJykge1xuICAgIG1pbWVUeXBlUmVjb3JkID0gcGFyc2VNSU1FVHlwZSgndGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJJylcbiAgfVxuXG4gIC8vIDE1LiBSZXR1cm4gYSBuZXcgZGF0YTogVVJMIHN0cnVjdCB3aG9zZSBNSU1FXG4gIC8vIHR5cGUgaXMgbWltZVR5cGVSZWNvcmQgYW5kIGJvZHkgaXMgYm9keS5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RhdGEtdXJsLXN0cnVjdFxuICByZXR1cm4geyBtaW1lVHlwZTogbWltZVR5cGVSZWNvcmQsIGJvZHkgfVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtdXJsLXNlcmlhbGl6ZXJcbi8qKlxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtib29sZWFufSBleGNsdWRlRnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gVVJMU2VyaWFsaXplciAodXJsLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBpZiAoIWV4Y2x1ZGVGcmFnbWVudCkge1xuICAgIHJldHVybiB1cmwuaHJlZlxuICB9XG5cbiAgY29uc3QgaHJlZiA9IHVybC5ocmVmXG4gIGNvbnN0IGhhc2hMZW5ndGggPSB1cmwuaGFzaC5sZW5ndGhcblxuICBjb25zdCBzZXJpYWxpemVkID0gaGFzaExlbmd0aCA9PT0gMCA/IGhyZWYgOiBocmVmLnN1YnN0cmluZygwLCBocmVmLmxlbmd0aCAtIGhhc2hMZW5ndGgpXG5cbiAgaWYgKCFoYXNoTGVuZ3RoICYmIGhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgIHJldHVybiBzZXJpYWxpemVkLnNsaWNlKDAsIC0xKVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYS1zZXF1ZW5jZS1vZi1jb2RlLXBvaW50c1xuLyoqXG4gKiBAcGFyYW0geyhjaGFyOiBzdHJpbmcpID0+IGJvb2xlYW59IGNvbmRpdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICAvLyAxLiBMZXQgcmVzdWx0IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCByZXN1bHQgPSAnJ1xuXG4gIC8vIDIuIFdoaWxlIHBvc2l0aW9uIGRvZXNu4oCZdCBwb2ludCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQgYW5kIHRoZVxuICAvLyBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBtZWV0cyB0aGUgY29uZGl0aW9uIGNvbmRpdGlvbjpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoICYmIGNvbmRpdGlvbihpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0pKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoYXQgY29kZSBwb2ludCB0byB0aGUgZW5kIG9mIHJlc3VsdC5cbiAgICByZXN1bHQgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyAyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHJlc3VsdC5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEEgZmFzdGVyIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMgdGhhdCBvbmx5IHdvcmtzIHdoZW4gY29tcGFyaW5nIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IChjaGFyLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgY29uc3QgaWR4ID0gaW5wdXQuaW5kZXhPZihjaGFyLCBwb3NpdGlvbi5wb3NpdGlvbilcbiAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIGlmIChpZHggPT09IC0xKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gPSBpbnB1dC5sZW5ndGhcbiAgICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQpXG4gIH1cblxuICBwb3NpdGlvbi5wb3NpdGlvbiA9IGlkeFxuICByZXR1cm4gaW5wdXQuc2xpY2Uoc3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3N0cmluZy1wZXJjZW50LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gc3RyaW5nUGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gTGV0IGJ5dGVzIGJlIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBpbnB1dC5cbiAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZShpbnB1dClcblxuICAvLyAyLiBSZXR1cm4gdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgYnl0ZXMuXG4gIHJldHVybiBwZXJjZW50RGVjb2RlKGJ5dGVzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKi9cbmZ1bmN0aW9uIGlzSGV4Q2hhckJ5dGUgKGJ5dGUpIHtcbiAgLy8gMC05IEEtRiBhLWZcbiAgcmV0dXJuIChieXRlID49IDB4MzAgJiYgYnl0ZSA8PSAweDM5KSB8fCAoYnl0ZSA+PSAweDQxICYmIGJ5dGUgPD0gMHg0NikgfHwgKGJ5dGUgPj0gMHg2MSAmJiBieXRlIDw9IDB4NjYpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAqL1xuZnVuY3Rpb24gaGV4Qnl0ZVRvTnVtYmVyIChieXRlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gMC05XG4gICAgYnl0ZSA+PSAweDMwICYmIGJ5dGUgPD0gMHgzOVxuICAgICAgPyAoYnl0ZSAtIDQ4KVxuICAgIC8vIENvbnZlcnQgdG8gdXBwZXJjYXNlXG4gICAgLy8gKChieXRlICYgMHhERikgLSA2NSkgKyAxMFxuICAgICAgOiAoKGJ5dGUgJiAweERGKSAtIDU1KVxuICApXG59XG5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0ICovXG5mdW5jdGlvbiBwZXJjZW50RGVjb2RlIChpbnB1dCkge1xuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgLy8gMS4gTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IGogPSAwXG4gIC8vIDIuIEZvciBlYWNoIGJ5dGUgYnl0ZSBpbiBpbnB1dDpcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGJ5dGUgPSBpbnB1dFtpXVxuXG4gICAgLy8gMS4gSWYgYnl0ZSBpcyBub3QgMHgyNSAoJSksIHRoZW4gYXBwZW5kIGJ5dGUgdG8gb3V0cHV0LlxuICAgIGlmIChieXRlICE9PSAweDI1KSB7XG4gICAgICBvdXRwdXRbaisrXSA9IGJ5dGVcblxuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYnl0ZSBpcyAweDI1ICglKSBhbmQgdGhlIG5leHQgdHdvIGJ5dGVzXG4gICAgLy8gYWZ0ZXIgYnl0ZSBpbiBpbnB1dCBhcmUgbm90IGluIHRoZSByYW5nZXNcbiAgICAvLyAweDMwICgwKSB0byAweDM5ICg5KSwgMHg0MSAoQSkgdG8gMHg0NiAoRiksXG4gICAgLy8gYW5kIDB4NjEgKGEpIHRvIDB4NjYgKGYpLCBhbGwgaW5jbHVzaXZlLCBhcHBlbmQgYnl0ZVxuICAgIC8vIHRvIG91dHB1dC5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYnl0ZSA9PT0gMHgyNSAmJlxuICAgICAgIShpc0hleENoYXJCeXRlKGlucHV0W2kgKyAxXSkgJiYgaXNIZXhDaGFyQnl0ZShpbnB1dFtpICsgMl0pKVxuICAgICkge1xuICAgICAgb3V0cHV0W2orK10gPSAweDI1XG5cbiAgICAvLyAzLiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIExldCBieXRlUG9pbnQgYmUgdGhlIHR3byBieXRlcyBhZnRlciBieXRlIGluIGlucHV0LFxuICAgICAgLy8gZGVjb2RlZCwgYW5kIHRoZW4gaW50ZXJwcmV0ZWQgYXMgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICAgICAgLy8gMi4gQXBwZW5kIGEgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBieXRlUG9pbnQgdG8gb3V0cHV0LlxuICAgICAgb3V0cHV0W2orK10gPSAoaGV4Qnl0ZVRvTnVtYmVyKGlucHV0W2kgKyAxXSkgPDwgNCkgfCBoZXhCeXRlVG9OdW1iZXIoaW5wdXRbaSArIDJdKVxuXG4gICAgICAvLyAzLiBTa2lwIHRoZSBuZXh0IHR3byBieXRlcyBpbiBpbnB1dC5cbiAgICAgIGkgKz0gMlxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBsZW5ndGggPT09IGogPyBvdXRwdXQgOiBvdXRwdXQuc3ViYXJyYXkoMCwgailcbn1cblxuLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1hLW1pbWUtdHlwZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAqL1xuZnVuY3Rpb24gcGFyc2VNSU1FVHlwZSAoaW5wdXQpIHtcbiAgLy8gMS4gUmVtb3ZlIGFueSBsZWFkaW5nIGFuZCB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBpbnB1dC5cbiAgaW5wdXQgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShpbnB1dCwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgaW5wdXQsXG4gIC8vIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gMy4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2VcbiAgLy8gb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAyRiAoLykgZnJvbVxuICAvLyBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gIGNvbnN0IHR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDQuIElmIHR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICAvLyBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtdG9rZW4tY29kZS1wb2ludFxuICBpZiAodHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIHJldHVyblxuICAvLyBmYWlsdXJlXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwMkYgKC8pLilcbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDcuIExldCBzdWJ0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mXG4gIC8vIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuXG4gIC8vIHBvc2l0aW9uLlxuICBsZXQgc3VidHlwZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICc7JyxcbiAgICBpbnB1dCxcbiAgICBwb3NpdGlvblxuICApXG5cbiAgLy8gOC4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBzdWJ0eXBlLlxuICBzdWJ0eXBlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2Uoc3VidHlwZSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gOS4gSWYgc3VidHlwZSBpcyB0aGUgZW1wdHkgc3RyaW5nIG9yIGRvZXMgbm90IHNvbGVseVxuICAvLyBjb250YWluIEhUVFAgdG9rZW4gY29kZSBwb2ludHMsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChzdWJ0eXBlLmxlbmd0aCA9PT0gMCB8fCAhSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3Qoc3VidHlwZSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCB0eXBlTG93ZXJjYXNlID0gdHlwZS50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHN1YnR5cGVMb3dlcmNhc2UgPSBzdWJ0eXBlLnRvTG93ZXJDYXNlKClcblxuICAvLyAxMC4gTGV0IG1pbWVUeXBlIGJlIGEgbmV3IE1JTUUgdHlwZSByZWNvcmQgd2hvc2UgdHlwZVxuICAvLyBpcyB0eXBlLCBpbiBBU0NJSSBsb3dlcmNhc2UsIGFuZCBzdWJ0eXBlIGlzIHN1YnR5cGUsXG4gIC8vIGluIEFTQ0lJIGxvd2VyY2FzZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGVcbiAgY29uc3QgbWltZVR5cGUgPSB7XG4gICAgdHlwZTogdHlwZUxvd2VyY2FzZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlTG93ZXJjYXNlLFxuICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBwYXJhbWV0ZXJzOiBuZXcgTWFwKCksXG4gICAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNtaW1lLXR5cGUtZXNzZW5jZVxuICAgIGVzc2VuY2U6IGAke3R5cGVMb3dlcmNhc2V9LyR7c3VidHlwZUxvd2VyY2FzZX1gXG4gIH1cblxuICAvLyAxMS4gV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgLy8gMS4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzQiAoOykuKVxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQXG4gICAgLy8gd2hpdGVzcGFjZSBmcm9tIGlucHV0IGdpdmVuIHBvc2l0aW9uLlxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gICAgICBjaGFyID0+IEhUVFBfV0hJVEVTUEFDRV9SRUdFWC50ZXN0KGNoYXIpLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDMuIExldCBwYXJhbWV0ZXJOYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhXG4gICAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAvLyBvciBVKzAwM0QgKD0pIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgIGxldCBwYXJhbWV0ZXJOYW1lID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnOycgJiYgY2hhciAhPT0gJz0nLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDQuIFNldCBwYXJhbWV0ZXJOYW1lIHRvIHBhcmFtZXRlck5hbWUsIGluIEFTQ0lJXG4gICAgLy8gbG93ZXJjYXNlLlxuICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDUuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyAxLiBJZiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXNcbiAgICAgIC8vIFUrMDAzQiAoOyksIHRoZW4gY29udGludWUuXG4gICAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnOycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLiAoVGhpcyBza2lwcyBwYXN0IFUrMDAzRCAoPSkuKVxuICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgIH1cblxuICAgIC8vIDYuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBicmVhay5cbiAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IHBhcmFtZXRlclZhbHVlIGJlIG51bGwuXG4gICAgbGV0IHBhcmFtZXRlclZhbHVlID0gbnVsbFxuXG4gICAgLy8gOC4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgLy8gVSswMDIyIChcIiksIHRoZW46XG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJ1wiJykge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYW4gSFRUUCBxdW90ZWQgc3RyaW5nIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZy5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhpbnB1dCwgcG9zaXRpb24sIHRydWUpXG5cbiAgICAgIC8vIDIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3RcbiAgICAgIC8vIFUrMDAzQiAoOykgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgIC8vIDkuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gU2V0IHBhcmFtZXRlclZhbHVlIHRvIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZ1xuICAgICAgLy8gYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KVxuICAgICAgLy8gZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgICAnOycsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBwb3NpdGlvblxuICAgICAgKVxuXG4gICAgICAvLyAyLiBSZW1vdmUgYW55IHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBmcm9tIHBhcmFtZXRlclZhbHVlLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSByZW1vdmVIVFRQV2hpdGVzcGFjZShwYXJhbWV0ZXJWYWx1ZSwgZmFsc2UsIHRydWUpXG5cbiAgICAgIC8vIDMuIElmIHBhcmFtZXRlclZhbHVlIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gY29udGludWUuXG4gICAgICBpZiAocGFyYW1ldGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGFyZSB0cnVlXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nXG4gICAgLy8gLSBwYXJhbWV0ZXJOYW1lIHNvbGVseSBjb250YWlucyBIVFRQIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBwYXJhbWV0ZXJWYWx1ZSBzb2xlbHkgY29udGFpbnMgSFRUUCBxdW90ZWQtc3RyaW5nIHRva2VuIGNvZGUgcG9pbnRzXG4gICAgLy8gLSBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSBkb2VzIG5vdCBleGlzdFxuICAgIC8vIHRoZW4gc2V0IG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdIHRvIHBhcmFtZXRlclZhbHVlLlxuICAgIGlmIChcbiAgICAgIHBhcmFtZXRlck5hbWUubGVuZ3RoICE9PSAwICYmXG4gICAgICBIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChwYXJhbWV0ZXJOYW1lKSAmJlxuICAgICAgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCB8fCBIVFRQX1FVT1RFRF9TVFJJTkdfVE9LRU5TLnRlc3QocGFyYW1ldGVyVmFsdWUpKSAmJlxuICAgICAgIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKHBhcmFtZXRlck5hbWUpXG4gICAgKSB7XG4gICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldChwYXJhbWV0ZXJOYW1lLCBwYXJhbWV0ZXJWYWx1ZSlcbiAgICB9XG4gIH1cblxuICAvLyAxMi4gUmV0dXJuIG1pbWVUeXBlLlxuICByZXR1cm4gbWltZVR5cGVcbn1cblxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2ZvcmdpdmluZy1iYXNlNjQtZGVjb2RlXG4vKiogQHBhcmFtIHtzdHJpbmd9IGRhdGEgKi9cbmZ1bmN0aW9uIGZvcmdpdmluZ0Jhc2U2NCAoZGF0YSkge1xuICAvLyAxLiBSZW1vdmUgYWxsIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBkYXRhLlxuICBkYXRhID0gZGF0YS5yZXBsYWNlKEFTQ0lJX1dISVRFU1BBQ0VfUkVQTEFDRV9SRUdFWCwgJycpICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgbGV0IGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aFxuICAvLyAyLiBJZiBkYXRh4oCZcyBjb2RlIHBvaW50IGxlbmd0aCBkaXZpZGVzIGJ5IDQgbGVhdmluZ1xuICAvLyBubyByZW1haW5kZXIsIHRoZW46XG4gIGlmIChkYXRhTGVuZ3RoICUgNCA9PT0gMCkge1xuICAgIC8vIDEuIElmIGRhdGEgZW5kcyB3aXRoIG9uZSBvciB0d28gVSswMDNEICg9KSBjb2RlIHBvaW50cyxcbiAgICAvLyB0aGVuIHJlbW92ZSB0aGVtIGZyb20gZGF0YS5cbiAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KGRhdGFMZW5ndGggLSAxKSA9PT0gMHgwMDNEKSB7XG4gICAgICAtLWRhdGFMZW5ndGhcbiAgICAgIGlmIChkYXRhLmNoYXJDb2RlQXQoZGF0YUxlbmd0aCAtIDEpID09PSAweDAwM0QpIHtcbiAgICAgICAgLS1kYXRhTGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMy4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gYSByZW1haW5kZXIgb2YgMSwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKGRhdGFMZW5ndGggJSA0ID09PSAxKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNC4gSWYgZGF0YSBjb250YWlucyBhIGNvZGUgcG9pbnQgdGhhdCBpcyBub3Qgb25lIG9mXG4gIC8vICBVKzAwMkIgKCspXG4gIC8vICBVKzAwMkYgKC8pXG4gIC8vICBBU0NJSSBhbHBoYW51bWVyaWNcbiAgLy8gdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChkYXRhLmxlbmd0aCA9PT0gZGF0YUxlbmd0aCA/IGRhdGEgOiBkYXRhLnN1YnN0cmluZygwLCBkYXRhTGVuZ3RoKSkpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0JylcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbGxlY3QtYW4taHR0cC1xdW90ZWQtc3RyaW5nXG4vLyB0ZXN0czogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2V4YW1wbGUtaHR0cC1xdW90ZWQtc3RyaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGV4dHJhY3RWYWx1ZVxuICovXG5mdW5jdGlvbiBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nIChpbnB1dCwgcG9zaXRpb24sIGV4dHJhY3RWYWx1ZSkge1xuICAvLyAxLiBMZXQgcG9zaXRpb25TdGFydCBiZSBwb3NpdGlvbi5cbiAgY29uc3QgcG9zaXRpb25TdGFydCA9IHBvc2l0aW9uLnBvc2l0aW9uXG5cbiAgLy8gMi4gTGV0IHZhbHVlIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGxldCB2YWx1ZSA9ICcnXG5cbiAgLy8gMy4gQXNzZXJ0OiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXRcbiAgLy8gaXMgVSswMDIyIChcIikuXG4gIGFzc2VydChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpXG5cbiAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNS4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAxLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHNcbiAgICAvLyB0aGF0IGFyZSBub3QgVSswMDIyIChcIikgb3IgVSswMDVDIChcXCkgZnJvbSBpbnB1dCwgZ2l2ZW5cbiAgICAvLyBwb3NpdGlvbiwgdG8gdmFsdWUuXG4gICAgdmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09ICdcXFxcJyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAyLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcXVvdGVPckJhY2tzbGFzaCBiZSB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW5cbiAgICAvLyBpbnB1dC5cbiAgICBjb25zdCBxdW90ZU9yQmFja3NsYXNoID0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAvLyA0LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gICAgLy8gNS4gSWYgcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwNUMgKFxcKSwgdGhlbjpcbiAgICBpZiAocXVvdGVPckJhY2tzbGFzaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAvLyAxLiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYXBwZW5kXG4gICAgICAvLyBVKzAwNUMgKFxcKSB0byB2YWx1ZSBhbmQgYnJlYWsuXG4gICAgICBpZiAocG9zaXRpb24ucG9zaXRpb24gPj0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJ1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBBcHBlbmQgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dXG5cbiAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDYuIE90aGVyd2lzZTpcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMS4gQXNzZXJ0OiBxdW90ZU9yQmFja3NsYXNoIGlzIFUrMDAyMiAoXCIpLlxuICAgICAgYXNzZXJ0KHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcIicpXG5cbiAgICAgIC8vIDIuIEJyZWFrLlxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyA2LiBJZiB0aGUgZXh0cmFjdC12YWx1ZSBmbGFnIGlzIHNldCwgdGhlbiByZXR1cm4gdmFsdWUuXG4gIGlmIChleHRyYWN0VmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB0aGUgY29kZSBwb2ludHMgZnJvbSBwb3NpdGlvblN0YXJ0IHRvIHBvc2l0aW9uLFxuICAvLyBpbmNsdXNpdmUsIHdpdGhpbiBpbnB1dC5cbiAgcmV0dXJuIGlucHV0LnNsaWNlKHBvc2l0aW9uU3RhcnQsIHBvc2l0aW9uLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1taW1lLXR5cGVcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQU1pbWVUeXBlIChtaW1lVHlwZSkge1xuICBhc3NlcnQobWltZVR5cGUgIT09ICdmYWlsdXJlJylcbiAgY29uc3QgeyBwYXJhbWV0ZXJzLCBlc3NlbmNlIH0gPSBtaW1lVHlwZVxuXG4gIC8vIDEuIExldCBzZXJpYWxpemF0aW9uIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIG1pbWVUeXBl4oCZc1xuICAvLyAgICB0eXBlLCBVKzAwMkYgKC8pLCBhbmQgbWltZVR5cGXigJlzIHN1YnR5cGUuXG4gIGxldCBzZXJpYWxpemF0aW9uID0gZXNzZW5jZVxuXG4gIC8vIDIuIEZvciBlYWNoIG5hbWUg4oaSIHZhbHVlIG9mIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzOlxuICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgLy8gMS4gQXBwZW5kIFUrMDAzQiAoOykgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9ICc7J1xuXG4gICAgLy8gMi4gQXBwZW5kIG5hbWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IG5hbWVcblxuICAgIC8vIDMuIEFwcGVuZCBVKzAwM0QgKD0pIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnPSdcblxuICAgIC8vIDQuIElmIHZhbHVlIGRvZXMgbm90IHNvbGVseSBjb250YWluIEhUVFAgdG9rZW4gY29kZVxuICAgIC8vICAgIHBvaW50cyBvciB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuOlxuICAgIGlmICghSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QodmFsdWUpKSB7XG4gICAgICAvLyAxLiBQcmVjZWRlIGVhY2ggb2NjdXJyZW5jZSBvZiBVKzAwMjIgKFwiKSBvclxuICAgICAgLy8gICAgVSswMDVDIChcXCkgaW4gdmFsdWUgd2l0aCBVKzAwNUMgKFxcKS5cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcXFx8XCIpL2csICdcXFxcJDEnKVxuXG4gICAgICAvLyAyLiBQcmVwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgPSAnXCInICsgdmFsdWVcblxuICAgICAgLy8gMy4gQXBwZW5kIFUrMDAyMiAoXCIpIHRvIHZhbHVlLlxuICAgICAgdmFsdWUgKz0gJ1wiJ1xuICAgIH1cblxuICAgIC8vIDUuIEFwcGVuZCB2YWx1ZSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gdmFsdWVcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBzZXJpYWxpemF0aW9uLlxuICByZXR1cm4gc2VyaWFsaXphdGlvblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNIVFRQV2hpdGVTcGFjZSAoY2hhcikge1xuICAvLyBcIlxcclxcblxcdCBcIlxuICByZXR1cm4gY2hhciA9PT0gMHgwMGQgfHwgY2hhciA9PT0gMHgwMGEgfHwgY2hhciA9PT0gMHgwMDkgfHwgY2hhciA9PT0gMHgwMjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xlYWRpbmc9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWlsaW5nPXRydWVdXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhUVFBXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgcmV0dXJuIHJlbW92ZUNoYXJzKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIGlzSFRUUFdoaXRlU3BhY2UpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktd2hpdGVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGNoYXJcbiAqL1xuZnVuY3Rpb24gaXNBU0NJSVdoaXRlc3BhY2UgKGNoYXIpIHtcbiAgLy8gXCJcXHJcXG5cXHRcXGYgXCJcbiAgcmV0dXJuIGNoYXIgPT09IDB4MDBkIHx8IGNoYXIgPT09IDB4MDBhIHx8IGNoYXIgPT09IDB4MDA5IHx8IGNoYXIgPT09IDB4MDBjIHx8IGNoYXIgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtbGVhZGluZy1hbmQtdHJhaWxpbmctYXNjaWktd2hpdGVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtib29sZWFufSBbbGVhZGluZz10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbdHJhaWxpbmc9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQVNDSUlXaGl0ZXNwYWNlIChzdHIsIGxlYWRpbmcgPSB0cnVlLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgcmV0dXJuIHJlbW92ZUNoYXJzKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIGlzQVNDSUlXaGl0ZXNwYWNlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSB0cmFpbGluZ1xuICogQHBhcmFtIHsoY2hhckNvZGU6IG51bWJlcikgPT4gYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZW1vdmVDaGFycyAoc3RyLCBsZWFkaW5nLCB0cmFpbGluZywgcHJlZGljYXRlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBzdHIubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgd2hpbGUgKGxlYWQgPCBzdHIubGVuZ3RoICYmIHByZWRpY2F0ZShzdHIuY2hhckNvZGVBdChsZWFkKSkpIGxlYWQrK1xuICB9XG5cbiAgaWYgKHRyYWlsaW5nKSB7XG4gICAgd2hpbGUgKHRyYWlsID4gMCAmJiBwcmVkaWNhdGUoc3RyLmNoYXJDb2RlQXQodHJhaWwpKSkgdHJhaWwtLVxuICB9XG5cbiAgcmV0dXJuIGxlYWQgPT09IDAgJiYgdHJhaWwgPT09IHN0ci5sZW5ndGggLSAxID8gc3RyIDogc3RyLnNsaWNlKGxlYWQsIHRyYWlsICsgMSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWRlY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaXNvbW9ycGhpY0RlY29kZSAoaW5wdXQpIHtcbiAgLy8gMS4gVG8gaXNvbW9ycGhpYyBkZWNvZGUgYSBieXRlIHNlcXVlbmNlIGlucHV0LCByZXR1cm4gYSBzdHJpbmcgd2hvc2UgY29kZSBwb2ludFxuICAvLyAgICBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGxlbmd0aCBhbmQgd2hvc2UgY29kZSBwb2ludHMgaGF2ZSB0aGUgc2FtZSB2YWx1ZXNcbiAgLy8gICAgYXMgdGhlIHZhbHVlcyBvZiBpbnB1dOKAmXMgYnl0ZXMsIGluIHRoZSBzYW1lIG9yZGVyLlxuICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGhcbiAgaWYgKCgyIDw8IDE1KSAtIDEgPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dClcbiAgfVxuICBsZXQgcmVzdWx0ID0gJyc7IGxldCBpID0gMFxuICBsZXQgYWRkaXRpb24gPSAoMiA8PCAxNSkgLSAxXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKGkgKyBhZGRpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgYWRkaXRpb24gPSBsZW5ndGggLSBpXG4gICAgfVxuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlucHV0LnN1YmFycmF5KGksIGkgKz0gYWRkaXRpb24pKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWluaW1pemUtYS1zdXBwb3J0ZWQtbWltZS10eXBlXG4gKiBAcGFyYW0ge0V4Y2x1ZGU8UmV0dXJuVHlwZTx0eXBlb2YgcGFyc2VNSU1FVHlwZT4sICdmYWlsdXJlJz59IG1pbWVUeXBlXG4gKi9cbmZ1bmN0aW9uIG1pbmltaXplU3VwcG9ydGVkTWltZVR5cGUgKG1pbWVUeXBlKSB7XG4gIHN3aXRjaCAobWltZVR5cGUuZXNzZW5jZSkge1xuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veC1qYXZhc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2VjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4wJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjEnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMic6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4zJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuNSc6XG4gICAgY2FzZSAndGV4dC9qc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2xpdmVzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQveC1lY21hc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L3gtamF2YXNjcmlwdCc6XG4gICAgICAvLyAxLiBJZiBtaW1lVHlwZSBpcyBhIEphdmFTY3JpcHQgTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcInRleHQvamF2YXNjcmlwdFwiLlxuICAgICAgcmV0dXJuICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6XG4gICAgY2FzZSAndGV4dC9qc29uJzpcbiAgICAgIC8vIDIuIElmIG1pbWVUeXBlIGlzIGEgSlNPTiBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24vanNvblwiLlxuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIGNhc2UgJ2ltYWdlL3N2Zyt4bWwnOlxuICAgICAgLy8gMy4gSWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJpbWFnZS9zdmcreG1sXCIsIHRoZW4gcmV0dXJuIFwiaW1hZ2Uvc3ZnK3htbFwiLlxuICAgICAgcmV0dXJuICdpbWFnZS9zdmcreG1sJ1xuICAgIGNhc2UgJ3RleHQveG1sJzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94bWwnOlxuICAgICAgLy8gNC4gSWYgbWltZVR5cGUgaXMgYW4gWE1MIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi94bWxcIi5cbiAgICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJ1xuICB9XG5cbiAgLy8gMi4gSWYgbWltZVR5cGUgaXMgYSBKU09OIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi9qc29uXCIuXG4gIGlmIChtaW1lVHlwZS5zdWJ0eXBlLmVuZHNXaXRoKCcranNvbicpKSB7XG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJ1xuICB9XG5cbiAgLy8gNC4gSWYgbWltZVR5cGUgaXMgYW4gWE1MIE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJhcHBsaWNhdGlvbi94bWxcIi5cbiAgaWYgKG1pbWVUeXBlLnN1YnR5cGUuZW5kc1dpdGgoJyt4bWwnKSkge1xuICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJ1xuICB9XG5cbiAgLy8gNS4gSWYgbWltZVR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50LCB0aGVuIHJldHVybiBtaW1lVHlwZeKAmXMgZXNzZW5jZS5cbiAgLy8gVGVjaG5pY2FsbHksIG5vZGUgZG9lc24ndCBzdXBwb3J0IGFueSBtaW1ldHlwZXMuXG5cbiAgLy8gNi4gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gIHJldHVybiAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGF0YVVSTFByb2Nlc3NvcixcbiAgVVJMU2VyaWFsaXplcixcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyxcbiAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QsXG4gIHN0cmluZ1BlcmNlbnREZWNvZGUsXG4gIHBhcnNlTUlNRVR5cGUsXG4gIGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcsXG4gIHNlcmlhbGl6ZUFNaW1lVHlwZSxcbiAgcmVtb3ZlQ2hhcnMsXG4gIHJlbW92ZUhUVFBXaGl0ZXNwYWNlLFxuICBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlLFxuICBIVFRQX1RPS0VOX0NPREVQT0lOVFMsXG4gIGlzb21vcnBoaWNEZWNvZGVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConnected, kSize } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\n\nclass CompatWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value[kConnected] === 0 && this.value[kSize] === 0\n      ? undefined\n      : this.value\n  }\n}\n\nclass CompatFinalizer {\n  constructor (finalizer) {\n    this.finalizer = finalizer\n  }\n\n  register (dispatcher, key) {\n    if (dispatcher.on) {\n      dispatcher.on('disconnect', () => {\n        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n          this.finalizer(key)\n        }\n      })\n    }\n  }\n\n  unregister (key) {}\n}\n\nmodule.exports = function () {\n  // FIXME: remove workaround when the Node bug is backported to v18\n  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n  if (process.env.NODE_V8_COVERAGE && process.version.startsWith('v18')) {\n    process._rawDebug('Using compatibility WeakRef and FinalizationRegistry')\n    return {\n      WeakRef: CompatWeakRef,\n      FinalizationRegistry: CompatFinalizer\n    }\n  }\n  return { WeakRef, FinalizationRegistry }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZGlzcGF0Y2hlci13ZWFrcmVmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25uZWN0ZWQsIGtTaXplIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuXG5jbGFzcyBDb21wYXRXZWFrUmVmIHtcbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBkZXJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVba0Nvbm5lY3RlZF0gPT09IDAgJiYgdGhpcy52YWx1ZVtrU2l6ZV0gPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMudmFsdWVcbiAgfVxufVxuXG5jbGFzcyBDb21wYXRGaW5hbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoZmluYWxpemVyKSB7XG4gICAgdGhpcy5maW5hbGl6ZXIgPSBmaW5hbGl6ZXJcbiAgfVxuXG4gIHJlZ2lzdGVyIChkaXNwYXRjaGVyLCBrZXkpIHtcbiAgICBpZiAoZGlzcGF0Y2hlci5vbikge1xuICAgICAgZGlzcGF0Y2hlci5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgaWYgKGRpc3BhdGNoZXJba0Nvbm5lY3RlZF0gPT09IDAgJiYgZGlzcGF0Y2hlcltrU2l6ZV0gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZpbmFsaXplcihrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdW5yZWdpc3RlciAoa2V5KSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gRklYTUU6IHJlbW92ZSB3b3JrYXJvdW5kIHdoZW4gdGhlIE5vZGUgYnVnIGlzIGJhY2twb3J0ZWQgdG8gdjE4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfVjhfQ09WRVJBR0UgJiYgcHJvY2Vzcy52ZXJzaW9uLnN0YXJ0c1dpdGgoJ3YxOCcpKSB7XG4gICAgcHJvY2Vzcy5fcmF3RGVidWcoJ1VzaW5nIGNvbXBhdGliaWxpdHkgV2Vha1JlZiBhbmQgRmluYWxpemF0aW9uUmVnaXN0cnknKVxuICAgIHJldHVybiB7XG4gICAgICBXZWFrUmVmOiBDb21wYXRXZWFrUmVmLFxuICAgICAgRmluYWxpemF0aW9uUmVnaXN0cnk6IENvbXBhdEZpbmFsaXplclxuICAgIH1cbiAgfVxuICByZXR1cm4geyBXZWFrUmVmLCBGaW5hbGl6YXRpb25SZWdpc3RyeSB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/file.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Blob, File } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\n// TODO(@KhafraDev): remove\nclass FileLike {\n  constructor (blobLike, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    this[kState] = {\n      blobLike,\n      name: n,\n      type: t,\n      lastModified: d\n    }\n  }\n\n  stream (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.stream(...args)\n  }\n\n  arrayBuffer (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.arrayBuffer(...args)\n  }\n\n  slice (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.slice(...args)\n  }\n\n  text (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.text(...args)\n  }\n\n  get size () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.size\n  }\n\n  get type () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.type\n  }\n\n  get name () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n}\n\nwebidl.converters.Blob = webidl.interfaceConverter(Blob)\n\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike (object) {\n  return (\n    (object instanceof File) ||\n    (\n      object &&\n      (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n      object[Symbol.toStringTag] === 'File'\n    )\n  )\n}\n\nmodule.exports = { FileLike, isFileLike }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDdEMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFckM7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQmxvYiwgRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuXG4vLyBUT0RPKEBLaGFmcmFEZXYpOiByZW1vdmVcbmNsYXNzIEZpbGVMaWtlIHtcbiAgY29uc3RydWN0b3IgKGJsb2JMaWtlLCBmaWxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVE9ETzogYXJndW1lbnQgaWRsIHR5cGUgY2hlY2tcblxuICAgIC8vIFRoZSBGaWxlIGNvbnN0cnVjdG9yIGlzIGludm9rZWQgd2l0aCB0d28gb3IgdGhyZWUgcGFyYW1ldGVycywgZGVwZW5kaW5nXG4gICAgLy8gb24gd2hldGhlciB0aGUgb3B0aW9uYWwgZGljdGlvbmFyeSBwYXJhbWV0ZXIgaXMgdXNlZC4gV2hlbiB0aGUgRmlsZSgpXG4gICAgLy8gY29uc3RydWN0b3IgaXMgaW52b2tlZCwgdXNlciBhZ2VudHMgbXVzdCBydW4gdGhlIGZvbGxvd2luZyBzdGVwczpcblxuICAgIC8vIDEuIExldCBieXRlcyBiZSB0aGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYmxvYiBwYXJ0cyBnaXZlbiBmaWxlQml0cyBhbmRcbiAgICAvLyBvcHRpb25zLlxuXG4gICAgLy8gMi4gTGV0IG4gYmUgdGhlIGZpbGVOYW1lIGFyZ3VtZW50IHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBuID0gZmlsZU5hbWVcblxuICAgIC8vIDMuIFByb2Nlc3MgRmlsZVByb3BlcnR5QmFnIGRpY3Rpb25hcnkgYXJndW1lbnQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nXG4gICAgLy8gc3Vic3RlcHM6XG5cbiAgICAvLyAgICAxLiBJZiB0aGUgdHlwZSBtZW1iZXIgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgdFxuICAgIC8vICAgIGJlIHNldCB0byB0aGUgdHlwZSBkaWN0aW9uYXJ5IG1lbWJlci4gSWYgdCBjb250YWlucyBhbnkgY2hhcmFjdGVyc1xuICAgIC8vICAgIG91dHNpZGUgdGhlIHJhbmdlIFUrMDAyMCB0byBVKzAwN0UsIHRoZW4gc2V0IHQgdG8gdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vICAgIGFuZCByZXR1cm4gZnJvbSB0aGVzZSBzdWJzdGVwcy5cbiAgICAvLyAgICBUT0RPXG4gICAgY29uc3QgdCA9IG9wdGlvbnMudHlwZVxuXG4gICAgLy8gICAgMi4gQ29udmVydCBldmVyeSBjaGFyYWN0ZXIgaW4gdCB0byBBU0NJSSBsb3dlcmNhc2UuXG4gICAgLy8gICAgVE9ET1xuXG4gICAgLy8gICAgMy4gSWYgdGhlIGxhc3RNb2RpZmllZCBtZW1iZXIgaXMgcHJvdmlkZWQsIGxldCBkIGJlIHNldCB0byB0aGVcbiAgICAvLyAgICBsYXN0TW9kaWZpZWQgZGljdGlvbmFyeSBtZW1iZXIuIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgc2V0IGQgdG8gdGhlXG4gICAgLy8gICAgY3VycmVudCBkYXRlIGFuZCB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gICAgLy8gICAgdGhlIFVuaXggRXBvY2ggKHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIERhdGUubm93KCkgW0VDTUEtMjYyXSkuXG4gICAgY29uc3QgZCA9IG9wdGlvbnMubGFzdE1vZGlmaWVkID8/IERhdGUubm93KClcblxuICAgIC8vIDQuIFJldHVybiBhIG5ldyBGaWxlIG9iamVjdCBGIHN1Y2ggdGhhdDpcbiAgICAvLyBGIHJlZmVycyB0byB0aGUgYnl0ZXMgYnl0ZSBzZXF1ZW5jZS5cbiAgICAvLyBGLnNpemUgaXMgc2V0IHRvIHRoZSBudW1iZXIgb2YgdG90YWwgYnl0ZXMgaW4gYnl0ZXMuXG4gICAgLy8gRi5uYW1lIGlzIHNldCB0byBuLlxuICAgIC8vIEYudHlwZSBpcyBzZXQgdG8gdC5cbiAgICAvLyBGLmxhc3RNb2RpZmllZCBpcyBzZXQgdG8gZC5cblxuICAgIHRoaXNba1N0YXRlXSA9IHtcbiAgICAgIGJsb2JMaWtlLFxuICAgICAgbmFtZTogbixcbiAgICAgIHR5cGU6IHQsXG4gICAgICBsYXN0TW9kaWZpZWQ6IGRcbiAgICB9XG4gIH1cblxuICBzdHJlYW0gKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc3RyZWFtKC4uLmFyZ3MpXG4gIH1cblxuICBhcnJheUJ1ZmZlciAoLi4uYXJncykge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5hcnJheUJ1ZmZlciguLi5hcmdzKVxuICB9XG5cbiAgc2xpY2UgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2xpY2UoLi4uYXJncylcbiAgfVxuXG4gIHRleHQgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UudGV4dCguLi5hcmdzKVxuICB9XG5cbiAgZ2V0IHNpemUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS5zaXplXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnR5cGVcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubmFtZVxuICB9XG5cbiAgZ2V0IGxhc3RNb2RpZmllZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddICgpIHtcbiAgICByZXR1cm4gJ0ZpbGUnXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuQmxvYiA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoQmxvYilcblxuLy8gSWYgdGhpcyBmdW5jdGlvbiBpcyBtb3ZlZCB0byAuL3V0aWwuanMsIHNvbWUgdG9vbHMgKHN1Y2ggYXNcbi8vIHJvbGx1cCkgd2lsbCB3YXJuIGFib3V0IGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gU2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzE2MjlcbmZ1bmN0aW9uIGlzRmlsZUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIChvYmplY3QgaW5zdGFuY2VvZiBGaWxlKSB8fFxuICAgIChcbiAgICAgIG9iamVjdCAmJlxuICAgICAgKHR5cGVvZiBvYmplY3Quc3RyZWFtID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb2JqZWN0LmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nKSAmJlxuICAgICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJ1xuICAgIClcbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUSVString, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\")\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { File: NodeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst File = globalThis.File ?? NodeFile\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('; filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    return 'failure'\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allow \\r\\n before the body.\n  if (input[0] === 0x0d && input[1] === 0x0a) {\n    position.position += 2\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      return 'failure'\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    if (result === 'failure') {\n      return 'failure'\n    }\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        return 'failure'\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(isUSVString(name))\n    assert((typeof value === 'string' && isUSVString(value)) || isFileLike(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        return 'failure'\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      return 'failure'\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      return 'failure'\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          return 'failure'\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        if (name === null) {\n          return 'failure'\n        }\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (bufferStartsWith(input, filenameBuffer, position)) {\n          // Note: undici also handles filename*\n          let check = position.position + filenameBuffer.length\n\n          if (input[check] === 0x2a) {\n            position.position += 1\n            check += 1\n          }\n\n          if (input[check] !== 0x3d || input[check + 1] !== 0x22) { // =\"\n            return 'failure'\n          }\n\n          // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n          //    (the one in the sequence of bytes matched above).\n          position.position += 12\n\n          // 2. Set filename to the result of parsing a multipart/form-data name given\n          //    input and position, if the result is not failure. Otherwise, return failure.\n          filename = parseMultipartFormDataName(input, position)\n\n          if (filename === null) {\n            return 'failure'\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    return null // name could be 'failure'\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDL0UsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQzVDLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN4RSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3ZDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEQ7O0FBRUEsbURBQW1EO0FBQ25ELHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1EQUFtRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGVBQWU7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsd0NBQXdDOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxtQkFBbUI7QUFDOUQsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0VBQW9FO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLFFBQVE7QUFDbkIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVywrQkFBK0I7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsZUFBZSxhQUFhO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmb3JtZGF0YS1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNVU1ZTdHJpbmcsIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IHV0ZjhEZWNvZGVCeXRlcyB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLCBpc29tb3JwaGljRGVjb2RlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgaXNGaWxlTGlrZSB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgbWFrZUVudHJ5IH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgRmlsZTogTm9kZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyBOb2RlRmlsZVxuXG5jb25zdCBmb3JtRGF0YU5hbWVCdWZmZXIgPSBCdWZmZXIuZnJvbSgnZm9ybS1kYXRhOyBuYW1lPVwiJylcbmNvbnN0IGZpbGVuYW1lQnVmZmVyID0gQnVmZmVyLmZyb20oJzsgZmlsZW5hbWUnKVxuY29uc3QgZGQgPSBCdWZmZXIuZnJvbSgnLS0nKVxuY29uc3QgZGRjcmxmID0gQnVmZmVyLmZyb20oJy0tXFxyXFxuJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNcbiAqL1xuZnVuY3Rpb24gaXNBc2NpaVN0cmluZyAoY2hhcnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7ICsraSkge1xuICAgIGlmICgoY2hhcnMuY2hhckNvZGVBdChpKSAmIH4weDdGKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI211bHRpcGFydC1mb3JtLWRhdGEtYm91bmRhcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJvdW5kYXJ5IChib3VuZGFyeSkge1xuICBjb25zdCBsZW5ndGggPSBib3VuZGFyeS5sZW5ndGhcblxuICAvLyAtIGl0cyBsZW5ndGggaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyNyBhbmQgbGVzc2VyIG9yIGVxdWFsIHRvIDcwLCBhbmRcbiAgaWYgKGxlbmd0aCA8IDI3IHx8IGxlbmd0aCA+IDcwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtIGl0IGlzIGNvbXBvc2VkIGJ5IGJ5dGVzIGluIHRoZSByYW5nZXMgMHgzMCB0byAweDM5LCAweDQxIHRvIDB4NUEsIG9yXG4gIC8vICAgMHg2MSB0byAweDdBLCBpbmNsdXNpdmUgKEFTQ0lJIGFscGhhbnVtZXJpYyksIG9yIHdoaWNoIGFyZSAweDI3ICgnKSxcbiAgLy8gICAweDJEICgtKSBvciAweDVGIChfKS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNwID0gYm91bmRhcnkuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKCEoXG4gICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxuICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1YSkgfHxcbiAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N2EpIHx8XG4gICAgICBjcCA9PT0gMHgyNyB8fFxuICAgICAgY3AgPT09IDB4MmQgfHxcbiAgICAgIGNwID09PSAweDVmXG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jbXVsdGlwYXJ0LWZvcm0tZGF0YS1wYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHtSZXR1cm5UeXBlPGltcG9ydCgnLi9kYXRhLXVybCcpWydwYXJzZU1JTUVUeXBlJ10+fSBtaW1lVHlwZVxuICovXG5mdW5jdGlvbiBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciAoaW5wdXQsIG1pbWVUeXBlKSB7XG4gIC8vIDEuIEFzc2VydDogbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIuXG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlLmVzc2VuY2UgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJylcblxuICBjb25zdCBib3VuZGFyeVN0cmluZyA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdib3VuZGFyeScpXG5cbiAgLy8gMi4gSWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIGZhaWx1cmUuXG4gIC8vICAgIE90aGVyd2lzZSwgbGV0IGJvdW5kYXJ5IGJlIHRoZSByZXN1bHQgb2YgVVRGLTggZGVjb2RpbmcgbWltZVR5cGXigJlzXG4gIC8vICAgIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXS5cbiAgaWYgKGJvdW5kYXJ5U3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IEJ1ZmZlci5mcm9tKGAtLSR7Ym91bmRhcnlTdHJpbmd9YCwgJ3V0ZjgnKVxuXG4gIC8vIDMuIExldCBlbnRyeSBsaXN0IGJlIGFuIGVtcHR5IGVudHJ5IGxpc3QuXG4gIGNvbnN0IGVudHJ5TGlzdCA9IFtdXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciB0byBhIGJ5dGUgaW4gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdFxuICAvLyAgICB0aGUgZmlyc3QgYnl0ZS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyBOb3RlOiB1bmRpY2kgYWRkaXRpb24sIGFsbG93IFxcclxcbiBiZWZvcmUgdGhlIGJvZHkuXG4gIGlmIChpbnB1dFswXSA9PT0gMHgwZCAmJiBpbnB1dFsxXSA9PT0gMHgwYSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IDJcbiAgfVxuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gNS4xLiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoIDB4MkQgMHgyRFxuICAgIC8vICAgICAgKGAtLWApIGZvbGxvd2VkIGJ5IGJvdW5kYXJ5LCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKyB0aGUgbGVuZ3RoIG9mXG4gICAgLy8gICAgICBib3VuZGFyeS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICAvLyBOb3RlOiBib3VuZGFyeSBpcyBwYWRkZWQgd2l0aCAyIGRhc2hlcyBhbHJlYWR5LCBubyBuZWVkIHRvIGFkZCAyLlxuICAgIGlmIChpbnB1dC5zdWJhcnJheShwb3NpdGlvbi5wb3NpdGlvbiwgcG9zaXRpb24ucG9zaXRpb24gKyBib3VuZGFyeS5sZW5ndGgpLmVxdWFscyhib3VuZGFyeSkpIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IGJvdW5kYXJ5Lmxlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNS4yLiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIDB4MkQgMHgyRCAweDBEIDB4MEFcbiAgICAvLyAgICAgIChgLS1gIGZvbGxvd2VkIGJ5IENSIExGKSBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIGlucHV0LCByZXR1cm4gZW50cnkgbGlzdC5cbiAgICAvLyBOb3RlOiBhIGJvZHkgZG9lcyBOT1QgbmVlZCB0byBlbmQgd2l0aCBDUkxGLiBJdCBjYW4gZW5kIHdpdGggLS0uXG4gICAgaWYgKFxuICAgICAgKHBvc2l0aW9uLnBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggLSAyICYmIGJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGRkLCBwb3NpdGlvbikpIHx8XG4gICAgICAocG9zaXRpb24ucG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCAtIDQgJiYgYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGRjcmxmLCBwb3NpdGlvbikpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZW50cnlMaXN0XG4gICAgfVxuXG4gICAgLy8gNS4zLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRFxuICAgIC8vICAgICAgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDBkIHx8IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gIT09IDB4MGEpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA1LjQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMi4gKFRoaXMgc2tpcHMgcGFzdCB0aGUgbmV3bGluZS4pXG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuXG4gICAgLy8gNS41LiBMZXQgbmFtZSwgZmlsZW5hbWUgYW5kIGNvbnRlbnRUeXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAgIC8vICAgICAgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBoZWFkZXJzIG9uIGlucHV0IGFuZCBwb3NpdGlvbiwgaWYgdGhlIHJlc3VsdFxuICAgIC8vICAgICAgaXMgbm90IGZhaWx1cmUuIE90aGVyd2lzZSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YUhlYWRlcnMoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgbGV0IHsgbmFtZSwgZmlsZW5hbWUsIGNvbnRlbnRUeXBlLCBlbmNvZGluZyB9ID0gcmVzdWx0XG5cbiAgICAvLyA1LjYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMi4gKFRoaXMgc2tpcHMgcGFzdCB0aGUgZW1wdHkgbGluZSB0aGF0IG1hcmtzXG4gICAgLy8gICAgICB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG5cbiAgICAvLyA1LjcuIExldCBib2R5IGJlIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAgIGxldCBib2R5XG5cbiAgICAvLyA1LjguIEJvZHkgbG9vcDogV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgICAvLyBUT0RPOiB0aGUgc3RlcHMgaGVyZSBhcmUgY29tcGxldGVseSB3cm9uZ1xuICAgIHtcbiAgICAgIGNvbnN0IGJvdW5kYXJ5SW5kZXggPSBpbnB1dC5pbmRleE9mKGJvdW5kYXJ5LnN1YmFycmF5KDIpLCBwb3NpdGlvbi5wb3NpdGlvbilcblxuICAgICAgaWYgKGJvdW5kYXJ5SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgIH1cblxuICAgICAgYm9keSA9IGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBib3VuZGFyeUluZGV4IC0gNClcblxuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm9keS5sZW5ndGhcblxuICAgICAgLy8gTm90ZTogcG9zaXRpb24gbXVzdCBiZSBhZHZhbmNlZCBieSB0aGUgYm9keSdzIGxlbmd0aCBiZWZvcmUgYmVpbmdcbiAgICAgIC8vIGRlY29kZWQsIG90aGVyd2lzZSB0aGUgcGFyc2luZyB3aWxsIGZhaWwuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCksICdiYXNlNjQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuOS4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoXG4gICAgLy8gICAgICAweDBEIDB4MEEgKENSIExGKSwgcmV0dXJuIGZhaWx1cmUuIE90aGVyd2lzZSwgYWR2YW5jZSBwb3NpdGlvbiBieSAyLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgfHwgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG4gICAgfVxuXG4gICAgLy8gNS4xMC4gSWYgZmlsZW5hbWUgaXMgbm90IG51bGw6XG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAoZmlsZW5hbWUgIT09IG51bGwpIHtcbiAgICAgIC8vIDUuMTAuMS4gSWYgY29udGVudFR5cGUgaXMgbnVsbCwgc2V0IGNvbnRlbnRUeXBlIHRvIFwidGV4dC9wbGFpblwiLlxuICAgICAgY29udGVudFR5cGUgPz89ICd0ZXh0L3BsYWluJ1xuXG4gICAgICAvLyA1LjEwLjIuIElmIGNvbnRlbnRUeXBlIGlzIG5vdCBhbiBBU0NJSSBzdHJpbmcsIHNldCBjb250ZW50VHlwZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgICAvLyBOb3RlOiBgYnVmZmVyLmlzQXNjaWlgIGNhbiBiZSB1c2VkIGF0IHplcm8tY29zdCwgYnV0IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBidWZmZXIgaXMgYSBoaWdoIG92ZXJoZWFkLlxuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGEgcmVsYXRpdmVseSBzbWFsbCBzdHJpbmcsIHNvIGl0IGlzIGZhc3RlciB0byB1c2UgYFN0cmluZyNjaGFyQ29kZUF0YC5cbiAgICAgIGlmICghaXNBc2NpaVN0cmluZyhjb250ZW50VHlwZSkpIHtcbiAgICAgICAgY29udGVudFR5cGUgPSAnJ1xuICAgICAgfVxuXG4gICAgICAvLyA1LjEwLjMuIExldCB2YWx1ZSBiZSBhIG5ldyBGaWxlIG9iamVjdCB3aXRoIG5hbWUgZmlsZW5hbWUsIHR5cGUgY29udGVudFR5cGUsIGFuZCBib2R5IGJvZHkuXG4gICAgICB2YWx1ZSA9IG5ldyBGaWxlKFtib2R5XSwgZmlsZW5hbWUsIHsgdHlwZTogY29udGVudFR5cGUgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNS4xMS4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA1LjExLjEuIExldCB2YWx1ZSBiZSB0aGUgVVRGLTggZGVjb2Rpbmcgd2l0aG91dCBCT00gb2YgYm9keS5cbiAgICAgIHZhbHVlID0gdXRmOERlY29kZUJ5dGVzKEJ1ZmZlci5mcm9tKGJvZHkpKVxuICAgIH1cblxuICAgIC8vIDUuMTIuIEFzc2VydDogbmFtZSBpcyBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgYW5kIHZhbHVlIGlzIGVpdGhlciBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgb3IgYSBGaWxlIG9iamVjdC5cbiAgICBhc3NlcnQoaXNVU1ZTdHJpbmcobmFtZSkpXG4gICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGlzVVNWU3RyaW5nKHZhbHVlKSkgfHwgaXNGaWxlTGlrZSh2YWx1ZSkpXG5cbiAgICAvLyA1LjEzLiBDcmVhdGUgYW4gZW50cnkgd2l0aCBuYW1lIGFuZCB2YWx1ZSwgYW5kIGFwcGVuZCBpdCB0byBlbnRyeSBsaXN0LlxuICAgIGVudHJ5TGlzdC5wdXNoKG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI3BhcnNlLW11bHRpcGFydC1mb3JtLWRhdGEtaGVhZGVyc1xuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyAoaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIExldCBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUgYmUgbnVsbC5cbiAgbGV0IG5hbWUgPSBudWxsXG4gIGxldCBmaWxlbmFtZSA9IG51bGxcbiAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbFxuICBsZXQgZW5jb2RpbmcgPSBudWxsXG5cbiAgLy8gMi4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAyLjEuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBIChDUiBMRik6XG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gMHgwZCAmJiBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdID09PSAweDBhKSB7XG4gICAgICAvLyAyLjEuMS4gSWYgbmFtZSBpcyBudWxsLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgIH1cblxuICAgICAgLy8gMi4xLjIuIFJldHVybiBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUuXG4gICAgICByZXR1cm4geyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH1cbiAgICB9XG5cbiAgICAvLyAyLjIuIExldCBoZWFkZXIgbmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgIC8vICAgICAgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4M0EgKDopLCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgaGVhZGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDNhLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuMy4gUmVtb3ZlIGFueSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBmcm9tIHRoZSBzdGFydCBvciBlbmQgb2YgaGVhZGVyIG5hbWUuXG4gICAgaGVhZGVyTmFtZSA9IHJlbW92ZUNoYXJzKGhlYWRlck5hbWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDIuNC4gSWYgaGVhZGVyIG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGZpZWxkLW5hbWUgdG9rZW4gcHJvZHVjdGlvbiwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChoZWFkZXJOYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gMi41LiBJZiB0aGUgYnl0ZSBhdCBwb3NpdGlvbiBpcyBub3QgMHgzQSAoOiksIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4M2EpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyAyLjYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyAyLjcuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLyAgICAgIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09IDB4MjAgfHwgY2hhciA9PT0gMHgwOSxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAyLjguIEJ5dGUtbG93ZXJjYXNlIGhlYWRlciBuYW1lIGFuZCBzd2l0Y2ggb24gdGhlIHJlc3VsdDpcbiAgICBzd2l0Y2ggKGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoaGVhZGVyTmFtZSkpIHtcbiAgICAgIGNhc2UgJ2NvbnRlbnQtZGlzcG9zaXRpb24nOiB7XG4gICAgICAgIC8vIDEuIFNldCBuYW1lIGFuZCBmaWxlbmFtZSB0byBudWxsLlxuICAgICAgICBuYW1lID0gZmlsZW5hbWUgPSBudWxsXG5cbiAgICAgICAgLy8gMi4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoXG4gICAgICAgIC8vICAgIGBmb3JtLWRhdGE7IG5hbWU9XCJgLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgICAgaWYgKCFidWZmZXJTdGFydHNXaXRoKGlucHV0LCBmb3JtRGF0YU5hbWVCdWZmZXIsIHBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKVxuICAgICAgICAvLyAgICBieXRlICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMTdcblxuICAgICAgICAvLyA0LiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIG5hbWUgZ2l2ZW5cbiAgICAgICAgLy8gICAgaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVyblxuICAgICAgICAvLyAgICBmYWlsdXJlLlxuICAgICAgICBuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCBgOyBmaWxlbmFtZT1cImA6XG4gICAgICAgIGlmIChidWZmZXJTdGFydHNXaXRoKGlucHV0LCBmaWxlbmFtZUJ1ZmZlciwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgLy8gTm90ZTogdW5kaWNpIGFsc28gaGFuZGxlcyBmaWxlbmFtZSpcbiAgICAgICAgICBsZXQgY2hlY2sgPSBwb3NpdGlvbi5wb3NpdGlvbiArIGZpbGVuYW1lQnVmZmVyLmxlbmd0aFxuXG4gICAgICAgICAgaWYgKGlucHV0W2NoZWNrXSA9PT0gMHgyYSkge1xuICAgICAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMVxuICAgICAgICAgICAgY2hlY2sgKz0gMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnB1dFtjaGVja10gIT09IDB4M2QgfHwgaW5wdXRbY2hlY2sgKyAxXSAhPT0gMHgyMikgeyAvLyA9XCJcbiAgICAgICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAxLiBBZHZhbmNlIHBvc2l0aW9uIHNvIGl0IHBvaW50cyBhdCB0aGUgYnl0ZSBhZnRlciB0aGUgbmV4dCAweDIyIChcIikgYnl0ZVxuICAgICAgICAgIC8vICAgICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxMlxuXG4gICAgICAgICAgLy8gMi4gU2V0IGZpbGVuYW1lIHRvIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11bHRpcGFydC9mb3JtLWRhdGEgbmFtZSBnaXZlblxuICAgICAgICAgIC8vICAgIGlucHV0IGFuZCBwb3NpdGlvbiwgaWYgdGhlIHJlc3VsdCBpcyBub3QgZmFpbHVyZS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgICAgICBmaWxlbmFtZSA9IHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFOYW1lKGlucHV0LCBwb3NpdGlvbilcblxuICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXR5cGUnOiB7XG4gICAgICAgIC8vIDEuIExldCBoZWFkZXIgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gICAgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyAyLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBoZWFkZXIgdmFsdWUuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgLy8gMy4gU2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgY29udGVudFR5cGUgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJzoge1xuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICBoZWFkZXJWYWx1ZSA9IHJlbW92ZUNoYXJzKGhlYWRlclZhbHVlLCBmYWxzZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgICAgIGVuY29kaW5nID0gaXNvbW9ycGhpY0RlY29kZShoZWFkZXJWYWx1ZSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICAvLyAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBXG4gICAgLy8gICAgICAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKHBhc3QgdGhlIG5ld2xpbmUpLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI3BhcnNlLWEtbXVsdGlwYXJ0LWZvcm0tZGF0YS1uYW1lXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFOYW1lIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gQXNzZXJ0OiBUaGUgYnl0ZSBhdCAocG9zaXRpb24gLSAxKSBpcyAweDIyIChcIikuXG4gIGFzc2VydChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiAtIDFdID09PSAweDIyKVxuXG4gIC8vIDIuIExldCBuYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIG5vdCAweDBBIChMRiksIDB4MEQgKENSKSBvciAweDIyIChcIiksIGdpdmVuIHBvc2l0aW9uLlxuICAvKiogQHR5cGUge3N0cmluZyB8IEJ1ZmZlcn0gKi9cbiAgbGV0IG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4MjIsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDMuIElmIHRoZSBieXRlIGF0IHBvc2l0aW9uIGlzIG5vdCAweDIyIChcIiksIHJldHVybiBmYWlsdXJlLiBPdGhlcndpc2UsIGFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgyMikge1xuICAgIHJldHVybiBudWxsIC8vIG5hbWUgY291bGQgYmUgJ2ZhaWx1cmUnXG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gNC4gUmVwbGFjZSBhbnkgb2NjdXJyZW5jZSBvZiB0aGUgZm9sbG93aW5nIHN1YnNlcXVlbmNlcyBpbiBuYW1lIHdpdGggdGhlIGdpdmVuIGJ5dGU6XG4gIC8vIC0gYCUwQWA6IDB4MEEgKExGKVxuICAvLyAtIGAlMERgOiAweDBEIChDUilcbiAgLy8gLSBgJTIyYDogMHgyMiAoXCIpXG4gIG5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmFtZSlcbiAgICAucmVwbGFjZSgvJTBBL2lnLCAnXFxuJylcbiAgICAucmVwbGFjZSgvJTBEL2lnLCAnXFxyJylcbiAgICAucmVwbGFjZSgvJTIyL2csICdcIicpXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSBVVEYtOCBkZWNvZGluZyB3aXRob3V0IEJPTSBvZiBuYW1lLlxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IG51bWJlcikgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICBsZXQgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIHdoaWxlIChzdGFydCA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbc3RhcnRdKSkge1xuICAgICsrc3RhcnRcbiAgfVxuXG4gIHJldHVybiBpbnB1dC5zdWJhcnJheShwb3NpdGlvbi5wb3NpdGlvbiwgKHBvc2l0aW9uLnBvc2l0aW9uID0gc3RhcnQpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSB0cmFpbGluZ1xuICogQHBhcmFtIHsoY2hhckNvZGU6IG51bWJlcikgPT4gYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiByZW1vdmVDaGFycyAoYnVmLCBsZWFkaW5nLCB0cmFpbGluZywgcHJlZGljYXRlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBidWYubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgd2hpbGUgKGxlYWQgPCBidWYubGVuZ3RoICYmIHByZWRpY2F0ZShidWZbbGVhZF0pKSBsZWFkKytcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIHdoaWxlICh0cmFpbCA+IDAgJiYgcHJlZGljYXRlKGJ1Zlt0cmFpbF0pKSB0cmFpbC0tXG4gIH1cblxuICByZXR1cm4gbGVhZCA9PT0gMCAmJiB0cmFpbCA9PT0gYnVmLmxlbmd0aCAtIDEgPyBidWYgOiBidWYuc3ViYXJyYXkobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB7QHBhcmFtIGJ1ZmZlcn0gc3RhcnRzIHdpdGgge0BwYXJhbSBzdGFydH1cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzdGFydFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gYnVmZmVyU3RhcnRzV2l0aCAoYnVmZmVyLCBzdGFydCwgcG9zaXRpb24pIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzdGFydC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGJ1ZmZlcltwb3NpdGlvbi5wb3NpdGlvbiArIGldKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIsXG4gIHZhbGlkYXRlQm91bmRhcnlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isBlobLike, iteratorMixin } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/undici/lib/web/fetch/file.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { File: NativeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\n\n/** @type {globalThis['File']} */\nconst File = globalThis.File ?? NativeFile\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  constructor (form) {\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n\n    this[kState] = []\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.append'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, prefix, 'value', { strict: false })\n      : webidl.converters.USVString(value, prefix, 'value')\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename, prefix, 'filename')\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    this[kState] = this[kState].filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.get'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.getAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.set'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, prefix, 'name', { strict: false })\n      : webidl.converters.USVString(value, prefix, 'name')\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename, prefix, 'name')\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    const state = this[kState].reduce((a, b) => {\n      if (a[b.name]) {\n        if (Array.isArray(a[b.name])) {\n          a[b.name].push(b.value)\n        } else {\n          a[b.name] = [a[b.name], b.value]\n        }\n      } else {\n        a[b.name] = b.value\n      }\n\n      return a\n    }, { __proto__: null })\n\n    options.depth ??= depth\n    options.colors ??= true\n\n    const output = nodeUtil.formatWithOptions(options, state)\n\n    // remove [Object null prototype]\n    return `FormData ${output.slice(output.indexOf(']') + 2)}`\n  }\n}\n\niteratorMixin('FormData', FormData, kState, 'name', 'value')\n\nObject.defineProperties(FormData.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  getAll: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // Note: This operation was done by the webidl converter USVString.\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!isFileLike(value)) {\n      value = value instanceof Blob\n        ? new File([value], 'blob', { type: value.type })\n        : new FileLike(value, 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = value instanceof NativeFile\n        ? new File([value], filename, options)\n        : new FileLike(value, filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nmodule.exports = { FormData, makeEntry }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3RELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDdEMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN6RCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDakQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXBDLFdBQVcsb0JBQW9CO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSSxpQkFBaUI7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hELHdDQUF3QyxrQkFBa0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGZvcm1kYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzQmxvYkxpa2UsIGl0ZXJhdG9yTWl4aW4gfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgRmlsZUxpa2UsIGlzRmlsZUxpa2UgfSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBGaWxlOiBOYXRpdmVGaWxlIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCBub2RlVXRpbCA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbi8qKiBAdHlwZSB7Z2xvYmFsVGhpc1snRmlsZSddfSAqL1xuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyBOYXRpdmVGaWxlXG5cbi8vIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jZm9ybWRhdGFcbmNsYXNzIEZvcm1EYXRhIHtcbiAgY29uc3RydWN0b3IgKGZvcm0pIHtcbiAgICBpZiAoZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgICBwcmVmaXg6ICdGb3JtRGF0YSBjb25zdHJ1Y3RvcicsXG4gICAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICAgIHR5cGVzOiBbJ3VuZGVmaW5lZCddXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXNba1N0YXRlXSA9IFtdXG4gIH1cblxuICBhcHBlbmQgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmFwcGVuZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHByZWZpeClcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmICFpc0Jsb2JMaWtlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kJyBvbiAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMiBpcyBub3Qgb2YgdHlwZSAnQmxvYidcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCBwcmVmaXgsICd2YWx1ZScsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgICAgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcbiAgICBmaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDNcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKGZpbGVuYW1lLCBwcmVmaXgsICdmaWxlbmFtZScpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aFxuICAgIC8vIG5hbWUsIHZhbHVlLCBhbmQgZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gQXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpc1trU3RhdGVdLnB1c2goZW50cnkpXG4gIH1cblxuICBkZWxldGUgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gVGhlIGRlbGV0ZShuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJlbW92ZSBhbGwgZW50cmllcyB3aG9zZSBuYW1lXG4gICAgLy8gaXMgbmFtZSBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgdGhpc1trU3RhdGVdID0gdGhpc1trU3RhdGVdLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICB9XG5cbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuZ2V0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIHRoZXJlIGlzIG5vIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0LFxuICAgIC8vIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgY29uc3QgaWR4ID0gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGZyb21cbiAgICAvLyB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV1baWR4XS52YWx1ZVxuICB9XG5cbiAgZ2V0QWxsIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuZ2V0QWxsJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIHRoZXJlIGlzIG5vIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0LFxuICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBlbXB0eSBsaXN0LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBlbnRyaWVzIHdob3NlIG5hbWUgaXMgbmFtZSwgaW4gb3JkZXIsXG4gICAgLy8gZnJvbSB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV1cbiAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgICAgLm1hcCgoZW50cnkpID0+IGVudHJ5LnZhbHVlKVxuICB9XG5cbiAgaGFzIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuaGFzJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIFRoZSBoYXMobmFtZSkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhbiBlbnRyeVxuICAgIC8vIHdob3NlIG5hbWUgaXMgbmFtZSBpbiB0aGlz4oCZcyBlbnRyeSBsaXN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKSAhPT0gLTFcbiAgfVxuXG4gIHNldCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuc2V0J1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdzZXQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVGhlIHNldChuYW1lLCB2YWx1ZSkgYW5kIHNldChuYW1lLCBibG9iVmFsdWUsIGZpbGVuYW1lKSBtZXRob2Qgc3RlcHNcbiAgICAvLyBhcmU6XG5cbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdmFsdWUgaWYgZ2l2ZW47IG90aGVyd2lzZSBibG9iVmFsdWUuXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gaXNCbG9iTGlrZSh2YWx1ZSlcbiAgICAgID8gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYih2YWx1ZSwgcHJlZml4LCAnbmFtZScsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgICAgOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodmFsdWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIC8vIDIuIExldCBlbnRyeSBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGVudHJ5IHdpdGggbmFtZSwgdmFsdWUsIGFuZFxuICAgIC8vIGZpbGVuYW1lIGlmIGdpdmVuLlxuICAgIGNvbnN0IGVudHJ5ID0gbWFrZUVudHJ5KG5hbWUsIHZhbHVlLCBmaWxlbmFtZSlcblxuICAgIC8vIDMuIElmIHRoZXJlIGFyZSBlbnRyaWVzIGluIHRoaXPigJlzIGVudHJ5IGxpc3Qgd2hvc2UgbmFtZSBpcyBuYW1lLCB0aGVuXG4gICAgLy8gcmVwbGFjZSB0aGUgZmlyc3Qgc3VjaCBlbnRyeSB3aXRoIGVudHJ5IGFuZCByZW1vdmUgdGhlIG90aGVycy5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgdGhpc1trU3RhdGVdID0gW1xuICAgICAgICAuLi50aGlzW2tTdGF0ZV0uc2xpY2UoMCwgaWR4KSxcbiAgICAgICAgZW50cnksXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZShpZHggKyAxKS5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5uYW1lICE9PSBuYW1lKVxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyA0LiBPdGhlcndpc2UsIGFwcGVuZCBlbnRyeSB0byB0aGlz4oCZcyBlbnRyeSBsaXN0LlxuICAgICAgdGhpc1trU3RhdGVdLnB1c2goZW50cnkpXG4gICAgfVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXNba1N0YXRlXS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhW2IubmFtZV0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYVtiLm5hbWVdKSkge1xuICAgICAgICAgIGFbYi5uYW1lXS5wdXNoKGIudmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYVtiLm5hbWVdID0gW2FbYi5uYW1lXSwgYi52YWx1ZV1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYVtiLm5hbWVdID0gYi52YWx1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVxuICAgIH0sIHsgX19wcm90b19fOiBudWxsIH0pXG5cbiAgICBvcHRpb25zLmRlcHRoID8/PSBkZXB0aFxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBvdXRwdXQgPSBub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBzdGF0ZSlcblxuICAgIC8vIHJlbW92ZSBbT2JqZWN0IG51bGwgcHJvdG90eXBlXVxuICAgIHJldHVybiBgRm9ybURhdGEgJHtvdXRwdXQuc2xpY2Uob3V0cHV0LmluZGV4T2YoJ10nKSArIDIpfWBcbiAgfVxufVxuXG5pdGVyYXRvck1peGluKCdGb3JtRGF0YScsIEZvcm1EYXRhLCBrU3RhdGUsICduYW1lJywgJ3ZhbHVlJylcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRm9ybURhdGEucHJvdG90eXBlLCB7XG4gIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdGb3JtRGF0YScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbi8qKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjcmVhdGUtYW4tZW50cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3xCbG9ifSB2YWx1ZVxuICogQHBhcmFtIHs/c3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWFrZUVudHJ5IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpIHtcbiAgLy8gMS4gU2V0IG5hbWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIG5hbWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IHRoZSB3ZWJpZGwgY29udmVydGVyIFVTVlN0cmluZy5cblxuICAvLyAyLiBJZiB2YWx1ZSBpcyBhIHN0cmluZywgdGhlbiBzZXQgdmFsdWUgdG8gdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nXG4gIC8vICAgIHZhbHVlIGludG8gYSBzY2FsYXIgdmFsdWUgc3RyaW5nLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IHRoZSB3ZWJpZGwgY29udmVydGVyIFVTVlN0cmluZy5cbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBJZiB2YWx1ZSBpcyBub3QgYSBGaWxlIG9iamVjdCwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSB2YWx1ZSBpcyBcImJsb2JcIlxuICAgIGlmICghaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBCbG9iXG4gICAgICAgID8gbmV3IEZpbGUoW3ZhbHVlXSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICAgICAgOiBuZXcgRmlsZUxpa2UodmFsdWUsICdibG9iJywgeyB0eXBlOiB2YWx1ZS50eXBlIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgZmlsZW5hbWUgaXMgZ2l2ZW4sIHRoZW4gc2V0IHZhbHVlIHRvIGEgbmV3IEZpbGUgb2JqZWN0LFxuICAgIC8vICAgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBieXRlcywgd2hvc2UgbmFtZSBhdHRyaWJ1dGUgaXMgZmlsZW5hbWUuXG4gICAgaWYgKGZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKiBAdHlwZSB7RmlsZVByb3BlcnR5QmFnfSAqL1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgbGFzdE1vZGlmaWVkOiB2YWx1ZS5sYXN0TW9kaWZpZWRcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIE5hdGl2ZUZpbGVcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCBmaWxlbmFtZSwgb3B0aW9ucylcbiAgICAgICAgOiBuZXcgRmlsZUxpa2UodmFsdWUsIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBhbiBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgYW5kIHdob3NlIHZhbHVlIGlzIHZhbHVlLlxuICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBGb3JtRGF0YSwgbWFrZUVudHJ5IH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0UsbUJBQW1CO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxnbG9iYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcywgaW5jcmVhc2UgdGhlIHZlcnNpb25cbi8vIG51bWJlciB0byBhdm9pZCBjb25mbGljdHMuXG5jb25zdCBnbG9iYWxPcmlnaW4gPSBTeW1ib2wuZm9yKCd1bmRpY2kuZ2xvYmFsT3JpZ2luLjEnKVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxPcmlnaW4gKCkge1xuICByZXR1cm4gZ2xvYmFsVGhpc1tnbG9iYWxPcmlnaW5dXG59XG5cbmZ1bmN0aW9uIHNldEdsb2JhbE9yaWdpbiAobmV3T3JpZ2luKSB7XG4gIGlmIChuZXdPcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxPcmlnaW4sIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwobmV3T3JpZ2luKVxuXG4gIGlmIChwYXJzZWRVUkwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgaHR0cCAmIGh0dHBzIHVybHMgYXJlIGFsbG93ZWQsIHJlY2VpdmVkICR7cGFyc2VkVVJMLnByb3RvY29sfWApXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgdmFsdWU6IHBhcnNlZFVSTCxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRHbG9iYWxPcmlnaW4sXG4gIHNldEdsb2JhbE9yaWdpblxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this[kHeadersMap].delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this[kHeadersMap].values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this[kHeadersMap].size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this[kHeadersMap][Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  #headersList\n\n  constructor (init = undefined) {\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers contructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this.#headersList[kHeadersSortedMap]) {\n      return this.#headersList[kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = this.#headersList.toSortedArray()\n\n    const cookies = this.#headersList.cookies\n\n    // fast-path\n    if (cookies === null || cookies.length === 1) {\n      // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n      return (this.#headersList[kHeadersSortedMap] = names)\n    }\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const { 0: name, 1: value } = names[i]\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        // Note: This operation was done by `HeadersList#toSortedArray`.\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    // 4. Return headers.\n    return (this.#headersList[kHeadersSortedMap] = headers)\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  static setHeadersList (o, list) {\n    o.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object') {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDRCQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkYsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNO0FBQ25ELE9BQU87QUFDUCxNQUFNO0FBQ04sNkNBQTZDLGFBQWE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxVQUFVO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1CLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiwyREFBMkQ7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcaGVhZGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vRXRoYW4tQXJyb3dvb2QvdW5kaWNpLWZldGNoXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7XG4gIGl0ZXJhdG9yTWl4aW4sXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWVcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG5jb25zdCBrSGVhZGVyc01hcCA9IFN5bWJvbCgnaGVhZGVycyBtYXAnKVxuY29uc3Qga0hlYWRlcnNTb3J0ZWRNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwIHNvcnRlZCcpXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlIChjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAweDAwYSB8fCBjb2RlID09PSAweDAwZCB8fCBjb2RlID09PSAweDAwOSB8fCBjb2RlID09PSAweDAyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLXZhbHVlLW5vcm1hbGl6ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGhlYWRlclZhbHVlTm9ybWFsaXplIChwb3RlbnRpYWxWYWx1ZSkge1xuICAvLyAgVG8gbm9ybWFsaXplIGEgYnl0ZSBzZXF1ZW5jZSBwb3RlbnRpYWxWYWx1ZSwgcmVtb3ZlXG4gIC8vICBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGJ5dGVzIGZyb21cbiAgLy8gIHBvdGVudGlhbFZhbHVlLlxuICBsZXQgaSA9IDA7IGxldCBqID0gcG90ZW50aWFsVmFsdWUubGVuZ3RoXG5cbiAgd2hpbGUgKGogPiBpICYmIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZShwb3RlbnRpYWxWYWx1ZS5jaGFyQ29kZUF0KGogLSAxKSkpIC0talxuICB3aGlsZSAoaiA+IGkgJiYgaXNIVFRQV2hpdGVTcGFjZUNoYXJDb2RlKHBvdGVudGlhbFZhbHVlLmNoYXJDb2RlQXQoaSkpKSArK2lcblxuICByZXR1cm4gaSA9PT0gMCAmJiBqID09PSBwb3RlbnRpYWxWYWx1ZS5sZW5ndGggPyBwb3RlbnRpYWxWYWx1ZSA6IHBvdGVudGlhbFZhbHVlLnN1YnN0cmluZyhpLCBqKVxufVxuXG5mdW5jdGlvbiBmaWxsIChoZWFkZXJzLCBvYmplY3QpIHtcbiAgLy8gVG8gZmlsbCBhIEhlYWRlcnMgb2JqZWN0IGhlYWRlcnMgd2l0aCBhIGdpdmVuIG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBzZXF1ZW5jZSwgdGhlbiBmb3IgZWFjaCBoZWFkZXIgaW4gb2JqZWN0OlxuICAvLyBOb3RlOiB3ZWJpZGwgY29udmVyc2lvbiB0byBhcnJheSBoYXMgYWxyZWFkeSBiZWVuIGRvbmUuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaGVhZGVyID0gb2JqZWN0W2ldXG4gICAgICAvLyAxLiBJZiBoZWFkZXIgZG9lcyBub3QgY29udGFpbiBleGFjdGx5IHR3byBpdGVtcywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChoZWFkZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgICBtZXNzYWdlOiBgZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCAke2hlYWRlci5sZW5ndGh9LmBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIChoZWFkZXLigJlzIGZpcnN0IGl0ZW0sIGhlYWRlcuKAmXMgc2Vjb25kIGl0ZW0pIHRvIGhlYWRlcnMuXG4gICAgICBhcHBlbmRIZWFkZXIoaGVhZGVycywgaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIC8vIE5vdGU6IG51bGwgc2hvdWxkIHRocm93XG5cbiAgICAvLyAyLiBPdGhlcndpc2UsIG9iamVjdCBpcyBhIHJlY29yZCwgdGhlbiBmb3IgZWFjaCBrZXkg4oaSIHZhbHVlIGluIG9iamVjdCxcbiAgICAvLyAgICBhcHBlbmQgKGtleSwgdmFsdWUpIHRvIGhlYWRlcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgYXBwZW5kSGVhZGVyKGhlYWRlcnMsIGtleXNbaV0sIG9iamVjdFtrZXlzW2ldXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgIHR5cGVzOiBbJ3NlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PicsICdyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlcnMtYXBwZW5kXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZEhlYWRlciAoaGVhZGVycywgbmFtZSwgdmFsdWUpIHtcbiAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICB2YWx1ZSA9IGhlYWRlclZhbHVlTm9ybWFsaXplKHZhbHVlKVxuXG4gIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoIWlzVmFsaWRIZWFkZXJOYW1lKG5hbWUpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgcHJlZml4OiAnSGVhZGVycy5hcHBlbmQnLFxuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgfSlcbiAgfSBlbHNlIGlmICghaXNWYWxpZEhlYWRlclZhbHVlKHZhbHVlKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlLFxuICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgLy8gNC4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAvLyA1LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCI6XG4gIC8vICAgIFRPRE9cbiAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gIGlmIChnZXRIZWFkZXJzR3VhcmQoaGVhZGVycykgPT09ICdpbW11dGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG5cbiAgLy8gNy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gIHJldHVybiBnZXRIZWFkZXJzTGlzdChoZWFkZXJzKS5hcHBlbmQobmFtZSwgdmFsdWUsIGZhbHNlKVxuXG4gIC8vIDguIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSBoZWFkZXJzXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVIZWFkZXJOYW1lIChhLCBiKSB7XG4gIHJldHVybiBhWzBdIDwgYlswXSA/IC0xIDogMVxufVxuXG5jbGFzcyBIZWFkZXJzTGlzdCB7XG4gIC8qKiBAdHlwZSB7W3N0cmluZywgc3RyaW5nXVtdfG51bGx9ICovXG4gIGNvb2tpZXMgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKGluaXQpIHtcbiAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEhlYWRlcnNMaXN0KSB7XG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXSA9IG5ldyBNYXAoaW5pdFtrSGVhZGVyc01hcF0pXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IGluaXRba0hlYWRlcnNTb3J0ZWRNYXBdXG4gICAgICB0aGlzLmNvb2tpZXMgPSBpbml0LmNvb2tpZXMgPT09IG51bGwgPyBudWxsIDogWy4uLmluaXQuY29va2llc11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXQpXG4gICAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLWxpc3QtY29udGFpbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgY29udGFpbnMgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gQSBoZWFkZXIgbGlzdCBsaXN0IGNvbnRhaW5zIGEgaGVhZGVyIG5hbWUgbmFtZSBpZiBsaXN0XG4gICAgLy8gY29udGFpbnMgYSBoZWFkZXIgd2hvc2UgbmFtZSBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZVxuICAgIC8vIG1hdGNoIGZvciBuYW1lLlxuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLmhhcyhpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKCkpXG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpc1trSGVhZGVyc01hcF0uY2xlYXIoKVxuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWFwcGVuZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgYXBwZW5kIChuYW1lLCB2YWx1ZSwgaXNMb3dlckNhc2UpIHtcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgbmFtZSB0byB0aGUgZmlyc3Qgc3VjaFxuICAgIC8vICAgIGhlYWRlcuKAmXMgbmFtZS5cbiAgICBjb25zdCBsb3dlcmNhc2VOYW1lID0gaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgZXhpc3RzID0gdGhpc1trSGVhZGVyc01hcF0uZ2V0KGxvd2VyY2FzZU5hbWUpXG5cbiAgICAvLyAyLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGxvd2VyY2FzZU5hbWUgPT09ICdjb29raWUnID8gJzsgJyA6ICcsICdcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7XG4gICAgICAgIG5hbWU6IGV4aXN0cy5uYW1lLFxuICAgICAgICB2YWx1ZTogYCR7ZXhpc3RzLnZhbHVlfSR7ZGVsaW1pdGVyfSR7dmFsdWV9YFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgICB9XG5cbiAgICBpZiAobG93ZXJjYXNlTmFtZSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAodGhpcy5jb29raWVzID8/PSBbXSkucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIHNldCAobmFtZSwgdmFsdWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gW3ZhbHVlXVxuICAgIH1cblxuICAgIC8vIDEuIElmIGxpc3QgY29udGFpbnMgbmFtZSwgdGhlbiBzZXQgdGhlIHZhbHVlIG9mXG4gICAgLy8gICAgdGhlIGZpcnN0IHN1Y2ggaGVhZGVyIHRvIHZhbHVlIGFuZCByZW1vdmUgdGhlXG4gICAgLy8gICAgb3RoZXJzLlxuICAgIC8vIDIuIE90aGVyd2lzZSwgYXBwZW5kIGhlYWRlciAobmFtZSwgdmFsdWUpIHRvIGxpc3QuXG4gICAgdGhpc1trSGVhZGVyc01hcF0uc2V0KGxvd2VyY2FzZU5hbWUsIHsgbmFtZSwgdmFsdWUgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWRlbGV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBkZWxldGUgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgaWYgKCFpc0xvd2VyQ2FzZSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgdGhpcy5jb29raWVzID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXNba0hlYWRlcnNNYXBdLmRlbGV0ZShuYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXQgKG5hbWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgLy8gMS4gSWYgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW4gcmV0dXJuIG51bGwuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgLy8gICAgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIG5hbWUsXG4gICAgLy8gICAgc2VwYXJhdGVkIGZyb20gZWFjaCBvdGhlciBieSAweDJDIDB4MjAsIGluIG9yZGVyLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5nZXQoaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpKT8udmFsdWUgPz8gbnVsbFxuICB9XG5cbiAgKiBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgLy8gdXNlIHRoZSBsb3dlcmNhc2VkIG5hbWVcbiAgICBmb3IgKGNvbnN0IHsgMDogbmFtZSwgMTogeyB2YWx1ZSB9IH0gb2YgdGhpc1trSGVhZGVyc01hcF0pIHtcbiAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV1cbiAgICB9XG4gIH1cblxuICBnZXQgZW50cmllcyAoKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9XG5cbiAgICBpZiAodGhpc1trSGVhZGVyc01hcF0uc2l6ZSAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgdGhpc1trSGVhZGVyc01hcF0udmFsdWVzKCkpIHtcbiAgICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIHJhd1ZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpXG4gIH1cblxuICBnZXQgZW50cmllc0xpc3QgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgaWYgKHRoaXNba0hlYWRlcnNNYXBdLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyAwOiBsb3dlck5hbWUsIDE6IHsgbmFtZSwgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICAgIGlmIChsb3dlck5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIHRoaXMuY29va2llcykge1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCBjb29raWVdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29udmVydC1oZWFkZXItbmFtZXMtdG8tYS1zb3J0ZWQtbG93ZXJjYXNlLXNldFxuICB0b1NvcnRlZEFycmF5ICgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpc1trSGVhZGVyc01hcF0uc2l6ZVxuICAgIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KHNpemUpXG4gICAgLy8gSW4gbW9zdCBjYXNlcywgeW91IHdpbGwgdXNlIHRoZSBmYXN0LXBhdGguXG4gICAgLy8gZmFzdC1wYXRoOiBVc2UgYmluYXJ5IGluc2VydGlvbiBzb3J0IGZvciBzbWFsbCBhcnJheXMuXG4gICAgaWYgKHNpemUgPD0gMzIpIHtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIC8vIElmIGVtcHR5LCBpdCBpcyBhbiBlbXB0eSBhcnJheS4gVG8gYXZvaWQgdGhlIGZpcnN0IGluZGV4IGFzc2lnbm1lbnQuXG4gICAgICAgIHJldHVybiBhcnJheVxuICAgICAgfVxuICAgICAgLy8gSW1wcm92ZSBwZXJmb3JtYW5jZSBieSB1bnJvbGxpbmcgbG9vcCBhbmQgYXZvaWRpbmcgZG91YmxlLWxvb3AuXG4gICAgICAvLyBEb3VibGUtbG9vcC1sZXNzIHZlcnNpb24gb2YgdGhlIGJpbmFyeSBpbnNlcnRpb24gc29ydC5cbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpc1trSGVhZGVyc01hcF1bU3ltYm9sLml0ZXJhdG9yXSgpXG4gICAgICBjb25zdCBmaXJzdFZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBmaXJzdCBpbmRleC5cbiAgICAgIGFycmF5WzBdID0gW2ZpcnN0VmFsdWVbMF0sIGZpcnN0VmFsdWVbMV0udmFsdWVdXG4gICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAvLyAzLjIuMi4gQXNzZXJ0OiB2YWx1ZSBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChmaXJzdFZhbHVlWzFdLnZhbHVlICE9PSBudWxsKVxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IGkgPSAxLCBqID0gMCwgcmlnaHQgPSAwLCBsZWZ0ID0gMCwgcGl2b3QgPSAwLCB4LCB2YWx1ZTtcbiAgICAgICAgaSA8IHNpemU7XG4gICAgICAgICsraVxuICAgICAgKSB7XG4gICAgICAgIC8vIGdldCBuZXh0IHZhbHVlXG4gICAgICAgIHZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlXG4gICAgICAgIC8vIHNldCBbbmFtZSwgdmFsdWVdIHRvIGN1cnJlbnQgaW5kZXguXG4gICAgICAgIHggPSBhcnJheVtpXSA9IFt2YWx1ZVswXSwgdmFsdWVbMV0udmFsdWVdXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh4WzFdICE9PSBudWxsKVxuICAgICAgICBsZWZ0ID0gMFxuICAgICAgICByaWdodCA9IGlcbiAgICAgICAgLy8gYmluYXJ5IHNlYXJjaFxuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgLy8gbWlkZGxlIGluZGV4XG4gICAgICAgICAgcGl2b3QgPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpID4+IDEpXG4gICAgICAgICAgLy8gY29tcGFyZSBoZWFkZXIgbmFtZVxuICAgICAgICAgIGlmIChhcnJheVtwaXZvdF1bMF0gPD0geFswXSkge1xuICAgICAgICAgICAgbGVmdCA9IHBpdm90ICsgMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaWdodCA9IHBpdm90XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9PSBwaXZvdCkge1xuICAgICAgICAgIGogPSBpXG4gICAgICAgICAgd2hpbGUgKGogPiBsZWZ0KSB7XG4gICAgICAgICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXlbbGVmdF0gPSB4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbiAgICAgIGlmICghaXRlcmF0b3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgZGVidWdnaW5nIGFuZCB3aWxsIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FzZSB3b3VsZCBiZSBhIHJhcmUgb2NjdXJyZW5jZS5cbiAgICAgIC8vIHNsb3ctcGF0aDogZmFsbGJhY2tcbiAgICAgIGxldCBpID0gMFxuICAgICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICAgIGFycmF5W2krK10gPSBbbmFtZSwgdmFsdWVdXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LXNvcnQtYW5kLWNvbWJpbmVcbiAgICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gbnVsbClcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheS5zb3J0KGNvbXBhcmVIZWFkZXJOYW1lKVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVycy1jbGFzc1xuY2xhc3MgSGVhZGVycyB7XG4gICNndWFyZFxuICAjaGVhZGVyc0xpc3RcblxuICBjb25zdHJ1Y3RvciAoaW5pdCA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChpbml0ID09PSBrQ29uc3RydWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLiNoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAvLyBUaGUgbmV3IEhlYWRlcnMoaW5pdCkgY29uc3RydWN0b3Igc3RlcHMgYXJlOlxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIGd1YXJkIHRvIFwibm9uZVwiLlxuICAgIHRoaXMuI2d1YXJkID0gJ25vbmUnXG5cbiAgICAvLyAyLiBJZiBpbml0IGlzIGdpdmVuLCB0aGVuIGZpbGwgdGhpcyB3aXRoIGluaXQuXG4gICAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0KGluaXQsICdIZWFkZXJzIGNvbnRydWN0b3InLCAnaW5pdCcpXG4gICAgICBmaWxsKHRoaXMsIGluaXQpXG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWFwcGVuZFxuICBhcHBlbmQgKG5hbWUsIHZhbHVlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ0hlYWRlcnMuYXBwZW5kJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmFwcGVuZCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJylcblxuICAgIHJldHVybiBhcHBlbmRIZWFkZXIodGhpcywgbmFtZSwgdmFsdWUpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZGVsZXRlXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmRlbGV0ZScpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5kZWxldGUnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4OiAnSGVhZGVycy5kZWxldGUnLFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcImltbXV0YWJsZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAgIC8vICAgIGZvcmJpZGRlbiBoZWFkZXIgbmFtZSwgcmV0dXJuLlxuICAgIC8vIDQuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgbmFtZVxuICAgIC8vICAgIGlzIG5vdCBhIG5vLUNPUlMtc2FmZWxpc3RlZCByZXF1ZXN0LWhlYWRlciBuYW1lLCBhbmRcbiAgICAvLyAgICBuYW1lIGlzIG5vdCBhIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpc1xuICAgIC8vICAgIGEgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA2LiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIG5hbWUsIHRoZW5cbiAgICAvLyAgICByZXR1cm4uXG4gICAgaWYgKCF0aGlzLiNoZWFkZXJzTGlzdC5jb250YWlucyhuYW1lLCBmYWxzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDcuIERlbGV0ZSBuYW1lIGZyb20gdGhpc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgLy8gOC4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0LW5vLWNvcnNcIiwgdGhlbiByZW1vdmVcbiAgICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhpcy5cbiAgICB0aGlzLiNoZWFkZXJzTGlzdC5kZWxldGUobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtZ2V0XG4gIGdldCAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmdldCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5nZXQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXJcbiAgICAvLyAgICBsaXN0LlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdC5nZXQobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtaGFzXG4gIGhhcyAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdIZWFkZXJzLmhhcycpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5oYXMnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyAxLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBuYW1lO1xuICAgIC8vICAgIG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpcy4jaGVhZGVyc0xpc3QuY29udGFpbnMobmFtZSwgZmFsc2UpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtc2V0XG4gIHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnSGVhZGVycy5zZXQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuc2V0J1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgLy8gMS4gTm9ybWFsaXplIHZhbHVlLlxuICAgIHZhbHVlID0gaGVhZGVyVmFsdWVOb3JtYWxpemUodmFsdWUpXG5cbiAgICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gICAgLy8gICAgaGVhZGVyIHZhbHVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICghaXNWYWxpZEhlYWRlck5hbWUobmFtZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZTogbmFtZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkSGVhZGVyVmFsdWUodmFsdWUpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiIGFuZFxuICAgIC8vICAgIG5hbWUvdmFsdWUgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyLFxuICAgIC8vICAgIHJldHVybi5cbiAgICAvLyA2LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBmb3JiaWRkZW4gaGVhZGVyIG5hbWVzXG4gICAgaWYgKHRoaXMuI2d1YXJkID09PSAnaW1tdXRhYmxlJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW1tdXRhYmxlJylcbiAgICB9XG5cbiAgICAvLyA3LiBTZXQgKG5hbWUsIHZhbHVlKSBpbiB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzXG4gICAgdGhpcy4jaGVhZGVyc0xpc3Quc2V0KG5hbWUsIHZhbHVlLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRzZXRjb29raWVcbiAgZ2V0U2V0Q29va2llICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgU2V0LUNvb2tpZWAsIHRoZW4gcmV0dXJuIMKrIMK7LlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIHRoaXPigJlzIGhlYWRlciBsaXN0IHdob3NlIG5hbWUgaXNcbiAgICAvLyAgICBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYFNldC1Db29raWVgLCBpbiBvcmRlci5cblxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNoZWFkZXJzTGlzdC5jb29raWVzXG5cbiAgICBpZiAobGlzdCkge1xuICAgICAgcmV0dXJuIFsuLi5saXN0XVxuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICBnZXQgW2tIZWFkZXJzU29ydGVkTWFwXSAoKSB7XG4gICAgaWYgKHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXVxuICAgIH1cblxuICAgIC8vIDEuIExldCBoZWFkZXJzIGJlIGFuIGVtcHR5IGxpc3Qgb2YgaGVhZGVycyB3aXRoIHRoZSBrZXkgYmVpbmcgdGhlIG5hbWVcbiAgICAvLyAgICBhbmQgdmFsdWUgdGhlIHZhbHVlLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXVxuXG4gICAgLy8gMi4gTGV0IG5hbWVzIGJlIHRoZSByZXN1bHQgb2YgY29udmVydCBoZWFkZXIgbmFtZXMgdG8gYSBzb3J0ZWQtbG93ZXJjYXNlXG4gICAgLy8gICAgc2V0IHdpdGggYWxsIHRoZSBuYW1lcyBvZiB0aGUgaGVhZGVycyBpbiBsaXN0LlxuICAgIGNvbnN0IG5hbWVzID0gdGhpcy4jaGVhZGVyc0xpc3QudG9Tb3J0ZWRBcnJheSgpXG5cbiAgICBjb25zdCBjb29raWVzID0gdGhpcy4jaGVhZGVyc0xpc3QuY29va2llc1xuXG4gICAgLy8gZmFzdC1wYXRoXG4gICAgaWYgKGNvb2tpZXMgPT09IG51bGwgfHwgY29va2llcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBub24tbnVsbCBhc3NlcnRpb24gb2YgdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBkb25lIGJ5IGBIZWFkZXJzTGlzdCN0b1NvcnRlZEFycmF5YFxuICAgICAgcmV0dXJuICh0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF0gPSBuYW1lcylcbiAgICB9XG5cbiAgICAvLyAzLiBGb3IgZWFjaCBuYW1lIG9mIG5hbWVzOlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHsgMDogbmFtZSwgMTogdmFsdWUgfSA9IG5hbWVzW2ldXG4gICAgICAvLyAxLiBJZiBuYW1lIGlzIGBzZXQtY29va2llYCwgdGhlbjpcbiAgICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgLy8gMS4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBvZiBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgICAgICAvLyAgICBpcyBhIGJ5dGUtY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgbmFtZSwgaW4gb3JkZXIuXG5cbiAgICAgICAgLy8gMi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICAgICAgICAvLyAxLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvb2tpZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIGNvb2tpZXNbal1dKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBPdGhlcndpc2U6XG5cbiAgICAgICAgLy8gMS4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gbGlzdC5cblxuICAgICAgICAvLyAyLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICAvLyBOb3RlOiBUaGlzIG9wZXJhdGlvbiB3YXMgZG9uZSBieSBgSGVhZGVyc0xpc3QjdG9Tb3J0ZWRBcnJheWAuXG5cbiAgICAgICAgLy8gMy4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gaGVhZGVycy5cbiAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIGhlYWRlcnMuXG4gICAgcmV0dXJuICh0aGlzLiNoZWFkZXJzTGlzdFtrSGVhZGVyc1NvcnRlZE1hcF0gPSBoZWFkZXJzKVxuICB9XG5cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG5cbiAgICByZXR1cm4gYEhlYWRlcnMgJHt1dGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHRoaXMuI2hlYWRlcnNMaXN0LmVudHJpZXMpfWBcbiAgfVxuXG4gIHN0YXRpYyBnZXRIZWFkZXJzR3VhcmQgKG8pIHtcbiAgICByZXR1cm4gby4jZ3VhcmRcbiAgfVxuXG4gIHN0YXRpYyBzZXRIZWFkZXJzR3VhcmQgKG8sIGd1YXJkKSB7XG4gICAgby4jZ3VhcmQgPSBndWFyZFxuICB9XG5cbiAgc3RhdGljIGdldEhlYWRlcnNMaXN0IChvKSB7XG4gICAgcmV0dXJuIG8uI2hlYWRlcnNMaXN0XG4gIH1cblxuICBzdGF0aWMgc2V0SGVhZGVyc0xpc3QgKG8sIGxpc3QpIHtcbiAgICBvLiNoZWFkZXJzTGlzdCA9IGxpc3RcbiAgfVxufVxuXG5jb25zdCB7IGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0d1YXJkLCBnZXRIZWFkZXJzTGlzdCwgc2V0SGVhZGVyc0xpc3QgfSA9IEhlYWRlcnNcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ2dldEhlYWRlcnNHdWFyZCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdzZXRIZWFkZXJzR3VhcmQnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnZ2V0SGVhZGVyc0xpc3QnKVxuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnc2V0SGVhZGVyc0xpc3QnKVxuXG5pdGVyYXRvck1peGluKCdIZWFkZXJzJywgSGVhZGVycywga0hlYWRlcnNTb3J0ZWRNYXAsIDAsIDEpXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG4gIGFwcGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZGVsZXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGhhczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2V0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBnZXRTZXRDb29raWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdIZWFkZXJzJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dOiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBjb25zdCBpdGVyYXRvciA9IFJlZmxlY3QuZ2V0KFYsIFN5bWJvbC5pdGVyYXRvcilcblxuICAgIC8vIEEgd29yay1hcm91bmQgdG8gZW5zdXJlIHdlIHNlbmQgdGhlIHByb3Blcmx5LWNhc2VkIEhlYWRlcnMgd2hlbiBWIGlzIGEgSGVhZGVycyBvYmplY3QuXG4gICAgLy8gUmVhZCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzMxNTkjaXNzdWVjb21tZW50LTIwNzU1MzcyMjYgYmVmb3JlIHRvdWNoaW5nLCBwbGVhc2UuXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUHJveHkoVikgJiYgaXRlcmF0b3IgPT09IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMpIHsgLy8gSGVhZGVycyBvYmplY3RcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBnZXRIZWFkZXJzTGlzdChWKS5lbnRyaWVzTGlzdFxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIGZhbGwtdGhyb3VnaFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10oViwgcHJlZml4LCBhcmd1bWVudCwgaXRlcmF0b3IuYmluZChWKSlcbiAgICB9XG5cbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgIHByZWZpeDogJ0hlYWRlcnMgY29uc3RydWN0b3InLFxuICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgdHlwZXM6IFsnc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+JywgJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaWxsLFxuICAvLyBmb3IgdGVzdC5cbiAgY29tcGFyZUhlYWRlck5hbWUsXG4gIEhlYWRlcnMsXG4gIEhlYWRlcnNMaXN0LFxuICBnZXRIZWFkZXJzR3VhcmQsXG4gIHNldEhlYWRlcnNHdWFyZCxcbiAgc2V0SGVhZGVyc0xpc3QsXG4gIGdldEhlYWRlcnNMaXN0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse\n} = __webpack_require__(/*! ./response */ \"(ssr)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { Request, cloneRequest } = __webpack_require__(/*! ./request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\nconst { Readable, pipeline, finished } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: requestObject[kDispatcher] // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range', true)\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL)\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntry’s object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blob’s size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blob’s type.\n      const type = blob.type\n\n      // 8. If request’s header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set response’s status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set response’s body to bodyWithType’s body.\n        response.body = bodyWithType[0]\n\n        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set response’s range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength − rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength − 1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set response’s body to slicedBodyWithType’s body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set response’s status to 206.\n        response.status = 206\n\n        // 14. Set response’s status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (fetchParams.request.url.protocol !== 'https:') {\n        return\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        // TODO: update markresourcetiming\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent)\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = async () => {\n    await fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      },\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.onAborted = onAborted\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n          // time, and fetchParams’s cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfo’s final network-request start time to the coarsened shared current time given\n          // fetchParams’s cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfo’s final network-response start time to the coarsened shared current\n          // time given fetchParams’s cross-origin isolated capability, immediately after the\n          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          /** @type {string[]} */\n          let codings = []\n          let location = ''\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const contentEncoding = headersList.get('content-encoding', true)\n          if (contentEncoding) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            // \"All content-coding values are case-insensitive...\"\n            codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())\n          }\n          location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (let i = 0; i < codings.length; ++i) {\n              const coding = codings[i]\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate())\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress())\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, () => { })\n              : this.body.on('error', () => { })\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          if (fetchParams.controller.onAborted) {\n            fetchParams.controller.off('terminated', fetchParams.controller.onAborted)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDeEIsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUMzQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDckQsYUFBYSxtQkFBTyxDQUFDLDRCQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGlDQUFpQyxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDekIsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5RCxRQUFRLHdFQUF3RSxFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQzNHLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNoRyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDdEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1DQUFtQztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTs7QUFFcEIsVUFBVSxtQkFBbUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQXVDO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFdBQVc7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBdUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGdCQUFnQjs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Es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QTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBtYWtlTmV0d29ya0Vycm9yLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBtYWtlUmVzcG9uc2UsXG4gIGZyb21Jbm5lclJlc3BvbnNlXG59ID0gcmVxdWlyZSgnLi9yZXNwb25zZScpXG5jb25zdCB7IEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBSZXF1ZXN0LCBjbG9uZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbm9kZTp6bGliJylcbmNvbnN0IHtcbiAgYnl0ZXNNYXRjaCxcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIHJlcXVlc3RCYWRQb3J0LFxuICBUQU9DaGVjayxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGlzQmxvYkxpa2UsXG4gIHNhbWVPcmlnaW4sXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgdXJsSGFzSHR0cHNTY2hlbWUsXG4gIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlLCBrRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgc2FmZWx5RXh0cmFjdEJvZHksIGV4dHJhY3RCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzU2V0LFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgc3VicmVzb3VyY2VTZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHsgUmVhZGFibGUsIHBpcGVsaW5lLCBmaW5pc2hlZCB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBhZGRBYm9ydExpc3RlbmVyLCBpc0Vycm9yZWQsIGlzUmVhZGFibGUsIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGRhdGFVUkxQcm9jZXNzb3IsIHNlcmlhbGl6ZUFNaW1lVHlwZSwgbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2dsb2JhbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCBHRVRfT1JfSEVBRCA9IFsnR0VUJywgJ0hFQUQnXVxuXG5jb25zdCBkZWZhdWx0VXNlckFnZW50ID0gdHlwZW9mIF9fVU5ESUNJX0lTX05PREVfXyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVzYnVpbGREZXRlY3Rpb24gIT09ICd1bmRlZmluZWQnXG4gID8gJ25vZGUnXG4gIDogJ3VuZGljaSdcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2J1ZmZlcicpLnJlc29sdmVPYmplY3RVUkx9ICovXG5sZXQgcmVzb2x2ZU9iamVjdFVSTFxuXG5jbGFzcyBGZXRjaCBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoZXIpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyXG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuZHVtcCA9IGZhbHNlXG4gICAgdGhpcy5zdGF0ZSA9ICdvbmdvaW5nJ1xuICB9XG5cbiAgdGVybWluYXRlIChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KHJlYXNvbilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCByZWFzb24pXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtY29udHJvbGxlci1hYm9ydFxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAxLiBTZXQgY29udHJvbGxlcuKAmXMgc3RhdGUgdG8gXCJhYm9ydGVkXCIuXG4gICAgdGhpcy5zdGF0ZSA9ICdhYm9ydGVkJ1xuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrRXJyb3IgYmUgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIC8vIDMuIFNldCBlcnJvciB0byBmYWxsYmFja0Vycm9yIGlmIGl0IGlzIG5vdCBnaXZlbi5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIExldCBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShlcnJvcikuXG4gICAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIGNhdGNoIGl0LCBhbmQgbGV0XG4gICAgLy8gICAgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZmFsbGJhY2tFcnJvcikuXG5cbiAgICAvLyA1LiBTZXQgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gdG8gc2VyaWFsaXplZEVycm9yLlxuICAgIHRoaXMuc2VyaWFsaXplZEFib3J0UmVhc29uID0gZXJyb3JcblxuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShlcnJvcilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCBlcnJvcilcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGZXRjaERvbmUgKHJlc3BvbnNlKSB7XG4gIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCAnZmV0Y2gnKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtbWV0aG9kXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2xvYmFsVGhpcy5mZXRjaCcpXG5cbiAgLy8gMS4gTGV0IHAgYmUgYSBuZXcgcHJvbWlzZS5cbiAgbGV0IHAgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDIuIExldCByZXF1ZXN0T2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAgLy8gUmVxdWVzdCBhcyBjb25zdHJ1Y3RvciB3aXRoIGlucHV0IGFuZCBpbml0IGFzIGFyZ3VtZW50cy4gSWYgdGhpcyB0aHJvd3NcbiAgLy8gYW4gZXhjZXB0aW9uLCByZWplY3QgcCB3aXRoIGl0IGFuZCByZXR1cm4gcC5cbiAgbGV0IHJlcXVlc3RPYmplY3RcblxuICB0cnkge1xuICAgIHJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHAucmVqZWN0KGUpXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gMy4gTGV0IHJlcXVlc3QgYmUgcmVxdWVzdE9iamVjdOKAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RPYmplY3Rba1N0YXRlXVxuXG4gIC8vIDQuIElmIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgaWYgKHJlcXVlc3RPYmplY3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAvLyAxLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgbnVsbCwgYW5kXG4gICAgLy8gICAgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCBudWxsLCByZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAvLyAyLiBSZXR1cm4gcC5cbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyA1LiBMZXQgZ2xvYmFsT2JqZWN0IGJlIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgY29uc3QgZ2xvYmFsT2JqZWN0ID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgLy8gNi4gSWYgZ2xvYmFsT2JqZWN0IGlzIGEgU2VydmljZVdvcmtlckdsb2JhbFNjb3BlIG9iamVjdCwgdGhlbiBzZXRcbiAgLy8gcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gIGlmIChnbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnU2VydmljZVdvcmtlckdsb2JhbFNjb3BlJykge1xuICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgfVxuXG4gIC8vIDcuIExldCByZXNwb25zZU9iamVjdCBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2VPYmplY3QgPSBudWxsXG5cbiAgLy8gOC4gTGV0IHJlbGV2YW50UmVhbG0gYmUgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG5cbiAgLy8gOS4gTGV0IGxvY2FsbHlBYm9ydGVkIGJlIGZhbHNlLlxuICBsZXQgbG9jYWxseUFib3J0ZWQgPSBmYWxzZVxuXG4gIC8vIDEwLiBMZXQgY29udHJvbGxlciBiZSBudWxsLlxuICBsZXQgY29udHJvbGxlciA9IG51bGxcblxuICAvLyAxMS4gQWRkIHRoZSBmb2xsb3dpbmcgYWJvcnQgc3RlcHMgdG8gcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFsOlxuICBhZGRBYm9ydExpc3RlbmVyKFxuICAgIHJlcXVlc3RPYmplY3Quc2lnbmFsLFxuICAgICgpID0+IHtcbiAgICAgIC8vIDEuIFNldCBsb2NhbGx5QWJvcnRlZCB0byB0cnVlLlxuICAgICAgbG9jYWxseUFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIEFzc2VydDogY29udHJvbGxlciBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChjb250cm9sbGVyICE9IG51bGwpXG5cbiAgICAgIC8vIDMuIEFib3J0IGNvbnRyb2xsZXIgd2l0aCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQocmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgICBjb25zdCByZWFsUmVzcG9uc2UgPSByZXNwb25zZU9iamVjdD8uZGVyZWYoKVxuXG4gICAgICAvLyA0LiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsXG4gICAgICAvLyAgICBhbmQgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlYWxSZXNwb25zZSwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuICAgIH1cbiAgKVxuXG4gIC8vIDEyLiBMZXQgaGFuZGxlRmV0Y2hEb25lIGdpdmVuIHJlc3BvbnNlIHJlc3BvbnNlIGJlIHRvIGZpbmFsaXplIGFuZFxuICAvLyByZXBvcnQgdGltaW5nIHdpdGggcmVzcG9uc2UsIGdsb2JhbE9iamVjdCwgYW5kIFwiZmV0Y2hcIi5cbiAgLy8gc2VlIGZ1bmN0aW9uIGhhbmRsZUZldGNoRG9uZVxuXG4gIC8vIDEzLiBTZXQgY29udHJvbGxlciB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZmV0Y2ggZ2l2ZW4gcmVxdWVzdCxcbiAgLy8gd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIGhhbmRsZUZldGNoRG9uZSwgYW5kIHByb2Nlc3NSZXNwb25zZVxuICAvLyBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdWJzdGVwczpcblxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAvLyAxLiBJZiBsb2NhbGx5QWJvcnRlZCBpcyB0cnVlLCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKGxvY2FsbHlBYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBJZiByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgLy8gMS4gTGV0IGRlc2VyaWFsaXplZEVycm9yIGJlIHRoZSByZXN1bHQgb2YgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkXG4gICAgICAvLyAgICBhYm9ydCByZWFzb24gZ2l2ZW4gY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kXG4gICAgICAvLyAgICByZWxldmFudFJlYWxtLlxuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGFuZFxuICAgICAgLy8gICAgZGVzZXJpYWxpemVkRXJyb3IuXG5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlamVjdCBwIHdpdGggYSBUeXBlRXJyb3JcbiAgICAvLyBhbmQgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBwLnJlamVjdChuZXcgVHlwZUVycm9yKCdmZXRjaCBmYWlsZWQnLCB7IGNhdXNlOiByZXNwb25zZS5lcnJvciB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZU9iamVjdCB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgcmVsZXZhbnRSZWFsbS5cbiAgICByZXNwb25zZU9iamVjdCA9IG5ldyBXZWFrUmVmKGZyb21Jbm5lclJlc3BvbnNlKHJlc3BvbnNlLCAnaW1tdXRhYmxlJykpXG5cbiAgICAvLyA1LiBSZXNvbHZlIHAgd2l0aCByZXNwb25zZU9iamVjdC5cbiAgICBwLnJlc29sdmUocmVzcG9uc2VPYmplY3QuZGVyZWYoKSlcbiAgICBwID0gbnVsbFxuICB9XG5cbiAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBkaXNwYXRjaGVyOiByZXF1ZXN0T2JqZWN0W2tEaXNwYXRjaGVyXSAvLyB1bmRpY2lcbiAgfSlcblxuICAvLyAxNC4gUmV0dXJuIHAuXG4gIHJldHVybiBwLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLWFuZC1yZXBvcnQtdGltaW5nXG5mdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyAocmVzcG9uc2UsIGluaXRpYXRvclR5cGUgPSAnb3RoZXInKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmIHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBudWxsIG9yIGVtcHR5LCB0aGVuIHJldHVybi5cbiAgaWYgKCFyZXNwb25zZS51cmxMaXN0Py5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDMuIExldCBvcmlnaW5hbFVSTCBiZSByZXNwb25zZeKAmXMgVVJMIGxpc3RbMF0uXG4gIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXVxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvXG5cbiAgLy8gNS4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAvLyA2LiBJZiBvcmlnaW5hbFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUob3JpZ2luYWxVUkwpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA3LiBJZiB0aW1pbmdJbmZvIGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gOC4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuOlxuICBpZiAoIXJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkKSB7XG4gICAgLy8gIDEuIFNldCB0aW1pbmdJbmZvIHRvIGEgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBvcGFxdWUgdGltaW5nIGluZm8gZm9yIHRpbWluZ0luZm8uXG4gICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgc3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICAgIH0pXG5cbiAgICAvLyAgMi4gU2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICBjYWNoZVN0YXRlID0gJydcbiAgfVxuXG4gIC8vIDkuIFNldCB0aW1pbmdJbmZv4oCZcyBlbmQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWVcbiAgLy8gZ2l2ZW4gZ2xvYmFs4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5LlxuICAvLyBUT0RPOiBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHk/XG4gIHRpbWluZ0luZm8uZW5kVGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKClcblxuICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aW1pbmdJbmZvLlxuICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mb1xuXG4gIC8vIDExLiBNYXJrIHJlc291cmNlIHRpbWluZyBmb3IgdGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsXG4gIC8vIGdsb2JhbCwgYW5kIGNhY2hlU3RhdGUuXG4gIG1hcmtSZXNvdXJjZVRpbWluZyhcbiAgICB0aW1pbmdJbmZvLFxuICAgIG9yaWdpbmFsVVJMLmhyZWYsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGVcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmNvbnN0IG1hcmtSZXNvdXJjZVRpbWluZyA9IHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZ1xuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYWJvcnQtZmV0Y2hcbmZ1bmN0aW9uIGFib3J0RmV0Y2ggKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBlcnJvcikge1xuICAvLyAxLiBSZWplY3QgcHJvbWlzZSB3aXRoIGVycm9yLlxuICBpZiAocCkge1xuICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSByZXNvbHZlZCB0aGUgcHJvbWlzZSBhdCB0aGlzIHN0YWdlXG4gICAgcC5yZWplY3QoZXJyb3IpXG4gIH1cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBjYW5jZWwgcmVxdWVzdOKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXF1ZXN0LmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXF1ZXN0LmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZU9iamVjdCBpcyBudWxsLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlT2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2UuXG4gIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXVxuXG4gIC8vIDUuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciByZXNwb25zZeKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVzcG9uc2UuYm9keT8uc3RyZWFtKSkge1xuICAgIHJlc3BvbnNlLmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoaW5nXG5mdW5jdGlvbiBmZXRjaGluZyAoe1xuICByZXF1ZXN0LFxuICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gIHByb2Nlc3NSZXNwb25zZSxcbiAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgdXNlUGFyYWxsZWxRdWV1ZSA9IGZhbHNlLFxuICBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIC8vIHVuZGljaVxufSkge1xuICAvLyBFbnN1cmUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBzZXQgYWNjb3JkaW5nbHlcbiAgYXNzZXJ0KGRpc3BhdGNoZXIpXG5cbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gIH0pXG5cbiAgLy8gNi4gTGV0IGZldGNoUGFyYW1zIGJlIGEgbmV3IGZldGNoIHBhcmFtcyB3aG9zZVxuICAvLyByZXF1ZXN0IGlzIHJlcXVlc3QsXG4gIC8vIHRpbWluZyBpbmZvIGlzIHRpbWluZ0luZm8sXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBib2R5IGNodW5rIGxlbmd0aCBpcyBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgLy8gcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGlzIHByb2Nlc3NSZXNwb25zZSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAvLyB0YXNrIGRlc3RpbmF0aW9uIGlzIHRhc2tEZXN0aW5hdGlvbixcbiAgLy8gYW5kIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5IGlzIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICBjb250cm9sbGVyOiBuZXcgRmV0Y2goZGlzcGF0Y2hlciksXG4gICAgcmVxdWVzdCxcbiAgICB0aW1pbmdJbmZvLFxuICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gICAgdGFza0Rlc3RpbmF0aW9uLFxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIGEgYnl0ZSBzZXF1ZW5jZSwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0b1xuICAvLyAgICByZXF1ZXN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgLy8gTk9URTogU2luY2UgZmV0Y2hpbmcgaXMgb25seSBjYWxsZWQgZnJvbSBmZXRjaCwgYm9keSBzaG91bGQgYWxyZWFkeSBiZVxuICAvLyBleHRyYWN0ZWQuXG4gIGFzc2VydCghcmVxdWVzdC5ib2R5IHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pXG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwiY2xpZW50XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHdpbmRvdyB0byByZXF1ZXN04oCZc1xuICAvLyBjbGllbnQsIGlmIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdCBpcyBhIFdpbmRvdyBvYmplY3Q7IG90aGVyd2lzZVxuICAvLyBcIm5vLXdpbmRvd1wiLlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qud2luZG93ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50Py5nbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnV2luZG93J1xuICAgICAgICA/IHJlcXVlc3QuY2xpZW50XG4gICAgICAgIDogJ25vLXdpbmRvdydcbiAgfVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW504oCZcyBvcmlnaW4uXG4gIGlmIChyZXF1ZXN0Lm9yaWdpbiA9PT0gJ2NsaWVudCcpIHtcbiAgICByZXF1ZXN0Lm9yaWdpbiA9IHJlcXVlc3QuY2xpZW50Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JywgdHJ1ZSkpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnLCB0cnVlKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicsIHRydWUpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlU2V0LmhhcyhyZXF1ZXN0LmRlc3RpbmF0aW9uKSkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE2LiBSdW4gbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgbWFpbkZldGNoKGZldGNoUGFyYW1zKVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyKVxuICAgIH0pXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGxvY2FsLVVSTHMtb25seSBmbGFnIGlzIHNldCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXNcbiAgLy8gbm90IGxvY2FsLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdsb2NhbCBVUkxzIG9ubHknKVxuICB9XG5cbiAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gVXBncmFkZSByZXF1ZXN0IHRvIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCBpZiBhcHByb3ByaWF0ZS5cbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgLy8gNi4gSWYgc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gYSBiYWQgcG9ydCwgc2hvdWxkIGZldGNoaW5nIHJlcXVlc3RcbiAgLy8gYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50LCBvciBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnRcbiAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdCkgPT09ICdibG9ja2VkJykge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignYmFkIHBvcnQnKVxuICB9XG4gIC8vIFRPRE86IHNob3VsZCBmZXRjaGluZyByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudD9cbiAgLy8gVE9ETzogc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeT9cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgcG9saWN5IHRvIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXLigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgdG8gXCJodHRwc1wiIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IGlzIGEgZG9tYWluXG4gIC8vIC0gTWF0Y2hpbmcgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgcGVyIEtub3duIEhTVFMgSG9zdCBEb21haW4gTmFtZVxuICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAvLyAgIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSBvciBhIGNvbmdydWVudCBtYXRjaCAod2l0aCBvciB3aXRob3V0IGFuXG4gIC8vICAgYXNzZXJ0ZWQgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlKS4gW0hTVFNdXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVjdXJzaXZlIGlzIGZhbHNlLCB0aGVuIHJ1biB0aGUgcmVtYWluaW5nIHN0ZXBzIGluIHBhcmFsbGVsLlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyB0aGUgc3RlcHMgY29ycmVzcG9uZGluZyB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50OlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICByZXNwb25zZSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgaWYgKFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBvcmlnaW4sXG4gICAgICAgIC8vICAgYW5kIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiYmFzaWNcIlxuICAgICAgICAoc2FtZU9yaWdpbihjdXJyZW50VVJMLCByZXF1ZXN0LnVybCkgJiYgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB8fFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiXG4gICAgICAgIChjdXJyZW50VVJMLnByb3RvY29sID09PSAnZGF0YTonKSB8fFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiIG9yIFwid2Vic29ja2V0XCJcbiAgICAgICAgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImJhc2ljXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdiYXNpYydcblxuICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwic2FtZS1vcmlnaW5cIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgICAvLyAxLiBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBub3QgXCJmb2xsb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ2ZvbGxvdycpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcIm9wYXF1ZVwiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnb3BhcXVlJ1xuXG4gICAgICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKVxuICAgICAgfVxuXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1bnNhZmUtcmVxdWVzdCBmbGFnIGlzIHNldCBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAgICAgLy8gICBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kIG9yIENPUlMtdW5zYWZlIHJlcXVlc3QtaGVhZGVyIG5hbWVzIHdpdGhcbiAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAvLyAgICAyLiBMZXQgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaFxuICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAvLyAgICAzLiBJZiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiBjbGVhciBjYWNoZVxuICAgICAgLy8gICAgZW50cmllcyB1c2luZyByZXF1ZXN0LlxuICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAvLyBUT0RPXG5cbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2NvcnMnXG5cbiAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgfSkoKVxuICB9XG5cbiAgLy8gMTIuIElmIHJlY3Vyc2l2ZSBpcyB0cnVlLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gMTMuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkXG4gIC8vIHJlc3BvbnNlLCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmICFyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgLy8gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVyTmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgLy8gZ2l2ZW4gYEFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZSBpcyBub3QgXCJpbmNsdWRlXCIgYW5kIGhlYWRlck5hbWVzXG4gICAgICAvLyBjb250YWlucyBgKmAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0b1xuICAgICAgLy8gYWxsIHVuaXF1ZSBoZWFkZXIgbmFtZXMgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJOYW1lcyBpcyBub3QgbnVsbCBvciBmYWlsdXJlLCB0aGVuIHNldFxuICAgICAgLy8gcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvIGhlYWRlck5hbWVzLlxuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnYmFzaWMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdjb3JzJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdvcGFxdWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gMTQuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBsZXQgaW50ZXJuYWxSZXNwb25zZSA9XG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwID8gcmVzcG9uc2UgOiByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG5cbiAgLy8gMTUuIElmIGludGVybmFsUmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LCB0aGVuIHNldCBpdCB0byBhIGNsb25lIG9mXG4gIC8vIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5wdXNoKC4uLnJlcXVlc3QudXJsTGlzdClcbiAgfVxuXG4gIC8vIDE2LiBJZiByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcgaXMgdW5zZXQsIHRoZW4gc2V0XG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZy5cbiAgaWYgKCFyZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkKSB7XG4gICAgcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxNy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgYW55IG9mIHRoZSBmb2xsb3dpbmcgcmV0dXJuc1xuICAvLyBibG9ja2VkXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3lcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGl0cyBNSU1FIHR5cGVcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIG5vc25pZmZcbiAgLy8gVE9ET1xuXG4gIC8vIDE4LiBJZiByZXNwb25zZeKAmXMgdHlwZSBpcyBcIm9wYXF1ZVwiLCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMjA2LFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZyBpcyBzZXQsIGFuZCByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNlIGFuZCBpbnRlcm5hbFJlc3BvbnNlXG4gIC8vIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNiAmJlxuICAgIGludGVybmFsUmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgJiZcbiAgICAhcmVxdWVzdC5oZWFkZXJzLmNvbnRhaW5zKCdyYW5nZScsIHRydWUpXG4gICkge1xuICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICB9XG5cbiAgLy8gMTkuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgLy8gYEhFQURgIG9yIGBDT05ORUNUYCwgb3IgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cyxcbiAgLy8gc2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgdG8gbnVsbCBhbmQgZGlzcmVnYXJkIGFueSBlbnF1ZXVpbmcgdG93YXJkXG4gIC8vIGl0IChpZiBhbnkpLlxuICBpZiAoXG4gICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmXG4gICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHxcbiAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgIG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKGludGVybmFsUmVzcG9uc2Uuc3RhdHVzKSlcbiAgKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS5ib2R5ID0gbnVsbFxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCA9IHRydWVcbiAgfVxuXG4gIC8vIDIwLiBJZiByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmludGVncml0eSkge1xuICAgIC8vIDEuIExldCBwcm9jZXNzQm9keUVycm9yIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtc1xuICAgIC8vIGFuZCBhIG5ldHdvcmsgZXJyb3IuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChyZWFzb24pID0+XG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pKVxuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJvcGFxdWVcIiwgb3IgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCxcbiAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAoYnl0ZXMpID0+IHtcbiAgICAgIC8vIDEuIElmIGJ5dGVzIGRvIG5vdCBtYXRjaCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEsXG4gICAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy4gW1NSSV1cbiAgICAgIGlmICghYnl0ZXNNYXRjaChieXRlcywgcmVxdWVzdC5pbnRlZ3JpdHkpKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoJ2ludGVncml0eSBtaXNtYXRjaCcpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYnl0ZXMgYXMgYSBib2R5LlxuICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXVxuXG4gICAgICAvLyAzLiBSdW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyA0LiBGdWxseSByZWFkIHJlc3BvbnNl4oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5IGFuZCBwcm9jZXNzQm9keUVycm9yLlxuICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgLy8gMjEuIE90aGVyd2lzZSwgcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXNjaGVtZS1mZXRjaFxuLy8gZ2l2ZW4gYSBmZXRjaCBwYXJhbXMgZmV0Y2hQYXJhbXNcbmZ1bmN0aW9uIHNjaGVtZUZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyBOb3RlOiBzaW5jZSB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb24gcmVkaXJlY3QsIHdoaWNoIHNldHMgZmV0Y2hQYXJhbXMgdG8gYVxuICAvLyBjYW5jZWxsZWQgc3RhdGUsIHdlIGRvIG5vdCB3YW50IHRoaXMgY29uZGl0aW9uIHRvIHRyaWdnZXIgKnVubGVzcyogdGhlcmUgaGF2ZSBiZWVuXG4gIC8vIG5vIHJlZGlyZWN0cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzc2XG4gIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykgJiYgZmV0Y2hQYXJhbXMucmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpKVxuICB9XG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHsgcmVxdWVzdCB9ID0gZmV0Y2hQYXJhbXNcblxuICBjb25zdCB7IHByb3RvY29sOiBzY2hlbWUgfSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgYW5kIHJ1biB0aGUgYXNzb2NpYXRlZCBzdGVwczpcbiAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICBjYXNlICdhYm91dDonOiB7XG4gICAgICAvLyBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgcGF0aCBpcyB0aGUgc3RyaW5nIFwiYmxhbmtcIiwgdGhlbiByZXR1cm4gYSBuZXcgcmVzcG9uc2VcbiAgICAgIC8vIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgYHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04YCkgwrssXG4gICAgICAvLyBhbmQgYm9keSBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSBhcyBhIGJvZHkuXG5cbiAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignYWJvdXQgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG4gICAgY2FzZSAnYmxvYjonOiB7XG4gICAgICBpZiAoIXJlc29sdmVPYmplY3RVUkwpIHtcbiAgICAgICAgcmVzb2x2ZU9iamVjdFVSTCA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTFxuICAgICAgfVxuXG4gICAgICAvLyAxLiBMZXQgYmxvYlVSTEVudHJ5IGJlIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBibG9iIFVSTCBlbnRyeS5cbiAgICAgIGNvbnN0IGJsb2JVUkxFbnRyeSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcGxhdGZvcm0tdGVzdHMvd3B0L2Jsb2IvN2IwZWJhY2NjNjJiNTY2YTE5NjUzOTZlNWJlN2JiMmJjMDZmODQxZi9GaWxlQVBJL3VybC9yZXNvdXJjZXMvZmV0Y2gtdGVzdHMuanMjTDUyLUw1NlxuICAgICAgLy8gQnVmZmVyLnJlc29sdmVPYmplY3RVUkwgZG9lcyBub3QgaWdub3JlIFVSTCBxdWVyaWVzLlxuICAgICAgaWYgKGJsb2JVUkxFbnRyeS5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvYiA9IHJlc29sdmVPYmplY3RVUkwoYmxvYlVSTEVudHJ5LnRvU3RyaW5nKCkpXG5cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAsIGJsb2JVUkxFbnRyeSBpcyBudWxsLCBvciBibG9iVVJMRW50cnnigJlzXG4gICAgICAvLyAgICBvYmplY3QgaXMgbm90IGEgQmxvYiBvYmplY3QsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgfHwgIWlzQmxvYkxpa2UoYmxvYikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdpbnZhbGlkIG1ldGhvZCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgYmxvYiBiZSBibG9iVVJMRW50cnnigJlzIG9iamVjdC5cbiAgICAgIC8vIE5vdGU6IGRvbmUgYWJvdmVcblxuICAgICAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIGEgbmV3IHJlc3BvbnNlLlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoKVxuXG4gICAgICAvLyA1LiBMZXQgZnVsbExlbmd0aCBiZSBibG9i4oCZcyBzaXplLlxuICAgICAgY29uc3QgZnVsbExlbmd0aCA9IGJsb2Iuc2l6ZVxuXG4gICAgICAvLyA2LiBMZXQgc2VyaWFsaXplZEZ1bGxMZW5ndGggYmUgZnVsbExlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgICAgY29uc3Qgc2VyaWFsaXplZEZ1bGxMZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke2Z1bGxMZW5ndGh9YClcblxuICAgICAgLy8gNy4gTGV0IHR5cGUgYmUgYmxvYuKAmXMgdHlwZS5cbiAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGVcblxuICAgICAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUmFuZ2VgOlxuICAgICAgLy8gOS4gT3RoZXJ3aXNlOlxuICAgICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScsIHRydWUpKSB7XG4gICAgICAgIC8vIDEuIExldCBib2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBibG9iLlxuICAgICAgICAvLyBOb3RlOiBpbiB0aGUgRmlsZUFQSSBhIGJsb2IgXCJvYmplY3RcIiBpcyBhIEJsb2IgKm9yKiBhIE1lZGlhU291cmNlLlxuICAgICAgICAvLyBJbiBub2RlLCB0aGlzIGNhbiBvbmx5IGV2ZXIgYmUgYSBCbG9iLiBUaGVyZWZvcmUgd2UgY2FuIHNhZmVseVxuICAgICAgICAvLyB1c2UgZXh0cmFjdEJvZHkgZGlyZWN0bHkuXG4gICAgICAgIGNvbnN0IGJvZHlXaXRoVHlwZSA9IGV4dHJhY3RCb2R5KGJsb2IpXG5cbiAgICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBgT0tgLlxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gJ09LJ1xuXG4gICAgICAgIC8vIDMuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBib2R5V2l0aFR5cGXigJlzIGJvZHkuXG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSBib2R5V2l0aFR5cGVbMF1cblxuICAgICAgICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IHRvIMKrIChgQ29udGVudC1MZW5ndGhgLCBzZXJpYWxpemVkRnVsbExlbmd0aCksIChgQ29udGVudC1UeXBlYCwgdHlwZSkgwrsuXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1sZW5ndGgnLCBzZXJpYWxpemVkRnVsbExlbmd0aCwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXR5cGUnLCB0eXBlLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZy5cbiAgICAgICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlXG5cbiAgICAgICAgLy8gMi4gTGV0IHJhbmdlSGVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBgUmFuZ2VgIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzTGlzdC5nZXQoJ3JhbmdlJywgdHJ1ZSlcblxuICAgICAgICAvLyAzLiBMZXQgcmFuZ2VWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYSBzaW5nbGUgcmFuZ2UgaGVhZGVyIHZhbHVlIGdpdmVuIHJhbmdlSGVhZGVyIGFuZCB0cnVlLlxuICAgICAgICBjb25zdCByYW5nZVZhbHVlID0gc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZShyYW5nZUhlYWRlciwgdHJ1ZSlcblxuICAgICAgICAvLyA0LiBJZiByYW5nZVZhbHVlIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgaWYgKHJhbmdlVmFsdWUgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gTGV0IChyYW5nZVN0YXJ0LCByYW5nZUVuZCkgYmUgcmFuZ2VWYWx1ZS5cbiAgICAgICAgbGV0IHsgcmFuZ2VTdGFydFZhbHVlOiByYW5nZVN0YXJ0LCByYW5nZUVuZFZhbHVlOiByYW5nZUVuZCB9ID0gcmFuZ2VWYWx1ZVxuXG4gICAgICAgIC8vIDYuIElmIHJhbmdlU3RhcnQgaXMgbnVsbDpcbiAgICAgICAgLy8gNy4gT3RoZXJ3aXNlOlxuICAgICAgICBpZiAocmFuZ2VTdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIDEuIFNldCByYW5nZVN0YXJ0IHRvIGZ1bGxMZW5ndGgg4oiSIHJhbmdlRW5kLlxuICAgICAgICAgIHJhbmdlU3RhcnQgPSBmdWxsTGVuZ3RoIC0gcmFuZ2VFbmRcblxuICAgICAgICAgIC8vIDIuIFNldCByYW5nZUVuZCB0byByYW5nZVN0YXJ0ICsgcmFuZ2VFbmQg4oiSIDEuXG4gICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgcmFuZ2VFbmQgLSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMS4gSWYgcmFuZ2VTdGFydCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZnVsbExlbmd0aCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICAgIGlmIChyYW5nZVN0YXJ0ID49IGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignUmFuZ2Ugc3RhcnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBibG9iXFwncyBzaXplLicpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDIuIElmIHJhbmdlRW5kIGlzIG51bGwgb3IgcmFuZ2VFbmQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGZ1bGxMZW5ndGgsIHRoZW4gc2V0XG4gICAgICAgICAgLy8gICAgcmFuZ2VFbmQgdG8gZnVsbExlbmd0aCDiiJIgMS5cbiAgICAgICAgICBpZiAocmFuZ2VFbmQgPT09IG51bGwgfHwgcmFuZ2VFbmQgPj0gZnVsbExlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSBmdWxsTGVuZ3RoIC0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDguIExldCBzbGljZWRCbG9iIGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgc2xpY2UgYmxvYiBnaXZlbiBibG9iLCByYW5nZVN0YXJ0LFxuICAgICAgICAvLyAgICByYW5nZUVuZCArIDEsIGFuZCB0eXBlLlxuICAgICAgICBjb25zdCBzbGljZWRCbG9iID0gYmxvYi5zbGljZShyYW5nZVN0YXJ0LCByYW5nZUVuZCwgdHlwZSlcblxuICAgICAgICAvLyA5LiBMZXQgc2xpY2VkQm9keVdpdGhUeXBlIGJlIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3Rpbmcgc2xpY2VkQmxvYi5cbiAgICAgICAgLy8gTm90ZTogc2FtZSByZWFzb24gYXMgbWVudGlvbmVkIGFib3ZlIGFzIHRvIHdoeSB3ZSB1c2UgZXh0cmFjdEJvZHlcbiAgICAgICAgY29uc3Qgc2xpY2VkQm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoc2xpY2VkQmxvYilcblxuICAgICAgICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIHNsaWNlZEJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNsaWNlZEJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDExLiBMZXQgc2VyaWFsaXplZFNsaWNlZExlbmd0aCBiZSBzbGljZWRCbG9i4oCZcyBzaXplLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRTbGljZWRMZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke3NsaWNlZEJsb2Iuc2l6ZX1gKVxuXG4gICAgICAgIC8vIDEyLiBMZXQgY29udGVudFJhbmdlIGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgYnVpbGQgYSBjb250ZW50IHJhbmdlIGdpdmVuIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgICByYW5nZUVuZCwgYW5kIGZ1bGxMZW5ndGguXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IGJ1aWxkQ29udGVudFJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKVxuXG4gICAgICAgIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyB0byAyMDYuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IDIwNlxuXG4gICAgICAgIC8vIDE0LiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBQYXJ0aWFsIENvbnRlbnRgLlxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gJ1BhcnRpYWwgQ29udGVudCdcblxuICAgICAgICAvLyAxNS4gU2V0IHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCB0byDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgc2VyaWFsaXplZFNsaWNlZExlbmd0aCksXG4gICAgICAgIC8vICAgICAoYENvbnRlbnQtVHlwZWAsIHR5cGUpLCAoYENvbnRlbnQtUmFuZ2VgLCBjb250ZW50UmFuZ2UpIMK7LlxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtbGVuZ3RoJywgc2VyaWFsaXplZFNsaWNlZExlbmd0aCwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXR5cGUnLCB0eXBlLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtcmFuZ2UnLCBjb250ZW50UmFuZ2UsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDEwLiBSZXR1cm4gcmVzcG9uc2UuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgIH1cbiAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgIC8vIDEuIExldCBkYXRhVVJMU3RydWN0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGVcbiAgICAgIC8vICAgIGRhdGE6IFVSTCBwcm9jZXNzb3Igb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAgIGNvbnN0IGRhdGFVUkxTdHJ1Y3QgPSBkYXRhVVJMUHJvY2Vzc29yKGN1cnJlbnRVUkwpXG5cbiAgICAgIC8vIDIuIElmIGRhdGFVUkxTdHJ1Y3QgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYVxuICAgICAgLy8gICAgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChkYXRhVVJMU3RydWN0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBtaW1lVHlwZSBiZSBkYXRhVVJMU3RydWN04oCZcyBNSU1FIHR5cGUsIHNlcmlhbGl6ZWQuXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShkYXRhVVJMU3RydWN0Lm1pbWVUeXBlKVxuXG4gICAgICAvLyA0LiBSZXR1cm4gYSByZXNwb25zZSB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLFxuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBtaW1lVHlwZSkgwrssXG4gICAgICAvLyAgICBhbmQgYm9keSBpcyBkYXRhVVJMU3RydWN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtdHlwZScsIHsgbmFtZTogJ0NvbnRlbnQtVHlwZScsIHZhbHVlOiBtaW1lVHlwZSB9XVxuICAgICAgICBdLFxuICAgICAgICBib2R5OiBzYWZlbHlFeHRyYWN0Qm9keShkYXRhVVJMU3RydWN0LmJvZHkpWzBdXG4gICAgICB9KSlcbiAgICB9XG4gICAgY2FzZSAnZmlsZTonOiB7XG4gICAgICAvLyBGb3Igbm93LCB1bmZvcnR1bmF0ZSBhcyBpdCBpcywgZmlsZSBVUkxzIGFyZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICAgICAgLy8gV2hlbiBpbiBkb3VidCwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignbm90IGltcGxlbWVudGVkLi4uIHlldC4uLicpKVxuICAgIH1cbiAgICBjYXNlICdodHRwOic6XG4gICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuXG4gICAgICByZXR1cm4gaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3Vua25vd24gc2NoZW1lJykpXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmaW5hbGl6ZS1yZXNwb25zZVxuZnVuY3Rpb24gZmluYWxpemVSZXNwb25zZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgLy8gMiwgSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBpcyBub3QgbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoXG4gIC8vIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgZ2l2ZW4gcmVzcG9uc2UsIHdpdGhcbiAgLy8gZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lKHJlc3BvbnNlKSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtZmluYWxlXG5mdW5jdGlvbiBmZXRjaEZpbmFsZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudCBpcyBhIHNlY3VyZSBjb250ZXh0LFxuICAvLyAgICB0aGVuIHNldCB0aW1pbmdJbmZv4oCZcyBzZXJ2ZXItdGltaW5nIGhlYWRlcnMgdG8gdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZ1xuICAvLyAgICBgU2VydmVyLVRpbWluZ2AgZnJvbSByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gMy4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgLy8gMS4gTGV0IHVuc2FmZUVuZFRpbWUgYmUgdGhlIHVuc2FmZSBzaGFyZWQgY3VycmVudCB0aW1lLlxuICAgIGNvbnN0IHVuc2FmZUVuZFRpbWUgPSBEYXRlLm5vdygpIC8vID9cblxuICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbiBpcyBcImRvY3VtZW50XCIsIHRoZW4gc2V0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZc1xuICAgIC8vICAgIGZ1bGwgdGltaW5nIGluZm8gdG8gZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmZ1bGxUaW1pbmdJbmZvID0gdGltaW5nSW5mb1xuICAgIH1cblxuICAgIC8vIDMuIFNldCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXMgcmVwb3J0IHRpbWluZyBzdGVwcyB0byB0aGUgZm9sbG93aW5nIHN0ZXBzIGdpdmVuIGEgZ2xvYmFsIG9iamVjdCBnbG9iYWw6XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXBvcnRUaW1pbmdTdGVwcyA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QudXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSByZWxhdGl2ZSBoaWdoIHJlc29sdXRpb24gdGltZSBnaXZlbiB1bnNhZmVFbmRUaW1lIGFuZCBnbG9iYWwuXG4gICAgICB0aW1pbmdJbmZvLmVuZFRpbWUgPSB1bnNhZmVFbmRUaW1lXG5cbiAgICAgIC8vIDMuIExldCBjYWNoZVN0YXRlIGJlIHJlc3BvbnNl4oCZcyBjYWNoZSBzdGF0ZS5cbiAgICAgIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gICAgICAvLyA0LiBMZXQgYm9keUluZm8gYmUgcmVzcG9uc2XigJlzIGJvZHkgaW5mby5cbiAgICAgIGNvbnN0IGJvZHlJbmZvID0gcmVzcG9uc2UuYm9keUluZm9cblxuICAgICAgLy8gNS4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuIHNldCB0aW1pbmdJbmZvIHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW5cbiAgICAgIC8vICAgIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mbyBhbmQgc2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAgICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8odGltaW5nSW5mbylcblxuICAgICAgICBjYWNoZVN0YXRlID0gJydcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IHJlc3BvbnNlU3RhdHVzIGJlIDAuXG4gICAgICBsZXQgcmVzcG9uc2VTdGF0dXMgPSAwXG5cbiAgICAgIC8vIDcuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5vdCBcIm5hdmlnYXRlXCIgb3IgcmVzcG9uc2XigJlzIGhhcy1jcm9zcy1vcmlnaW4tcmVkaXJlY3RzIGlzIGZhbHNlOlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QubW9kZSAhPT0gJ25hdmlnYXRvcicgfHwgIXJlc3BvbnNlLmhhc0Nyb3NzT3JpZ2luUmVkaXJlY3RzKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXNwb25zZVN0YXR1cyB0byByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgICAgICByZXNwb25zZVN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c1xuXG4gICAgICAgIC8vIDIuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKHJlc3BvbnNlLmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIDMuIElmIG1pbWVUeXBlIGlzIG5vdCBmYWlsdXJlLCB0aGVuIHNldCBib2R5SW5mb+KAmXMgY29udGVudCB0eXBlIHRvIHRoZSByZXN1bHQgb2YgbWluaW1pemluZyBhIHN1cHBvcnRlZCBNSU1FIHR5cGUgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgYm9keUluZm8uY29udGVudFR5cGUgPSBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDguIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSBpcyBub24tbnVsbCwgdGhlbiBtYXJrIHJlc291cmNlIHRpbWluZyBnaXZlbiB0aW1pbmdJbmZvLFxuICAgICAgLy8gICAgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTCwgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlLCBnbG9iYWwsIGNhY2hlU3RhdGUsIGJvZHlJbmZvLFxuICAgICAgLy8gICAgYW5kIHJlc3BvbnNlU3RhdHVzLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBtYXJrcmVzb3VyY2V0aW1pbmdcbiAgICAgICAgbWFya1Jlc291cmNlVGltaW5nKHRpbWluZ0luZm8sIGZldGNoUGFyYW1zLnJlcXVlc3QudXJsLmhyZWYsIGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSwgZ2xvYmFsVGhpcywgY2FjaGVTdGF0ZSwgYm9keUluZm8sIHJlc3BvbnNlU3RhdHVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIExldCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrIGJlIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayA9ICgpID0+IHtcbiAgICAgIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICAgICAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBlbmQtb2YtYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3NcbiAgICAgIC8vICAgIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGdpdmVuIHJlc3BvbnNlLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAhPSBudWxsKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keShyZXNwb25zZSkpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSBpcyBub24tbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudOKAmXNcbiAgICAgIC8vICAgIGdsb2JhbCBvYmplY3QgaXMgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24sIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZcyByZXBvcnRcbiAgICAgIC8vICAgIHRpbWluZyBzdGVwcyBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVwb3J0VGltaW5nU3RlcHMoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzaygpKVxuICB9XG5cbiAgLy8gNC4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgaXMgbm9uLW51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gICAgcHJvY2VzcyByZXNwb25zZSBnaXZlbiByZXNwb25zZSwgd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlID0gbnVsbFxuICAgIH0pXG4gIH1cblxuICAvLyA1LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yOyBvdGhlcndpc2UgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlLlxuICBjb25zdCBpbnRlcm5hbFJlc3BvbnNlID0gcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyA/IHJlc3BvbnNlIDogKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UgPz8gcmVzcG9uc2UpXG5cbiAgLy8gNi4gSWYgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gIC8vIDcuIE90aGVyd2lzZTpcbiAgaWYgKGludGVybmFsUmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KClcbiAgfSBlbHNlIHtcbiAgICAvLyBtY29sbGluYTogYWxsIHRoZSBmb2xsb3dpbmcgc3RlcHMgb2YgdGhlIHNwZWNzIGFyZSBza2lwcGVkLlxuICAgIC8vIFRoZSBpbnRlcm5hbCB0cmFuc2Zvcm0gc3RyZWFtIGlzIG5vdCBuZWVkZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMzA5MyNpc3N1ZWNvbW1lbnQtMjA1MDE5ODU0MVxuXG4gICAgLy8gMS4gTGV0IHRyYW5zZm9ybVN0cmVhbSBiZSBhIG5ldyBUcmFuc2Zvcm1TdHJlYW0uXG4gICAgLy8gMi4gTGV0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB3aGljaCwgZ2l2ZW4gY2h1bmssIGVucXVldWVzIGNodW5rIGluIHRyYW5zZm9ybVN0cmVhbS5cbiAgICAvLyAzLiBTZXQgdXAgdHJhbnNmb3JtU3RyZWFtIHdpdGggdHJhbnNmb3JtQWxnb3JpdGhtIHNldCB0byBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSBhbmQgZmx1c2hBbGdvcml0aG1cbiAgICAvLyAgICBzZXQgdG8gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICAgIC8vIDQuIFNldCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R54oCZcyBzdHJlYW0gdG8gdGhlIHJlc3VsdCBvZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R54oCZcyBzdHJlYW0gcGlwZWQgdGhyb3VnaCB0cmFuc2Zvcm1TdHJlYW0uXG5cbiAgICBmaW5pc2hlZChpbnRlcm5hbFJlc3BvbnNlLmJvZHkuc3RyZWFtLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBMZXQgYWN0dWFsUmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IGFjdHVhbFJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA1LiBJZiByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSBpcyBcImFsbFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9PT0gJ2FsbCcpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA2LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBtYWtlQ09SU1ByZWZsaWdodCBpcyB0cnVlIGFuZCBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpcyB0cnVlOlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgXCJmb2xsb3dcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgICAvLyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgcmVzcG9uc2UgYW5kIGFjdHVhbFJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgIC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goZmV0Y2hQYXJhbXMpXG5cbiAgICAvLyA0LiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBhbmQgYSBDT1JTIGNoZWNrXG4gICAgLy8gZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnICYmXG4gICAgICBjb3JzQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZSdcbiAgICApIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdjb3JzIGZhaWx1cmUnKVxuICAgIH1cblxuICAgIC8vIDUuIElmIHRoZSBUQU8gY2hlY2sgZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAvLyByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcuXG4gICAgaWYgKFRBT0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIElmIGVpdGhlciByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBvciByZXNwb25zZeKAmXMgdHlwZVxuICAvLyBpcyBcIm9wYXF1ZVwiLCBhbmQgdGhlIGNyb3NzLW9yaWdpbiByZXNvdXJjZSBwb2xpY3kgY2hlY2sgd2l0aFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4sIHJlcXVlc3TigJlzIGNsaWVudCwgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24sXG4gIC8vIGFuZCBhY3R1YWxSZXNwb25zZSByZXR1cm5zIGJsb2NrZWQsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnIHx8IHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnKSAmJlxuICAgIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayhcbiAgICAgIHJlcXVlc3Qub3JpZ2luLFxuICAgICAgcmVxdWVzdC5jbGllbnQsXG4gICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uLFxuICAgICAgYWN0dWFsUmVzcG9uc2VcbiAgICApID09PSAnYmxvY2tlZCdcbiAgKSB7XG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2Jsb2NrZWQnKVxuICB9XG5cbiAgLy8gOC4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbjpcbiAgaWYgKHJlZGlyZWN0U3RhdHVzU2V0LmhhcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgLy8gMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsLFxuICAgIC8vIGFuZCB0aGUgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB1c2VyIGFnZW50cyBtYXksIGFuZCBhcmUgZXZlblxuICAgIC8vIGVuY291cmFnZWQgdG8sIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjg4XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSh1bmRlZmluZWQsIGZhbHNlKVxuICAgIH1cblxuICAgIC8vIDIuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlOlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZXJyb3InKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCd1bmV4cGVjdGVkIHJlZGlyZWN0JylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdtYW51YWwnKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gYW4gb3BhcXVlLXJlZGlyZWN0IGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsXG4gICAgICAvLyByZXNwb25zZSBpcyBhY3R1YWxSZXNwb25zZS5cbiAgICAgIC8vIE5PVEUoc3BlYyk6IE9uIHRoZSB3ZWIgdGhpcyB3b3VsZCByZXR1cm4gYW4gYG9wYXF1ZXJlZGlyZWN0YCByZXNwb25zZSxcbiAgICAgIC8vIGJ1dCB0aGF0IGRvZXNuJ3QgbWFrZSBzZW5zZSBzZXJ2ZXIgc2lkZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTE5My5cbiAgICAgIHJlc3BvbnNlID0gYWN0dWFsUmVzcG9uc2VcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtcmVkaXJlY3QgZmV0Y2ggZ2l2ZW5cbiAgICAgIC8vIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cFJlZGlyZWN0RmV0Y2goZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aW1pbmdJbmZvLlxuICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mb1xuXG4gIC8vIDEwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1yZWRpcmVjdC1mZXRjaFxuZnVuY3Rpb24gaHR0cFJlZGlyZWN0RmV0Y2ggKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgYWN0dWFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkIHJlc3BvbnNlLFxuICAvLyBhbmQgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlIG90aGVyd2lzZS5cbiAgY29uc3QgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG4gICAgPyByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG4gICAgOiByZXNwb25zZVxuXG4gIC8vIDMuIExldCBsb2NhdGlvblVSTCBiZSBhY3R1YWxSZXNwb25zZeKAmXMgbG9jYXRpb24gVVJMIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgLy8gVVJM4oCZcyBmcmFnbWVudC5cbiAgbGV0IGxvY2F0aW9uVVJMXG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvblVSTCA9IHJlc3BvbnNlTG9jYXRpb25VUkwoXG4gICAgICBhY3R1YWxSZXNwb25zZSxcbiAgICAgIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpLmhhc2hcbiAgICApXG5cbiAgICAvLyA0LiBJZiBsb2NhdGlvblVSTCBpcyBudWxsLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgICBpZiAobG9jYXRpb25VUkwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyA1LiBJZiBsb2NhdGlvblVSTCBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKGVycikpXG4gIH1cblxuICAvLyA2LiBJZiBsb2NhdGlvblVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vIGVycm9yLlxuICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGxvY2F0aW9uVVJMKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKSlcbiAgfVxuXG4gIC8vIDcuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGlzIDIwLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LnJlZGlyZWN0Q291bnQgPT09IDIwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdyZWRpcmVjdCBjb3VudCBleGNlZWRlZCcpKVxuICB9XG5cbiAgLy8gOC4gSW5jcmVhc2UgcmVxdWVzdOKAmXMgcmVkaXJlY3QgY291bnQgYnkgMS5cbiAgcmVxdWVzdC5yZWRpcmVjdENvdW50ICs9IDFcblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwiY29yc1wiLCBsb2NhdGlvblVSTCBpbmNsdWRlcyBjcmVkZW50aWFscywgYW5kXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBsb2NhdGlvblVSTOKAmXMgb3JpZ2luLCB0aGVuIHJldHVyblxuICAvLyAgYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVxdWVzdC5tb2RlID09PSAnY29ycycgJiZcbiAgICAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpICYmXG4gICAgIXNhbWVPcmlnaW4ocmVxdWVzdCwgbG9jYXRpb25VUkwpXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignY3Jvc3Mgb3JpZ2luIG5vdCBhbGxvd2VkIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInKSlcbiAgfVxuXG4gIC8vIDEwLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBhbmQgbG9jYXRpb25VUkwgaW5jbHVkZXNcbiAgLy8gY3JlZGVudGlhbHMsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAnVVJMIGNhbm5vdCBjb250YWluIGNyZWRlbnRpYWxzIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInXG4gICAgKSlcbiAgfVxuXG4gIC8vIDExLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsXG4gIC8vIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgYWN0dWFsUmVzcG9uc2Uuc3RhdHVzICE9PSAzMDMgJiZcbiAgICByZXF1ZXN0LmJvZHkgIT0gbnVsbCAmJlxuICAgIHJlcXVlc3QuYm9keS5zb3VyY2UgPT0gbnVsbFxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoKSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gIC8vIC0gYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDEgb3IgMzAyIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYFBPU1RgXG4gIC8vIC0gYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDMgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAgb3IgYEhFQURgXG4gIGlmIChcbiAgICAoWzMwMSwgMzAyXS5pbmNsdWRlcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpICYmIHJlcXVlc3QubWV0aG9kID09PSAnUE9TVCcpIHx8XG4gICAgKGFjdHVhbFJlc3BvbnNlLnN0YXR1cyA9PT0gMzAzICYmXG4gICAgICAhR0VUX09SX0hFQUQuaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKVxuICApIHtcbiAgICAvLyB0aGVuOlxuICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyBtZXRob2QgdG8gYEdFVGAgYW5kIHJlcXVlc3TigJlzIGJvZHkgdG8gbnVsbC5cbiAgICByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnXG4gICAgcmVxdWVzdC5ib2R5ID0gbnVsbFxuXG4gICAgLy8gMi4gRm9yIGVhY2ggaGVhZGVyTmFtZSBvZiByZXF1ZXN0LWJvZHktaGVhZGVyIG5hbWUsIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb21cbiAgICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgcmVxdWVzdEJvZHlIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKGhlYWRlck5hbWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzXG4gIC8vICAgICBvcmlnaW4sIHRoZW4gZm9yIGVhY2ggaGVhZGVyTmFtZSBvZiBDT1JTIG5vbi13aWxkY2FyZCByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAvLyAgICAgZGVsZXRlIGhlYWRlck5hbWUgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpLCBsb2NhdGlvblVSTCkpIHtcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29ycy1ub24td2lsZGNhcmQtcmVxdWVzdC1oZWFkZXItbmFtZVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdhdXRob3JpemF0aW9uJywgdHJ1ZSlcblxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhdXRoZW50aWNhdGlvbi1lbnRyaWVzXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ3Byb3h5LWF1dGhvcml6YXRpb24nLCB0cnVlKVxuXG4gICAgLy8gXCJDb29raWVcIiBhbmQgXCJIb3N0XCIgYXJlIGZvcmJpZGRlbiByZXF1ZXN0LWhlYWRlcnMsIHdoaWNoIHVuZGljaSBkb2Vzbid0IGltcGxlbWVudC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnY29va2llJywgdHJ1ZSlcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcsIHRydWUpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0byB0aGUgZmlyc3QgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIHNhZmVseSBleHRyYWN0aW5nIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgICByZXF1ZXN0LmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShyZXF1ZXN0LmJvZHkuc291cmNlKVswXVxuICB9XG5cbiAgLy8gMTUuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAxNi4gU2V0IHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IGVuZCB0aW1lIGFuZCBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGhlXG4gIC8vIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgdGltaW5nSW5mby5yZWRpcmVjdEVuZFRpbWUgPSB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSA9XG4gICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgLy8gMTcuIElmIHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IHN0YXJ0IHRpbWUgaXMgMCwgdGhlbiBzZXQgdGltaW5nSW5mb+KAmXNcbiAgLy8gIHJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGltaW5nSW5mb+KAmXMgc3RhcnQgdGltZS5cbiAgaWYgKHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPT09IDApIHtcbiAgICB0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID0gdGltaW5nSW5mby5zdGFydFRpbWVcbiAgfVxuXG4gIC8vIDE4LiBBcHBlbmQgbG9jYXRpb25VUkwgdG8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlcXVlc3QudXJsTGlzdC5wdXNoKGxvY2F0aW9uVVJMKVxuXG4gIC8vIDE5LiBJbnZva2Ugc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBvbiByZWRpcmVjdCBvbiByZXF1ZXN0IGFuZFxuICAvLyBhY3R1YWxSZXNwb25zZS5cbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0LCBhY3R1YWxSZXNwb25zZSlcblxuICAvLyAyMC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICByZXR1cm4gbWFpbkZldGNoKGZldGNoUGFyYW1zLCB0cnVlKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLW9yLWNhY2hlLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya09yQ2FjaGVGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggPSBmYWxzZSxcbiAgaXNOZXdDb25uZWN0aW9uRmV0Y2ggPSBmYWxzZVxuKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBodHRwRmV0Y2hQYXJhbXMgYmUgbnVsbC5cbiAgbGV0IGh0dHBGZXRjaFBhcmFtcyA9IG51bGxcblxuICAvLyAzLiBMZXQgaHR0cFJlcXVlc3QgYmUgbnVsbC5cbiAgbGV0IGh0dHBSZXF1ZXN0ID0gbnVsbFxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0b3JlZFJlc3BvbnNlIGJlIG51bGwuXG4gIC8vIFRPRE86IGNhY2hlXG5cbiAgLy8gNi4gTGV0IGh0dHBDYWNoZSBiZSBudWxsLlxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNy4gTGV0IHRoZSByZXZhbGlkYXRpbmdGbGFnIGJlIHVuc2V0LlxuICBjb25zdCByZXZhbGlkYXRpbmdGbGFnID0gZmFsc2VcblxuICAvLyA4LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIgYW5kIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXNcbiAgLy8gICAgXCJlcnJvclwiLCB0aGVuIHNldCBodHRwRmV0Y2hQYXJhbXMgdG8gZmV0Y2hQYXJhbXMgYW5kIGh0dHBSZXF1ZXN0IHRvXG4gIC8vICAgIHJlcXVlc3QuXG4gIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycgJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgIGh0dHBGZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zXG4gICAgaHR0cFJlcXVlc3QgPSByZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gU2V0IGh0dHBSZXF1ZXN0IHRvIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgICBodHRwUmVxdWVzdCA9IGNsb25lUmVxdWVzdChyZXF1ZXN0KVxuXG4gICAgLy8gMi4gU2V0IGh0dHBGZXRjaFBhcmFtcyB0byBhIGNvcHkgb2YgZmV0Y2hQYXJhbXMuXG4gICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9XG5cbiAgICAvLyAzLiBTZXQgaHR0cEZldGNoUGFyYW1z4oCZcyByZXF1ZXN0IHRvIGh0dHBSZXF1ZXN0LlxuICAgIGh0dHBGZXRjaFBhcmFtcy5yZXF1ZXN0ID0gaHR0cFJlcXVlc3RcbiAgfVxuXG4gIC8vICAgIDMuIExldCBpbmNsdWRlQ3JlZGVudGlhbHMgYmUgdHJ1ZSBpZiBvbmUgb2ZcbiAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID1cbiAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScgfHxcbiAgICAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ3NhbWUtb3JpZ2luJyAmJlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKVxuXG4gIC8vICAgIDQuIExldCBjb250ZW50TGVuZ3RoIGJlIGh0dHBSZXF1ZXN04oCZcyBib2R54oCZcyBsZW5ndGgsIGlmIGh0dHBSZXF1ZXN04oCZc1xuICAvLyAgICBib2R5IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGxcblxuICAvLyAgICA1LiBMZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGJlIG51bGwuXG4gIGxldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBudWxsXG5cbiAgLy8gICAgNi4gSWYgaHR0cFJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGAgb3JcbiAgLy8gICAgYFBVVGAsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBgMGAuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiZcbiAgICBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKVxuICApIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSAnMCdcbiAgfVxuXG4gIC8vICAgIDcuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0b1xuICAvLyAgICBjb250ZW50TGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKGAke2NvbnRlbnRMZW5ndGh9YClcbiAgfVxuXG4gIC8vICAgIDguIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENvbnRlbnQtTGVuZ3RoYC9jb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudExlbmd0aEhlYWRlclZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgOS4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtTGVuZ3RoYCxcbiAgLy8gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgMTAuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBrZWVwYWxpdmUgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBodHRwUmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAvLyBOT1RFOiBrZWVwYWxpdmUgaXMgYSBub29wIG91dHNpZGUgb2YgYnJvd3NlciBjb250ZXh0LlxuICB9XG5cbiAgLy8gICAgMTEuIElmIGh0dHBSZXF1ZXN04oCZcyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYFJlZmVyZXJgL2h0dHBSZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLFxuICAvLyAgICAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3JlZmVyZXInLCBpc29tb3JwaGljRW5jb2RlKGh0dHBSZXF1ZXN0LnJlZmVycmVyLmhyZWYpLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTIuIEFwcGVuZCBhIHJlcXVlc3QgYE9yaWdpbmAgaGVhZGVyIGZvciBodHRwUmVxdWVzdC5cbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihodHRwUmVxdWVzdClcblxuICAvLyAgICAxMy4gQXBwZW5kIHRoZSBGZXRjaCBtZXRhZGF0YSBoZWFkZXJzIGZvciBodHRwUmVxdWVzdC4gW0ZFVENILU1FVEFEQVRBXVxuICBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDE0LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgVXNlci1BZ2VudGAsIHRoZW5cbiAgLy8gICAgdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgVXNlci1BZ2VudGAvZGVmYXVsdCBgVXNlci1BZ2VudGAgdmFsdWUgdG9cbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd1c2VyLWFnZW50JywgdHJ1ZSkpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3VzZXItYWdlbnQnLCBkZWZhdWx0VXNlckFnZW50KVxuICB9XG5cbiAgLy8gICAgMTUuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwiZGVmYXVsdFwiIGFuZCBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QgY29udGFpbnMgYElmLU1vZGlmaWVkLVNpbmNlYCwgYElmLU5vbmUtTWF0Y2hgLFxuICAvLyAgICBgSWYtVW5tb2RpZmllZC1TaW5jZWAsIGBJZi1NYXRjaGAsIG9yIGBJZi1SYW5nZWAsIHRoZW4gc2V0XG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnZGVmYXVsdCcgJiZcbiAgICAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1ub25lLW1hdGNoJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi11bm1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tYXRjaCcsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtcmFuZ2UnLCB0cnVlKSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAxNi4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1jYWNoZVwiLCBodHRwUmVxdWVzdOKAmXMgcHJldmVudFxuICAvLyAgICBuby1jYWNoZSBjYWNoZS1jb250cm9sIGhlYWRlciBtb2RpZmljYXRpb24gZmxhZyBpcyB1bnNldCwgYW5kXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENhY2hlLUNvbnRyb2xgL2BtYXgtYWdlPTBgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tY2FjaGUnICYmXG4gICAgIWh0dHBSZXF1ZXN0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uICYmXG4gICAgIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJywgdHJ1ZSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ21heC1hZ2U9MCcsIHRydWUpXG4gIH1cblxuICAvLyAgICAxNy4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1zdG9yZVwiIG9yIFwicmVsb2FkXCIsIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ3JlbG9hZCcpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUHJhZ21hYCwgdGhlbiBhcHBlbmRcbiAgICAvLyBgUHJhZ21hYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdwcmFnbWEnLCB0cnVlKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdwcmFnbWEnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cblxuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCxcbiAgICAvLyB0aGVuIGFwcGVuZCBgQ2FjaGUtQ29udHJvbGAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcsIHRydWUpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDE4LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYEFjY2VwdC1FbmNvZGluZ2AvYGlkZW50aXR5YCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5JywgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDE5LiBNb2RpZnkgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IHBlciBIVFRQLiBEbyBub3QgYXBwZW5kIGEgZ2l2ZW5cbiAgLy8gICAgaGVhZGVyIGlmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyB0aGF0IGhlYWRlcuKAmXMgbmFtZS5cbiAgLy8gICAgVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4NSNpc3N1ZWNvbW1lbnQtODk2NTYwMTI5XG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1lbmNvZGluZycsIHRydWUpKSB7XG4gICAgaWYgKHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2JyLCBnemlwLCBkZWZsYXRlJywgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JywgdHJ1ZSlcblxuICAvLyAgICAyMC4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIHRoZW46XG4gIGlmIChpbmNsdWRlQ3JlZGVudGlhbHMpIHtcbiAgICAvLyAxLiBJZiB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZCB0byBibG9jayBjb29raWVzIGZvciBodHRwUmVxdWVzdFxuICAgIC8vIChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQXV0aG9yaXphdGlvbmAsIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vICAgIDIxLiBJZiB0aGVyZeKAmXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeSwgdXNlIGl0IGFzIGFwcHJvcHJpYXRlLlxuICAvLyAgICBUT0RPOiBwcm94eS1hdXRoZW50aWNhdGlvblxuXG4gIC8vICAgIDIyLiBTZXQgaHR0cENhY2hlIHRvIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGVcbiAgLy8gICAgcGFydGl0aW9uLCBnaXZlbiBodHRwUmVxdWVzdC5cbiAgLy8gICAgVE9ETzogY2FjaGVcblxuICAvLyAgICAyMy4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvXG4gIC8vICAgIFwibm8tc3RvcmVcIi5cbiAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAyNC4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgbmVpdGhlciBcIm5vLXN0b3JlXCIgbm9yIFwicmVsb2FkXCIsXG4gIC8vICAgIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSAhPT0gJ25vLXN0b3JlJyAmJiBodHRwUmVxdWVzdC5jYWNoZSAhPT0gJ3JlbG9hZCcpIHtcbiAgICAvLyBUT0RPOiBjYWNoZVxuICB9XG5cbiAgLy8gOS4gSWYgYWJvcnRlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAvLyBUT0RPXG5cbiAgLy8gMTAuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiLCB0aGVuIHJldHVybiBhXG4gICAgLy8gbmV0d29yayBlcnJvci5cbiAgICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdvbmx5LWlmLWNhY2hlZCcpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdvbmx5IGlmIGNhY2hlZCcpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGZvcndhcmRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrIGZldGNoXG4gICAgLy8gZ2l2ZW4gaHR0cEZldGNoUGFyYW1zLCBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBpc05ld0Nvbm5lY3Rpb25GZXRjaC5cbiAgICBjb25zdCBmb3J3YXJkUmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya0ZldGNoKFxuICAgICAgaHR0cEZldGNoUGFyYW1zLFxuICAgICAgaW5jbHVkZUNyZWRlbnRpYWxzLFxuICAgICAgaXNOZXdDb25uZWN0aW9uRmV0Y2hcbiAgICApXG5cbiAgICAvLyAzLiBJZiBodHRwUmVxdWVzdOKAmXMgbWV0aG9kIGlzIHVuc2FmZSBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXNcbiAgICAvLyBpbiB0aGUgcmFuZ2UgMjAwIHRvIDM5OSwgaW5jbHVzaXZlLCBpbnZhbGlkYXRlIGFwcHJvcHJpYXRlIHN0b3JlZFxuICAgIC8vIHJlc3BvbnNlcyBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGUgXCJJbnZhbGlkYXRpb25cIiBjaGFwdGVyIG9mIEhUVFBcbiAgICAvLyBDYWNoaW5nLCBhbmQgc2V0IHN0b3JlZFJlc3BvbnNlIHRvIG51bGwuIFtIVFRQLUNBQ0hJTkddXG4gICAgaWYgKFxuICAgICAgIXNhZmVNZXRob2RzU2V0LmhhcyhodHRwUmVxdWVzdC5tZXRob2QpICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA8PSAzOTlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdGhlIHJldmFsaWRhdGluZ0ZsYWcgaXMgc2V0IGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDQsXG4gICAgLy8gdGhlbjpcbiAgICBpZiAocmV2YWxpZGF0aW5nRmxhZyAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNlIHRvIGZvcndhcmRSZXNwb25zZS5cbiAgICAgIHJlc3BvbnNlID0gZm9yd2FyZFJlc3BvbnNlXG5cbiAgICAgIC8vIDIuIFN0b3JlIGh0dHBSZXF1ZXN0IGFuZCBmb3J3YXJkUmVzcG9uc2UgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlXG4gICAgICAvLyBcIlN0b3JpbmcgUmVzcG9uc2VzIGluIENhY2hlc1wiIGNoYXB0ZXIgb2YgSFRUUCBDYWNoaW5nLiBbSFRUUC1DQUNISU5HXVxuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG4gIH1cblxuICAvLyAxMS4gU2V0IHJlc3BvbnNl4oCZcyBVUkwgbGlzdCB0byBhIGNsb25lIG9mIGh0dHBSZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgcmVzcG9uc2UudXJsTGlzdCA9IFsuLi5odHRwUmVxdWVzdC51cmxMaXN0XVxuXG4gIC8vIDEyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzXG4gIC8vIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcbiAgfVxuXG4gIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHJlcXVlc3QtaW5jbHVkZXMtY3JlZGVudGlhbHMgdG8gaW5jbHVkZUNyZWRlbnRpYWxzLlxuICByZXNwb25zZS5yZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyA9IGluY2x1ZGVDcmVkZW50aWFsc1xuXG4gIC8vIDE0LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwMSwgaHR0cFJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIG5vdFxuICAvLyBcImNvcnNcIiwgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIGFuZCByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnRcbiAgLy8gc2V0dGluZ3Mgb2JqZWN0LCB0aGVuOlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDA3LCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDcpIHtcbiAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJuby13aW5kb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyAyLiA/Pz9cblxuICAgIC8vIDMuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyA0LiBQcm9tcHQgdGhlIGVuZCB1c2VyIGFzIGFwcHJvcHJpYXRlIGluIHJlcXVlc3TigJlzIHdpbmRvdyBhbmQgc3RvcmVcbiAgICAvLyB0aGUgcmVzdWx0IGFzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnkuIFtIVFRQLUFVVEhdXG4gICAgLy8gVE9ETzogSW52b2tlIHNvbWUga2luZCBvZiBjYWxsYmFjaz9cblxuICAgIC8vIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuXG4gICAgLy8gZmV0Y2hQYXJhbXMuXG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdwcm94eSBhdXRoZW50aWNhdGlvbiByZXF1aXJlZCcpXG4gIH1cblxuICAvLyAxNi4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWVcbiAgaWYgKFxuICAgIC8vIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDIxXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSA0MjEgJiZcbiAgICAvLyBpc05ld0Nvbm5lY3Rpb25GZXRjaCBpcyBmYWxzZVxuICAgICFpc05ld0Nvbm5lY3Rpb25GZXRjaCAmJlxuICAgIC8vIHJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCwgb3IgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG5vbi1udWxsXG4gICAgKHJlcXVlc3QuYm9keSA9PSBudWxsIHx8IHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgKSB7XG4gICAgLy8gdGhlbjpcblxuICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZVxuICAgIC8vIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLCBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsIGFuZCB0cnVlLlxuXG4gICAgLy8gVE9ETyAoc3BlYyk6IFRoZSBzcGVjIGRvZXNuJ3Qgc3BlY2lmeSB0aGlzIGJ1dCB3ZSBuZWVkIHRvIGNhbmNlbFxuICAgIC8vIHRoZSBhY3RpdmUgcmVzcG9uc2UgYmVmb3JlIHdlIGNhbiBzdGFydCBhIG5ldyBvbmUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI5M1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goXG4gICAgICBmZXRjaFBhcmFtcyxcbiAgICAgIGlzQXV0aGVudGljYXRpb25GZXRjaCxcbiAgICAgIHRydWVcbiAgICApXG4gIH1cblxuICAvLyAxNy4gSWYgaXNBdXRoZW50aWNhdGlvbkZldGNoIGlzIHRydWUsIHRoZW4gY3JlYXRlIGFuIGF1dGhlbnRpY2F0aW9uIGVudHJ5XG4gIGlmIChpc0F1dGhlbnRpY2F0aW9uRmV0Y2gpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxOC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpbmNsdWRlQ3JlZGVudGlhbHMgPSBmYWxzZSxcbiAgZm9yY2VOZXdDb25uZWN0aW9uID0gZmFsc2Vcbikge1xuICBhc3NlcnQoIWZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiB8fCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveWVkKVxuXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiA9IHtcbiAgICBhYm9ydDogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIGRlc3Ryb3kgKGVyciwgYWJvcnQgPSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Py4oZXJyID8/IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDQuIExldCBodHRwQ2FjaGUgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZSBwYXJ0aXRpb24sXG4gIC8vIGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE86IGNhY2hlXG4gIGNvbnN0IGh0dHBDYWNoZSA9IG51bGxcblxuICAvLyA1LiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIHJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyA2LiBMZXQgbmV0d29ya1BhcnRpdGlvbktleSBiZSB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBuZXR3b3JrXG4gIC8vIHBhcnRpdGlvbiBrZXkgZ2l2ZW4gcmVxdWVzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDcuIExldCBuZXdDb25uZWN0aW9uIGJlIFwieWVzXCIgaWYgZm9yY2VOZXdDb25uZWN0aW9uIGlzIHRydWU7IG90aGVyd2lzZVxuICAvLyBcIm5vXCIuXG4gIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBmb3JjZU5ld0Nvbm5lY3Rpb24gPyAneWVzJyA6ICdubycgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8vIDguIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBtb2RlOlxuICBpZiAocmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24sXG4gICAgLy8gZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgLy8gVE9ET1xuICB9IGVsc2Uge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgY29ubmVjdGlvbiwgZ2l2ZW5cbiAgICAvLyBuZXR3b3JrUGFydGl0aW9uS2V5LCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luLFxuICAgIC8vIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGZvcmNlTmV3Q29ubmVjdGlvbi5cbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA5LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgY29ubmVjdGlvbiBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgMi4gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBjYWxsaW5nIGNsYW1wIGFuZCBjb2Fyc2VuIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gd2l0aCBjb25uZWN0aW9u4oCZc1xuICAvLyAgICB0aW1pbmcgaW5mbywgdGltaW5nSW5mb+KAmXMgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lLCBhbmQgZmV0Y2hQYXJhbXPigJlzXG4gIC8vICAgIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDMuIElmIGNvbm5lY3Rpb24gaXMgbm90IGFuIEhUVFAvMiBjb25uZWN0aW9uLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyAgICBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gYXBwZW5kIChgVHJhbnNmZXItRW5jb2RpbmdgLFxuICAvLyAgICBgY2h1bmtlZGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDQuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlcXVlc3Qgc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyAgICBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIG1ha2luZyBhbiBIVFRQIHJlcXVlc3Qgb3ZlciBjb25uZWN0aW9uXG4gIC8vICAgIHVzaW5nIHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIGNhdmVhdHM6XG5cbiAgLy8gICAgICAgIC0gRm9sbG93IHRoZSByZWxldmFudCByZXF1aXJlbWVudHMgZnJvbSBIVFRQLiBbSFRUUF0gW0hUVFAtU0VNQU5USUNTXVxuICAvLyAgICAgICAgW0hUVFAtQ09ORF0gW0hUVFAtQ0FDSElOR10gW0hUVFAtQVVUSF1cblxuICAvLyAgICAgICAgLSBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsXG4gIC8vICAgICAgICB0aGVuIHRoZSB1c2VyIGFnZW50IG1heSBoYXZlIGEgYnVmZmVyIG9mIHVwIHRvIDY0IGtpYmlieXRlcyBhbmQgc3RvcmVcbiAgLy8gICAgICAgIGEgcGFydCBvZiByZXF1ZXN04oCZcyBib2R5IGluIHRoYXQgYnVmZmVyLiBJZiB0aGUgdXNlciBhZ2VudCByZWFkcyBmcm9tXG4gIC8vICAgICAgICByZXF1ZXN04oCZcyBib2R5IGJleW9uZCB0aGF0IGJ1ZmZlcuKAmXMgc2l6ZSBhbmQgdGhlIHVzZXIgYWdlbnQgbmVlZHMgdG9cbiAgLy8gICAgICAgIHJlc2VuZCByZXF1ZXN0LCB0aGVuIGluc3RlYWQgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyAgICAgICAgLSBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWRcbiAgLy8gICAgICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LFxuICAvLyAgICAgICAgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHVzZXIgYWdlbnTigJlzIEhUVFAgcGFyc2VyIHJlY2VpdmVzIHRoZSBmaXJzdCBieXRlXG4gIC8vICAgICAgICBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIGZyYW1lIGhlYWRlciBieXRlcyBmb3IgSFRUUC8yIG9yIHJlc3BvbnNlIHN0YXR1c1xuICAvLyAgICAgICAgbGluZSBmb3IgSFRUUC8xLngpLlxuXG4gIC8vICAgICAgICAtIFdhaXQgdW50aWwgYWxsIHRoZSBoZWFkZXJzIGFyZSB0cmFuc21pdHRlZC5cblxuICAvLyAgICAgICAgLSBBbnkgcmVzcG9uc2VzIHdob3NlIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2UgMTAwIHRvIDE5OSwgaW5jbHVzaXZlLFxuICAvLyAgICAgICAgYW5kIGlzIG5vdCAxMDEsIGFyZSB0byBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzZXR0aW5nXG4gIC8vICAgICAgICB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgYWJvdmUuXG5cbiAgLy8gICAgLSBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgVHJhbnNmZXItRW5jb2RpbmdgL2BjaHVua2VkYCBhbmRcbiAgLy8gICAgcmVzcG9uc2UgaXMgdHJhbnNmZXJyZWQgdmlhIEhUVFAvMS4wIG9yIG9sZGVyLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gICAgZXJyb3IuXG5cbiAgLy8gICAgLSBJZiB0aGUgSFRUUCByZXF1ZXN0IHJlc3VsdHMgaW4gYSBUTFMgY2xpZW50IGNlcnRpZmljYXRlIGRpYWxvZywgdGhlbjpcblxuICAvLyAgICAgICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCwgbWFrZSB0aGVcbiAgLy8gICAgICAgIGRpYWxvZyBhdmFpbGFibGUgaW4gcmVxdWVzdOKAmXMgd2luZG93LlxuXG4gIC8vICAgICAgICAyLiBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gVG8gdHJhbnNtaXQgcmVxdWVzdOKAmXMgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG4gIGxldCByZXF1ZXN0Qm9keSA9IG51bGxcbiAgLy8gMS4gSWYgYm9keSBpcyBudWxsIGFuZCBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzXG4gIC8vIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0XG4gIC8vIGVuZC1vZi1ib2R5IGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKHJlcXVlc3QuYm9keSA9PSBudWxsICYmIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKSlcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYm9keSBpcyBub24tbnVsbDpcblxuICAgIC8vICAgIDEuIExldCBwcm9jZXNzQm9keUNodW5rIGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5Q2h1bmsgPSBhc3luYyBmdW5jdGlvbiAqIChieXRlcykge1xuICAgICAgLy8gMS4gSWYgdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6IHRyYW5zbWl0IGJ5dGVzLlxuICAgICAgeWllbGQgYnl0ZXNcblxuICAgICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHJ1blxuICAgICAgLy8gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGdpdmVuIGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aD8uKGJ5dGVzLmJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHByb2Nlc3NFbmRPZkJvZHkgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0VuZE9mQm9keSA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBub24tbnVsbCxcbiAgICAgIC8vIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIExldCBwcm9jZXNzQm9keUVycm9yIGdpdmVuIGUgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChlKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGUgaXMgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLCB0aGVuIGFib3J0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJbmNyZW1lbnRhbGx5IHJlYWQgcmVxdWVzdOKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keUNodW5rLCBwcm9jZXNzRW5kT2ZCb2R5LFxuICAgIC8vIHByb2Nlc3NCb2R5RXJyb3IsIGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICByZXF1ZXN0Qm9keSA9IChhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYnl0ZXMgb2YgcmVxdWVzdC5ib2R5LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcHJvY2Vzc0JvZHlDaHVuayhieXRlcylcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRW5kT2ZCb2R5KClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIHNvY2tldCBpcyBvbmx5IHByb3ZpZGVkIGZvciB3ZWJzb2NrZXRzXG4gICAgY29uc3QgeyBib2R5LCBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0LCBzb2NrZXQgfSA9IGF3YWl0IGRpc3BhdGNoKHsgYm9keTogcmVxdWVzdEJvZHkgfSlcblxuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gYm9keVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0ID0gKCkgPT4gaXRlcmF0b3IubmV4dCgpXG5cbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCB9KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gMTAuIElmIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIC8vIDEuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgICAgLy8gMi4gUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMsIGVycilcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihlcnIpXG4gIH1cblxuICAvLyAxMS4gTGV0IHB1bGxBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgb25nb2luZyBmZXRjaFxuICAvLyBpZiBpdCBpcyBzdXNwZW5kZWQuXG4gIGNvbnN0IHB1bGxBbGdvcml0aG0gPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUoKVxuICB9XG5cbiAgLy8gMTIuIExldCBjYW5jZWxBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWJvcnRzIGZldGNoUGFyYW1z4oCZc1xuICAvLyBjb250cm9sbGVyIHdpdGggcmVhc29uLCBnaXZlbiByZWFzb24uXG4gIGNvbnN0IGNhbmNlbEFsZ29yaXRobSA9IChyZWFzb24pID0+IHtcbiAgICAvLyBJZiB0aGUgYWJvcnRlZCBmZXRjaCB3YXMgYWxyZWFkeSB0ZXJtaW5hdGVkLCB0aGVuIHdlIGRvIG5vdFxuICAgIC8vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgaWYgKCFpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQocmVhc29uKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBMZXQgaGlnaFdhdGVyTWFyayBiZSBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiBudW1iZXIsIGNob3NlbiBieVxuICAvLyB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE0LiBMZXQgc2l6ZUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhY2NlcHRzIGEgY2h1bmsgb2JqZWN0XG4gIC8vIGFuZCByZXR1cm5zIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOLCBub24taW5maW5pdGUgbnVtYmVyLCBjaG9zZW4gYnkgdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNS4gTGV0IHN0cmVhbSBiZSBhIG5ldyBSZWFkYWJsZVN0cmVhbS5cbiAgLy8gMTYuIFNldCB1cCBzdHJlYW0gd2l0aCBieXRlIHJlYWRpbmcgc3VwcG9ydCB3aXRoIHB1bGxBbGdvcml0aG0gc2V0IHRvIHB1bGxBbGdvcml0aG0sXG4gIC8vICAgICBjYW5jZWxBbGdvcml0aG0gc2V0IHRvIGNhbmNlbEFsZ29yaXRobS5cbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgIHtcbiAgICAgIGFzeW5jIHN0YXJ0IChjb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlciA9IGNvbnRyb2xsZXJcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IHB1bGxBbGdvcml0aG0oY29udHJvbGxlcilcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBjYW5jZWxBbGdvcml0aG0ocmVhc29uKVxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9XG4gIClcblxuICAvLyAxNy4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBhIG5ldyBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0uXG4gIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbSwgc291cmNlOiBudWxsLCBsZW5ndGg6IG51bGwgfVxuXG4gIC8vICAgIDIuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXNcbiAgLy8gICAgbm90IFwibm8tc3RvcmVcIiwgdGhlbiB1cGRhdGUgcmVzcG9uc2UgaW4gaHR0cENhY2hlIGZvciByZXF1ZXN0LlxuICAvLyAgICBUT0RPXG5cbiAgLy8gICAgMy4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkXG4gIC8vICAgIHRvIGJsb2NrIGNvb2tpZXMgZm9yIHJlcXVlc3QgKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbiBydW4gdGhlXG4gIC8vICAgIFwic2V0LWNvb2tpZS1zdHJpbmdcIiBwYXJzaW5nIGFsZ29yaXRobSAoc2VlIHNlY3Rpb24gNS4yIG9mIFtDT09LSUVTXSkgb25cbiAgLy8gICAgdGhlIHZhbHVlIG9mIGVhY2ggaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gIC8vICAgIGBTZXQtQ29va2llYCBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QsIGlmIGFueSwgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAvLyAgICBUT0RPXG5cbiAgLy8gMTguIElmIGFib3J0ZWQsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxOS4gUnVuIHRoZXNlIHN0ZXBzIGluIHBhcmFsbGVsOlxuXG4gIC8vICAgIDEuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQ6XG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkID0gb25BYm9ydGVkXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBvbkFib3J0ZWQpXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIDEuIFdoaWxlIHRydWVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gMS0zLiBTZWUgb25EYXRhLi4uXG5cbiAgICAgIC8vIDQuIFNldCBieXRlcyB0byB0aGUgcmVzdWx0IG9mIGhhbmRsaW5nIGNvbnRlbnQgY29kaW5ncyBnaXZlblxuICAgICAgLy8gY29kaW5ncyBhbmQgYnl0ZXMuXG4gICAgICBsZXQgYnl0ZXNcbiAgICAgIGxldCBpc0ZhaWx1cmVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCgpXG5cbiAgICAgICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZXMgPSBkb25lID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCAmJiAhdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUpIHtcbiAgICAgICAgICAvLyB6bGliIGRvZXNuJ3QgbGlrZSBlbXB0eSBzdHJlYW1zLlxuICAgICAgICAgIGJ5dGVzID0gdW5kZWZpbmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZXMgPSBlcnJcblxuICAgICAgICAgIC8vIGVyciBtYXkgYmUgcHJvcGFnYXRlZCBmcm9tIHRoZSByZXN1bHQgb2YgY2FsbGluZyByZWFkYWJsZXN0cmVhbS5jYW5jZWwsXG4gICAgICAgICAgLy8gd2hpY2ggbWlnaHQgbm90IGJlIGFuIGVycm9yLiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAwOVxuICAgICAgICAgIGlzRmFpbHVyZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHRoZSBieXRlcyB0cmFuc21pc3Npb24gZm9yIHJlc3BvbnNl4oCZcyBtZXNzYWdlXG4gICAgICAgIC8vIGJvZHkgaXMgZG9uZSBub3JtYWxseSBhbmQgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGNsb3NlXG4gICAgICAgIC8vIHN0cmVhbSwgZmluYWxpemUgcmVzcG9uc2UgZm9yIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZSwgYW5kXG4gICAgICAgIC8vIGFib3J0IHRoZXNlIGluLXBhcmFsbGVsIHN0ZXBzLlxuICAgICAgICByZWFkYWJsZVN0cmVhbUNsb3NlKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlcilcblxuICAgICAgICBmaW5hbGl6ZVJlc3BvbnNlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSW5jcmVhc2UgdGltaW5nSW5mb+KAmXMgZGVjb2RlZCBib2R5IHNpemUgYnkgYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgIHRpbWluZ0luZm8uZGVjb2RlZEJvZHlTaXplICs9IGJ5dGVzPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgICAgLy8gNi4gSWYgYnl0ZXMgaXMgZmFpbHVyZSwgdGhlbiB0ZXJtaW5hdGUgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXIuXG4gICAgICBpZiAoaXNGYWlsdXJlKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGJ5dGVzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNy4gRW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBieXRlc1xuICAgICAgLy8gaW50byBzdHJlYW0uXG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcylcbiAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICB9XG5cbiAgICAgIC8vIDguIElmIHN0cmVhbSBpcyBlcnJvcmVkLCB0aGVuIHRlcm1pbmF0ZSB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmIChpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA5LiBJZiBzdHJlYW0gZG9lc27igJl0IG5lZWQgbW9yZSBkYXRhIGFzayB0aGUgdXNlciBhZ2VudCB0byBzdXNwZW5kXG4gICAgICAvLyB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAgICAyLiBJZiBhYm9ydGVkLCB0aGVuOlxuICBmdW5jdGlvbiBvbkFib3J0ZWQgKHJlYXNvbikge1xuICAgIC8vIDIuIElmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnLlxuICAgICAgcmVzcG9uc2UuYWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gSWYgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGVycm9yIHN0cmVhbSB3aXRoIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzXG4gICAgICAvLyAgICBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBhbmQgYW5cbiAgICAgIC8vICAgIGltcGxlbWVudGF0aW9uLWRlZmluZWQgcmVhbG0uXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgc3RyZWFtIGlzIHJlYWRhYmxlLCBlcnJvciBzdHJlYW0gd2l0aCBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKG5ldyBUeXBlRXJyb3IoJ3Rlcm1pbmF0ZWQnLCB7XG4gICAgICAgICAgY2F1c2U6IGlzRXJyb3JMaWtlKHJlYXNvbikgPyByZWFzb24gOiB1bmRlZmluZWRcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgdGhlIHVzZXIgYWdlbnQgc2hvdWxkIGNsb3NlIGNvbm5lY3Rpb24gdW5sZXNzIGl0IHdvdWxkIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gZG8gc28uXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuICB9XG5cbiAgLy8gMjAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2ggKHsgYm9keSB9KSB7XG4gICAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vLi4nKS5BZ2VudH0gKi9cbiAgICBjb25zdCBhZ2VudCA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlclxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFnZW50LmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICBwYXRoOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIGJvZHk6IGFnZW50LmlzTW9ja0FjdGl2ZSA/IHJlcXVlc3QuYm9keSAmJiAocmVxdWVzdC5ib2R5LnNvdXJjZSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKSA6IGJvZHksXG4gICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVyc0xpc3QuZW50cmllcyxcbiAgICAgICAgbWF4UmVkaXJlY3Rpb25zOiAwLFxuICAgICAgICB1cGdyYWRlOiByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnID8gJ3dlYnNvY2tldCcgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgIGFib3J0OiBudWxsLFxuXG4gICAgICAgIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIGNvbm5lY3Rpb24gaGVyZT9cbiAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXJcblxuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlblxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gd2l0aCBjb25uZWN0aW9u4oCZcyB0aW1pbmcgaW5mbywgdGltaW5nSW5mb+KAmXMgcG9zdC1yZWRpcmVjdCBzdGFydFxuICAgICAgICAgIC8vIHRpbWUsIGFuZCBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNvbm5lY3Rpb24gdGltaW5nXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvID0gY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8odW5kZWZpbmVkLCB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSwgZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIGFib3J0KVxuICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlcXVlc3Qgc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgICAgICAgICAvLyBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNwb25zZVN0YXJ0ZWQgKCkge1xuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudFxuICAgICAgICAgIC8vIHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgICAgICAgICAvLyB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIGZyYW1lIGhlYWRlclxuICAgICAgICAgIC8vIGJ5dGVzIGZvciBIVFRQLzIgb3IgcmVzcG9uc2Ugc3RhdHVzIGxpbmUgZm9yIEhUVFAvMS54KS5cbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25IZWFkZXJzIChzdGF0dXMsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgPCAyMDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgICAgICAgbGV0IGNvZGluZ3MgPSBbXVxuICAgICAgICAgIGxldCBsb2NhdGlvbiA9ICcnXG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0hlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKHJhd0hlYWRlcnNbaV0pLCByYXdIZWFkZXJzW2kgKyAxXS50b1N0cmluZygnbGF0aW4xJyksIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGhlYWRlcnNMaXN0LmdldCgnY29udGVudC1lbmNvZGluZycsIHRydWUpXG4gICAgICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi0zLjEuMi4xXG4gICAgICAgICAgICAvLyBcIkFsbCBjb250ZW50LWNvZGluZyB2YWx1ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuLi5cIlxuICAgICAgICAgICAgY29kaW5ncyA9IGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYXRpb24gPSBoZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJywgdHJ1ZSlcblxuICAgICAgICAgIHRoaXMuYm9keSA9IG5ldyBSZWFkYWJsZSh7IHJlYWQ6IHJlc3VtZSB9KVxuXG4gICAgICAgICAgY29uc3QgZGVjb2RlcnMgPSBbXVxuXG4gICAgICAgICAgY29uc3Qgd2lsbEZvbGxvdyA9IGxvY2F0aW9uICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnICYmXG4gICAgICAgICAgICByZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKVxuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtRW5jb2RpbmdcbiAgICAgICAgICBpZiAoY29kaW5ncy5sZW5ndGggIT09IDAgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0NPTk5FQ1QnICYmICFudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpICYmICF3aWxsRm9sbG93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGluZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29kaW5nID0gY29kaW5nc1tpXVxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMi5odG1sI3NlY3Rpb24tNy4yXG4gICAgICAgICAgICAgIGlmIChjb2RpbmcgPT09ICd4LWd6aXAnIHx8IGNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcnMucHVzaCh6bGliLmNyZWF0ZUd1bnppcCh7XG4gICAgICAgICAgICAgICAgICAvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcbiAgICAgICAgICAgICAgICAgIC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuICAgICAgICAgICAgICAgICAgLy8gYnkgY29tbW9uIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0gsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hGbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNIXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKGNyZWF0ZUluZmxhdGUoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdicicpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyc0xpc3QsXG4gICAgICAgICAgICBib2R5OiBkZWNvZGVycy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBwaXBlbGluZSh0aGlzLmJvZHksIC4uLmRlY29kZXJzLCAoKSA9PiB7IH0pXG4gICAgICAgICAgICAgIDogdGhpcy5ib2R5Lm9uKCdlcnJvcicsICgpID0+IHsgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRhdGEgKGNodW5rKSB7XG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gMS4gSWYgb25lIG9yIG1vcmUgYnl0ZXMgaGF2ZSBiZWVuIHRyYW5zbWl0dGVkIGZyb20gcmVzcG9uc2XigJlzXG4gICAgICAgICAgLy8gbWVzc2FnZSBib2R5LCB0aGVuOlxuXG4gICAgICAgICAgLy8gIDEuIExldCBieXRlcyBiZSB0aGUgdHJhbnNtaXR0ZWQgYnl0ZXMuXG4gICAgICAgICAgY29uc3QgYnl0ZXMgPSBjaHVua1xuXG4gICAgICAgICAgLy8gIDIuIExldCBjb2RpbmdzIGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBoZWFkZXIgbGlzdCB2YWx1ZXNcbiAgICAgICAgICAvLyAgZ2l2ZW4gYENvbnRlbnQtRW5jb2RpbmdgIGFuZCByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgICAgLy8gIFNlZSBwdWxsQWxnb3JpdGhtLlxuXG4gICAgICAgICAgLy8gIDMuIEluY3JlYXNlIHRpbWluZ0luZm/igJlzIGVuY29kZWQgYm9keSBzaXplIGJ5IGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICAgICAgdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUgKz0gYnl0ZXMuYnl0ZUxlbmd0aFxuXG4gICAgICAgICAgLy8gIDQuIFNlZSBwdWxsQWxnb3JpdGhtLi4uXG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5LnB1c2goYnl0ZXMpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db21wbGV0ZSAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbkFib3J0ZWQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbkFib3J0ZWQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCA9IHRydWVcblxuICAgICAgICAgIHRoaXMuYm9keS5wdXNoKG51bGwpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FcnJvciAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5hYm9ydCkge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vZmYoJ3Rlcm1pbmF0ZWQnLCB0aGlzLmFib3J0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYm9keT8uZGVzdHJveShlcnJvcilcblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGVycm9yKVxuXG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uVXBncmFkZSAoc3RhdHVzLCByYXdIZWFkZXJzLCBzb2NrZXQpIHtcbiAgICAgICAgICBpZiAoc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnNMaXN0KClcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3SGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgaGVhZGVyc0xpc3QuYXBwZW5kKGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUocmF3SGVhZGVyc1tpXSksIHJhd0hlYWRlcnNbaSArIDFdLnRvU3RyaW5nKCdsYXRpbjEnKSwgdHJ1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFNUQVRVU19DT0RFU1tzdGF0dXNdLFxuICAgICAgICAgICAgaGVhZGVyc0xpc3QsXG4gICAgICAgICAgICBzb2NrZXRcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZldGNoLFxuICBGZXRjaCxcbiAgZmV0Y2hpbmcsXG4gIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ \"(ssr)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\")()\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { kHeaders, kSignal, kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = {}) {\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input, prefix, 'input')\n    init = webidl.converters.RequestInit(init, prefix, 'init')\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this[kDispatcher] = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      this[kDispatcher] = init.dispatcher || input[kDispatcher]\n\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set request’s referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set request’s method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // Third-party AbortControllers may not work with these.\n        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n        try {\n          // If the max amount of listeners is equal to the default, increase it\n          // This is only available in node >= v19.9.0\n          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          }\n        } catch {}\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersList(this[kHeaders], request.headersList)\n    setHeadersGuard(this[kHeaders], 'request')\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      setHeadersGuard(this[kHeaders], 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this[kHeaders])\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty this’s headers’s header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kHeaders], headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !getHeadersList(this[kHeaders]).contains('content-type', true)) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return URLSerializer(this[kState].url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body?.locked) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Request)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, signal, guard) {\n  const request = new Request(kConstruct)\n  request[kState] = innerRequest\n  request[kSignal] = signal\n  request[kHeaders] = new Headers(kConstruct)\n  setHeadersList(request[kHeaders], innerRequest.headersList)\n  setHeadersGuard(request[kHeaders], guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.converters.Request = webidl.interfaceConverter(\n  Request\n)\n\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function (V, prefix, argument) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, argument)\n  }\n\n  if (V instanceof Request) {\n    return webidl.converters.Request(V, prefix, argument)\n  }\n\n  return webidl.converters.USVString(V, prefix, argument)\n}\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  AbortSignal\n)\n\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal',\n        { strict: false }\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = { Request, makeRequest, fromInnerRequest, cloneRequest }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDOUQsUUFBUSw0R0FBNEcsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ3pJLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDL0QsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw0QkFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsNEVBQTRFO0FBQ3BGLFFBQVEseUNBQXlDLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUN0RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUM5QyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUUxRzs7QUFFQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUVBQW1FLFlBQVk7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsc0JBQXNCOztBQUVwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkNBQTJDLFNBQVMsMEJBQTBCLFlBQVk7QUFDMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBZ0Q7QUFDdEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLHdCQUF3Qjs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxtRUFBbUU7QUFDOUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSB9ID0gcmVxdWlyZSgnLi9ib2R5JylcbmNvbnN0IHsgSGVhZGVycywgZmlsbDogZmlsbEhlYWRlcnMsIEhlYWRlcnNMaXN0LCBzZXRIZWFkZXJzR3VhcmQsIGdldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0xpc3QsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBGaW5hbGl6YXRpb25SZWdpc3RyeSB9ID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLXdlYWtyZWYnKSgpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHtcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgc2FtZU9yaWdpbixcbiAgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7XG4gIGZvcmJpZGRlbk1ldGhvZHNTZXQsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldCxcbiAgcmVmZXJyZXJQb2xpY3ksXG4gIHJlcXVlc3RSZWRpcmVjdCxcbiAgcmVxdWVzdE1vZGUsXG4gIHJlcXVlc3RDcmVkZW50aWFscyxcbiAgcmVxdWVzdENhY2hlLFxuICByZXF1ZXN0RHVwbGV4XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UsIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzIH0gPSB1dGlsXG5jb25zdCB7IGtIZWFkZXJzLCBrU2lnbmFsLCBrU3RhdGUsIGtEaXNwYXRjaGVyIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGtDb25zdHJ1Y3QgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGdldE1heExpc3RlbmVycywgc2V0TWF4TGlzdGVuZXJzLCBnZXRFdmVudExpc3RlbmVycywgZGVmYXVsdE1heExpc3RlbmVycyB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuXG5jb25zdCBrQWJvcnRDb250cm9sbGVyID0gU3ltYm9sKCdhYm9ydENvbnRyb2xsZXInKVxuXG5jb25zdCByZXF1ZXN0RmluYWxpemVyID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCh7IHNpZ25hbCwgYWJvcnQgfSkgPT4ge1xuICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcbn0pXG5cbmNvbnN0IGRlcGVuZGVudENvbnRyb2xsZXJNYXAgPSBuZXcgV2Vha01hcCgpXG5cbmZ1bmN0aW9uIGJ1aWxkQWJvcnQgKGFjUmVmKSB7XG4gIHJldHVybiBhYm9ydFxuXG4gIGZ1bmN0aW9uIGFib3J0ICgpIHtcbiAgICBjb25zdCBhYyA9IGFjUmVmLmRlcmVmKClcbiAgICBpZiAoYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ3VycmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCBGaW5hbGl6YXRpb25SZWdpc3RyeS5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDc3NDhcbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFib3J0LCB0aGUgZmlyc3Qgc3RlcCBpcyB0byB1bnJlZ2lzdGVyIGZyb20gaXQuXG4gICAgICAvLyBJZiB0aGUgY29udHJvbGxlciBjYW4gcmVmZXIgdG8gaXQsIGl0IGlzIHN0aWxsIHJlZ2lzdGVyZWQuXG4gICAgICAvLyBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHJlcXVlc3RGaW5hbGl6ZXIudW5yZWdpc3RlcihhYm9ydClcblxuICAgICAgLy8gVW5zdWJzY3JpYmUgYSBsaXN0ZW5lci5cbiAgICAgIC8vIEZpbmFsaXphdGlvblJlZ2lzdHJ5IHdpbGwgbm8gbG9uZ2VyIGJlIGNhbGxlZCwgc28gdGhpcyBtdXN0IGJlIGRvbmUuXG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQpXG5cbiAgICAgIGFjLmFib3J0KHRoaXMucmVhc29uKVxuXG4gICAgICBjb25zdCBjb250cm9sbGVyTGlzdCA9IGRlcGVuZGVudENvbnRyb2xsZXJNYXAuZ2V0KGFjLnNpZ25hbClcblxuICAgICAgaWYgKGNvbnRyb2xsZXJMaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJMaXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBjb250cm9sbGVyTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY3RybCA9IHJlZi5kZXJlZigpXG4gICAgICAgICAgICBpZiAoY3RybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN0cmwuYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXJMaXN0LmNsZWFyKClcbiAgICAgICAgfVxuICAgICAgICBkZXBlbmRlbnRDb250cm9sbGVyTWFwLmRlbGV0ZShhYy5zaWduYWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBwYXRjaE1ldGhvZFdhcm5pbmcgPSBmYWxzZVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdC1jbGFzc1xuY2xhc3MgUmVxdWVzdCB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdFxuICBjb25zdHJ1Y3RvciAoaW5wdXQsIGluaXQgPSB7fSkge1xuICAgIGlmIChpbnB1dCA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1JlcXVlc3QgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpbnB1dCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKGlucHV0LCBwcmVmaXgsICdpbnB1dCcpXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbml0KGluaXQsIHByZWZpeCwgJ2luaXQnKVxuXG4gICAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgbnVsbC5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGxcblxuICAgIC8vIDIuIExldCBmYWxsYmFja01vZGUgYmUgbnVsbC5cbiAgICBsZXQgZmFsbGJhY2tNb2RlID0gbnVsbFxuXG4gICAgLy8gMy4gTGV0IGJhc2VVUkwgYmUgdGhpc+KAmXMgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN04oCZcyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVybCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gNC4gTGV0IHNpZ25hbCBiZSBudWxsLlxuICAgIGxldCBzaWduYWwgPSBudWxsXG5cbiAgICAvLyA1LiBJZiBpbnB1dCBpcyBhIHN0cmluZywgdGhlbjpcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1trRGlzcGF0Y2hlcl0gPSBpbml0LmRpc3BhdGNoZXJcblxuICAgICAgLy8gMS4gTGV0IHBhcnNlZFVSTCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgaW5wdXQgd2l0aCBiYXNlVVJMLlxuICAgICAgLy8gMi4gSWYgcGFyc2VkVVJMIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBsZXQgcGFyc2VkVVJMXG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKGlucHV0LCBiYXNlVXJsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBVUkwgZnJvbSAnICsgaW5wdXQsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBwYXJzZWRVUkwgaW5jbHVkZXMgY3JlZGVudGlhbHMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAocGFyc2VkVVJMLnVzZXJuYW1lIHx8IHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdSZXF1ZXN0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBmcm9tIGEgVVJMIHRoYXQgaW5jbHVkZXMgY3JlZGVudGlhbHM6ICcgK1xuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdCB0byBhIG5ldyByZXF1ZXN0IHdob3NlIFVSTCBpcyBwYXJzZWRVUkwuXG4gICAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3QoeyB1cmxMaXN0OiBbcGFyc2VkVVJMXSB9KVxuXG4gICAgICAvLyA1LiBTZXQgZmFsbGJhY2tNb2RlIHRvIFwiY29yc1wiLlxuICAgICAgZmFsbGJhY2tNb2RlID0gJ2NvcnMnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0Rpc3BhdGNoZXJdID0gaW5pdC5kaXNwYXRjaGVyIHx8IGlucHV0W2tEaXNwYXRjaGVyXVxuXG4gICAgICAvLyA2LiBPdGhlcndpc2U6XG5cbiAgICAgIC8vIDcuIEFzc2VydDogaW5wdXQgaXMgYSBSZXF1ZXN0IG9iamVjdC5cbiAgICAgIGFzc2VydChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpXG5cbiAgICAgIC8vIDguIFNldCByZXF1ZXN0IHRvIGlucHV04oCZcyByZXF1ZXN0LlxuICAgICAgcmVxdWVzdCA9IGlucHV0W2tTdGF0ZV1cblxuICAgICAgLy8gOS4gU2V0IHNpZ25hbCB0byBpbnB1dOKAmXMgc2lnbmFsLlxuICAgICAgc2lnbmFsID0gaW5wdXRba1NpZ25hbF1cbiAgICB9XG5cbiAgICAvLyA3LiBMZXQgb3JpZ2luIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgb3JpZ2luLlxuICAgIGNvbnN0IG9yaWdpbiA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3Qub3JpZ2luXG5cbiAgICAvLyA4LiBMZXQgd2luZG93IGJlIFwiY2xpZW50XCIuXG4gICAgbGV0IHdpbmRvdyA9ICdjbGllbnQnXG5cbiAgICAvLyA5LiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0IGFuZCBpdHMgb3JpZ2luXG4gICAgLy8gaXMgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW4sIHRoZW4gc2V0IHdpbmRvdyB0byByZXF1ZXN04oCZcyB3aW5kb3cuXG4gICAgaWYgKFxuICAgICAgcmVxdWVzdC53aW5kb3c/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCcgJiZcbiAgICAgIHNhbWVPcmlnaW4ocmVxdWVzdC53aW5kb3csIG9yaWdpbilcbiAgICApIHtcbiAgICAgIHdpbmRvdyA9IHJlcXVlc3Qud2luZG93XG4gICAgfVxuXG4gICAgLy8gMTAuIElmIGluaXRbXCJ3aW5kb3dcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoaW5pdC53aW5kb3cgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ3dpbmRvdycgb3B0aW9uICcke3dpbmRvd30nIG11c3QgYmUgbnVsbGApXG4gICAgfVxuXG4gICAgLy8gMTEuIElmIGluaXRbXCJ3aW5kb3dcIl0gZXhpc3RzLCB0aGVuIHNldCB3aW5kb3cgdG8gXCJuby13aW5kb3dcIi5cbiAgICBpZiAoJ3dpbmRvdycgaW4gaW5pdCkge1xuICAgICAgd2luZG93ID0gJ25vLXdpbmRvdydcbiAgICB9XG5cbiAgICAvLyAxMi4gU2V0IHJlcXVlc3QgdG8gYSBuZXcgcmVxdWVzdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICByZXF1ZXN0ID0gbWFrZVJlcXVlc3Qoe1xuICAgICAgLy8gVVJMIHJlcXVlc3TigJlzIFVSTC5cbiAgICAgIC8vIHVuZGljaSBpbXBsZW1lbnRhdGlvbiBub3RlOiB0aGlzIGlzIHNldCBhcyB0aGUgZmlyc3QgaXRlbSBpbiByZXF1ZXN0J3MgdXJsTGlzdCBpbiBtYWtlUmVxdWVzdFxuICAgICAgLy8gbWV0aG9kIHJlcXVlc3TigJlzIG1ldGhvZC5cbiAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAvLyBoZWFkZXIgbGlzdCBBIGNvcHkgb2YgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogaGVhZGVyc0xpc3QgaXMgY2xvbmVkIGluIG1ha2VSZXF1ZXN0XG4gICAgICBoZWFkZXJzTGlzdDogcmVxdWVzdC5oZWFkZXJzTGlzdCxcbiAgICAgIC8vIHVuc2FmZS1yZXF1ZXN0IGZsYWcgU2V0LlxuICAgICAgdW5zYWZlUmVxdWVzdDogcmVxdWVzdC51bnNhZmVSZXF1ZXN0LFxuICAgICAgLy8gY2xpZW50IFRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cbiAgICAgIGNsaWVudDogZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdCxcbiAgICAgIC8vIHdpbmRvdyB3aW5kb3cuXG4gICAgICB3aW5kb3csXG4gICAgICAvLyBwcmlvcml0eSByZXF1ZXN04oCZcyBwcmlvcml0eS5cbiAgICAgIHByaW9yaXR5OiByZXF1ZXN0LnByaW9yaXR5LFxuICAgICAgLy8gb3JpZ2luIHJlcXVlc3TigJlzIG9yaWdpbi4gVGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBvcmlnaW4gaXMgb25seSBzaWduaWZpY2FudCBmb3IgbmF2aWdhdGlvbiByZXF1ZXN0c1xuICAgICAgLy8gYmVpbmcgaGFuZGxlZCBieSBhIHNlcnZpY2Ugd29ya2VyLiBJbiB0aGlzIHNjZW5hcmlvIGEgcmVxdWVzdCBjYW4gaGF2ZSBhbiBvcmlnaW4gdGhhdCBpcyBkaWZmZXJlbnRcbiAgICAgIC8vIGZyb20gdGhlIGN1cnJlbnQgY2xpZW50LlxuICAgICAgb3JpZ2luOiByZXF1ZXN0Lm9yaWdpbixcbiAgICAgIC8vIHJlZmVycmVyIHJlcXVlc3TigJlzIHJlZmVycmVyLlxuICAgICAgcmVmZXJyZXI6IHJlcXVlc3QucmVmZXJyZXIsXG4gICAgICAvLyByZWZlcnJlciBwb2xpY3kgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHJlcXVlc3QucmVmZXJyZXJQb2xpY3ksXG4gICAgICAvLyBtb2RlIHJlcXVlc3TigJlzIG1vZGUuXG4gICAgICBtb2RlOiByZXF1ZXN0Lm1vZGUsXG4gICAgICAvLyBjcmVkZW50aWFscyBtb2RlIHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGUuXG4gICAgICBjcmVkZW50aWFsczogcmVxdWVzdC5jcmVkZW50aWFscyxcbiAgICAgIC8vIGNhY2hlIG1vZGUgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZS5cbiAgICAgIGNhY2hlOiByZXF1ZXN0LmNhY2hlLFxuICAgICAgLy8gcmVkaXJlY3QgbW9kZSByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgICAgcmVkaXJlY3Q6IHJlcXVlc3QucmVkaXJlY3QsXG4gICAgICAvLyBpbnRlZ3JpdHkgbWV0YWRhdGEgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhLlxuICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0LmludGVncml0eSxcbiAgICAgIC8vIGtlZXBhbGl2ZSByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgICBrZWVwYWxpdmU6IHJlcXVlc3Qua2VlcGFsaXZlLFxuICAgICAgLy8gcmVsb2FkLW5hdmlnYXRpb24gZmxhZyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVsb2FkTmF2aWdhdGlvbjogcmVxdWVzdC5yZWxvYWROYXZpZ2F0aW9uLFxuICAgICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICBoaXN0b3J5TmF2aWdhdGlvbjogcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbixcbiAgICAgIC8vIFVSTCBsaXN0IEEgY2xvbmUgb2YgcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gICAgICB1cmxMaXN0OiBbLi4ucmVxdWVzdC51cmxMaXN0XVxuICAgIH0pXG5cbiAgICBjb25zdCBpbml0SGFzS2V5ID0gT2JqZWN0LmtleXMoaW5pdCkubGVuZ3RoICE9PSAwXG5cbiAgICAvLyAxMy4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8vIDEuIElmIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHNldCBpdCB0byBcInNhbWUtb3JpZ2luXCIuXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICAgIHJlcXVlc3QubW9kZSA9ICdzYW1lLW9yaWdpbidcbiAgICAgIH1cblxuICAgICAgLy8gMi4gVW5zZXQgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDMuIFVuc2V0IHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgcmVxdWVzdC5oaXN0b3J5TmF2aWdhdGlvbiA9IGZhbHNlXG5cbiAgICAgIC8vIDQuIFNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gXCJjbGllbnRcIi5cbiAgICAgIHJlcXVlc3Qub3JpZ2luID0gJ2NsaWVudCdcblxuICAgICAgLy8gNS4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwiY2xpZW50XCJcbiAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuXG4gICAgICAvLyA2LiBTZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5IHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICByZXF1ZXN0LnJlZmVycmVyUG9saWN5ID0gJydcblxuICAgICAgLy8gNy4gU2V0IHJlcXVlc3TigJlzIFVSTCB0byByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgICAgIHJlcXVlc3QudXJsID0gcmVxdWVzdC51cmxMaXN0W3JlcXVlc3QudXJsTGlzdC5sZW5ndGggLSAxXVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdOKAmXMgVVJMIGxpc3QgdG8gwqsgcmVxdWVzdOKAmXMgVVJMIMK7LlxuICAgICAgcmVxdWVzdC51cmxMaXN0ID0gW3JlcXVlc3QudXJsXVxuICAgIH1cblxuICAgIC8vIDE0LiBJZiBpbml0W1wicmVmZXJyZXJcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0LnJlZmVycmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWZlcnJlciBiZSBpbml0W1wicmVmZXJyZXJcIl0uXG4gICAgICBjb25zdCByZWZlcnJlciA9IGluaXQucmVmZXJyZXJcblxuICAgICAgLy8gMi4gSWYgcmVmZXJyZXIgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJuby1yZWZlcnJlclwiLlxuICAgICAgaWYgKHJlZmVycmVyID09PSAnJykge1xuICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ25vLXJlZmVycmVyJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gTGV0IHBhcnNlZFJlZmVycmVyIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyByZWZlcnJlciB3aXRoXG4gICAgICAgIC8vIGJhc2VVUkwuXG4gICAgICAgIC8vIDIuIElmIHBhcnNlZFJlZmVycmVyIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGxldCBwYXJzZWRSZWZlcnJlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZFJlZmVycmVyID0gbmV3IFVSTChyZWZlcnJlciwgYmFzZVVybClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUmVmZXJyZXIgXCIke3JlZmVycmVyfVwiIGlzIG5vdCBhIHZhbGlkIFVSTC5gLCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIElmIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWVcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgc2NoZW1lIGlzIFwiYWJvdXRcIiBhbmQgcGF0aCBpcyB0aGUgc3RyaW5nIFwiY2xpZW50XCJcbiAgICAgICAgLy8gLSBwYXJzZWRSZWZlcnJlcuKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIG9yaWdpblxuICAgICAgICAvLyB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcnNlZFJlZmVycmVyLnByb3RvY29sID09PSAnYWJvdXQ6JyAmJiBwYXJzZWRSZWZlcnJlci5ob3N0bmFtZSA9PT0gJ2NsaWVudCcpIHx8XG4gICAgICAgICAgKG9yaWdpbiAmJiAhc2FtZU9yaWdpbihwYXJzZWRSZWZlcnJlciwgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdC5iYXNlVXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICdjbGllbnQnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gcGFyc2VkUmVmZXJyZXIuXG4gICAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9IHBhcnNlZFJlZmVycmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxNS4gSWYgaW5pdFtcInJlZmVycmVyUG9saWN5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5XG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQucmVmZXJyZXJQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IGluaXQucmVmZXJyZXJQb2xpY3lcbiAgICB9XG5cbiAgICAvLyAxNi4gTGV0IG1vZGUgYmUgaW5pdFtcIm1vZGVcIl0gaWYgaXQgZXhpc3RzLCBhbmQgZmFsbGJhY2tNb2RlIG90aGVyd2lzZS5cbiAgICBsZXQgbW9kZVxuICAgIGlmIChpbml0Lm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbW9kZSA9IGluaXQubW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlID0gZmFsbGJhY2tNb2RlXG4gICAgfVxuXG4gICAgLy8gMTcuIElmIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChtb2RlID09PSAnbmF2aWdhdGUnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ1JlcXVlc3QgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0IG1vZGUgbmF2aWdhdGUuJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgbW9kZSBpcyBub24tbnVsbCwgc2V0IHJlcXVlc3TigJlzIG1vZGUgdG8gbW9kZS5cbiAgICBpZiAobW9kZSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0Lm1vZGUgPSBtb2RlXG4gICAgfVxuXG4gICAgLy8gMTkuIElmIGluaXRbXCJjcmVkZW50aWFsc1wiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGNyZWRlbnRpYWxzIG1vZGVcbiAgICAvLyB0byBpdC5cbiAgICBpZiAoaW5pdC5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gaW5pdC5jcmVkZW50aWFsc1xuICAgIH1cblxuICAgIC8vIDE4LiBJZiBpbml0W1wiY2FjaGVcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LmNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QuY2FjaGUgPSBpbml0LmNhY2hlXG4gICAgfVxuXG4gICAgLy8gMjEuIElmIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiIGFuZCByZXF1ZXN04oCZcyBtb2RlIGlzXG4gICAgLy8gbm90IFwic2FtZS1vcmlnaW5cIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAocmVxdWVzdC5jYWNoZSA9PT0gJ29ubHktaWYtY2FjaGVkJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ29ubHktaWYtY2FjaGVkJyBjYW4gYmUgc2V0IG9ubHkgd2l0aCAnc2FtZS1vcmlnaW4nIG1vZGVcIlxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIDIyLiBJZiBpbml0W1wicmVkaXJlY3RcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBpbml0LnJlZGlyZWN0XG4gICAgfVxuXG4gICAgLy8gMjMuIElmIGluaXRbXCJpbnRlZ3JpdHlcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgdG8gaXQuXG4gICAgaWYgKGluaXQuaW50ZWdyaXR5ICE9IG51bGwpIHtcbiAgICAgIHJlcXVlc3QuaW50ZWdyaXR5ID0gU3RyaW5nKGluaXQuaW50ZWdyaXR5KVxuICAgIH1cblxuICAgIC8vIDI0LiBJZiBpbml0W1wia2VlcGFsaXZlXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMga2VlcGFsaXZlIHRvIGl0LlxuICAgIGlmIChpbml0LmtlZXBhbGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmtlZXBhbGl2ZSA9IEJvb2xlYW4oaW5pdC5rZWVwYWxpdmUpXG4gICAgfVxuXG4gICAgLy8gMjUuIElmIGluaXRbXCJtZXRob2RcIl0gZXhpc3RzLCB0aGVuOlxuICAgIGlmIChpbml0Lm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgbWV0aG9kIGJlIGluaXRbXCJtZXRob2RcIl0uXG4gICAgICBsZXQgbWV0aG9kID0gaW5pdC5tZXRob2RcblxuICAgICAgY29uc3QgbWF5QmVOb3JtYWxpemVkID0gbm9ybWFsaXplZE1ldGhvZFJlY29yZHNbbWV0aG9kXVxuXG4gICAgICBpZiAobWF5QmVOb3JtYWxpemVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTm90ZTogQnlwYXNzIHZhbGlkYXRpb24gREVMRVRFLCBHRVQsIEhFQUQsIE9QVElPTlMsIFBPU1QsIFBVVCwgUEFUQ0ggYW5kIHRoZXNlIGxvd2VyY2FzZSBvbmVzXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gbWF5QmVOb3JtYWxpemVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAyLiBJZiBtZXRob2QgaXMgbm90IGEgbWV0aG9kIG9yIG1ldGhvZCBpcyBhIGZvcmJpZGRlbiBtZXRob2QsIHRoZW5cbiAgICAgICAgLy8gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIGlmICghaXNWYWxpZEhUVFBUb2tlbihtZXRob2QpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgaXMgbm90IGEgdmFsaWQgSFRUUCBtZXRob2QuYClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwcGVyQ2FzZSA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cbiAgICAgICAgaWYgKGZvcmJpZGRlbk1ldGhvZHNTZXQuaGFzKHVwcGVyQ2FzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnJHttZXRob2R9JyBIVFRQIG1ldGhvZCBpcyB1bnN1cHBvcnRlZC5gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gTm9ybWFsaXplIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kLW5vcm1hbGl6ZVxuICAgICAgICAvLyBOb3RlOiBtdXN0IGJlIGluIHVwcGVyY2FzZVxuICAgICAgICBtZXRob2QgPSBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2VbdXBwZXJDYXNlXSA/PyBtZXRob2RcblxuICAgICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgbWV0aG9kIHRvIG1ldGhvZC5cbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPSBtZXRob2RcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXRjaE1ldGhvZFdhcm5pbmcgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnVXNpbmcgYHBhdGNoYCBpcyBoaWdobHkgbGlrZWx5IHRvIHJlc3VsdCBpbiBhIGA0MDUgTWV0aG9kIE5vdCBBbGxvd2VkYC4gYFBBVENIYCBpcyBtdWNoIG1vcmUgbGlrZWx5IHRvIHN1Y2NlZWQuJywge1xuICAgICAgICAgIGNvZGU6ICdVTkRJQ0ktRkVUQ0gtcGF0Y2gnXG4gICAgICAgIH0pXG5cbiAgICAgICAgcGF0Y2hNZXRob2RXYXJuaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDI2LiBJZiBpbml0W1wic2lnbmFsXCJdIGV4aXN0cywgdGhlbiBzZXQgc2lnbmFsIHRvIGl0LlxuICAgIGlmIChpbml0LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzaWduYWwgPSBpbml0LnNpZ25hbFxuICAgIH1cblxuICAgIC8vIDI3LiBTZXQgdGhpc+KAmXMgcmVxdWVzdCB0byByZXF1ZXN0LlxuICAgIHRoaXNba1N0YXRlXSA9IHJlcXVlc3RcblxuICAgIC8vIDI4LiBTZXQgdGhpc+KAmXMgc2lnbmFsIHRvIGEgbmV3IEFib3J0U2lnbmFsIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0uXG4gICAgLy8gVE9ETzogY291bGQgdGhpcyBiZSBzaW1wbGlmaWVkIHdpdGggQWJvcnRTaWduYWwuYW55XG4gICAgLy8gKGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWFib3J0c2lnbmFsLWFueSlcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIHRoaXNba1NpZ25hbF0gPSBhYy5zaWduYWxcblxuICAgIC8vIDI5LiBJZiBzaWduYWwgaXMgbm90IG51bGwsIHRoZW4gbWFrZSB0aGlz4oCZcyBzaWduYWwgZm9sbG93IHNpZ25hbC5cbiAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNpZ25hbCB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFib3J0ZWQgIT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXCJcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWMuYWJvcnQoc2lnbmFsLnJlYXNvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgYSBzdHJvbmcgcmVmIHRvIGFjIHdoaWxlIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIC8vIGlzIGFsaXZlLiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IEFib3J0Q29udHJvbGxlclxuICAgICAgICAvLyBmcm9tIGJlaW5nIHByZW1hdHVyZWx5IGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAgICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xOTI2LlxuICAgICAgICB0aGlzW2tBYm9ydENvbnRyb2xsZXJdID0gYWNcblxuICAgICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgICBjb25zdCBhYm9ydCA9IGJ1aWxkQWJvcnQoYWNSZWYpXG5cbiAgICAgICAgLy8gVGhpcmQtcGFydHkgQWJvcnRDb250cm9sbGVycyBtYXkgbm90IHdvcmsgd2l0aCB0aGVzZS5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9wdWxsLzE5MTAjaXNzdWVjb21tZW50LTE0NjQ0OTU2MTkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG1heCBhbW91bnQgb2YgbGlzdGVuZXJzIGlzIGVxdWFsIHRvIHRoZSBkZWZhdWx0LCBpbmNyZWFzZSBpdFxuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gbm9kZSA+PSB2MTkuOS4wXG4gICAgICAgICAgaWYgKHR5cGVvZiBnZXRNYXhMaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgJiYgZ2V0TWF4TGlzdGVuZXJzKHNpZ25hbCkgPT09IGRlZmF1bHRNYXhMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHNldE1heExpc3RlbmVycygxNTAwLCBzaWduYWwpXG4gICAgICAgICAgfSBlbHNlIGlmIChnZXRFdmVudExpc3RlbmVycyhzaWduYWwsICdhYm9ydCcpLmxlbmd0aCA+PSBkZWZhdWx0TWF4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTUwMCwgc2lnbmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgIHV0aWwuYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGFib3J0KVxuICAgICAgICAvLyBUaGUgdGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIHJlZ2lzdHJ5IGtleSB0byBiZSB1bnJlZ2lzdGVyZWQuXG4gICAgICAgIC8vIFdpdGhvdXQgaXQsIHlvdSBjYW5ub3QgdW5yZWdpc3Rlci5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICAgICAgLy8gYWJvcnQgaXMgdXNlZCBhcyB0aGUgdW5yZWdpc3RlciBrZXkuIChiZWNhdXNlIGl0IGlzIHVuaXF1ZSlcbiAgICAgICAgcmVxdWVzdEZpbmFsaXplci5yZWdpc3RlcihhYywgeyBzaWduYWwsIGFib3J0IH0sIGFib3J0KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMwLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZCBpc1xuICAgIC8vIFwicmVxdWVzdFwiLlxuICAgIHRoaXNba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSwgcmVxdWVzdC5oZWFkZXJzTGlzdClcbiAgICBzZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10sICdyZXF1ZXN0JylcblxuICAgIC8vIDMxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiLCB0aGVuOlxuICAgIGlmIChtb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmICghY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LmhhcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgJyR7cmVxdWVzdC5tZXRob2R9IGlzIHVuc3VwcG9ydGVkIGluIG5vLWNvcnMgbW9kZS5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkIHRvIFwicmVxdWVzdC1uby1jb3JzXCIuXG4gICAgICBzZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10sICdyZXF1ZXN0LW5vLWNvcnMnKVxuICAgIH1cblxuICAgIC8vIDMyLiBJZiBpbml0IGlzIG5vdCBlbXB0eSwgdGhlbjpcbiAgICBpZiAoaW5pdEhhc0tleSkge1xuICAgICAgLyoqIEB0eXBlIHtIZWFkZXJzTGlzdH0gKi9cbiAgICAgIGNvbnN0IGhlYWRlcnNMaXN0ID0gZ2V0SGVhZGVyc0xpc3QodGhpc1trSGVhZGVyc10pXG4gICAgICAvLyAxLiBMZXQgaGVhZGVycyBiZSBhIGNvcHkgb2YgdGhpc+KAmXMgaGVhZGVycyBhbmQgaXRzIGFzc29jaWF0ZWQgaGVhZGVyXG4gICAgICAvLyBsaXN0LlxuICAgICAgLy8gMi4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIHNldCBoZWFkZXJzIHRvIGluaXRbXCJoZWFkZXJzXCJdLlxuICAgICAgY29uc3QgaGVhZGVycyA9IGluaXQuaGVhZGVycyAhPT0gdW5kZWZpbmVkID8gaW5pdC5oZWFkZXJzIDogbmV3IEhlYWRlcnNMaXN0KGhlYWRlcnNMaXN0KVxuXG4gICAgICAvLyAzLiBFbXB0eSB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAgIGhlYWRlcnNMaXN0LmNsZWFyKClcblxuICAgICAgLy8gNC4gSWYgaGVhZGVycyBpcyBhIEhlYWRlcnMgb2JqZWN0LCB0aGVuIGZvciBlYWNoIGhlYWRlciBpbiBpdHMgaGVhZGVyXG4gICAgICAvLyBsaXN0LCBhcHBlbmQgaGVhZGVy4oCZcyBuYW1lL2hlYWRlcuKAmXMgdmFsdWUgdG8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVyc0xpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIHZhbHVlIH0gb2YgaGVhZGVycy5yYXdWYWx1ZXMoKSkge1xuICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChuYW1lLCB2YWx1ZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogQ29weSB0aGUgYHNldC1jb29raWVgIG1ldGEtZGF0YS5cbiAgICAgICAgaGVhZGVyc0xpc3QuY29va2llcyA9IGhlYWRlcnMuY29va2llc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBmaWxsIHRoaXPigJlzIGhlYWRlcnMgd2l0aCBoZWFkZXJzLlxuICAgICAgICBmaWxsSGVhZGVycyh0aGlzW2tIZWFkZXJzXSwgaGVhZGVycylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMy4gTGV0IGlucHV0Qm9keSBiZSBpbnB1dOKAmXMgcmVxdWVzdOKAmXMgYm9keSBpZiBpbnB1dCBpcyBhIFJlcXVlc3RcbiAgICAvLyBvYmplY3Q7IG90aGVyd2lzZSBudWxsLlxuICAgIGNvbnN0IGlucHV0Qm9keSA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0W2tTdGF0ZV0uYm9keSA6IG51bGxcblxuICAgIC8vIDM0LiBJZiBlaXRoZXIgaW5pdFtcImJvZHlcIl0gZXhpc3RzIGFuZCBpcyBub24tbnVsbCBvciBpbnB1dEJvZHkgaXNcbiAgICAvLyBub24tbnVsbCwgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBgR0VUYCBvciBgSEVBRGAsIHRoZW4gdGhyb3cgYVxuICAgIC8vIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICAoaW5pdC5ib2R5ICE9IG51bGwgfHwgaW5wdXRCb2R5ICE9IG51bGwpICYmXG4gICAgICAocmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHkuJylcbiAgICB9XG5cbiAgICAvLyAzNS4gTGV0IGluaXRCb2R5IGJlIG51bGwuXG4gICAgbGV0IGluaXRCb2R5ID0gbnVsbFxuXG4gICAgLy8gMzYuIElmIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXQuYm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBMZXQgQ29udGVudC1UeXBlIGJlIG51bGwuXG4gICAgICAvLyAyLiBTZXQgaW5pdEJvZHkgYW5kIENvbnRlbnQtVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmdcbiAgICAgIC8vIGluaXRbXCJib2R5XCJdLCB3aXRoIGtlZXBhbGl2ZSBzZXQgdG8gcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIGNvbnRlbnRUeXBlXSA9IGV4dHJhY3RCb2R5KFxuICAgICAgICBpbml0LmJvZHksXG4gICAgICAgIHJlcXVlc3Qua2VlcGFsaXZlXG4gICAgICApXG4gICAgICBpbml0Qm9keSA9IGV4dHJhY3RlZEJvZHlcblxuICAgICAgLy8gMywgSWYgQ29udGVudC1UeXBlIGlzIG5vbi1udWxsIGFuZCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBoZWFkZXIgbGlzdCBkb2VzXG4gICAgICAvLyBub3QgY29udGFpbiBgQ29udGVudC1UeXBlYCwgdGhlbiBhcHBlbmQgYENvbnRlbnQtVHlwZWAvQ29udGVudC1UeXBlIHRvXG4gICAgICAvLyB0aGlz4oCZcyBoZWFkZXJzLlxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICFnZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSkuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICAgIHRoaXNba0hlYWRlcnNdLmFwcGVuZCgnY29udGVudC10eXBlJywgY29udGVudFR5cGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzcuIExldCBpbnB1dE9ySW5pdEJvZHkgYmUgaW5pdEJvZHkgaWYgaXQgaXMgbm9uLW51bGw7IG90aGVyd2lzZVxuICAgIC8vIGlucHV0Qm9keS5cbiAgICBjb25zdCBpbnB1dE9ySW5pdEJvZHkgPSBpbml0Qm9keSA/PyBpbnB1dEJvZHlcblxuICAgIC8vIDM4LiBJZiBpbnB1dE9ySW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGlucHV0T3JJbml0Qm9keeKAmXMgc291cmNlIGlzXG4gICAgLy8gbnVsbCwgdGhlbjpcbiAgICBpZiAoaW5wdXRPckluaXRCb2R5ICE9IG51bGwgJiYgaW5wdXRPckluaXRCb2R5LnNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbml0Qm9keSBpcyBub24tbnVsbCBhbmQgaW5pdFtcImR1cGxleFwiXSBkb2VzIG5vdCBleGlzdCxcbiAgICAgIC8vICAgIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaW5pdEJvZHkgIT0gbnVsbCAmJiBpbml0LmR1cGxleCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3RJbml0OiBkdXBsZXggb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gc2VuZGluZyBhIGJvZHkuJylcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBuZWl0aGVyIFwic2FtZS1vcmlnaW5cIiBub3IgXCJjb3JzXCIsXG4gICAgICAvLyB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSAhPT0gJ3NhbWUtb3JpZ2luJyAmJiByZXF1ZXN0Lm1vZGUgIT09ICdjb3JzJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdJZiByZXF1ZXN0IGlzIG1hZGUgZnJvbSBSZWFkYWJsZVN0cmVhbSwgbW9kZSBzaG91bGQgYmUgXCJzYW1lLW9yaWdpblwiIG9yIFwiY29yc1wiJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIFNldCB0aGlz4oCZcyByZXF1ZXN04oCZcyB1c2UtQ09SUy1wcmVmbGlnaHQgZmxhZy5cbiAgICAgIHJlcXVlc3QudXNlQ09SU1ByZWZsaWdodEZsYWcgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gMzkuIExldCBmaW5hbEJvZHkgYmUgaW5wdXRPckluaXRCb2R5LlxuICAgIGxldCBmaW5hbEJvZHkgPSBpbnB1dE9ySW5pdEJvZHlcblxuICAgIC8vIDQwLiBJZiBpbml0Qm9keSBpcyBudWxsIGFuZCBpbnB1dEJvZHkgaXMgbm9uLW51bGwsIHRoZW46XG4gICAgaWYgKGluaXRCb2R5ID09IG51bGwgJiYgaW5wdXRCb2R5ICE9IG51bGwpIHtcbiAgICAgIC8vIDEuIElmIGlucHV0IGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHV0aWwuaXNEaXN0dXJiZWQoaW5wdXRCb2R5LnN0cmVhbSkgfHwgaW5wdXRCb2R5LnN0cmVhbS5sb2NrZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGNvbnN0cnVjdCBhIFJlcXVlc3Qgd2l0aCBhIFJlcXVlc3Qgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkLidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgZmluYWxCb2R5IHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBwcm94eSBmb3IgaW5wdXRCb2R5LlxuICAgICAgLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tY3JlYXRlLWEtcHJveHlcbiAgICAgIGNvbnN0IGlkZW50aXR5VHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpXG4gICAgICBpbnB1dEJvZHkuc3RyZWFtLnBpcGVUaHJvdWdoKGlkZW50aXR5VHJhbnNmb3JtKVxuICAgICAgZmluYWxCb2R5ID0ge1xuICAgICAgICBzb3VyY2U6IGlucHV0Qm9keS5zb3VyY2UsXG4gICAgICAgIGxlbmd0aDogaW5wdXRCb2R5Lmxlbmd0aCxcbiAgICAgICAgc3RyZWFtOiBpZGVudGl0eVRyYW5zZm9ybS5yZWFkYWJsZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQxLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgYm9keSB0byBmaW5hbEJvZHkuXG4gICAgdGhpc1trU3RhdGVdLmJvZHkgPSBmaW5hbEJvZHlcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgSFRUUCBtZXRob2QsIHdoaWNoIGlzIFwiR0VUXCIgYnkgZGVmYXVsdC5cbiAgZ2V0IG1ldGhvZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBtZXRob2QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbWV0aG9kLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubWV0aG9kXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBVUkwgb2YgcmVxdWVzdCBhcyBhIHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgVVJMLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1N0YXRlXS51cmwpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgSGVhZGVycyBvYmplY3QgY29uc2lzdGluZyBvZiB0aGUgaGVhZGVycyBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdC5cbiAgLy8gTm90ZSB0aGF0IGhlYWRlcnMgYWRkZWQgaW4gdGhlIG5ldHdvcmsgbGF5ZXIgYnkgdGhlIHVzZXIgYWdlbnQgd2lsbCBub3RcbiAgLy8gYmUgYWNjb3VudGVkIGZvciBpbiB0aGlzIG9iamVjdCwgZS5nLiwgdGhlIFwiSG9zdFwiIGhlYWRlci5cbiAgZ2V0IGhlYWRlcnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUga2luZCBvZiByZXNvdXJjZSByZXF1ZXN0ZWQgYnkgcmVxdWVzdCwgZS5nLiwgXCJkb2N1bWVudFwiXG4gIC8vIG9yIFwic2NyaXB0XCIuXG4gIGdldCBkZXN0aW5hdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBnZXR0ZXIgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbi5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmRlc3RpbmF0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBvZiByZXF1ZXN0LiBJdHMgdmFsdWUgY2FuIGJlIGEgc2FtZS1vcmlnaW4gVVJMIGlmXG4gIC8vIGV4cGxpY2l0bHkgc2V0IGluIGluaXQsIHRoZSBlbXB0eSBzdHJpbmcgdG8gaW5kaWNhdGUgbm8gcmVmZXJyZXIsIGFuZFxuICAvLyBcImFib3V0OmNsaWVudFwiIHdoZW4gZGVmYXVsdGluZyB0byB0aGUgZ2xvYmFs4oCZcyBkZWZhdWx0LiBUaGlzIGlzIHVzZWRcbiAgLy8gZHVyaW5nIGZldGNoaW5nIHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGBSZWZlcmVyYCBoZWFkZXIgb2YgdGhlXG4gIC8vIHJlcXVlc3QgYmVpbmcgbWFkZS5cbiAgZ2V0IHJlZmVycmVyICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJuby1yZWZlcnJlclwiLCB0aGVuIHJldHVybiB0aGVcbiAgICAvLyBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKHRoaXNba1N0YXRlXS5yZWZlcnJlciA9PT0gJ25vLXJlZmVycmVyJykge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgLy8gMi4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgaXMgXCJjbGllbnRcIiwgdGhlbiByZXR1cm5cbiAgICAvLyBcImFib3V0OmNsaWVudFwiLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICdjbGllbnQnKSB7XG4gICAgICByZXR1cm4gJ2Fib3V0OmNsaWVudCdcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIsIHNlcmlhbGl6ZWQuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWZlcnJlci50b1N0cmluZygpXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSByZWZlcnJlciBwb2xpY3kgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdXNlZCBkdXJpbmcgZmV0Y2hpbmcgdG8gY29tcHV0ZSB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3TigJlzXG4gIC8vIHJlZmVycmVyLlxuICBnZXQgcmVmZXJyZXJQb2xpY3kgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVmZXJyZXJQb2xpY3kgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVmZXJyZXIgcG9saWN5LlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXJQb2xpY3lcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmdcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCB3aWxsIHVzZSBDT1JTLCBvciB3aWxsIGJlIHJlc3RyaWN0ZWQgdG8gc2FtZS1vcmlnaW5cbiAgLy8gVVJMcy5cbiAgZ2V0IG1vZGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbW9kZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubW9kZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgY3JlZGVudGlhbHMgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyB3aGV0aGVyIGNyZWRlbnRpYWxzIHdpbGwgYmUgc2VudCB3aXRoIHRoZVxuICAvLyByZXF1ZXN0IGFsd2F5cywgbmV2ZXIsIG9yIG9ubHkgd2hlbiBzZW50IHRvIGEgc2FtZS1vcmlnaW4gVVJMLlxuICBnZXQgY3JlZGVudGlhbHMgKCkge1xuICAgIC8vIFRoZSBjcmVkZW50aWFscyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNhY2hlIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHRoZSByZXF1ZXN0IHdpbGxcbiAgLy8gaW50ZXJhY3Qgd2l0aCB0aGUgYnJvd3NlcuKAmXMgY2FjaGUgd2hlbiBmZXRjaGluZy5cbiAgZ2V0IGNhY2hlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGNhY2hlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5jYWNoZVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVkaXJlY3QgbW9kZSBhc3NvY2lhdGVkIHdpdGggcmVxdWVzdCxcbiAgLy8gd2hpY2ggaXMgYSBzdHJpbmcgaW5kaWNhdGluZyBob3cgcmVkaXJlY3RzIGZvciB0aGVcbiAgLy8gcmVxdWVzdCB3aWxsIGJlIGhhbmRsZWQgZHVyaW5nIGZldGNoaW5nLiBBIHJlcXVlc3RcbiAgLy8gd2lsbCBmb2xsb3cgcmVkaXJlY3RzIGJ5IGRlZmF1bHQuXG4gIGdldCByZWRpcmVjdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSByZWRpcmVjdCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVkaXJlY3RcbiAgfVxuXG4gIC8vIFJldHVybnMgcmVxdWVzdOKAmXMgc3VicmVzb3VyY2UgaW50ZWdyaXR5IG1ldGFkYXRhLCB3aGljaCBpcyBhXG4gIC8vIGNyeXB0b2dyYXBoaWMgaGFzaCBvZiB0aGUgcmVzb3VyY2UgYmVpbmcgZmV0Y2hlZC4gSXRzIHZhbHVlXG4gIC8vIGNvbnNpc3RzIG9mIG11bHRpcGxlIGhhc2hlcyBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZS4gW1NSSV1cbiAgZ2V0IGludGVncml0eSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpbnRlZ3JpdHkgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgaW50ZWdyaXR5XG4gICAgLy8gbWV0YWRhdGEuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5pbnRlZ3JpdHlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBjYW4gb3V0bGl2ZSB0aGVcbiAgLy8gZ2xvYmFsIGluIHdoaWNoIGl0IHdhcyBjcmVhdGVkLlxuICBnZXQga2VlcGFsaXZlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGtlZXBhbGl2ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBrZWVwYWxpdmUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5rZWVwYWxpdmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgcmVxdWVzdCBpcyBmb3IgYSByZWxvYWRcbiAgLy8gbmF2aWdhdGlvbi5cbiAgZ2V0IGlzUmVsb2FkTmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc1JlbG9hZE5hdmlnYXRpb24gZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZc1xuICAgIC8vIHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5yZWxvYWROYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgaGlzdG9yeVxuICAvLyBuYXZpZ2F0aW9uIChhLmsuYS4gYmFjay1mb3J3YXJkIG5hdmlnYXRpb24pLlxuICBnZXQgaXNIaXN0b3J5TmF2aWdhdGlvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBpc0hpc3RvcnlOYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVxdWVzdOKAmXNcbiAgICAvLyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZyBpcyBzZXQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmhpc3RvcnlOYXZpZ2F0aW9uXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBzaWduYWwgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsIHdoaWNoIGlzIGFuIEFib3J0U2lnbmFsXG4gIC8vIG9iamVjdCBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgYW5kIGl0c1xuICAvLyBhYm9ydCBldmVudCBoYW5kbGVyLlxuICBnZXQgc2lnbmFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHNpZ25hbCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBzaWduYWwuXG4gICAgcmV0dXJuIHRoaXNba1NpZ25hbF1cbiAgfVxuXG4gIGdldCBib2R5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICBnZXQgZHVwbGV4ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgcmV0dXJuICdoYWxmJ1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlcXVlc3QuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gMS4gSWYgdGhpcyBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodGhpcy5ib2R5VXNlZCB8fCB0aGlzLmJvZHk/LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gTGV0IGNsb25lZFJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlcXVlc3Qgb2JqZWN0LFxuICAgIC8vIGdpdmVuIGNsb25lZFJlcXVlc3QsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgLy8gNC4gTWFrZSBjbG9uZWRSZXF1ZXN0T2JqZWN04oCZcyBzaWduYWwgZm9sbG93IHRoaXPigJlzIHNpZ25hbC5cbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsaXN0ID0gZGVwZW5kZW50Q29udHJvbGxlck1hcC5nZXQodGhpcy5zaWduYWwpXG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3QgPSBuZXcgU2V0KClcbiAgICAgICAgZGVwZW5kZW50Q29udHJvbGxlck1hcC5zZXQodGhpcy5zaWduYWwsIGxpc3QpXG4gICAgICB9XG4gICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgbGlzdC5hZGQoYWNSZWYpXG4gICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoXG4gICAgICAgIGFjLnNpZ25hbCxcbiAgICAgICAgYnVpbGRBYm9ydChhY1JlZilcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdC5cbiAgICByZXR1cm4gZnJvbUlubmVyUmVxdWVzdChjbG9uZWRSZXF1ZXN0LCBhYy5zaWduYWwsIGdldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSkpXG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRlcHRoID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmRlcHRoID0gMlxuICAgIH1cblxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbixcbiAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHRoaXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QsXG4gICAgICBpbnRlZ3JpdHk6IHRoaXMuaW50ZWdyaXR5LFxuICAgICAga2VlcGFsaXZlOiB0aGlzLmtlZXBhbGl2ZSxcbiAgICAgIGlzUmVsb2FkTmF2aWdhdGlvbjogdGhpcy5pc1JlbG9hZE5hdmlnYXRpb24sXG4gICAgICBpc0hpc3RvcnlOYXZpZ2F0aW9uOiB0aGlzLmlzSGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIGBSZXF1ZXN0ICR7bm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgcHJvcGVydGllcyl9YFxuICB9XG59XG5cbm1peGluQm9keShSZXF1ZXN0KVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdHNcbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0IChpbml0KSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBpbml0Lm1ldGhvZCA/PyAnR0VUJyxcbiAgICBsb2NhbFVSTHNPbmx5OiBpbml0LmxvY2FsVVJMc09ubHkgPz8gZmFsc2UsXG4gICAgdW5zYWZlUmVxdWVzdDogaW5pdC51bnNhZmVSZXF1ZXN0ID8/IGZhbHNlLFxuICAgIGJvZHk6IGluaXQuYm9keSA/PyBudWxsLFxuICAgIGNsaWVudDogaW5pdC5jbGllbnQgPz8gbnVsbCxcbiAgICByZXNlcnZlZENsaWVudDogaW5pdC5yZXNlcnZlZENsaWVudCA/PyBudWxsLFxuICAgIHJlcGxhY2VzQ2xpZW50SWQ6IGluaXQucmVwbGFjZXNDbGllbnRJZCA/PyAnJyxcbiAgICB3aW5kb3c6IGluaXQud2luZG93ID8/ICdjbGllbnQnLFxuICAgIGtlZXBhbGl2ZTogaW5pdC5rZWVwYWxpdmUgPz8gZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcnM6IGluaXQuc2VydmljZVdvcmtlcnMgPz8gJ2FsbCcsXG4gICAgaW5pdGlhdG9yOiBpbml0LmluaXRpYXRvciA/PyAnJyxcbiAgICBkZXN0aW5hdGlvbjogaW5pdC5kZXN0aW5hdGlvbiA/PyAnJyxcbiAgICBwcmlvcml0eTogaW5pdC5wcmlvcml0eSA/PyBudWxsLFxuICAgIG9yaWdpbjogaW5pdC5vcmlnaW4gPz8gJ2NsaWVudCcsXG4gICAgcG9saWN5Q29udGFpbmVyOiBpbml0LnBvbGljeUNvbnRhaW5lciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlcjogaW5pdC5yZWZlcnJlciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlclBvbGljeTogaW5pdC5yZWZlcnJlclBvbGljeSA/PyAnJyxcbiAgICBtb2RlOiBpbml0Lm1vZGUgPz8gJ25vLWNvcnMnLFxuICAgIHVzZUNPUlNQcmVmbGlnaHRGbGFnOiBpbml0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID8/IGZhbHNlLFxuICAgIGNyZWRlbnRpYWxzOiBpbml0LmNyZWRlbnRpYWxzID8/ICdzYW1lLW9yaWdpbicsXG4gICAgdXNlQ3JlZGVudGlhbHM6IGluaXQudXNlQ3JlZGVudGlhbHMgPz8gZmFsc2UsXG4gICAgY2FjaGU6IGluaXQuY2FjaGUgPz8gJ2RlZmF1bHQnLFxuICAgIHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0ID8/ICdmb2xsb3cnLFxuICAgIGludGVncml0eTogaW5pdC5pbnRlZ3JpdHkgPz8gJycsXG4gICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiBpbml0LmNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSA/PyAnJyxcbiAgICBwYXJzZXJNZXRhZGF0YTogaW5pdC5wYXJzZXJNZXRhZGF0YSA/PyAnJyxcbiAgICByZWxvYWROYXZpZ2F0aW9uOiBpbml0LnJlbG9hZE5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgaGlzdG9yeU5hdmlnYXRpb246IGluaXQuaGlzdG9yeU5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgdXNlckFjdGl2YXRpb246IGluaXQudXNlckFjdGl2YXRpb24gPz8gZmFsc2UsXG4gICAgdGFpbnRlZE9yaWdpbjogaW5pdC50YWludGVkT3JpZ2luID8/IGZhbHNlLFxuICAgIHJlZGlyZWN0Q291bnQ6IGluaXQucmVkaXJlY3RDb3VudCA/PyAwLFxuICAgIHJlc3BvbnNlVGFpbnRpbmc6IGluaXQucmVzcG9uc2VUYWludGluZyA/PyAnYmFzaWMnLFxuICAgIHByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uOiBpbml0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uID8/IGZhbHNlLFxuICAgIGRvbmU6IGluaXQuZG9uZSA/PyBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd0ZhaWxlZDogaW5pdC50aW1pbmdBbGxvd0ZhaWxlZCA/PyBmYWxzZSxcbiAgICB1cmxMaXN0OiBpbml0LnVybExpc3QsXG4gICAgdXJsOiBpbml0LnVybExpc3RbMF0sXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1jbG9uZVxuZnVuY3Rpb24gY2xvbmVSZXF1ZXN0IChyZXF1ZXN0KSB7XG4gIC8vIFRvIGNsb25lIGEgcmVxdWVzdCByZXF1ZXN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gTGV0IG5ld1JlcXVlc3QgYmUgYSBjb3B5IG9mIHJlcXVlc3QsIGV4Y2VwdCBmb3IgaXRzIGJvZHkuXG4gIGNvbnN0IG5ld1JlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IC4uLnJlcXVlc3QsIGJvZHk6IG51bGwgfSlcblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBzZXQgbmV3UmVxdWVzdOKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVxdWVzdOKAmXMgYm9keS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgbmV3UmVxdWVzdC5ib2R5ID0gY2xvbmVCb2R5KHJlcXVlc3QuYm9keSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBuZXdSZXF1ZXN0LlxuICByZXR1cm4gbmV3UmVxdWVzdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY3JlYXRlXG4gKiBAcGFyYW0ge2FueX0gaW5uZXJSZXF1ZXN0XG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7J3JlcXVlc3QnIHwgJ2ltbXV0YWJsZScgfCAncmVxdWVzdC1uby1jb3JzJyB8ICdyZXNwb25zZScgfCAnbm9uZSd9IGd1YXJkXG4gKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAqL1xuZnVuY3Rpb24gZnJvbUlubmVyUmVxdWVzdCAoaW5uZXJSZXF1ZXN0LCBzaWduYWwsIGd1YXJkKSB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChrQ29uc3RydWN0KVxuICByZXF1ZXN0W2tTdGF0ZV0gPSBpbm5lclJlcXVlc3RcbiAgcmVxdWVzdFtrU2lnbmFsXSA9IHNpZ25hbFxuICByZXF1ZXN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldEhlYWRlcnNMaXN0KHJlcXVlc3Rba0hlYWRlcnNdLCBpbm5lclJlcXVlc3QuaGVhZGVyc0xpc3QpXG4gIHNldEhlYWRlcnNHdWFyZChyZXF1ZXN0W2tIZWFkZXJzXSwgZ3VhcmQpXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZHVwbGV4OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZXN0aW5hdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzSGlzdG9yeU5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzUmVsb2FkTmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2VlcGFsaXZlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbnRlZ3JpdHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNhY2hlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYXR0cmlidXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlclBvbGljeToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1vZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFJlcXVlc3RcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RpbmZvXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdChWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG53ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEFib3J0U2lnbmFsXG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgJ1JlcXVlc3RJbml0JyxcbiAgICAgICAgJ3NpZ25hbCcsXG4gICAgICAgIHsgc3RyaWN0OiBmYWxzZSB9XG4gICAgICApXG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAnd2luZG93JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9LFxuICB7XG4gICAga2V5OiAnZHVwbGV4JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0RHVwbGV4XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJywgLy8gdW5kaWNpIHNwZWNpZmljIG9wdGlvblxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCwgZnJvbUlubmVyUmVxdWVzdCwgY2xvbmVSZXF1ZXN0IH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ \"(ssr)/./node_modules/undici/lib/web/fetch/body.js\")\nconst util = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode,\n  environmentSettingsObject: relevantRealm\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kState, kHeaders } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(ssr)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { isDisturbed, isErrored } = __webpack_require__(/*! node:stream */ \"node:stream\")\n\nconst textEncoder = new TextEncoder('utf-8')\n\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0\nlet registry\n\nif (hasFinalizationRegistry) {\n  registry = new FinalizationRegistry((weakRef) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop)\n    }\n  })\n}\n\nfunction noop () {}\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersGuard(this[kHeaders], 'response')\n    setHeadersList(this[kHeaders], this[kState].headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body?.locked) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('content-type', true)) {\n      response[kState].headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  response[kState] = innerResponse\n  response[kHeaders] = new Headers(kConstruct)\n  setHeadersList(response[kHeaders], innerResponse.headersList)\n  setHeadersGuard(response[kHeaders], guard)\n\n  if (hasFinalizationRegistry && innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    registry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, prefix, name, { strict: false })\n  }\n\n  if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n    return webidl.converters.BufferSource(V, prefix, name)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, prefix, name, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V, prefix, name)\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V, prefix, argument)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSwrRUFBK0UsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzVHLFFBQVEsb0NBQW9DLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUM5RCxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUNoRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDekMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzlDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3JDLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0EsK0NBQStDLHlDQUF5Qzs7QUFFeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxJQUFJLEtBQUssWUFBWTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGdEQUFnRDtBQUN2RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMseUJBQXlCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLFlBQVk7QUFDakgsbUZBQW1GLFlBQVk7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0I7QUFDakUsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLG1FQUFtRTtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxyZXNwb25zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBIZWFkZXJzLCBIZWFkZXJzTGlzdCwgZmlsbCwgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBleHRyYWN0Qm9keSwgY2xvbmVCb2R5LCBtaXhpbkJvZHkgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbFxuY29uc3Qge1xuICBpc1ZhbGlkUmVhc29uUGhyYXNlLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNBYm9ydGVkLFxuICBpc0Jsb2JMaWtlLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gIGlzRXJyb3JMaWtlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0OiByZWxldmFudFJlYWxtXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIG51bGxCb2R5U3RhdHVzXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IGlzRGlzdHVyYmVkLCBpc0Vycm9yZWQgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoJ3V0Zi04JylcblxuY29uc3QgaGFzRmluYWxpemF0aW9uUmVnaXN0cnkgPSBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MTgnKSAhPT0gMFxubGV0IHJlZ2lzdHJ5XG5cbmlmIChoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSkge1xuICByZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgod2Vha1JlZikgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IHdlYWtSZWYuZGVyZWYoKVxuICAgIGlmIChzdHJlYW0gJiYgIXN0cmVhbS5sb2NrZWQgJiYgIWlzRGlzdHVyYmVkKHN0cmVhbSkgJiYgIWlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICBzdHJlYW0uY2FuY2VsKCdSZXNwb25zZSBvYmplY3QgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQnKS5jYXRjaChub29wKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2UtY2xhc3NcbmNsYXNzIFJlc3BvbnNlIHtcbiAgLy8gQ3JlYXRlcyBuZXR3b3JrIGVycm9yIFJlc3BvbnNlLlxuICBzdGF0aWMgZXJyb3IgKCkge1xuICAgIC8vIFRoZSBzdGF0aWMgZXJyb3IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFcbiAgICAvLyBSZXNwb25zZSBvYmplY3QsIGdpdmVuIGEgbmV3IG5ldHdvcmsgZXJyb3IsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZc1xuICAgIC8vIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZU5ldHdvcmtFcnJvcigpLCAnaW1tdXRhYmxlJylcblxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZS1qc29uXG4gIHN0YXRpYyBqc29uIChkYXRhLCBpbml0ID0ge30pIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdSZXNwb25zZS5qc29uJylcblxuICAgIGlmIChpbml0ICE9PSBudWxsKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2VJbml0KGluaXQpXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IGJ5dGVzIHRoZSByZXN1bHQgb2YgcnVubmluZyBzZXJpYWxpemUgYSBKYXZhU2NyaXB0IHZhbHVlIHRvIEpTT04gYnl0ZXMgb24gZGF0YS5cbiAgICBjb25zdCBieXRlcyA9IHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyhkYXRhKVxuICAgIClcblxuICAgIC8vIDIuIExldCBib2R5IGJlIHRoZSByZXN1bHQgb2YgZXh0cmFjdGluZyBieXRlcy5cbiAgICBjb25zdCBib2R5ID0gZXh0cmFjdEJvZHkoYnl0ZXMpXG5cbiAgICAvLyAzLiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgcmVzcG9uc2UsXG4gICAgLy8gICAgXCJyZXNwb25zZVwiLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShtYWtlUmVzcG9uc2Uoe30pLCAncmVzcG9uc2UnKVxuXG4gICAgLy8gNC4gUGVyZm9ybSBpbml0aWFsaXplIGEgcmVzcG9uc2UgZ2l2ZW4gcmVzcG9uc2VPYmplY3QsIGluaXQsIGFuZCAoYm9keSwgXCJhcHBsaWNhdGlvbi9qc29uXCIpLlxuICAgIGluaXRpYWxpemVSZXNwb25zZShyZXNwb25zZU9iamVjdCwgaW5pdCwgeyBib2R5OiBib2R5WzBdLCB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSlcblxuICAgIC8vIDUuIFJldHVybiByZXNwb25zZU9iamVjdC5cbiAgICByZXR1cm4gcmVzcG9uc2VPYmplY3RcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSByZWRpcmVjdCBSZXNwb25zZSB0aGF0IHJlZGlyZWN0cyB0byB1cmwgd2l0aCBzdGF0dXMgc3RhdHVzLlxuICBzdGF0aWMgcmVkaXJlY3QgKHVybCwgc3RhdHVzID0gMzAyKSB7XG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnUmVzcG9uc2UucmVkaXJlY3QnKVxuXG4gICAgdXJsID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHVybClcbiAgICBzdGF0dXMgPSB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShzdGF0dXMpXG5cbiAgICAvLyAxLiBMZXQgcGFyc2VkVVJMIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB1cmwgd2l0aCBjdXJyZW50IHNldHRpbmdzXG4gICAgLy8gb2JqZWN04oCZcyBBUEkgYmFzZSBVUkwuXG4gICAgLy8gMi4gSWYgcGFyc2VkVVJMIGlzIGZhaWx1cmUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gVE9ETzogYmFzZS1VUkw/XG4gICAgbGV0IHBhcnNlZFVSTFxuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVUkwgPSBuZXcgVVJMKHVybCwgcmVsZXZhbnRSZWFsbS5zZXR0aW5nc09iamVjdC5iYXNlVXJsKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIHBhcnNlIFVSTCBmcm9tICR7dXJsfWAsIHsgY2F1c2U6IGVyciB9KVxuICAgIH1cblxuICAgIC8vIDMuIElmIHN0YXR1cyBpcyBub3QgYSByZWRpcmVjdCBzdGF0dXMsIHRoZW4gdGhyb3cgYSBSYW5nZUVycm9yLlxuICAgIGlmICghcmVkaXJlY3RTdGF0dXNTZXQuaGFzKHN0YXR1cykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHN0YXR1cyBjb2RlICR7c3RhdHVzfWApXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IHJlc3BvbnNlT2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsXG4gICAgLy8gZ2l2ZW4gYSBuZXcgcmVzcG9uc2UsIFwiaW1tdXRhYmxlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VSZXNwb25zZSh7fSksICdpbW11dGFibGUnKVxuXG4gICAgLy8gNS4gU2V0IHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIHRvIHN0YXR1cy5cbiAgICByZXNwb25zZU9iamVjdFtrU3RhdGVdLnN0YXR1cyA9IHN0YXR1c1xuXG4gICAgLy8gNi4gTGV0IHZhbHVlIGJlIHBhcnNlZFVSTCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgIGNvbnN0IHZhbHVlID0gaXNvbW9ycGhpY0VuY29kZShVUkxTZXJpYWxpemVyKHBhcnNlZFVSTCkpXG5cbiAgICAvLyA3LiBBcHBlbmQgYExvY2F0aW9uYC92YWx1ZSB0byByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uaGVhZGVyc0xpc3QuYXBwZW5kKCdsb2NhdGlvbicsIHZhbHVlLCB0cnVlKVxuXG4gICAgLy8gOC4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXNwb25zZVxuICBjb25zdHJ1Y3RvciAoYm9keSA9IG51bGwsIGluaXQgPSB7fSkge1xuICAgIGlmIChib2R5ID09PSBrQ29uc3RydWN0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYm9keSAhPT0gbnVsbCkge1xuICAgICAgYm9keSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0KGJvZHkpXG4gICAgfVxuXG4gICAgaW5pdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdChpbml0KVxuXG4gICAgLy8gMS4gU2V0IHRoaXPigJlzIHJlc3BvbnNlIHRvIGEgbmV3IHJlc3BvbnNlLlxuICAgIHRoaXNba1N0YXRlXSA9IG1ha2VSZXNwb25zZSh7fSlcblxuICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJzIHRvIGEgbmV3IEhlYWRlcnMgb2JqZWN0IHdpdGggdGhpc+KAmXMgcmVsZXZhbnRcbiAgICAvLyBSZWFsbSwgd2hvc2UgaGVhZGVyIGxpc3QgaXMgdGhpc+KAmXMgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IGFuZCBndWFyZFxuICAgIC8vIGlzIFwicmVzcG9uc2VcIi5cbiAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gICAgc2V0SGVhZGVyc0d1YXJkKHRoaXNba0hlYWRlcnNdLCAncmVzcG9uc2UnKVxuICAgIHNldEhlYWRlcnNMaXN0KHRoaXNba0hlYWRlcnNdLCB0aGlzW2tTdGF0ZV0uaGVhZGVyc0xpc3QpXG5cbiAgICAvLyAzLiBMZXQgYm9keVdpdGhUeXBlIGJlIG51bGwuXG4gICAgbGV0IGJvZHlXaXRoVHlwZSA9IG51bGxcblxuICAgIC8vIDQuIElmIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IGJvZHlXaXRoVHlwZSB0byB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYm9keS5cbiAgICBpZiAoYm9keSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBbZXh0cmFjdGVkQm9keSwgdHlwZV0gPSBleHRyYWN0Qm9keShib2R5KVxuICAgICAgYm9keVdpdGhUeXBlID0geyBib2R5OiBleHRyYWN0ZWRCb2R5LCB0eXBlIH1cbiAgICB9XG5cbiAgICAvLyA1LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiB0aGlzLCBpbml0LCBhbmQgYm9keVdpdGhUeXBlLlxuICAgIGluaXRpYWxpemVSZXNwb25zZSh0aGlzLCBpbml0LCBib2R5V2l0aFR5cGUpXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyB0eXBlLCBlLmcuLCBcImNvcnNcIi5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHR5cGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHR5cGUuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50eXBlXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBVUkwsIGlmIGl0IGhhcyBvbmU7IG90aGVyd2lzZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBnZXQgdXJsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIGNvbnN0IHVybExpc3QgPSB0aGlzW2tTdGF0ZV0udXJsTGlzdFxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGlmIHRoaXPigJlzXG4gICAgLy8gcmVzcG9uc2XigJlzIFVSTCBpcyBudWxsOyBvdGhlcndpc2UgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTCxcbiAgICAvLyBzZXJpYWxpemVkIHdpdGggZXhjbHVkZSBmcmFnbWVudCBzZXQgdG8gdHJ1ZS5cbiAgICBjb25zdCB1cmwgPSB1cmxMaXN0W3VybExpc3QubGVuZ3RoIC0gMV0gPz8gbnVsbFxuXG4gICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIFVSTFNlcmlhbGl6ZXIodXJsLCB0cnVlKVxuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNlIHdhcyBvYnRhaW5lZCB0aHJvdWdoIGEgcmVkaXJlY3QuXG4gIGdldCByZWRpcmVjdGVkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSByZWRpcmVjdGVkIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIFVSTFxuICAgIC8vIGxpc3QgaGFzIG1vcmUgdGhhbiBvbmUgaXRlbTsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udXJsTGlzdC5sZW5ndGggPiAxXG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMuXG4gIGdldCBzdGF0dXMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1cyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzXG4gIH1cblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhbiBvayBzdGF0dXMuXG4gIGdldCBvayAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgb2sgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdHJ1ZSBpZiB0aGlz4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIGlzIGFuXG4gICAgLy8gb2sgc3RhdHVzOyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXMgPj0gMjAwICYmIHRoaXNba1N0YXRlXS5zdGF0dXMgPD0gMjk5XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZS5cbiAgZ2V0IHN0YXR1c1RleHQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIHN0YXR1c1RleHQgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1c1xuICAgIC8vIG1lc3NhZ2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5zdGF0dXNUZXh0XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlc3BvbnNl4oCZcyBoZWFkZXJzIGFzIEhlYWRlcnMuXG4gIGdldCBoZWFkZXJzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBoZWFkZXJzIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgcmV0dXJuIHRoaXNba0hlYWRlcnNdXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJvZHkgPyB0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0gOiBudWxsXG4gIH1cblxuICBnZXQgYm9keVVzZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgcmV0dXJuICEhdGhpc1trU3RhdGVdLmJvZHkgJiYgdXRpbC5pc0Rpc3R1cmJlZCh0aGlzW2tTdGF0ZV0uYm9keS5zdHJlYW0pXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgY2xvbmUgb2YgcmVzcG9uc2UuXG4gIGNsb25lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIDEuIElmIHRoaXMgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHRoaXMuYm9keVVzZWQgfHwgdGhpcy5ib2R5Py5sb2NrZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UuY2xvbmUnLFxuICAgICAgICBtZXNzYWdlOiAnQm9keSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNsb25lZFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXNwb25zZS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsIGdpdmVuXG4gICAgLy8gY2xvbmVkUmVzcG9uc2UsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgcmV0dXJuIGZyb21Jbm5lclJlc3BvbnNlKGNsb25lZFJlc3BvbnNlLCBnZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10pKVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kZXB0aCA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5kZXB0aCA9IDJcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHksXG4gICAgICBib2R5VXNlZDogdGhpcy5ib2R5VXNlZCxcbiAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgcmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH1cblxuICAgIHJldHVybiBgUmVzcG9uc2UgJHtub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBwcm9wZXJ0aWVzKX1gXG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlc3BvbnNlKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgdHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9rOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXNwb25zZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLCB7XG4gIGpzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gIC8vIFRvIGNsb25lIGEgcmVzcG9uc2UgcmVzcG9uc2UsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlLCB0aGVuIHJldHVybiBhIG5ldyBpZGVudGljYWxcbiAgLy8gZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWwgcmVzcG9uc2UgaXMgYSBjbG9uZSBvZiByZXNwb25zZeKAmXNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgY2xvbmVSZXNwb25zZShyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSxcbiAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICApXG4gIH1cblxuICAvLyAyLiBMZXQgbmV3UmVzcG9uc2UgYmUgYSBjb3B5IG9mIHJlc3BvbnNlLCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IC4uLnJlc3BvbnNlLCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IG5ld1Jlc3BvbnNl4oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXNwb25zZeKAmXMgYm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkocmVzcG9uc2UuYm9keSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiBuZXdSZXNwb25zZS5cbiAgcmV0dXJuIG5ld1Jlc3BvbnNlXG59XG5cbmZ1bmN0aW9uIG1ha2VSZXNwb25zZSAoaW5pdCkge1xuICByZXR1cm4ge1xuICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgIHJhbmdlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd1Bhc3NlZDogZmFsc2UsXG4gICAgcmVxdWVzdEluY2x1ZGVzQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIHR5cGU6ICdkZWZhdWx0JyxcbiAgICBzdGF0dXM6IDIwMCxcbiAgICB0aW1pbmdJbmZvOiBudWxsLFxuICAgIGNhY2hlU3RhdGU6ICcnLFxuICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgIC4uLmluaXQsXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQ/LmhlYWRlcnNMaXN0XG4gICAgICA/IG5ldyBIZWFkZXJzTGlzdChpbml0Py5oZWFkZXJzTGlzdClcbiAgICAgIDogbmV3IEhlYWRlcnNMaXN0KCksXG4gICAgdXJsTGlzdDogaW5pdD8udXJsTGlzdCA/IFsuLi5pbml0LnVybExpc3RdIDogW11cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTmV0d29ya0Vycm9yIChyZWFzb24pIHtcbiAgY29uc3QgaXNFcnJvciA9IGlzRXJyb3JMaWtlKHJlYXNvbilcbiAgcmV0dXJuIG1ha2VSZXNwb25zZSh7XG4gICAgdHlwZTogJ2Vycm9yJyxcbiAgICBzdGF0dXM6IDAsXG4gICAgZXJyb3I6IGlzRXJyb3JcbiAgICAgID8gcmVhc29uXG4gICAgICA6IG5ldyBFcnJvcihyZWFzb24gPyBTdHJpbmcocmVhc29uKSA6IHJlYXNvbiksXG4gICAgYWJvcnRlZDogcmVhc29uICYmIHJlYXNvbi5uYW1lID09PSAnQWJvcnRFcnJvcidcbiAgfSlcbn1cblxuLy8gQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1uZXR3b3JrLWVycm9yXG5mdW5jdGlvbiBpc05ldHdvcmtFcnJvciAocmVzcG9uc2UpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIG5ldHdvcmsgZXJyb3IgaXMgYSByZXNwb25zZSB3aG9zZSB0eXBlIGlzIFwiZXJyb3JcIixcbiAgICByZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmXG4gICAgLy8gc3RhdHVzIGlzIDBcbiAgICByZXNwb25zZS5zdGF0dXMgPT09IDBcbiAgKVxufVxuXG5mdW5jdGlvbiBtYWtlRmlsdGVyZWRSZXNwb25zZSAocmVzcG9uc2UsIHN0YXRlKSB7XG4gIHN0YXRlID0ge1xuICAgIGludGVybmFsUmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgIC4uLnN0YXRlXG4gIH1cblxuICByZXR1cm4gbmV3IFByb3h5KHJlc3BvbnNlLCB7XG4gICAgZ2V0ICh0YXJnZXQsIHApIHtcbiAgICAgIHJldHVybiBwIGluIHN0YXRlID8gc3RhdGVbcF0gOiB0YXJnZXRbcF1cbiAgICB9LFxuICAgIHNldCAodGFyZ2V0LCBwLCB2YWx1ZSkge1xuICAgICAgYXNzZXJ0KCEocCBpbiBzdGF0ZSkpXG4gICAgICB0YXJnZXRbcF0gPSB2YWx1ZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWZpbHRlcmVkLXJlc3BvbnNlXG5mdW5jdGlvbiBmaWx0ZXJSZXNwb25zZSAocmVzcG9uc2UsIHR5cGUpIHtcbiAgLy8gU2V0IHJlc3BvbnNlIHRvIHRoZSBmb2xsb3dpbmcgZmlsdGVyZWQgcmVzcG9uc2Ugd2l0aCByZXNwb25zZSBhcyBpdHNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgaWYgKHR5cGUgPT09ICdiYXNpYycpIHtcbiAgICAvLyBBIGJhc2ljIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImJhc2ljXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBhIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZS5cblxuICAgIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIHJlc3BvbnNlLWhlYWRlciBuYW1lc1xuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ2Jhc2ljJyxcbiAgICAgIGhlYWRlcnNMaXN0OiByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvcnMnKSB7XG4gICAgLy8gQSBDT1JTIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImNvcnNcIlxuICAgIC8vIGFuZCBoZWFkZXIgbGlzdCBleGNsdWRlcyBhbnkgaGVhZGVycyBpbiBpbnRlcm5hbCByZXNwb25zZeKAmXMgaGVhZGVyXG4gICAgLy8gbGlzdCB3aG9zZSBuYW1lIGlzIG5vdCBhIENPUlMtc2FmZWxpc3RlZCByZXNwb25zZS1oZWFkZXIgbmFtZSwgZ2l2ZW5cbiAgICAvLyBpbnRlcm5hbCByZXNwb25zZeKAmXMgQ09SUy1leHBvc2VkIGhlYWRlci1uYW1lIGxpc3QuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IENPUlMtc2FmZWxpc3RlZCByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdjb3JzJyxcbiAgICAgIGhlYWRlcnNMaXN0OiByZXNwb25zZS5oZWFkZXJzTGlzdFxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wYXF1ZScpIHtcbiAgICAvLyBBbiBvcGFxdWUgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlIGlzXG4gICAgLy8gXCJvcGFxdWVcIiwgVVJMIGxpc3QgaXMgdGhlIGVtcHR5IGxpc3QsIHN0YXR1cyBpcyAwLCBzdGF0dXMgbWVzc2FnZVxuICAgIC8vIGlzIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlLCBoZWFkZXIgbGlzdCBpcyBlbXB0eSwgYW5kIGJvZHkgaXMgbnVsbC5cblxuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ29wYXF1ZScsXG4gICAgICB1cmxMaXN0OiBPYmplY3QuZnJlZXplKFtdKSxcbiAgICAgIHN0YXR1czogMCxcbiAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgYm9keTogbnVsbFxuICAgIH0pXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wYXF1ZXJlZGlyZWN0Jykge1xuICAgIC8vIEFuIG9wYXF1ZS1yZWRpcmVjdCBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGVcbiAgICAvLyBpcyBcIm9wYXF1ZXJlZGlyZWN0XCIsIHN0YXR1cyBpcyAwLCBzdGF0dXMgbWVzc2FnZSBpcyB0aGUgZW1wdHkgYnl0ZVxuICAgIC8vIHNlcXVlbmNlLCBoZWFkZXIgbGlzdCBpcyBlbXB0eSwgYW5kIGJvZHkgaXMgbnVsbC5cblxuICAgIHJldHVybiBtYWtlRmlsdGVyZWRSZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgdHlwZTogJ29wYXF1ZXJlZGlyZWN0JyxcbiAgICAgIHN0YXR1czogMCxcbiAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgaGVhZGVyc0xpc3Q6IFtdLFxuICAgICAgYm9keTogbnVsbFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhcHByb3ByaWF0ZS1uZXR3b3JrLWVycm9yXG5mdW5jdGlvbiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IgKGZldGNoUGFyYW1zLCBlcnIgPSBudWxsKSB7XG4gIC8vIDEuIEFzc2VydDogZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQuXG4gIGFzc2VydChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpXG5cbiAgLy8gMi4gUmV0dXJuIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciBpZiBmZXRjaFBhcmFtcyBpcyBhYm9ydGVkO1xuICAvLyBvdGhlcndpc2UgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgcmV0dXJuIGlzQWJvcnRlZChmZXRjaFBhcmFtcylcbiAgICA/IG1ha2VOZXR3b3JrRXJyb3IoT2JqZWN0LmFzc2lnbihuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJyksIHsgY2F1c2U6IGVyciB9KSlcbiAgICA6IG1ha2VOZXR3b3JrRXJyb3IoT2JqZWN0LmFzc2lnbihuZXcgRE9NRXhjZXB0aW9uKCdSZXF1ZXN0IHdhcyBjYW5jZWxsZWQuJyksIHsgY2F1c2U6IGVyciB9KSlcbn1cblxuLy8gaHR0cHM6Ly93aGF0cHIub3JnL2ZldGNoLzEzOTIuaHRtbCNpbml0aWFsaXplLWEtcmVzcG9uc2VcbmZ1bmN0aW9uIGluaXRpYWxpemVSZXNwb25zZSAocmVzcG9uc2UsIGluaXQsIGJvZHkpIHtcbiAgLy8gMS4gSWYgaW5pdFtcInN0YXR1c1wiXSBpcyBub3QgaW4gdGhlIHJhbmdlIDIwMCB0byA1OTksIGluY2x1c2l2ZSwgdGhlblxuICAvLyAgICB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gIGlmIChpbml0LnN0YXR1cyAhPT0gbnVsbCAmJiAoaW5pdC5zdGF0dXMgPCAyMDAgfHwgaW5pdC5zdGF0dXMgPiA1OTkpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luaXRbXCJzdGF0dXNcIl0gbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMjAwIHRvIDU5OSwgaW5jbHVzaXZlLicpXG4gIH1cblxuICAvLyAyLiBJZiBpbml0W1wic3RhdHVzVGV4dFwiXSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVhc29uLXBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLFxuICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoJ3N0YXR1c1RleHQnIGluIGluaXQgJiYgaW5pdC5zdGF0dXNUZXh0ICE9IG51bGwpIHtcbiAgICAvLyBTZWUsIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMS4yOlxuICAgIC8vICAgcmVhc29uLXBocmFzZSAgPSAqKCBIVEFCIC8gU1AgLyBWQ0hBUiAvIG9icy10ZXh0IClcbiAgICBpZiAoIWlzVmFsaWRSZWFzb25QaHJhc2UoU3RyaW5nKGluaXQuc3RhdHVzVGV4dCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0YXR1c1RleHQnKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFNldCByZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyB0byBpbml0W1wic3RhdHVzXCJdLlxuICBpZiAoJ3N0YXR1cycgaW4gaW5pdCAmJiBpbml0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgcmVzcG9uc2Vba1N0YXRlXS5zdGF0dXMgPSBpbml0LnN0YXR1c1xuICB9XG5cbiAgLy8gNC4gU2V0IHJlc3BvbnNl4oCZcyByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UgdG8gaW5pdFtcInN0YXR1c1RleHRcIl0uXG4gIGlmICgnc3RhdHVzVGV4dCcgaW4gaW5pdCAmJiBpbml0LnN0YXR1c1RleHQgIT0gbnVsbCkge1xuICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzVGV4dCA9IGluaXQuc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gNS4gSWYgaW5pdFtcImhlYWRlcnNcIl0gZXhpc3RzLCB0aGVuIGZpbGwgcmVzcG9uc2XigJlzIGhlYWRlcnMgd2l0aCBpbml0W1wiaGVhZGVyc1wiXS5cbiAgaWYgKCdoZWFkZXJzJyBpbiBpbml0ICYmIGluaXQuaGVhZGVycyAhPSBudWxsKSB7XG4gICAgZmlsbChyZXNwb25zZVtrSGVhZGVyc10sIGluaXQuaGVhZGVycylcbiAgfVxuXG4gIC8vIDYuIElmIGJvZHkgd2FzIGdpdmVuLCB0aGVuOlxuICBpZiAoYm9keSkge1xuICAgIC8vIDEuIElmIHJlc3BvbnNlJ3Mgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cywgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAobnVsbEJvZHlTdGF0dXMuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXNwb25zZSBjb25zdHJ1Y3RvcicsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cyBjb2RlICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHJlc3BvbnNlJ3MgYm9keSB0byBib2R5J3MgYm9keS5cbiAgICByZXNwb25zZVtrU3RhdGVdLmJvZHkgPSBib2R5LmJvZHlcblxuICAgIC8vIDMuIElmIGJvZHkncyB0eXBlIGlzIG5vbi1udWxsIGFuZCByZXNwb25zZSdzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW5cbiAgICAvLyAgICBgQ29udGVudC1UeXBlYCwgdGhlbiBhcHBlbmQgKGBDb250ZW50LVR5cGVgLCBib2R5J3MgdHlwZSkgdG8gcmVzcG9uc2UncyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoYm9keS50eXBlICE9IG51bGwgJiYgIXJlc3BvbnNlW2tTdGF0ZV0uaGVhZGVyc0xpc3QuY29udGFpbnMoJ2NvbnRlbnQtdHlwZScsIHRydWUpKSB7XG4gICAgICByZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmFwcGVuZCgnY29udGVudC10eXBlJywgYm9keS50eXBlLCB0cnVlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3Jlc3BvbnNlLWNyZWF0ZVxuICogQHBhcmFtIHthbnl9IGlubmVyUmVzcG9uc2VcbiAqIEBwYXJhbSB7J3JlcXVlc3QnIHwgJ2ltbXV0YWJsZScgfCAncmVxdWVzdC1uby1jb3JzJyB8ICdyZXNwb25zZScgfCAnbm9uZSd9IGd1YXJkXG4gKiBAcmV0dXJucyB7UmVzcG9uc2V9XG4gKi9cbmZ1bmN0aW9uIGZyb21Jbm5lclJlc3BvbnNlIChpbm5lclJlc3BvbnNlLCBndWFyZCkge1xuICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShrQ29uc3RydWN0KVxuICByZXNwb25zZVtrU3RhdGVdID0gaW5uZXJSZXNwb25zZVxuICByZXNwb25zZVtrSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICBzZXRIZWFkZXJzTGlzdChyZXNwb25zZVtrSGVhZGVyc10sIGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QpXG4gIHNldEhlYWRlcnNHdWFyZChyZXNwb25zZVtrSGVhZGVyc10sIGd1YXJkKVxuXG4gIGlmIChoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSAmJiBpbm5lclJlc3BvbnNlLmJvZHk/LnN0cmVhbSkge1xuICAgIC8vIElmIHRoZSB0YXJnZXQgKHJlc3BvbnNlKSBpcyByZWNsYWltZWQsIHRoZSBjbGVhbnVwIGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCB3aXRoXG4gICAgLy8gdGhlIGhlbGQgdmFsdWUgcHJvdmlkZWQgZm9yIGl0IChpbm5lclJlc3BvbnNlLmJvZHkuc3RyZWFtKS4gVGhlIGhlbGQgdmFsdWUgY2FuIGJlIGFueSB2YWx1ZTpcbiAgICAvLyBhIHByaW1pdGl2ZSBvciBhbiBvYmplY3QsIGV2ZW4gdW5kZWZpbmVkLiBJZiB0aGUgaGVsZCB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZSByZWdpc3RyeSBrZWVwc1xuICAgIC8vIGEgc3Ryb25nIHJlZmVyZW5jZSB0byBpdCAoc28gaXQgY2FuIHBhc3MgaXQgdG8gdGhlIGNsZWFudXAgY2FsbGJhY2sgbGF0ZXIpLiBSZXdvcmRlZCBmcm9tXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmluYWxpemF0aW9uUmVnaXN0cnlcbiAgICByZWdpc3RyeS5yZWdpc3RlcihyZXNwb25zZSwgbmV3IFdlYWtSZWYoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkpXG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUmVhZGFibGVTdHJlYW0gPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBSZWFkYWJsZVN0cmVhbVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YSA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEZvcm1EYXRhXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLlVSTFNlYXJjaFBhcmFtcyA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFVSTFNlYXJjaFBhcmFtc1xuKVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jdHlwZWRlZmRlZi14bWxodHRwcmVxdWVzdGJvZHlpbml0XG53ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgbmFtZSkge1xuICBpZiAodHlwZW9mIFYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBwcmVmaXgsIG5hbWUpXG4gIH1cblxuICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHByZWZpeCwgbmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KFYpIHx8IHR5cGVzLmlzQXJyYXlCdWZmZXIoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYsIHByZWZpeCwgbmFtZSlcbiAgfVxuXG4gIGlmICh1dGlsLmlzRm9ybURhdGFMaWtlKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkZvcm1EYXRhKFYsIHByZWZpeCwgbmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhWLCBwcmVmaXgsIG5hbWUpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuQm9keUluaXQgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICBpZiAoViBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGluY2x1ZGUgYXN5bmMgaXRlcmFibGVzLFxuICAvLyB0aGlzIGlzIGFuIHVuZGljaSBleHRlbnNpb24uXG4gIGlmIChWPy5bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIFZcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5YTUxIdHRwUmVxdWVzdEJvZHlJbml0KFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlc3BvbnNlSW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3N0YXR1cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDIwMFxuICB9LFxuICB7XG4gICAga2V5OiAnc3RhdHVzVGV4dCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2hlYWRlcnMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXRcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzTmV0d29ya0Vycm9yLFxuICBtYWtlTmV0d29ya0Vycm9yLFxuICBtYWtlUmVzcG9uc2UsXG4gIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcixcbiAgZmlsdGVyUmVzcG9uc2UsXG4gIFJlc3BvbnNlLFxuICBjbG9uZVJlc3BvbnNlLFxuICBmcm9tSW5uZXJSZXNwb25zZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kUrl: Symbol('url'),\n  kHeaders: Symbol('headers'),\n  kSignal: Symbol('signal'),\n  kState: Symbol('state'),\n  kDispatcher: Symbol('dispatcher')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrVXJsOiBTeW1ib2woJ3VybCcpLFxuICBrSGVhZGVyczogU3ltYm9sKCdoZWFkZXJzJyksXG4gIGtTaWduYWw6IFN5bWJvbCgnc2lnbmFsJyksXG4gIGtTdGF0ZTogU3ltYm9sKCdzdGF0ZScpLFxuICBrRGlzcGF0Y2hlcjogU3ltYm9sKCdkaXNwYXRjaGVyJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(ssr)/./node_modules/undici/lib/web/fetch/global.js\")\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\")\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  url = new URL(url)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index\n      const values = this.#target[kInternalIterator]\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    successSteps(await readAllBytes(reader))\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\nfunction isReadableStreamLike (stream) {\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate()\n        : zlib.createInflateRaw()\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\nfunction createInflate () {\n  return new InflateStream()\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxRQUFRLDBFQUEwRSxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDekcsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQzlDLFFBQVEsc0ZBQXNGLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNwSCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNqRCxRQUFRLGdGQUFnRixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ25ILGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNsRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVOztBQUVyQzs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLElBQUk7O0FBRXpHO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEIsSUFBSTtBQUMvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUUvQztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFdBQVc7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7IHJlZGlyZWN0U3RhdHVzU2V0LCByZWZlcnJlclBvbGljeVNldDogcmVmZXJyZXJQb2xpY3lUb2tlbnMsIGJhZFBvcnRzU2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLCBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLCByZW1vdmVDaGFycywgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSByZXF1aXJlKCdub2RlOnBlcmZfaG9va3MnKVxuY29uc3QgeyBpc0Jsb2JMaWtlLCBSZWFkYWJsZVN0cmVhbUZyb20sIGlzVmFsaWRIVFRQVG9rZW4sIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgaXNVaW50OEFycmF5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwvdHlwZXMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcblxubGV0IHN1cHBvcnRlZEhhc2hlcyA9IFtdXG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjZGV0ZXJtaW5pbmctaWYtY3J5cHRvLXN1cHBvcnQtaXMtdW5hdmFpbGFibGVcbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbiAgY29uc3QgcG9zc2libGVSZWxldmFudEhhc2hlcyA9IFsnc2hhMjU2JywgJ3NoYTM4NCcsICdzaGE1MTInXVxuICBzdXBwb3J0ZWRIYXNoZXMgPSBjcnlwdG8uZ2V0SGFzaGVzKCkuZmlsdGVyKChoYXNoKSA9PiBwb3NzaWJsZVJlbGV2YW50SGFzaGVzLmluY2x1ZGVzKGhhc2gpKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG5cbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDIuIExldCBsb2NhdGlvbiBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuXG4gIC8vIGBMb2NhdGlvbmAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgLy8gMy4gSWYgbG9jYXRpb24gaXMgYSBoZWFkZXIgdmFsdWUsIHRoZW4gc2V0IGxvY2F0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgcGFyc2luZyBsb2NhdGlvbiB3aXRoIHJlc3BvbnNl4oCZcyBVUkwuXG4gIGlmIChsb2NhdGlvbiAhPT0gbnVsbCAmJiBpc1ZhbGlkSGVhZGVyVmFsdWUobG9jYXRpb24pKSB7XG4gICAgaWYgKCFpc1ZhbGlkRW5jb2RlZFVSTChsb2NhdGlvbikpIHtcbiAgICAgIC8vIFNvbWUgd2Vic2l0ZXMgcmVzcG9uZCBsb2NhdGlvbiBoZWFkZXIgaW4gVVRGLTggZm9ybSB3aXRob3V0IGVuY29kaW5nIHRoZW0gYXMgQVNDSUlcbiAgICAgIC8vIGFuZCBtYWpvciBicm93c2VycyByZWRpcmVjdCB0aGVtIHRvIGNvcnJlY3RseSBVVEYtOCBlbmNvZGVkIGFkZHJlc3Nlcy5cbiAgICAgIC8vIEhlcmUsIHdlIGhhbmRsZSB0aGF0IGJlaGF2aW9yIGluIHRoZSBzYW1lIHdheS5cbiAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4KGxvY2F0aW9uKVxuICAgIH1cbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMTczOCNzZWN0aW9uLTIuMlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbmNvZGVkVVJMICh1cmwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmwubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gdXJsLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIE5vbi1VUy1BU0NJSSArIERFTFxuICAgICAgY29kZSA8IDB4MjAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIE5VTCAtIFVTXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBJZiBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzc3VtZXMgaXQncyBVVEYtOCBlbmNvZGVkIGFuZCBkZWNvZGVzIGl0LlxuICogU2luY2UgVVRGLTggaXMgYSBzdXBlcnNldCBvZiBBU0NJSSwgdGhpcyB3aWxsIHdvcmsgZm9yIEFTQ0lJIHN0cmluZ3MgYXMgd2VsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4ICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdiaW5hcnknKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gaXNWYWxpZEhUVFBUb2tlblxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgcmV0dXJuIChcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJ1xcdCcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJyAnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcXHQnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICcgJyB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXG4nKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXHInKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXDAnKVxuICApID09PSBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCAocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICAvLyAgdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAgLy8gIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBhY3R1YWxSZXNwb25zZVxuICAvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knLCB0cnVlKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIE5vdGU6IEFzIHRoZSByZWZlcnJlci1wb2xpY3kgY2FuIGNvbnRhaW4gbXVsdGlwbGUgcG9saWNpZXNcbiAgLy8gc2VwYXJhdGVkIGJ5IGNvbW1hLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbVxuICAvLyBhbmQgcGljayB0aGUgZmlyc3QgdmFsaWQgb25lLlxuICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZWZlcnJlci1Qb2xpY3kjc3BlY2lmeV9hX2ZhbGxiYWNrX3BvbGljeVxuICBsZXQgcG9saWN5ID0gJydcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5oYXModG9rZW4pKSB7XG4gICAgICAgIHBvbGljeSA9IHRva2VuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgcG9saWN5IGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgdG8gcG9saWN5LlxuICBpZiAocG9saWN5ICE9PSAnJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBwb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3Jvc3Mtb3JpZ2luLXJlc291cmNlLXBvbGljeS1jaGVja1xuZnVuY3Rpb24gY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNvcnMtY2hlY2tcbmZ1bmN0aW9uIGNvcnNDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YW8tY2hlY2tcbmZ1bmN0aW9uIFRBT0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbmZ1bmN0aW9uIGFwcGVuZEZldGNoTWV0YWRhdGEgKGh0dHBSZXF1ZXN0KSB7XG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtZGVzdC1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLW1vZGUtaGVhZGVyXG5cbiAgLy8gIDEuIEFzc2VydDogcuKAmXMgdXJsIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLlxuICAvLyAgVE9ET1xuXG4gIC8vICAyLiBMZXQgaGVhZGVyIGJlIGEgU3RydWN0dXJlZCBIZWFkZXIgd2hvc2UgdmFsdWUgaXMgYSB0b2tlbi5cbiAgbGV0IGhlYWRlciA9IG51bGxcblxuICAvLyAgMy4gU2V0IGhlYWRlcuKAmXMgdmFsdWUgdG8gcuKAmXMgbW9kZS5cbiAgaGVhZGVyID0gaHR0cFJlcXVlc3QubW9kZVxuXG4gIC8vICA0LiBTZXQgYSBzdHJ1Y3R1cmVkIGZpZWxkIHZhbHVlIGBTZWMtRmV0Y2gtTW9kZWAvaGVhZGVyIGluIHLigJlzIGhlYWRlciBsaXN0LlxuICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5zZXQoJ3NlYy1mZXRjaC1tb2RlJywgaGVhZGVyLCB0cnVlKVxuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtc2l0ZS1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXVzZXItaGVhZGVyXG4gIC8vICBUT0RPXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhcHBlbmQtYS1yZXF1ZXN0LW9yaWdpbi1oZWFkZXJcbmZ1bmN0aW9uIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHNlcmlhbGl6ZWRPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cbiAgLy8gICAgd2l0aCByZXF1ZXN0LlxuICAvLyBUT0RPOiBpbXBsZW1lbnQgXCJieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cIlxuICBsZXQgc2VyaWFsaXplZE9yaWdpbiA9IHJlcXVlc3Qub3JpZ2luXG5cbiAgLy8gLSBcIidjbGllbnQnIGlzIGNoYW5nZWQgdG8gYW4gb3JpZ2luIGR1cmluZyBmZXRjaGluZy5cIlxuICAvLyAgIFRoaXMgZG9lc24ndCBoYXBwZW4gaW4gdW5kaWNpIChpbiBtb3N0IGNhc2VzKSBiZWNhdXNlIHVuZGljaSwgYnkgZGVmYXVsdCxcbiAgLy8gICBoYXMgbm8gY29uY2VwdCBvZiBvcmlnaW4uXG4gIC8vIC0gcmVxdWVzdC5vcmlnaW4gY2FuIGFsc28gYmUgc2V0IHRvIHJlcXVlc3QuY2xpZW50Lm9yaWdpbiAoY2xpZW50IGJlaW5nXG4gIC8vICAgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0KSwgd2hpY2ggaXMgdW5kZWZpbmVkIHdpdGhvdXQgdXNpbmdcbiAgLy8gICBzZXRHbG9iYWxPcmlnaW4uXG4gIGlmIChzZXJpYWxpemVkT3JpZ2luID09PSAnY2xpZW50JyB8fCBzZXJpYWxpemVkT3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIG9yIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJ3ZWJzb2NrZXRcIixcbiAgLy8gICAgdGhlbiBhcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbmVpdGhlciBgR0VUYCBub3IgYEhFQURgLCB0aGVuOlxuICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luLCB0cnVlKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgLy8gMS4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeTpcbiAgICBzd2l0Y2ggKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyJzpcbiAgICAgICAgLy8gU2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIGEgdHVwbGUgb3JpZ2luLCBpdHMgc2NoZW1lIGlzIFwiaHR0cHNcIiwgYW5kXG4gICAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IFwiaHR0cHNcIiwgdGhlbiBzZXRcbiAgICAgICAgLy8gc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm9yaWdpbiAmJiB1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Lm9yaWdpbikgJiYgIXVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZc1xuICAgICAgICAvLyBvcmlnaW4sIHRoZW4gc2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdCwgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnb3JpZ2luJywgc2VyaWFsaXplZE9yaWdpbiwgdHJ1ZSlcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vaHItdGltZS8jZGZuLWNvYXJzZW4tdGltZVxuZnVuY3Rpb24gY29hcnNlblRpbWUgKHRpbWVzdGFtcCwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gdGltZXN0YW1wXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjbGFtcC1hbmQtY29hcnNlbi1jb25uZWN0aW9uLXRpbWluZy1pbmZvXG5mdW5jdGlvbiBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyAoY29ubmVjdGlvblRpbWluZ0luZm8sIGRlZmF1bHRTdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIGlmICghY29ubmVjdGlvblRpbWluZ0luZm8/LnN0YXJ0VGltZSB8fCBjb25uZWN0aW9uVGltaW5nSW5mby5zdGFydFRpbWUgPCBkZWZhdWx0U3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGRvbWFpbkxvb2t1cEVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBjb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgY29ubmVjdGlvbkVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8/LkFMUE5OZWdvdGlhdGVkUHJvdG9jb2xcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgZG9tYWluTG9va3VwRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwRW5kVGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGNvbm5lY3Rpb25TdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmNvbm5lY3Rpb25TdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBjb25uZWN0aW9uRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uY29ubmVjdGlvbkVuZFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5zZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8uQUxQTk5lZ290aWF0ZWRQcm90b2NvbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9oci10aW1lLyNkZm4tY29hcnNlbmVkLXNoYXJlZC1jdXJyZW50LXRpbWVcbmZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIChjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICByZXR1cm4gY29hcnNlblRpbWUocGVyZm9ybWFuY2Uubm93KCksIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLWFuLW9wYXF1ZS10aW1pbmctaW5mb1xuZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyAodGltaW5nSW5mbykge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICByZWRpcmVjdFN0YXJ0VGltZTogMCxcbiAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIGZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgIGVuZFRpbWU6IDAsXG4gICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICBmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvOiBudWxsXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lciAoKSB7XG4gIC8vIE5vdGU6IHRoZSBmZXRjaCBzcGVjIGRvZXNuJ3QgbWFrZSB1c2Ugb2YgZW1iZWRkZXIgcG9saWN5IG9yIENTUCBsaXN0XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJ1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI2Nsb25lLWEtcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gY2xvbmVQb2xpY3lDb250YWluZXIgKHBvbGljeUNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiBwb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gbm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgY29uc3QgYXJlU2FtZU9yaWdpbiA9IHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpXG4gIGNvbnN0IGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA9IGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiZcbiAgICAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlcXVlc3QudXJsKVxuXG4gIC8vIDguIEV4ZWN1dGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlICdvcmlnaW4nOiByZXR1cm4gcmVmZXJyZXJPcmlnaW4gIT0gbnVsbCA/IHJlZmVycmVyT3JpZ2luIDogc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcbiAgICBjYXNlICd1bnNhZmUtdXJsJzogcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlck9yaWdpbiA6ICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlclVSTCA6IHJlZmVycmVyT3JpZ2luXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8qKlxuICAgICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICAgKiB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAgICovXG4gICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAqIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZFxuICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgKiAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgICovXG5cbiAgICBkZWZhdWx0OiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5ID8gJ25vLXJlZmVycmVyJyA6IHJlZmVycmVyT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IG9yaWdpbk9ubHlcbiAqL1xuZnVuY3Rpb24gc3RyaXBVUkxGb3JSZWZlcnJlciAodXJsLCBvcmlnaW5Pbmx5KSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQodXJsIGluc3RhbmNlb2YgVVJMKVxuXG4gIHVybCA9IG5ldyBVUkwodXJsKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2JsYW5rOicpIHtcbiAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICB9XG5cbiAgLy8gMy4gU2V0IHVybOKAmXMgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnVzZXJuYW1lID0gJydcblxuICAvLyA0LiBTZXQgdXJs4oCZcyBwYXNzd29yZCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwucGFzc3dvcmQgPSAnJ1xuXG4gIC8vIDUuIFNldCB1cmzigJlzIGZyYWdtZW50IHRvIG51bGwuXG4gIHVybC5oYXNoID0gJydcblxuICAvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuICBpZiAob3JpZ2luT25seSkge1xuICAgIC8vIDEuIFNldCB1cmzigJlzIHBhdGggdG8gwqsgdGhlIGVtcHR5IHN0cmluZyDCuy5cbiAgICB1cmwucGF0aG5hbWUgPSAnJ1xuXG4gICAgLy8gMi4gU2V0IHVybOKAmXMgcXVlcnkgdG8gbnVsbC5cbiAgICB1cmwuc2VhcmNoID0gJydcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB1cmwuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5ICh1cmwpIHtcbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgb2YgYWJvdXQsIHJldHVybiB0cnVlXG4gIGlmICh1cmwuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJyB8fCB1cmwuaHJlZiA9PT0gJ2Fib3V0OnNyY2RvYycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2NoZW1lIGlzIGRhdGEsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHJldHVybiB0cnVlXG5cbiAgLy8gSWYgZmlsZSwgcmV0dXJuIHRydWVcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JykgcmV0dXJuIHRydWVcblxuICByZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybC5vcmlnaW4pXG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IChvcmlnaW4pIHtcbiAgICAvLyBJZiBvcmlnaW4gaXMgZXhwbGljaXRseSBudWxsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAob3JpZ2luID09IG51bGwgfHwgb3JpZ2luID09PSAnbnVsbCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3JpZ2luQXNVUkwgPSBuZXcgVVJMKG9yaWdpbilcblxuICAgIC8vIElmIHNlY3VyZSwgcmV0dXJuIHRydWVcbiAgICBpZiAob3JpZ2luQXNVUkwucHJvdG9jb2wgPT09ICdodHRwczonIHx8IG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgbG9jYWxob3N0IG9yIHZhcmlhbnRzLCByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjEyNyg/OlxcLlswLTldKyl7MCwyfVxcLlswLTldKyR8XlxcWyg/OjAqOikqPzo/MCoxXFxdJC8udGVzdChvcmlnaW5Bc1VSTC5ob3N0bmFtZSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBvcmlnaW5Bc1VSTC5ob3N0bmFtZS5pbmNsdWRlcygnbG9jYWxob3N0LicpKSB8fFxuICAgICAob3JpZ2luQXNVUkwuaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzTWF0Y2ggKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgLy8gSWYgbm9kZSBpcyBub3QgYnVpbHQgd2l0aCBPcGVuU1NMIHN1cHBvcnQsIHdlIGNhbm5vdCBjaGVja1xuICAvLyBhIHJlcXVlc3QncyBpbnRlZ3JpdHksIHNvIGFsbG93IGl0IGJ5IGRlZmF1bHQgKHRoZSBzcGVjIHdpbGxcbiAgLy8gYWxsb3cgcmVxdWVzdHMgaWYgYW4gaW52YWxpZCBoYXNoIGlzIGdpdmVuLCBhcyBwcmVjZWRlbmNlKS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBvbmx5IGlmIG5vZGUgaXMgYnVpbHQgd2l0aCAtLXdpdGhvdXQtc3NsICovXG4gIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAxLiBMZXQgcGFyc2VkTWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIG1ldGFkYXRhTGlzdC5cbiAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAvLyAyLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyBubyBtZXRhZGF0YSwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gJ25vIG1ldGFkYXRhJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZSBpcyBub3QgZWxpZ2libGUgZm9yIGludGVncml0eSB2YWxpZGF0aW9uLCByZXR1cm4gZmFsc2UuXG4gIC8vIFRPRE9cblxuICAvLyA0LiBJZiBwYXJzZWRNZXRhZGF0YSBpcyB0aGUgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyA1LiBMZXQgbWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIHRoZSBzdHJvbmdlc3RcbiAgLy8gICAgbWV0YWRhdGEgZnJvbSBwYXJzZWRNZXRhZGF0YS5cbiAgY29uc3Qgc3Ryb25nZXN0ID0gZ2V0U3Ryb25nZXN0TWV0YWRhdGEocGFyc2VkTWV0YWRhdGEpXG4gIGNvbnN0IG1ldGFkYXRhID0gZmlsdGVyTWV0YWRhdGFMaXN0QnlBbGdvcml0aG0ocGFyc2VkTWV0YWRhdGEsIHN0cm9uZ2VzdClcblxuICAvLyA2LiBGb3IgZWFjaCBpdGVtIGluIG1ldGFkYXRhOlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAvLyAxLiBMZXQgYWxnb3JpdGhtIGJlIHRoZSBhbGcgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvXG5cbiAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgdmFsIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBpdGVtLmhhc2hcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9jb21taXQvZTRjNWNjN2E1ZTQ4MDkzMjIwNTI4ZGZkZDFjNDAxMmRjMzgzN2EwZVxuICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICAvLyAzLiBMZXQgYWN0dWFsVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhbGdvcml0aG0gdG8gYnl0ZXMuXG4gICAgbGV0IGFjdHVhbFZhbHVlID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgnYmFzZTY0JylcblxuICAgIGlmIChhY3R1YWxWYWx1ZVthY3R1YWxWYWx1ZS5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICBpZiAoYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWUubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICBhY3R1YWxWYWx1ZSA9IGFjdHVhbFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWUgPSBhY3R1YWxWYWx1ZS5zbGljZSgwLCAtMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBhY3R1YWxWYWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciBleHBlY3RlZFZhbHVlLFxuICAgIC8vICAgIHJldHVybiB0cnVlLlxuICAgIGlmIChjb21wYXJlQmFzZTY0TWl4ZWQoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNncmFtbWFyZGVmLWhhc2gtd2l0aC1vcHRpb25zXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NQMi8jc291cmNlLWxpc3Qtc3ludGF4XG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTIzNCNhcHBlbmRpeC1CLjFcbmNvbnN0IHBhcnNlSGFzaFdpdGhPcHRpb25zID0gLyg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSgoPzxoYXNoPltBLVphLXowLTkrL10rfFtBLVphLXowLTlfLV0rKT17MCwyfSg/Olxcc3wkKSggK1shLX5dKik/KT8vaVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI3BhcnNlLW1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0LlxuICAvKiogQHR5cGUge3sgYWxnbzogc3RyaW5nLCBoYXNoOiBzdHJpbmcgfVtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIExldCBlbXB0eSBiZSBlcXVhbCB0byB0cnVlLlxuICBsZXQgZW1wdHkgPSB0cnVlXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBtZXRhZGF0YS5zcGxpdCgnICcpKSB7XG4gICAgLy8gMS4gU2V0IGVtcHR5IHRvIGZhbHNlLlxuICAgIGVtcHR5ID0gZmFsc2VcblxuICAgIC8vIDIuIFBhcnNlIHRva2VuIGFzIGEgaGFzaC13aXRoLW9wdGlvbnMuXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKVxuXG4gICAgLy8gMy4gSWYgdG9rZW4gZG9lcyBub3QgcGFyc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuICAgIGlmIChcbiAgICAgIHBhcnNlZFRva2VuID09PSBudWxsIHx8XG4gICAgICBwYXJzZWRUb2tlbi5ncm91cHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ28gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgLy8gTm90ZTogQ2hyb21pdW0gYmxvY2tzIHRoZSByZXF1ZXN0IGF0IHRoaXMgcG9pbnQsIGJ1dCBGaXJlZm94XG4gICAgICAvLyBnaXZlcyBhIHdhcm5pbmcgdGhhdCBhbiBpbnZhbGlkIGludGVncml0eSB3YXMgZ2l2ZW4uIFRoZVxuICAgICAgLy8gY29ycmVjdCBiZWhhdmlvciBpcyB0byBpZ25vcmUgdGhlc2UsIGFuZCBzdWJzZXF1ZW50bHkgbm90XG4gICAgICAvLyBjaGVjayB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNvdXJjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaGFzaC1hbGdvIGNvbXBvbmVudCBvZiB0b2tlbi5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnby50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBhbGdvcml0aG0gaXMgYSBoYXNoIGZ1bmN0aW9uIHJlY29nbml6ZWQgYnkgdGhlIHVzZXJcbiAgICAvLyAgICBhZ2VudCwgYWRkIHRoZSBwYXJzZWQgdG9rZW4gdG8gcmVzdWx0LlxuICAgIGlmIChzdXBwb3J0ZWRIYXNoZXMuaW5jbHVkZXMoYWxnb3JpdGhtKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBubyBtZXRhZGF0YSBpZiBlbXB0eSBpcyB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdC5cbiAgaWYgKGVtcHR5ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdubyBtZXRhZGF0YSdcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3sgYWxnbzogJ3NoYTI1NicgfCAnc2hhMzg0JyB8ICdzaGE1MTInIH1bXX0gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGdldFN0cm9uZ2VzdE1ldGFkYXRhIChtZXRhZGF0YUxpc3QpIHtcbiAgLy8gTGV0IGFsZ29yaXRobSBiZSB0aGUgYWxnbyBjb21wb25lbnQgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gbWV0YWRhdGFMaXN0LlxuICAvLyBDYW4gYmUgc2hhMjU2XG4gIGxldCBhbGdvcml0aG0gPSBtZXRhZGF0YUxpc3RbMF0uYWxnb1xuICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gIC8vIGFuZCB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5XG4gIGlmIChhbGdvcml0aG1bM10gPT09ICc1Jykge1xuICAgIHJldHVybiBhbGdvcml0aG1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWV0YWRhdGFMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YUxpc3RbaV1cbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gICAgLy8gYW5kIHdlIGNhbiBicmVhayB0aGUgbG9vcCBpbW1lZGlhdGVseVxuICAgIGlmIChtZXRhZGF0YS5hbGdvWzNdID09PSAnNScpIHtcbiAgICAgIGFsZ29yaXRobSA9ICdzaGE1MTInXG4gICAgICBicmVha1xuICAgIC8vIElmIHRoZSBhbGdvcml0aG0gaXMgc2hhMzg0LCB0aGVuIGEgcG90ZW50aWFsIHNoYTI1NiBvciBzaGEzODQgaXMgaWdub3JlZFxuICAgIH0gZWxzZSBpZiAoYWxnb3JpdGhtWzNdID09PSAnMycpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgLy8gYWxnb3JpdGhtIGlzIHNoYTI1NiwgY2hlY2sgaWYgYWxnb3JpdGhtIGlzIHNoYTM4NCBhbmQgaWYgc28sIHNldCBpdCBhc1xuICAgIC8vIHRoZSBzdHJvbmdlc3RcbiAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLmFsZ29bM10gPT09ICczJykge1xuICAgICAgYWxnb3JpdGhtID0gJ3NoYTM4NCdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsZ29yaXRobVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNZXRhZGF0YUxpc3RCeUFsZ29yaXRobSAobWV0YWRhdGFMaXN0LCBhbGdvcml0aG0pIHtcbiAgaWYgKG1ldGFkYXRhTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFMaXN0XG4gIH1cblxuICBsZXQgcG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFkYXRhTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChtZXRhZGF0YUxpc3RbaV0uYWxnbyA9PT0gYWxnb3JpdGhtKSB7XG4gICAgICBtZXRhZGF0YUxpc3RbcG9zKytdID0gbWV0YWRhdGFMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgbWV0YWRhdGFMaXN0Lmxlbmd0aCA9IHBvc1xuXG4gIHJldHVybiBtZXRhZGF0YUxpc3Rcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmFzZTY0IHN0cmluZ3MsIGFsbG93aW5nIGZvciBiYXNlNjR1cmxcbiAqIGluIHRoZSBzZWNvbmQgc3RyaW5nLlxuICpcbiogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFZhbHVlIGFsd2F5cyBiYXNlNjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFZhbHVlIGJhc2U2NCBvciBiYXNlNjR1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlQmFzZTY0TWl4ZWQgKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSB7XG4gIGlmIChhY3R1YWxWYWx1ZS5sZW5ndGggIT09IGV4cGVjdGVkVmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3R1YWxWYWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhY3R1YWxWYWx1ZVtpXSAhPT0gZXhwZWN0ZWRWYWx1ZVtpXSkge1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0dWFsVmFsdWVbaV0gPT09ICcrJyAmJiBleHBlY3RlZFZhbHVlW2ldID09PSAnLScpIHx8XG4gICAgICAgIChhY3R1YWxWYWx1ZVtpXSA9PT0gJy8nICYmIGV4cGVjdGVkVmFsdWVbaV0gPT09ICdfJylcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlICgpIHtcbiAgbGV0IHJlc1xuICBsZXQgcmVqXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfVxufVxuXG5mdW5jdGlvbiBpc0Fib3J0ZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCdcbn1cblxuZnVuY3Rpb24gaXNDYW5jZWxsZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCcgfHxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAndGVybWluYXRlZCdcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kIChtZXRob2QpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPz8gbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvciAobmFtZSwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4ID0gMCwgdmFsdWVJbmRleCA9IDEpIHtcbiAgY2xhc3MgRmFzdEl0ZXJhYmxlSXRlcmF0b3Ige1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICN0YXJnZXRcbiAgICAvKiogQHR5cGUgeydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSAqL1xuICAgICNraW5kXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgI2luZGV4XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWRlZmF1bHQtaXRlcmF0b3Itb2JqZWN0XG4gICAgICogQHBhcmFtIHt1bmtub3dufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHRhcmdldCwga2luZCkge1xuICAgICAgdGhpcy4jdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICB0aGlzLiNraW5kID0ga2luZFxuICAgICAgdGhpcy4jaW5kZXggPSAwXG4gICAgfVxuXG4gICAgbmV4dCAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW50ZXJmYWNlIGJlIHRoZSBpbnRlcmZhY2UgZm9yIHdoaWNoIHRoZSBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGV4aXN0cy5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQgb2JqZWN0IGJlID8gVG9PYmplY3QodGhpc1ZhbHVlKS5cbiAgICAgIC8vIDQuIElmIG9iamVjdCBpcyBhIHBsYXRmb3JtIG9iamVjdCwgdGhlbiBwZXJmb3JtIGEgc2VjdXJpdHlcbiAgICAgIC8vICAgIGNoZWNrLCBwYXNzaW5nOlxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JyB8fCB0aGlzID09PSBudWxsIHx8ICEoI3RhcmdldCBpbiB0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNpbmRleFxuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4jdGFyZ2V0W2tJbnRlcm5hbEl0ZXJhdG9yXVxuXG4gICAgICAvLyA5LiBMZXQgbGVuIGJlIHRoZSBsZW5ndGggb2YgdmFsdWVzLlxuICAgICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyAxMC4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGxlbiwgdGhlbiByZXR1cm5cbiAgICAgIC8vICAgICBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSkuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMTEuIExldCBwYWlyIGJlIHRoZSBlbnRyeSBpbiB2YWx1ZXMgYXQgaW5kZXggaW5kZXguXG4gICAgICBjb25zdCB7IFtrZXlJbmRleF06IGtleSwgW3ZhbHVlSW5kZXhdOiB2YWx1ZSB9ID0gdmFsdWVzW2luZGV4XVxuXG4gICAgICAvLyAxMi4gU2V0IG9iamVjdOKAmXMgaW5kZXggdG8gaW5kZXggKyAxLlxuICAgICAgdGhpcy4jaW5kZXggPSBpbmRleCArIDFcblxuICAgICAgLy8gMTMuIFJldHVybiB0aGUgaXRlcmF0b3IgcmVzdWx0IGZvciBwYWlyIGFuZCBraW5kLlxuXG4gICAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2l0ZXJhdG9yLXJlc3VsdFxuXG4gICAgICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgICAgIGxldCByZXN1bHRcbiAgICAgIHN3aXRjaCAodGhpcy4ja2luZCkge1xuICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxLZXkgYmUgcGFpcuKAmXMga2V5LlxuICAgICAgICAgIC8vIDIuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gcmVzdWx0IGlzIGtleS5cbiAgICAgICAgICByZXN1bHQgPSBrZXlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDMuIHJlc3VsdCBpcyB2YWx1ZS5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2tleSt2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAgICAgLy8gMi4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDMuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNC4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxWYWx1ZSB0b1xuICAgICAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAgICAgLy8gNi4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIwXCIsIGtleSkuXG4gICAgICAgICAgLy8gNy4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIxXCIsIHZhbHVlKS5cbiAgICAgICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICAgICAgcmVzdWx0ID0gW2tleSwgdmFsdWVdXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gUmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBmYWxzZSkuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAgLy8gQHRzLWlnbm9yZVxuICBkZWxldGUgRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZSwgZXNJdGVyYXRvclByb3RvdHlwZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUsIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYCR7bmFtZX0gSXRlcmF0b3JgXG4gICAgfSxcbiAgICBuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuICB9KVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHRhcmdldFxuICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuICAgIHJldHVybiBuZXcgRmFzdEl0ZXJhYmxlSXRlcmF0b3IodGFyZ2V0LCBraW5kKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IG9iamVjdCBjbGFzc1xuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBpdGVyYXRvck1peGluIChuYW1lLCBvYmplY3QsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCA9IDAsIHZhbHVlSW5kZXggPSAxKSB7XG4gIGNvbnN0IG1ha2VJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yKG5hbWUsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCwgdmFsdWVJbmRleClcblxuICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgIGtleXM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXknKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpXG4gICAgICB9XG4gICAgfSxcbiAgICBlbnRyaWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJylcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFja2ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgYCR7bmFtZX0uZm9yRWFjaGApXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICcke25hbWV9JzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyAwOiBrZXksIDE6IHZhbHVlIH0gb2YgbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKSkge1xuICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAuLi5wcm9wZXJ0aWVzLFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHByb3BlcnRpZXMuZW50cmllcy52YWx1ZVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LWZ1bGx5LXJlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnVsbHlSZWFkQm9keSAoYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpIHtcbiAgLy8gMS4gSWYgdGFza0Rlc3RpbmF0aW9uIGlzIG51bGwsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0b1xuICAvLyAgICB0aGUgcmVzdWx0IG9mIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuXG4gIC8vIDIuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzIGJlIHRvIHF1ZXVlIGFcbiAgLy8gICAgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMsIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBzdWNjZXNzU3RlcHMgPSBwcm9jZXNzQm9keVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGJlIHRvIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHlFcnJvcixcbiAgLy8gICAgd2l0aCB0YXNrRGVzdGluYXRpb24uXG4gIGNvbnN0IGVycm9yU3RlcHMgPSBwcm9jZXNzQm9keUVycm9yXG5cbiAgLy8gNC4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZm9yIGJvZHnigJlzIHN0cmVhbS5cbiAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHMgd2l0aCB0aGF0XG4gIC8vICAgIGV4Y2VwdGlvbiBhbmQgcmV0dXJuLlxuICBsZXQgcmVhZGVyXG5cbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBib2R5LnN0cmVhbS5nZXRSZWFkZXIoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNS4gUmVhZCBhbGwgYnl0ZXMgZnJvbSByZWFkZXIsIGdpdmVuIHN1Y2Nlc3NTdGVwcyBhbmQgZXJyb3JTdGVwcy5cbiAgdHJ5IHtcbiAgICBzdWNjZXNzU3RlcHMoYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcikpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvclN0ZXBzKGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2UgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+fSBjb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtQ2xvc2UgKGNvbnRyb2xsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBjb21tZW50IGV4cGxhaW5pbmcgd2h5IHRoaXMgZXJyb3Igb2NjdXJzLlxuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0NvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWQnKSAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1JlYWRhYmxlU3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXggPSAvW15cXHgwMC1cXHhGRl0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWVuY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNFbmNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIEFzc2VydDogaW5wdXQgY29udGFpbnMgbm8gY29kZSBwb2ludHMgZ3JlYXRlciB0aGFuIFUrMDBGRi5cbiAgYXNzZXJ0KCFpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXgudGVzdChpbnB1dCkpXG5cbiAgLy8gMi4gUmV0dXJuIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGNvZGVcbiAgLy8gICAgcG9pbnQgbGVuZ3RoIGFuZCB3aG9zZSBieXRlcyBoYXZlIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgLy8gICAgdmFsdWVzIG9mIGlucHV04oCZcyBjb2RlIHBvaW50cywgaW4gdGhlIHNhbWUgb3JkZXJcbiAgcmV0dXJuIGlucHV0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbWRlZmF1bHRyZWFkZXItcmVhZC1hbGwtYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZC1sb29wXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcn0gcmVhZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyAocmVhZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gW11cbiAgbGV0IGJ5dGVMZW5ndGggPSAwXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIC8vIDEuIENhbGwgc3VjY2Vzc1N0ZXBzIHdpdGggYnl0ZXMuXG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChieXRlcywgYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjaHVuayBpcyBub3QgYSBVaW50OEFycmF5IG9iamVjdCwgY2FsbCBmYWlsdXJlU3RlcHNcbiAgICAvLyAgICB3aXRoIGEgVHlwZUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlY2VpdmVkIG5vbi1VaW50OEFycmF5IGNodW5rJylcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgdGhlIGJ5dGVzIHJlcHJlc2VudGVkIGJ5IGNodW5rIHRvIGJ5dGVzLlxuICAgIGJ5dGVzLnB1c2goY2h1bmspXG4gICAgYnl0ZUxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIC8vIDMuIFJlYWQtbG9vcCBnaXZlbiByZWFkZXIsIGJ5dGVzLCBzdWNjZXNzU3RlcHMsIGFuZCBmYWlsdXJlU3RlcHMuXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNpcy1sb2NhbFxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0xvY2FsICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2Fib3V0OicgfHwgcHJvdG9jb2wgPT09ICdibG9iOicgfHwgcHJvdG9jb2wgPT09ICdkYXRhOidcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEhhc0h0dHBzU2NoZW1lICh1cmwpIHtcbiAgcmV0dXJuIChcbiAgICAoXG4gICAgICB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgdXJsWzVdID09PSAnOicgJiZcbiAgICAgIHVybFswXSA9PT0gJ2gnICYmXG4gICAgICB1cmxbMV0gPT09ICd0JyAmJlxuICAgICAgdXJsWzJdID09PSAndCcgJiZcbiAgICAgIHVybFszXSA9PT0gJ3AnICYmXG4gICAgICB1cmxbNF0gPT09ICdzJ1xuICAgICkgfHxcbiAgICB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG4gIClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXNjaGVtZVxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0h0dHBIdHRwc1NjaGVtZSAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgfHwgcHJvdG9jb2wgPT09ICdodHRwczonXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jc2ltcGxlLXJhbmdlLWhlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93V2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiBzaW1wbGVSYW5nZUhlYWRlclZhbHVlICh2YWx1ZSwgYWxsb3dXaGl0ZXNwYWNlKSB7XG4gIC8vIDEuIExldCBkYXRhIGJlIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIHZhbHVlLlxuICAvLyBOb3RlOiBpc29tb3JwaGljIGRlY29kaW5nIHRha2VzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgKGllLiBhIFVpbnQ4QXJyYXkpIGFuZCB0dXJucyBpdCBpbnRvIGEgc3RyaW5nLFxuICAvLyBub3RoaW5nIG1vcmUuIFdlIG9idmlvdXNseSBkb24ndCBuZWVkIHRvIGRvIHRoYXQgaWYgdmFsdWUgaXMgYSBzdHJpbmcgYWxyZWFkeS5cbiAgY29uc3QgZGF0YSA9IHZhbHVlXG5cbiAgLy8gMi4gSWYgZGF0YSBkb2VzIG5vdCBzdGFydCB3aXRoIFwiYnl0ZXNcIiwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAzLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgZGF0YSwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSA1dGggY29kZSBwb2ludCBvZiBkYXRhLlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDUgfVxuXG4gIC8vIDQuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gNS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGRhdGEgaXMgbm90IFUrMDAzRCAoPSksIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhLmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pICE9PSAweDNEKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSwgZnJvbVxuICAvLyAgICBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyA4LiBMZXQgcmFuZ2VTdGFydCBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBBU0NJSSBkaWdpdHMsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgcmFuZ2VTdGFydCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDkuIExldCByYW5nZVN0YXJ0VmFsdWUgYmUgcmFuZ2VTdGFydCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlU3RhcnQgaXMgbm90IHRoZVxuICAvLyAgICBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICBjb25zdCByYW5nZVN0YXJ0VmFsdWUgPSByYW5nZVN0YXJ0Lmxlbmd0aCA/IE51bWJlcihyYW5nZVN0YXJ0KSA6IG51bGxcblxuICAvLyAxMC4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSxcbiAgLy8gICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gMTEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwMkQgKC0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgyRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDEyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyAxMy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYlxuICAvLyAgICAgb3Igc3BhY2UsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogaXRzIHRoZSBzYW1lIHN0ZXAgYXMgaW4gIzggYWdhaW4gbG9sXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDE0LiBMZXQgcmFuZ2VFbmQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmVcbiAgLy8gICAgIEFTQ0lJIGRpZ2l0cywgZnJvbSBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiB5b3Ugd291bGRuJ3QgZ3Vlc3MgaXQsIGJ1dCB0aGlzIGlzIGFsc28gdGhlIHNhbWUgc3RlcCBhcyAjOFxuICBjb25zdCByYW5nZUVuZCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDE1LiBMZXQgcmFuZ2VFbmRWYWx1ZSBiZSByYW5nZUVuZCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlRW5kXG4gIC8vICAgICBpcyBub3QgdGhlIGVtcHR5IHN0cmluZzsgb3RoZXJ3aXNlIG51bGwuXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IFRIRSBTQU1FIFNURVAsIEFHQUlOISEhXG4gIC8vIE5vdGU6IHdoeSBpbnRlcnByZXQgYXMgYSBkZWNpbWFsIGlmIHdlIG9ubHkgY29sbGVjdCBhc2NpaSBkaWdpdHM/XG4gIGNvbnN0IHJhbmdlRW5kVmFsdWUgPSByYW5nZUVuZC5sZW5ndGggPyBOdW1iZXIocmFuZ2VFbmQpIDogbnVsbFxuXG4gIC8vIDE2LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGRhdGEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTcuIElmIHJhbmdlRW5kVmFsdWUgYW5kIHJhbmdlU3RhcnRWYWx1ZSBhcmUgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHJhbmdlRW5kVmFsdWUgPT09IG51bGwgJiYgcmFuZ2VTdGFydFZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTguIElmIHJhbmdlU3RhcnRWYWx1ZSBhbmQgcmFuZ2VFbmRWYWx1ZSBhcmUgbnVtYmVycywgYW5kIHJhbmdlU3RhcnRWYWx1ZSBpc1xuICAvLyAgICAgZ3JlYXRlciB0aGFuIHJhbmdlRW5kVmFsdWUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIE5vdGU6IC4uLiB3aGVuIGNhbiB0aGV5IG5vdCBiZSBudW1iZXJzP1xuICBpZiAocmFuZ2VTdGFydFZhbHVlID4gcmFuZ2VFbmRWYWx1ZSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE5LiBSZXR1cm4gKHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSkuXG4gIHJldHVybiB7IHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYnVpbGQtYS1jb250ZW50LXJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZnVsbExlbmd0aFxuICovXG5mdW5jdGlvbiBidWlsZENvbnRlbnRSYW5nZSAocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIGZ1bGxMZW5ndGgpIHtcbiAgLy8gMS4gTGV0IGNvbnRlbnRSYW5nZSBiZSBgYnl0ZXMgYC5cbiAgbGV0IGNvbnRlbnRSYW5nZSA9ICdieXRlcyAnXG5cbiAgLy8gMi4gQXBwZW5kIHJhbmdlU3RhcnQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCwgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtyYW5nZVN0YXJ0fWApXG5cbiAgLy8gMy4gQXBwZW5kIDB4MkQgKC0pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICctJ1xuXG4gIC8vIDQuIEFwcGVuZCByYW5nZUVuZCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VFbmR9YClcblxuICAvLyA1LiBBcHBlbmQgMHgyRiAoLykgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gJy8nXG5cbiAgLy8gNi4gQXBwZW5kIGZ1bGxMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke2Z1bGxMZW5ndGh9YClcblxuICAvLyA3LiBSZXR1cm4gY29udGVudFJhbmdlLlxuICByZXR1cm4gY29udGVudFJhbmdlXG59XG5cbi8vIEEgU3RyZWFtLCB3aGljaCBwaXBlcyB0aGUgcmVzcG9uc2UgdG8gemxpYi5jcmVhdGVJbmZsYXRlKCkgb3Jcbi8vIHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpIGRlcGVuZGluZyBvbiB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgQnVmZmVyLlxuLy8gSWYgdGhlIGxvd2VyIGJ5dGUgb2YgdGhlIGZpcnN0IGJ5dGUgaXMgMHgwOCwgdGhlbiB0aGUgc3RyZWFtIGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhIHpsaWIgc3RyZWFtLCBvdGhlcndpc2UgaXQncyBpbnRlcnByZXRlZCBhcyBhXG4vLyByYXcgZGVmbGF0ZSBzdHJlYW0uXG5jbGFzcyBJbmZsYXRlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgX3RyYW5zZm9ybSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5faW5mbGF0ZVN0cmVhbSkge1xuICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbSA9IChjaHVua1swXSAmIDB4MEYpID09PSAweDA4XG4gICAgICAgID8gemxpYi5jcmVhdGVJbmZsYXRlKClcbiAgICAgICAgOiB6bGliLmNyZWF0ZUluZmxhdGVSYXcoKVxuXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdkYXRhJywgdGhpcy5wdXNoLmJpbmQodGhpcykpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB0aGlzLnB1c2gobnVsbCkpXG4gICAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHRoaXMuZGVzdHJveShlcnIpKVxuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVTdHJlYW0ud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgfVxuXG4gIF9maW5hbCAoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZVN0cmVhbSkge1xuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5lbmQoKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbSA9IG51bGxcbiAgICB9XG4gICAgY2FsbGJhY2soKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZmxhdGUgKCkge1xuICByZXR1cm4gbmV3IEluZmxhdGVTdHJlYW0oKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWV4dHJhY3QtbWltZS10eXBlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1pbWVUeXBlIChoZWFkZXJzKSB7XG4gIC8vIDEuIExldCBjaGFyc2V0IGJlIG51bGwuXG4gIGxldCBjaGFyc2V0ID0gbnVsbFxuXG4gIC8vIDIuIExldCBlc3NlbmNlIGJlIG51bGwuXG4gIGxldCBlc3NlbmNlID0gbnVsbFxuXG4gIC8vIDMuIExldCBtaW1lVHlwZSBiZSBudWxsLlxuICBsZXQgbWltZVR5cGUgPSBudWxsXG5cbiAgLy8gNC4gTGV0IHZhbHVlcyBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nIGBDb250ZW50LVR5cGVgIGZyb20gaGVhZGVycy5cbiAgY29uc3QgdmFsdWVzID0gZ2V0RGVjb2RlU3BsaXQoJ2NvbnRlbnQtdHlwZScsIGhlYWRlcnMpXG5cbiAgLy8gNS4gSWYgdmFsdWVzIGlzIG51bGwsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA2LiBGb3IgZWFjaCB2YWx1ZSBvZiB2YWx1ZXM6XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gNi4xLiBMZXQgdGVtcG9yYXJ5TWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHZhbHVlLlxuICAgIGNvbnN0IHRlbXBvcmFyeU1pbWVUeXBlID0gcGFyc2VNSU1FVHlwZSh2YWx1ZSlcblxuICAgIC8vIDYuMi4gSWYgdGVtcG9yYXJ5TWltZVR5cGUgaXMgZmFpbHVyZSBvciBpdHMgZXNzZW5jZSBpcyBcIiovKlwiLCB0aGVuIGNvbnRpbnVlLlxuICAgIGlmICh0ZW1wb3JhcnlNaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnIHx8IHRlbXBvcmFyeU1pbWVUeXBlLmVzc2VuY2UgPT09ICcqLyonKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIDYuMy4gU2V0IG1pbWVUeXBlIHRvIHRlbXBvcmFyeU1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gdGVtcG9yYXJ5TWltZVR5cGVcblxuICAgIC8vIDYuNC4gSWYgbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgbm90IGVzc2VuY2UsIHRoZW46XG4gICAgaWYgKG1pbWVUeXBlLmVzc2VuY2UgIT09IGVzc2VuY2UpIHtcbiAgICAgIC8vIDYuNC4xLiBTZXQgY2hhcnNldCB0byBudWxsLlxuICAgICAgY2hhcnNldCA9IG51bGxcblxuICAgICAgLy8gNi40LjIuIElmIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSBleGlzdHMsIHRoZW4gc2V0IGNoYXJzZXQgdG9cbiAgICAgIC8vICAgICAgICBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0uXG4gICAgICBpZiAobWltZVR5cGUucGFyYW1ldGVycy5oYXMoJ2NoYXJzZXQnKSkge1xuICAgICAgICBjaGFyc2V0ID0gbWltZVR5cGUucGFyYW1ldGVycy5nZXQoJ2NoYXJzZXQnKVxuICAgICAgfVxuXG4gICAgICAvLyA2LjQuMy4gU2V0IGVzc2VuY2UgdG8gbWltZVR5cGXigJlzIGVzc2VuY2UuXG4gICAgICBlc3NlbmNlID0gbWltZVR5cGUuZXNzZW5jZVxuICAgIH0gZWxzZSBpZiAoIW1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKCdjaGFyc2V0JykgJiYgY2hhcnNldCAhPT0gbnVsbCkge1xuICAgICAgLy8gNi41LiBPdGhlcndpc2UsIGlmIG1pbWVUeXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXSBkb2VzIG5vdCBleGlzdCwgYW5kXG4gICAgICAvLyAgICAgIGNoYXJzZXQgaXMgbm9uLW51bGwsIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gdG8gY2hhcnNldC5cbiAgICAgIG1pbWVUeXBlLnBhcmFtZXRlcnMuc2V0KCdjaGFyc2V0JywgY2hhcnNldClcbiAgICB9XG4gIH1cblxuICAvLyA3LiBJZiBtaW1lVHlwZSBpcyBudWxsLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAobWltZVR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDguIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLXZhbHVlLWdldC1kZWNvZGUtYW5kLXNwbGl0XG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXR0aW5nRGVjb2RpbmdTcGxpdHRpbmcgKHZhbHVlKSB7XG4gIC8vIDEuIExldCBpbnB1dCBiZSB0aGUgcmVzdWx0IG9mIGlzb21vcnBoaWMgZGVjb2RpbmcgdmFsdWUuXG4gIGNvbnN0IGlucHV0ID0gdmFsdWVcblxuICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgaW5wdXQuXG4gIGNvbnN0IHBvc2l0aW9uID0geyBwb3NpdGlvbjogMCB9XG5cbiAgLy8gMy4gTGV0IHZhbHVlcyBiZSBhIGxpc3Qgb2Ygc3RyaW5ncywgaW5pdGlhbGx5IGVtcHR5LlxuICBjb25zdCB2YWx1ZXMgPSBbXVxuXG4gIC8vIDQuIExldCB0ZW1wb3JhcnlWYWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdGVtcG9yYXJ5VmFsdWUgPSAnJ1xuXG4gIC8vIDUuIFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgIC8vIDUuMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwMjIgKFwiKVxuICAgIC8vICAgICAgb3IgVSswMDJDICgsKSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbiwgdG8gdGVtcG9yYXJ5VmFsdWUuXG4gICAgdGVtcG9yYXJ5VmFsdWUgKz0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyICE9PSAnXCInICYmIGNoYXIgIT09ICcsJyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyA1LjIuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW46XG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAvLyA1LjIuMS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pID09PSAweDIyKSB7XG4gICAgICAgIC8vIDUuMi4xLjEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYW4gSFRUUCBxdW90ZWQgc3RyaW5nIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLCB0byB0ZW1wb3JhcnlWYWx1ZS5cbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgKz0gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyhcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG5cbiAgICAgICAgLy8gNS4yLjEuMi4gSWYgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiBjb250aW51ZS5cbiAgICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gNS4yLjIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyA1LjIuMi4xLiBBc3NlcnQ6IHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpcyBVKzAwMkMgKCwpLlxuICAgICAgICBhc3NlcnQoaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbi5wb3NpdGlvbikgPT09IDB4MkMpXG5cbiAgICAgICAgLy8gNS4yLjIuMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4zLiBSZW1vdmUgYWxsIEhUVFAgdGFiIG9yIHNwYWNlIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGVtcG9yYXJ5VmFsdWUuXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSByZW1vdmVDaGFycyh0ZW1wb3JhcnlWYWx1ZSwgdHJ1ZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgLy8gNS40LiBBcHBlbmQgdGVtcG9yYXJ5VmFsdWUgdG8gdmFsdWVzLlxuICAgIHZhbHVlcy5wdXNoKHRlbXBvcmFyeVZhbHVlKVxuXG4gICAgLy8gNS42LiBTZXQgdGVtcG9yYXJ5VmFsdWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICB0ZW1wb3JhcnlWYWx1ZSA9ICcnXG4gIH1cblxuICAvLyA2LiBSZXR1cm4gdmFsdWVzLlxuICByZXR1cm4gdmFsdWVzXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1nZXQtZGVjb2RlLXNwbGl0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBsb3dlcmNhc2UgaGVhZGVyIG5hbWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2hlYWRlcnMnKS5IZWFkZXJzTGlzdH0gbGlzdFxuICovXG5mdW5jdGlvbiBnZXREZWNvZGVTcGxpdCAobmFtZSwgbGlzdCkge1xuICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuICBjb25zdCB2YWx1ZSA9IGxpc3QuZ2V0KG5hbWUsIHRydWUpXG5cbiAgLy8gMi4gSWYgdmFsdWUgaXMgbnVsbCwgdGhlbiByZXR1cm4gbnVsbC5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIGdldHRpbmcsIGRlY29kaW5nLCBhbmQgc3BsaXR0aW5nIHZhbHVlLlxuICByZXR1cm4gZ2V0dGluZ0RlY29kaW5nU3BsaXR0aW5nKHZhbHVlKVxufVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jdXRmLTgtZGVjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHV0ZjhEZWNvZGVCeXRlcyAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyAxLiBMZXQgYnVmZmVyIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyB0aHJlZSBieXRlcyBmcm9tXG4gIC8vICAgIGlvUXVldWUsIGNvbnZlcnRlZCB0byBhIGJ5dGUgc2VxdWVuY2UuXG5cbiAgLy8gMi4gSWYgYnVmZmVyIGlzIDB4RUYgMHhCQiAweEJGLCB0aGVuIHJlYWQgdGhyZWVcbiAgLy8gICAgYnl0ZXMgZnJvbSBpb1F1ZXVlLiAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgaWYgKGJ1ZmZlclswXSA9PT0gMHhFRiAmJiBidWZmZXJbMV0gPT09IDB4QkIgJiYgYnVmZmVyWzJdID09PSAweEJGKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KDMpXG4gIH1cblxuICAvLyAzLiBQcm9jZXNzIGEgcXVldWUgd2l0aCBhbiBpbnN0YW5jZSBvZiBVVEYtOOKAmXNcbiAgLy8gICAgZGVjb2RlciwgaW9RdWV1ZSwgb3V0cHV0LCBhbmQgXCJyZXBsYWNlbWVudFwiLlxuICBjb25zdCBvdXRwdXQgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYnVmZmVyKVxuXG4gIC8vIDQuIFJldHVybiBvdXRwdXQuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuY2xhc3MgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdEJhc2Uge1xuICBnZXQgYmFzZVVybCAoKSB7XG4gICAgcmV0dXJuIGdldEdsb2JhbE9yaWdpbigpXG4gIH1cblxuICBnZXQgb3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVXJsPy5vcmlnaW5cbiAgfVxuXG4gIHBvbGljeUNvbnRhaW5lciA9IG1ha2VQb2xpY3lDb250YWluZXIoKVxufVxuXG5jbGFzcyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IHtcbiAgc2V0dGluZ3NPYmplY3QgPSBuZXcgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdEJhc2UoKVxufVxuXG5jb25zdCBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0ID0gbmV3IEVudmlyb25tZW50U2V0dGluZ3NPYmplY3QoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBYm9ydGVkLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNWYWxpZEVuY29kZWRVUkwsXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZSxcbiAgUmVhZGFibGVTdHJlYW1Gcm9tLFxuICB0cnlVcGdyYWRlUmVxdWVzdFRvQVBvdGVudGlhbGx5VHJ1c3R3b3J0aHlVUkwsXG4gIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvLFxuICBjb2Fyc2VuZWRTaGFyZWRDdXJyZW50VGltZSxcbiAgZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcixcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIGFwcGVuZEZldGNoTWV0YWRhdGEsXG4gIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIsXG4gIFRBT0NoZWNrLFxuICBjb3JzQ2hlY2ssXG4gIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCxcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgcmVxdWVzdEJhZFBvcnQsXG4gIHJlcXVlc3RDdXJyZW50VVJMLFxuICByZXNwb25zZVVSTCxcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgaXNCbG9iTGlrZSxcbiAgaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5LFxuICBpc1ZhbGlkUmVhc29uUGhyYXNlLFxuICBzYW1lT3JpZ2luLFxuICBub3JtYWxpemVNZXRob2QsXG4gIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyxcbiAgaXRlcmF0b3JNaXhpbixcbiAgY3JlYXRlSXRlcmF0b3IsXG4gIGlzVmFsaWRIZWFkZXJOYW1lLFxuICBpc1ZhbGlkSGVhZGVyVmFsdWUsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICBieXRlc01hdGNoLFxuICBpc1JlYWRhYmxlU3RyZWFtTGlrZSxcbiAgcmVhZGFibGVTdHJlYW1DbG9zZSxcbiAgaXNvbW9ycGhpY0VuY29kZSxcbiAgdXJsSXNMb2NhbCxcbiAgdXJsSGFzSHR0cHNTY2hlbWUsXG4gIHVybElzSHR0cEh0dHBzU2NoZW1lLFxuICByZWFkQWxsQnl0ZXMsXG4gIHNpbXBsZVJhbmdlSGVhZGVyVmFsdWUsXG4gIGJ1aWxkQ29udGVudFJhbmdlLFxuICBwYXJzZU1ldGFkYXRhLFxuICBjcmVhdGVJbmZsYXRlLFxuICBleHRyYWN0TWltZVR5cGUsXG4gIGdldERlY29kZVNwbGl0LFxuICB1dGY4RGVjb2RlQnl0ZXMsXG4gIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Rcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { toUSVString } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts) {\n  if (opts?.strict !== false) {\n    if (!(V instanceof I)) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  } else {\n    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case 'Symbol':\n      return `Symbol(${V.description})`\n    case 'Object':\n      return inspect(V)\n    case 'String':\n      return `\"${V}\"`\n    default:\n      return `${V}`\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, prefix, argument, opts) => {\n    if (opts?.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = Object.hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value ??= defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V, prefix, argument)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, name, opts) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['BufferSource']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUM5QyxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjs7QUFFakQsV0FBVyx3Q0FBd0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZSxJQUFJLGdCQUFnQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtCQUFrQjtBQUN6QixPQUFPLE9BQU8sSUFBSSx5QkFBeUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxrQkFBa0IsYUFBYTtBQUM5RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssVUFBVSxzQkFBc0I7QUFDdkQscUJBQXFCLHVCQUF1QixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEUsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsV0FBVyxRQUFRLEVBQUU7QUFDN0UsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxHQUFHLHlCQUF5QjtBQUMxRCxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUyxHQUFHLFFBQVE7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsSUFBSSxvQkFBb0I7QUFDdEQsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsSUFBSSx5QkFBeUIsMEJBQTBCLE9BQU87QUFDckcsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QyxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxjQUFjLHlDQUF5Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRCxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUyxHQUFHLElBQUk7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLDJDQUEyQyxpQ0FBaUM7QUFDM0csV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxpQkFBaUIscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVLElBQUkseUJBQXlCO0FBQzFEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSSx5QkFBeUI7QUFDdEQ7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDZCQUE2QjtBQUN6Rjs7QUFFQTtBQUNBLDBFQUEwRSw2QkFBNkI7QUFDdkc7O0FBRUE7QUFDQSx5REFBeUQsNkJBQTZCO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxJQUFJLHlCQUF5QjtBQUNwRDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHdlYmlkbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB0eXBlcywgaW5zcGVjdCB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy93ZWJpZGwnKS5XZWJpZGx9ICovXG5jb25zdCB3ZWJpZGwgPSB7fVxud2ViaWRsLmNvbnZlcnRlcnMgPSB7fVxud2ViaWRsLnV0aWwgPSB7fVxud2ViaWRsLmVycm9ycyA9IHt9XG5cbndlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKVxufVxuXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwbHVyYWwgPSBjb250ZXh0LnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke2NvbnRleHQuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke2NvbnRleHQudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbndlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dC52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dC50eXBlfS5gXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaW1wbGVtZW50c1xud2ViaWRsLmJyYW5kQ2hlY2sgPSBmdW5jdGlvbiAoViwgSSwgb3B0cykge1xuICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSkge1xuICAgIGlmICghKFYgaW5zdGFuY2VvZiBJKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChWPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSAhPT0gSS5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbndlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrID0gZnVuY3Rpb24gKHsgbGVuZ3RoIH0sIG1pbiwgY3R4KSB7XG4gIGlmIChsZW5ndGggPCBtaW4pIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBtZXNzYWdlOiBgJHttaW59IGFyZ3VtZW50JHttaW4gIT09IDEgPyAncycgOiAnJ30gcmVxdWlyZWQsIGAgK1xuICAgICAgICAgICAgICAgYGJ1dCR7bGVuZ3RoID8gJyBvbmx5JyA6ICcnfSAke2xlbmd0aH0gZm91bmQuYCxcbiAgICAgIGhlYWRlcjogY3R4XG4gICAgfSlcbiAgfVxufVxuXG53ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiAnVHlwZUVycm9yJyxcbiAgICBtZXNzYWdlOiAnSWxsZWdhbCBjb25zdHJ1Y3RvcidcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xud2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdCb29sZWFuJ1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnTnVtYmVyJ1xuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT2JqZWN0J1xuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWNvbnZlcnR0b2ludFxud2ViaWRsLnV0aWwuQ29udmVydFRvSW50ID0gZnVuY3Rpb24gKFYsIGJpdExlbmd0aCwgc2lnbmVkbmVzcywgb3B0cykge1xuICBsZXQgdXBwZXJCb3VuZFxuICBsZXQgbG93ZXJCb3VuZFxuXG4gIC8vIDEuIElmIGJpdExlbmd0aCBpcyA2NCwgdGhlbjpcbiAgaWYgKGJpdExlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyAxLiBMZXQgdXBwZXJCb3VuZCBiZSAyXjUzIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCA1MykgLSAxXG5cbiAgICAvLyAyLiBJZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbiBsZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgICBsb3dlckJvdW5kID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAzLiBPdGhlcndpc2UgbGV0IGxvd2VyQm91bmQgYmUg4oiSMl41MyArIDEuXG4gICAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIDUzKSArIDFcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2lnbmVkbmVzcyA9PT0gJ3Vuc2lnbmVkJykge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgc2lnbmVkbmVzcyBpcyBcInVuc2lnbmVkXCIsIHRoZW46XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAwLlxuICAgIGxvd2VyQm91bmQgPSAwXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDFcbiAgfSBlbHNlIHtcbiAgICAvLyAzLiBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBMZXQgbG93ZXJCb3VuZCBiZSAtMl5iaXRMZW5ndGgg4oiSIDEuXG4gICAgbG93ZXJCb3VuZCA9IE1hdGgucG93KC0yLCBiaXRMZW5ndGgpIC0gMVxuXG4gICAgLy8gMi4gTGV0IHVwcGVyQm91bmQgYmUgMl5iaXRMZW5ndGgg4oiSIDEg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpIC0gMVxuICB9XG5cbiAgLy8gNC4gTGV0IHggYmUgPyBUb051bWJlcihWKS5cbiAgbGV0IHggPSBOdW1iZXIoVilcblxuICAvLyA1LiBJZiB4IGlzIOKIkjAsIHRoZW4gc2V0IHggdG8gKzAuXG4gIGlmICh4ID09PSAwKSB7XG4gICAgeCA9IDBcbiAgfVxuXG4gIC8vIDYuIElmIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0VuZm9yY2VSYW5nZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAob3B0cz8uZW5mb3JjZVJhbmdlID09PSB0cnVlKSB7XG4gICAgLy8gMS4gSWYgeCBpcyBOYU4sICviiJ4sIG9yIOKIkuKIniwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBOdW1iZXIuaXNOYU4oeCkgfHxcbiAgICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogJ0ludGVnZXIgY29udmVyc2lvbicsXG4gICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgY29udmVydCAke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX0gdG8gYW4gaW50ZWdlci5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICAgIHggPSB3ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCh4KVxuXG4gICAgLy8gMy4gSWYgeCA8IGxvd2VyQm91bmQgb3IgeCA+IHVwcGVyQm91bmQsIHRoZW5cbiAgICAvLyAgICB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnSW50ZWdlciBjb252ZXJzaW9uJyxcbiAgICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgYmV0d2VlbiAke2xvd2VyQm91bmR9LSR7dXBwZXJCb3VuZH0sIGdvdCAke3h9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gNC4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDcuIElmIHggaXMgbm90IE5hTiBhbmQgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMXG4gIC8vICAgIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBbQ2xhbXBdIGV4dGVuZGVkXG4gIC8vICAgIGF0dHJpYnV0ZSwgdGhlbjpcbiAgaWYgKCFOdW1iZXIuaXNOYU4oeCkgJiYgb3B0cz8uY2xhbXAgPT09IHRydWUpIHtcbiAgICAvLyAxLiBTZXQgeCB0byBtaW4obWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKS5cbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpXG5cbiAgICAvLyAyLiBSb3VuZCB4IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGNob29zaW5nIHRoZVxuICAgIC8vICAgIGV2ZW4gaW50ZWdlciBpZiBpdCBsaWVzIGhhbGZ3YXkgYmV0d2VlbiB0d28sXG4gICAgLy8gICAgYW5kIGNob29zaW5nICswIHJhdGhlciB0aGFuIOKIkjAuXG4gICAgaWYgKE1hdGguZmxvb3IoeCkgJSAyID09PSAwKSB7XG4gICAgICB4ID0gTWF0aC5mbG9vcih4KVxuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5jZWlsKHgpXG4gICAgfVxuXG4gICAgLy8gMy4gUmV0dXJuIHguXG4gICAgcmV0dXJuIHhcbiAgfVxuXG4gIC8vIDguIElmIHggaXMgTmFOLCArMCwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHJldHVybiArMC5cbiAgaWYgKFxuICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICh4ID09PSAwICYmIE9iamVjdC5pcygwLCB4KSkgfHxcbiAgICB4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcbiAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIDkuIFNldCB4IHRvIEludGVnZXJQYXJ0KHgpLlxuICB4ID0gd2ViaWRsLnV0aWwuSW50ZWdlclBhcnQoeClcblxuICAvLyAxMC4gU2V0IHggdG8geCBtb2R1bG8gMl5iaXRMZW5ndGguXG4gIHggPSB4ICUgTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuXG4gIC8vIDExLiBJZiBzaWduZWRuZXNzIGlzIFwic2lnbmVkXCIgYW5kIHgg4omlIDJeYml0TGVuZ3RoIOKIkiAxLFxuICAvLyAgICB0aGVuIHJldHVybiB4IOKIkiAyXmJpdExlbmd0aC5cbiAgaWYgKHNpZ25lZG5lc3MgPT09ICdzaWduZWQnICYmIHggPj0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKSAtIDEpIHtcbiAgICByZXR1cm4geCAtIE1hdGgucG93KDIsIGJpdExlbmd0aClcbiAgfVxuXG4gIC8vIDEyLiBPdGhlcndpc2UsIHJldHVybiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Fic3RyYWN0LW9wZGVmLWludGVnZXJwYXJ0XG53ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIDEuIExldCByIGJlIGZsb29yKGFicyhuKSkuXG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKVxuXG4gIC8vIDIuIElmIG4gPCAwLCB0aGVuIHJldHVybiAtMSDDlyByLlxuICBpZiAobiA8IDApIHtcbiAgICByZXR1cm4gLTEgKiByXG4gIH1cblxuICAvLyAzLiBPdGhlcndpc2UsIHJldHVybiByLlxuICByZXR1cm4gclxufVxuXG53ZWJpZGwudXRpbC5TdHJpbmdpZnkgPSBmdW5jdGlvbiAoVikge1xuICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShWKVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgICByZXR1cm4gYFN5bWJvbCgke1YuZGVzY3JpcHRpb259KWBcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIGluc3BlY3QoVilcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIGBcIiR7Vn1cImBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGAke1Z9YFxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtc2VxdWVuY2VcbndlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBJdGVyYWJsZSkgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gKCR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfSkgaXMgbm90IGl0ZXJhYmxlLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IG1ldGhvZCBiZSA/IEdldE1ldGhvZChWLCBAQGl0ZXJhdG9yKS5cbiAgICAvKiogQHR5cGUge0dlbmVyYXRvcn0gKi9cbiAgICBjb25zdCBtZXRob2QgPSB0eXBlb2YgSXRlcmFibGUgPT09ICdmdW5jdGlvbicgPyBJdGVyYWJsZSgpIDogVj8uW1N5bWJvbC5pdGVyYXRvcl0/LigpXG4gICAgY29uc3Qgc2VxID0gW11cbiAgICBsZXQgaW5kZXggPSAwXG5cbiAgICAvLyAzLiBJZiBtZXRob2QgaXMgdW5kZWZpbmVkLCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoXG4gICAgICBtZXRob2QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdHlwZW9mIG1ldGhvZC5uZXh0ICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gaXMgbm90IGl0ZXJhYmxlLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNjcmVhdGUtc2VxdWVuY2UtZnJvbS1pdGVyYWJsZVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBtZXRob2QubmV4dCgpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNlcS5wdXNoKGNvbnZlcnRlcih2YWx1ZSwgcHJlZml4LCBgJHthcmd1bWVudH1bJHtpbmRleCsrfV1gKSlcbiAgICB9XG5cbiAgICByZXR1cm4gc2VxXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy10by1yZWNvcmRcbndlYmlkbC5yZWNvcmRDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoa2V5Q29udmVydGVyLCB2YWx1ZUNvbnZlcnRlcikge1xuICByZXR1cm4gKE8sIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICAvLyAxLiBJZiBUeXBlKE8pIGlzIG5vdCBPYmplY3QsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh3ZWJpZGwudXRpbC5UeXBlKE8pICE9PSAnT2JqZWN0Jykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IChcIiR7d2ViaWRsLnV0aWwuVHlwZShPKX1cIikgaXMgbm90IGFuIE9iamVjdC5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIExldCByZXN1bHQgYmUgYSBuZXcgZW1wdHkgaW5zdGFuY2Ugb2YgcmVjb3JkPEssIFY+LlxuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgICBpZiAoIXR5cGVzLmlzUHJveHkoTykpIHtcbiAgICAgIC8vIDEuIExldCBkZXNjIGJlID8gTy5bW0dldE93blByb3BlcnR5XV0oa2V5KS5cbiAgICAgIGNvbnN0IGtleXMgPSBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTyksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTyldXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGVkS2V5IGJlIGtleSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgSy5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXlDb252ZXJ0ZXIoa2V5LCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSA/IEdldChPLCBrZXkpLlxuICAgICAgICAvLyAzLiBMZXQgdHlwZWRWYWx1ZSBiZSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gSURMIHZhbHVlIG9mIHR5cGUgVi5cbiAgICAgICAgY29uc3QgdHlwZWRWYWx1ZSA9IHZhbHVlQ29udmVydGVyKE9ba2V5XSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyA0LiBTZXQgcmVzdWx0W3R5cGVkS2V5XSB0byB0eXBlZFZhbHVlLlxuICAgICAgICByZXN1bHRbdHlwZWRLZXldID0gdHlwZWRWYWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIDMuIExldCBrZXlzIGJlID8gTy5bW093blByb3BlcnR5S2V5c11dKCkuXG4gICAgY29uc3Qga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhPKVxuXG4gICAgLy8gNC4gRm9yIGVhY2gga2V5IG9mIGtleXMuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgLy8gMS4gTGV0IGRlc2MgYmUgPyBPLltbR2V0T3duUHJvcGVydHldXShrZXkpLlxuICAgICAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSlcblxuICAgICAgLy8gMi4gSWYgZGVzYyBpcyBub3QgdW5kZWZpbmVkIGFuZCBkZXNjLltbRW51bWVyYWJsZV1dIGlzIHRydWU6XG4gICAgICBpZiAoZGVzYz8uZW51bWVyYWJsZSkge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZWRLZXkgYmUga2V5IGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBLLlxuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleUNvbnZlcnRlcihrZXksIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlID8gR2V0KE8sIGtleSkuXG4gICAgICAgIC8vIDMuIExldCB0eXBlZFZhbHVlIGJlIHZhbHVlIGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBWLlxuICAgICAgICBjb25zdCB0eXBlZFZhbHVlID0gdmFsdWVDb252ZXJ0ZXIoT1trZXldLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxud2ViaWRsLmludGVyZmFjZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykgPT4ge1xuICAgIGlmIChvcHRzPy5zdHJpY3QgIT09IGZhbHNlICYmICEoViBpbnN0YW5jZW9mIGkpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpIHRvIGJlIGFuIGluc3RhbmNlIG9mICR7aS5uYW1lfS5gXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBWXG4gIH1cbn1cblxud2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVycykge1xuICByZXR1cm4gKGRpY3Rpb25hcnksIHByZWZpeCwgYXJndW1lbnQpID0+IHtcbiAgICBjb25zdCB0eXBlID0gd2ViaWRsLnV0aWwuVHlwZShkaWN0aW9uYXJ5KVxuICAgIGNvbnN0IGRpY3QgPSB7fVxuXG4gICAgaWYgKHR5cGUgPT09ICdOdWxsJyB8fCB0eXBlID09PSAnVW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRpY3RcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJHtkaWN0aW9uYXJ5fSB0byBiZSBvbmUgb2Y6IE51bGwsIFVuZGVmaW5lZCwgT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvcHRpb25zIG9mIGNvbnZlcnRlcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCBkZWZhdWx0VmFsdWUsIHJlcXVpcmVkLCBjb252ZXJ0ZXIgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKHJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTWlzc2luZyByZXF1aXJlZCBrZXkgXCIke2tleX1cIi5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSBkaWN0aW9uYXJ5W2tleV1cbiAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBPYmplY3QuaGFzT3duKG9wdGlvbnMsICdkZWZhdWx0VmFsdWUnKVxuXG4gICAgICAvLyBPbmx5IHVzZSBkZWZhdWx0VmFsdWUgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZFxuICAgICAgLy8gYSBkZWZhdWx0VmFsdWUgb3B0aW9ucyB3YXMgcHJvdmlkZWQuXG4gICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA/Pz0gZGVmYXVsdFZhbHVlKClcbiAgICAgIH1cblxuICAgICAgLy8gQSBrZXkgY2FuIGJlIG9wdGlvbmFsIGFuZCBoYXZlIG5vIGRlZmF1bHQgdmFsdWUuXG4gICAgICAvLyBXaGVuIHRoaXMgaGFwcGVucywgZG8gbm90IHBlcmZvcm0gYSBjb252ZXJzaW9uLFxuICAgICAgLy8gYW5kIGRvIG5vdCBhc3NpZ24gdGhlIGtleSBhIHZhbHVlLlxuICAgICAgaWYgKHJlcXVpcmVkIHx8IGhhc0RlZmF1bHQgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IGNvbnZlcnRlcih2YWx1ZSwgcHJlZml4LCBgJHthcmd1bWVudH0uJHtrZXl9YClcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0aW9ucy5hbGxvd2VkVmFsdWVzICYmXG4gICAgICAgICAgIW9wdGlvbnMuYWxsb3dlZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHt2YWx1ZX0gaXMgbm90IGFuIGFjY2VwdGVkIHR5cGUuIEV4cGVjdGVkIG9uZSBvZiAke29wdGlvbnMuYWxsb3dlZFZhbHVlcy5qb2luKCcsICcpfS5gXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRpY3Rba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpY3RcbiAgfVxufVxuXG53ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoY29udmVydGVyKSB7XG4gIHJldHVybiAoViwgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIGlmIChWID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gVlxuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZXIoViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLURPTVN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gSWYgViBpcyBudWxsIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJREwgdHlwZVxuICAvLyAgICBhc3NvY2lhdGVkIHdpdGggdGhlIFtMZWdhY3lOdWxsVG9FbXB0eVN0cmluZ11cbiAgLy8gICAgZXh0ZW5kZWQgYXR0cmlidXRlLCB0aGVuIHJldHVybiB0aGUgRE9NU3RyaW5nIHZhbHVlXG4gIC8vICAgIHRoYXQgcmVwcmVzZW50cyB0aGUgZW1wdHkgc3RyaW5nLlxuICBpZiAoViA9PT0gbnVsbCAmJiBvcHRzPy5sZWdhY3lOdWxsVG9FbXB0eVN0cmluZykge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMi4gTGV0IHggYmUgPyBUb1N0cmluZyhWKS5cbiAgaWYgKHR5cGVvZiBWID09PSAnc3ltYm9sJykge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgbWVzc2FnZTogYCR7YXJndW1lbnR9IGlzIGEgc3ltYm9sLCB3aGljaCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgRE9NU3RyaW5nLmBcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIHRoZSBJREwgRE9NU3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgLy8gICAgc2FtZSBzZXF1ZW5jZSBvZiBjb2RlIHVuaXRzIGFzIHRoZSBvbmUgdGhlXG4gIC8vICAgIEVDTUFTY3JpcHQgU3RyaW5nIHZhbHVlIHggcmVwcmVzZW50cy5cbiAgcmV0dXJuIFN0cmluZyhWKVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLUJ5dGVTdHJpbmdcbndlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICAvLyBOb3RlOiBET01TdHJpbmcgY29udmVydGVyIHBlcmZvcm0gPyBUb1N0cmluZyhWKVxuICBjb25zdCB4ID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gSWYgdGhlIHZhbHVlIG9mIGFueSBlbGVtZW50IG9mIHggaXMgZ3JlYXRlciB0aGFuXG4gIC8vICAgIDI1NSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKHguY2hhckNvZGVBdChpbmRleCkgPiAyNTUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgY29udmVydCBhcmd1bWVudCB0byBhIEJ5dGVTdHJpbmcgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGF0ICcgK1xuICAgICAgICBgaW5kZXggJHtpbmRleH0gaGFzIGEgdmFsdWUgb2YgJHt4LmNoYXJDb2RlQXQoaW5kZXgpfSB3aGljaCBpcyBncmVhdGVyIHRoYW4gMjU1LmBcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYW4gSURMIEJ5dGVTdHJpbmcgdmFsdWUgd2hvc2UgbGVuZ3RoIGlzIHRoZVxuICAvLyAgICBsZW5ndGggb2YgeCwgYW5kIHdoZXJlIHRoZSB2YWx1ZSBvZiBlYWNoIGVsZW1lbnQgaXNcbiAgLy8gICAgdGhlIHZhbHVlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1VU1ZTdHJpbmdcbi8vIFRPRE86IHJld3JpdGUgdGhpcyBzbyB3ZSBjYW4gY29udHJvbCB0aGUgZXJyb3JzIHRocm93blxud2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nID0gdG9VU1ZTdHJpbmdcblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1ib29sZWFuXG53ZWJpZGwuY29udmVydGVycy5ib29sZWFuID0gZnVuY3Rpb24gKFYpIHtcbiAgLy8gMS4gTGV0IHggYmUgdGhlIHJlc3VsdCBvZiBjb21wdXRpbmcgVG9Cb29sZWFuKFYpLlxuICBjb25zdCB4ID0gQm9vbGVhbihWKVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGJvb2xlYW4gdmFsdWUgdGhhdCBpcyB0aGUgb25lIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSB0cnV0aCB2YWx1ZSBhcyB0aGUgRUNNQVNjcmlwdCBCb29sZWFuIHZhbHVlIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtYW55XG53ZWJpZGwuY29udmVydGVycy5hbnkgPSBmdW5jdGlvbiAoVikge1xuICByZXR1cm4gVlxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ2xvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwic2lnbmVkXCIpLlxuICBjb25zdCB4ID0gd2ViaWRsLnV0aWwuQ29udmVydFRvSW50KFYsIDY0LCAnc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIGxvbmcgbG9uZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmctbG9uZ1xud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgNjQsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICd1bnNpZ25lZCcsIHVuZGVmaW5lZCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMzIsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMzIsICd1bnNpZ25lZCcsIHVuZGVmaW5lZCwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBsb25nIHZhbHVlIHRoYXRcbiAgLy8gICAgcmVwcmVzZW50cyB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtc2hvcnRcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gTGV0IHggYmUgPyBDb252ZXJ0VG9JbnQoViwgMTYsIFwidW5zaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgMTYsICd1bnNpZ25lZCcsIG9wdHMsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgdW5zaWduZWQgc2hvcnQgdmFsdWUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNpZGwtQXJyYXlCdWZmZXJcbndlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQsIG9wdHMpIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYW5cbiAgLy8gICAgW1tBcnJheUJ1ZmZlckRhdGFdXSBpbnRlcm5hbCBzbG90LCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICAvLyBzZWU6IGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvcGVydGllcy1vZi10aGUtYXJyYXlidWZmZXItaW5zdGFuY2VzXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1zaGFyZWRhcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgaWYgKFxuICAgIHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8XG4gICAgIXR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVilcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeCxcbiAgICAgIGFyZ3VtZW50OiBgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICAgIHR5cGVzOiBbJ0FycmF5QnVmZmVyJ11cbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIGlmIChvcHRzPy5hbGxvd1NoYXJlZCA9PT0gZmFsc2UgJiYgdHlwZXMuaXNTaGFyZWRBcnJheUJ1ZmZlcihWKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWKSBpcyB0cnVlLCB0aGVuIHRocm93IGFcbiAgLy8gICAgVHlwZUVycm9yLlxuICBpZiAoVi5yZXNpemFibGUgfHwgVi5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIEFycmF5QnVmZmVyIHZhbHVlIHRoYXQgaXMgYVxuICAvLyAgICByZWZlcmVuY2UgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoViwgVCwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIC8vIDEuIExldCBUIGJlIHRoZSBJREwgdHlwZSBWIGlzIGJlaW5nIGNvbnZlcnRlZCB0by5cblxuICAvLyAyLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbVHlwZWRBcnJheU5hbWVdXSBpbnRlcm5hbCBzbG90IHdpdGggYSB2YWx1ZVxuICAvLyAgICBlcXVhbCB0byBU4oCZcyBuYW1lLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNUeXBlZEFycmF5KFYpIHx8XG4gICAgVi5jb25zdHJ1Y3Rvci5uYW1lICE9PSBULm5hbWVcbiAgKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5jb252ZXJzaW9uRmFpbGVkKHtcbiAgICAgIHByZWZpeCxcbiAgICAgIGFyZ3VtZW50OiBgJHtuYW1lfSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFtULm5hbWVdXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHM/LmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFYuYnVmZmVyLnJlc2l6YWJsZSB8fCBWLmJ1ZmZlci5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDUuIFJldHVybiB0aGUgSURMIHZhbHVlIG9mIHR5cGUgVCB0aGF0IGlzIGEgcmVmZXJlbmNlXG4gIC8vICAgIHRvIHRoZSBzYW1lIG9iamVjdCBhcyBWLlxuICByZXR1cm4gVlxufVxuXG53ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUsIG9wdHMpIHtcbiAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCBvciBWIGRvZXMgbm90IGhhdmUgYVxuICAvLyAgICBbW0RhdGFWaWV3XV0gaW50ZXJuYWwgc2xvdCwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgIT09ICdPYmplY3QnIHx8ICF0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHtuYW1lfSBpcyBub3QgYSBEYXRhVmlldy5gXG4gICAgfSlcbiAgfVxuXG4gIC8vIDIuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1NoYXJlZF0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNTaGFyZWRBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKG9wdHM/LmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYuYnVmZmVyKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYWxsb3dlZC4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBjb252ZXJzaW9uIGlzIG5vdCB0byBhbiBJREwgdHlwZSBhc3NvY2lhdGVkXG4gIC8vICAgIHdpdGggdGhlIFtBbGxvd1Jlc2l6YWJsZV0gZXh0ZW5kZWQgYXR0cmlidXRlLCBhbmRcbiAgLy8gICAgSXNSZXNpemFibGVBcnJheUJ1ZmZlcihWLltbVmlld2VkQXJyYXlCdWZmZXJdXSkgaXNcbiAgLy8gICAgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKFYuYnVmZmVyLnJlc2l6YWJsZSB8fCBWLmJ1ZmZlci5ncm93YWJsZSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgIGhlYWRlcjogJ0FycmF5QnVmZmVyJyxcbiAgICAgIG1lc3NhZ2U6ICdSZWNlaXZlZCBhIHJlc2l6YWJsZSBBcnJheUJ1ZmZlci4nXG4gICAgfSlcbiAgfVxuXG4gIC8vIDQuIFJldHVybiB0aGUgSURMIERhdGFWaWV3IHZhbHVlIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jQnVmZmVyU291cmNlXG53ZWJpZGwuY29udmVydGVycy5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBuYW1lLCBvcHRzKSB7XG4gIGlmICh0eXBlcy5pc0FueUFycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkFycmF5QnVmZmVyKFYsIHByZWZpeCwgbmFtZSwgeyAuLi5vcHRzLCBhbGxvd1NoYXJlZDogZmFsc2UgfSlcbiAgfVxuXG4gIGlmICh0eXBlcy5pc1R5cGVkQXJyYXkoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheShWLCBWLmNvbnN0cnVjdG9yLCBwcmVmaXgsIG5hbWUsIHsgLi4ub3B0cywgYWxsb3dTaGFyZWQ6IGZhbHNlIH0pXG4gIH1cblxuICBpZiAodHlwZXMuaXNEYXRhVmlldyhWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5EYXRhVmlldyhWLCBwcmVmaXgsIG5hbWUsIHsgLi4ub3B0cywgYWxsb3dTaGFyZWQ6IGZhbHNlIH0pXG4gIH1cblxuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgIHByZWZpeCxcbiAgICBhcmd1bWVudDogYCR7bmFtZX0gKFwiJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9XCIpYCxcbiAgICB0eXBlczogWydCdWZmZXJTb3VyY2UnXVxuICB9KVxufVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8Qnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydyZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz4nXSA9IHdlYmlkbC5yZWNvcmRDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcsXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmdcbilcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdlYmlkbFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */\nfunction getEncoding (label) {\n  if (!label) {\n    return 'failure'\n  }\n\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  // 2. If label is an ASCII case-insensitive match for any of the\n  //    labels listed in the table below, then return the\n  //    corresponding encoding; otherwise return failure.\n  switch (label.trim().toLowerCase()) {\n    case 'unicode-1-1-utf-8':\n    case 'unicode11utf8':\n    case 'unicode20utf8':\n    case 'utf-8':\n    case 'utf8':\n    case 'x-unicode20utf8':\n      return 'UTF-8'\n    case '866':\n    case 'cp866':\n    case 'csibm866':\n    case 'ibm866':\n      return 'IBM866'\n    case 'csisolatin2':\n    case 'iso-8859-2':\n    case 'iso-ir-101':\n    case 'iso8859-2':\n    case 'iso88592':\n    case 'iso_8859-2':\n    case 'iso_8859-2:1987':\n    case 'l2':\n    case 'latin2':\n      return 'ISO-8859-2'\n    case 'csisolatin3':\n    case 'iso-8859-3':\n    case 'iso-ir-109':\n    case 'iso8859-3':\n    case 'iso88593':\n    case 'iso_8859-3':\n    case 'iso_8859-3:1988':\n    case 'l3':\n    case 'latin3':\n      return 'ISO-8859-3'\n    case 'csisolatin4':\n    case 'iso-8859-4':\n    case 'iso-ir-110':\n    case 'iso8859-4':\n    case 'iso88594':\n    case 'iso_8859-4':\n    case 'iso_8859-4:1988':\n    case 'l4':\n    case 'latin4':\n      return 'ISO-8859-4'\n    case 'csisolatincyrillic':\n    case 'cyrillic':\n    case 'iso-8859-5':\n    case 'iso-ir-144':\n    case 'iso8859-5':\n    case 'iso88595':\n    case 'iso_8859-5':\n    case 'iso_8859-5:1988':\n      return 'ISO-8859-5'\n    case 'arabic':\n    case 'asmo-708':\n    case 'csiso88596e':\n    case 'csiso88596i':\n    case 'csisolatinarabic':\n    case 'ecma-114':\n    case 'iso-8859-6':\n    case 'iso-8859-6-e':\n    case 'iso-8859-6-i':\n    case 'iso-ir-127':\n    case 'iso8859-6':\n    case 'iso88596':\n    case 'iso_8859-6':\n    case 'iso_8859-6:1987':\n      return 'ISO-8859-6'\n    case 'csisolatingreek':\n    case 'ecma-118':\n    case 'elot_928':\n    case 'greek':\n    case 'greek8':\n    case 'iso-8859-7':\n    case 'iso-ir-126':\n    case 'iso8859-7':\n    case 'iso88597':\n    case 'iso_8859-7':\n    case 'iso_8859-7:1987':\n    case 'sun_eu_greek':\n      return 'ISO-8859-7'\n    case 'csiso88598e':\n    case 'csisolatinhebrew':\n    case 'hebrew':\n    case 'iso-8859-8':\n    case 'iso-8859-8-e':\n    case 'iso-ir-138':\n    case 'iso8859-8':\n    case 'iso88598':\n    case 'iso_8859-8':\n    case 'iso_8859-8:1988':\n    case 'visual':\n      return 'ISO-8859-8'\n    case 'csiso88598i':\n    case 'iso-8859-8-i':\n    case 'logical':\n      return 'ISO-8859-8-I'\n    case 'csisolatin6':\n    case 'iso-8859-10':\n    case 'iso-ir-157':\n    case 'iso8859-10':\n    case 'iso885910':\n    case 'l6':\n    case 'latin6':\n      return 'ISO-8859-10'\n    case 'iso-8859-13':\n    case 'iso8859-13':\n    case 'iso885913':\n      return 'ISO-8859-13'\n    case 'iso-8859-14':\n    case 'iso8859-14':\n    case 'iso885914':\n      return 'ISO-8859-14'\n    case 'csisolatin9':\n    case 'iso-8859-15':\n    case 'iso8859-15':\n    case 'iso885915':\n    case 'iso_8859-15':\n    case 'l9':\n      return 'ISO-8859-15'\n    case 'iso-8859-16':\n      return 'ISO-8859-16'\n    case 'cskoi8r':\n    case 'koi':\n    case 'koi8':\n    case 'koi8-r':\n    case 'koi8_r':\n      return 'KOI8-R'\n    case 'koi8-ru':\n    case 'koi8-u':\n      return 'KOI8-U'\n    case 'csmacintosh':\n    case 'mac':\n    case 'macintosh':\n    case 'x-mac-roman':\n      return 'macintosh'\n    case 'iso-8859-11':\n    case 'iso8859-11':\n    case 'iso885911':\n    case 'tis-620':\n    case 'windows-874':\n      return 'windows-874'\n    case 'cp1250':\n    case 'windows-1250':\n    case 'x-cp1250':\n      return 'windows-1250'\n    case 'cp1251':\n    case 'windows-1251':\n    case 'x-cp1251':\n      return 'windows-1251'\n    case 'ansi_x3.4-1968':\n    case 'ascii':\n    case 'cp1252':\n    case 'cp819':\n    case 'csisolatin1':\n    case 'ibm819':\n    case 'iso-8859-1':\n    case 'iso-ir-100':\n    case 'iso8859-1':\n    case 'iso88591':\n    case 'iso_8859-1':\n    case 'iso_8859-1:1987':\n    case 'l1':\n    case 'latin1':\n    case 'us-ascii':\n    case 'windows-1252':\n    case 'x-cp1252':\n      return 'windows-1252'\n    case 'cp1253':\n    case 'windows-1253':\n    case 'x-cp1253':\n      return 'windows-1253'\n    case 'cp1254':\n    case 'csisolatin5':\n    case 'iso-8859-9':\n    case 'iso-ir-148':\n    case 'iso8859-9':\n    case 'iso88599':\n    case 'iso_8859-9':\n    case 'iso_8859-9:1989':\n    case 'l5':\n    case 'latin5':\n    case 'windows-1254':\n    case 'x-cp1254':\n      return 'windows-1254'\n    case 'cp1255':\n    case 'windows-1255':\n    case 'x-cp1255':\n      return 'windows-1255'\n    case 'cp1256':\n    case 'windows-1256':\n    case 'x-cp1256':\n      return 'windows-1256'\n    case 'cp1257':\n    case 'windows-1257':\n    case 'x-cp1257':\n      return 'windows-1257'\n    case 'cp1258':\n    case 'windows-1258':\n    case 'x-cp1258':\n      return 'windows-1258'\n    case 'x-mac-cyrillic':\n    case 'x-mac-ukrainian':\n      return 'x-mac-cyrillic'\n    case 'chinese':\n    case 'csgb2312':\n    case 'csiso58gb231280':\n    case 'gb2312':\n    case 'gb_2312':\n    case 'gb_2312-80':\n    case 'gbk':\n    case 'iso-ir-58':\n    case 'x-gbk':\n      return 'GBK'\n    case 'gb18030':\n      return 'gb18030'\n    case 'big5':\n    case 'big5-hkscs':\n    case 'cn-big5':\n    case 'csbig5':\n    case 'x-x-big5':\n      return 'Big5'\n    case 'cseucpkdfmtjapanese':\n    case 'euc-jp':\n    case 'x-euc-jp':\n      return 'EUC-JP'\n    case 'csiso2022jp':\n    case 'iso-2022-jp':\n      return 'ISO-2022-JP'\n    case 'csshiftjis':\n    case 'ms932':\n    case 'ms_kanji':\n    case 'shift-jis':\n    case 'shift_jis':\n    case 'sjis':\n    case 'windows-31j':\n    case 'x-sjis':\n      return 'Shift_JIS'\n    case 'cseuckr':\n    case 'csksc56011987':\n    case 'euc-kr':\n    case 'iso-ir-149':\n    case 'korean':\n    case 'ks_c_5601-1987':\n    case 'ks_c_5601-1989':\n    case 'ksc5601':\n    case 'ksc_5601':\n    case 'windows-949':\n      return 'EUC-KR'\n    case 'csiso2022kr':\n    case 'hz-gb-2312':\n    case 'iso-2022-cn':\n    case 'iso-2022-cn-ext':\n    case 'iso-2022-kr':\n    case 'replacement':\n      return 'replacement'\n    case 'unicodefffe':\n    case 'utf-16be':\n      return 'UTF-16BE'\n    case 'csunicode':\n    case 'iso-10646-ucs-2':\n    case 'ucs-2':\n    case 'unicode':\n    case 'unicodefeff':\n    case 'utf-16':\n    case 'utf-16le':\n      return 'UTF-16LE'\n    case 'x-user-defined':\n      return 'x-user-defined'\n    default: return 'failure'\n  }\n}\n\nmodule.exports = {\n  getEncoding\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmaWxlYXBpXFxlbmNvZGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWVuY29kaW5nLWdldFxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBsYWJlbFxuICovXG5mdW5jdGlvbiBnZXRFbmNvZGluZyAobGFiZWwpIHtcbiAgaWYgKCFsYWJlbCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDEuIFJlbW92ZSBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgQVNDSUkgd2hpdGVzcGFjZSBmcm9tIGxhYmVsLlxuICAvLyAyLiBJZiBsYWJlbCBpcyBhbiBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBhbnkgb2YgdGhlXG4gIC8vICAgIGxhYmVscyBsaXN0ZWQgaW4gdGhlIHRhYmxlIGJlbG93LCB0aGVuIHJldHVybiB0aGVcbiAgLy8gICAgY29ycmVzcG9uZGluZyBlbmNvZGluZzsgb3RoZXJ3aXNlIHJldHVybiBmYWlsdXJlLlxuICBzd2l0Y2ggKGxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAndW5pY29kZS0xLTEtdXRmLTgnOlxuICAgIGNhc2UgJ3VuaWNvZGUxMXV0ZjgnOlxuICAgIGNhc2UgJ3VuaWNvZGUyMHV0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd4LXVuaWNvZGUyMHV0ZjgnOlxuICAgICAgcmV0dXJuICdVVEYtOCdcbiAgICBjYXNlICc4NjYnOlxuICAgIGNhc2UgJ2NwODY2JzpcbiAgICBjYXNlICdjc2libTg2Nic6XG4gICAgY2FzZSAnaWJtODY2JzpcbiAgICAgIHJldHVybiAnSUJNODY2J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW4yJzpcbiAgICBjYXNlICdpc28tODg1OS0yJzpcbiAgICBjYXNlICdpc28taXItMTAxJzpcbiAgICBjYXNlICdpc284ODU5LTInOlxuICAgIGNhc2UgJ2lzbzg4NTkyJzpcbiAgICBjYXNlICdpc29fODg1OS0yJzpcbiAgICBjYXNlICdpc29fODg1OS0yOjE5ODcnOlxuICAgIGNhc2UgJ2wyJzpcbiAgICBjYXNlICdsYXRpbjInOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0yJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW4zJzpcbiAgICBjYXNlICdpc28tODg1OS0zJzpcbiAgICBjYXNlICdpc28taXItMTA5JzpcbiAgICBjYXNlICdpc284ODU5LTMnOlxuICAgIGNhc2UgJ2lzbzg4NTkzJzpcbiAgICBjYXNlICdpc29fODg1OS0zJzpcbiAgICBjYXNlICdpc29fODg1OS0zOjE5ODgnOlxuICAgIGNhc2UgJ2wzJzpcbiAgICBjYXNlICdsYXRpbjMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0zJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW40JzpcbiAgICBjYXNlICdpc28tODg1OS00JzpcbiAgICBjYXNlICdpc28taXItMTEwJzpcbiAgICBjYXNlICdpc284ODU5LTQnOlxuICAgIGNhc2UgJ2lzbzg4NTk0JzpcbiAgICBjYXNlICdpc29fODg1OS00JzpcbiAgICBjYXNlICdpc29fODg1OS00OjE5ODgnOlxuICAgIGNhc2UgJ2w0JzpcbiAgICBjYXNlICdsYXRpbjQnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS00J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5jeXJpbGxpYyc6XG4gICAgY2FzZSAnY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2lzby04ODU5LTUnOlxuICAgIGNhc2UgJ2lzby1pci0xNDQnOlxuICAgIGNhc2UgJ2lzbzg4NTktNSc6XG4gICAgY2FzZSAnaXNvODg1OTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTU6MTk4OCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTUnXG4gICAgY2FzZSAnYXJhYmljJzpcbiAgICBjYXNlICdhc21vLTcwOCc6XG4gICAgY2FzZSAnY3Npc284ODU5NmUnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZpJzpcbiAgICBjYXNlICdjc2lzb2xhdGluYXJhYmljJzpcbiAgICBjYXNlICdlY21hLTExNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNic6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1lJzpcbiAgICBjYXNlICdpc28tODg1OS02LWknOlxuICAgIGNhc2UgJ2lzby1pci0xMjcnOlxuICAgIGNhc2UgJ2lzbzg4NTktNic6XG4gICAgY2FzZSAnaXNvODg1OTYnOlxuICAgIGNhc2UgJ2lzb184ODU5LTYnOlxuICAgIGNhc2UgJ2lzb184ODU5LTY6MTk4Nyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTYnXG4gICAgY2FzZSAnY3Npc29sYXRpbmdyZWVrJzpcbiAgICBjYXNlICdlY21hLTExOCc6XG4gICAgY2FzZSAnZWxvdF85MjgnOlxuICAgIGNhc2UgJ2dyZWVrJzpcbiAgICBjYXNlICdncmVlazgnOlxuICAgIGNhc2UgJ2lzby04ODU5LTcnOlxuICAgIGNhc2UgJ2lzby1pci0xMjYnOlxuICAgIGNhc2UgJ2lzbzg4NTktNyc6XG4gICAgY2FzZSAnaXNvODg1OTcnOlxuICAgIGNhc2UgJ2lzb184ODU5LTcnOlxuICAgIGNhc2UgJ2lzb184ODU5LTc6MTk4Nyc6XG4gICAgY2FzZSAnc3VuX2V1X2dyZWVrJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNydcbiAgICBjYXNlICdjc2lzbzg4NTk4ZSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmhlYnJldyc6XG4gICAgY2FzZSAnaGVicmV3JzpcbiAgICBjYXNlICdpc28tODg1OS04JzpcbiAgICBjYXNlICdpc28tODg1OS04LWUnOlxuICAgIGNhc2UgJ2lzby1pci0xMzgnOlxuICAgIGNhc2UgJ2lzbzg4NTktOCc6XG4gICAgY2FzZSAnaXNvODg1OTgnOlxuICAgIGNhc2UgJ2lzb184ODU5LTgnOlxuICAgIGNhc2UgJ2lzb184ODU5LTg6MTk4OCc6XG4gICAgY2FzZSAndmlzdWFsJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktOCdcbiAgICBjYXNlICdjc2lzbzg4NTk4aSc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1pJzpcbiAgICBjYXNlICdsb2dpY2FsJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktOC1JJ1xuICAgIGNhc2UgJ2NzaXNvbGF0aW42JzpcbiAgICBjYXNlICdpc28tODg1OS0xMCc6XG4gICAgY2FzZSAnaXNvLWlyLTE1Nyc6XG4gICAgY2FzZSAnaXNvODg1OS0xMCc6XG4gICAgY2FzZSAnaXNvODg1OTEwJzpcbiAgICBjYXNlICdsNic6XG4gICAgY2FzZSAnbGF0aW42JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTAnXG4gICAgY2FzZSAnaXNvLTg4NTktMTMnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTMnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMyc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEzJ1xuICAgIGNhc2UgJ2lzby04ODU5LTE0JzpcbiAgICBjYXNlICdpc284ODU5LTE0JzpcbiAgICBjYXNlICdpc284ODU5MTQnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNCdcbiAgICBjYXNlICdjc2lzb2xhdGluOSc6XG4gICAgY2FzZSAnaXNvLTg4NTktMTUnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTUnOlxuICAgIGNhc2UgJ2lzbzg4NTkxNSc6XG4gICAgY2FzZSAnaXNvXzg4NTktMTUnOlxuICAgIGNhc2UgJ2w5JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTUnXG4gICAgY2FzZSAnaXNvLTg4NTktMTYnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xNidcbiAgICBjYXNlICdjc2tvaThyJzpcbiAgICBjYXNlICdrb2knOlxuICAgIGNhc2UgJ2tvaTgnOlxuICAgIGNhc2UgJ2tvaTgtcic6XG4gICAgY2FzZSAna29pOF9yJzpcbiAgICAgIHJldHVybiAnS09JOC1SJ1xuICAgIGNhc2UgJ2tvaTgtcnUnOlxuICAgIGNhc2UgJ2tvaTgtdSc6XG4gICAgICByZXR1cm4gJ0tPSTgtVSdcbiAgICBjYXNlICdjc21hY2ludG9zaCc6XG4gICAgY2FzZSAnbWFjJzpcbiAgICBjYXNlICdtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ3gtbWFjLXJvbWFuJzpcbiAgICAgIHJldHVybiAnbWFjaW50b3NoJ1xuICAgIGNhc2UgJ2lzby04ODU5LTExJzpcbiAgICBjYXNlICdpc284ODU5LTExJzpcbiAgICBjYXNlICdpc284ODU5MTEnOlxuICAgIGNhc2UgJ3Rpcy02MjAnOlxuICAgIGNhc2UgJ3dpbmRvd3MtODc0JzpcbiAgICAgIHJldHVybiAnd2luZG93cy04NzQnXG4gICAgY2FzZSAnY3AxMjUwJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTAnOlxuICAgIGNhc2UgJ3gtY3AxMjUwJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUwJ1xuICAgIGNhc2UgJ2NwMTI1MSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUxJzpcbiAgICBjYXNlICd4LWNwMTI1MSc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MSdcbiAgICBjYXNlICdhbnNpX3gzLjQtMTk2OCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2NwMTI1Mic6XG4gICAgY2FzZSAnY3A4MTknOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW4xJzpcbiAgICBjYXNlICdpYm04MTknOlxuICAgIGNhc2UgJ2lzby04ODU5LTEnOlxuICAgIGNhc2UgJ2lzby1pci0xMDAnOlxuICAgIGNhc2UgJ2lzbzg4NTktMSc6XG4gICAgY2FzZSAnaXNvODg1OTEnOlxuICAgIGNhc2UgJ2lzb184ODU5LTEnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE6MTk4Nyc6XG4gICAgY2FzZSAnbDEnOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAndXMtYXNjaWknOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Mic6XG4gICAgY2FzZSAneC1jcDEyNTInOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTInXG4gICAgY2FzZSAnY3AxMjUzJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTMnOlxuICAgIGNhc2UgJ3gtY3AxMjUzJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUzJ1xuICAgIGNhc2UgJ2NwMTI1NCc6XG4gICAgY2FzZSAnY3Npc29sYXRpbjUnOlxuICAgIGNhc2UgJ2lzby04ODU5LTknOlxuICAgIGNhc2UgJ2lzby1pci0xNDgnOlxuICAgIGNhc2UgJ2lzbzg4NTktOSc6XG4gICAgY2FzZSAnaXNvODg1OTknOlxuICAgIGNhc2UgJ2lzb184ODU5LTknOlxuICAgIGNhc2UgJ2lzb184ODU5LTk6MTk4OSc6XG4gICAgY2FzZSAnbDUnOlxuICAgIGNhc2UgJ2xhdGluNSc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU0JzpcbiAgICBjYXNlICd4LWNwMTI1NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NCdcbiAgICBjYXNlICdjcDEyNTUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NSc6XG4gICAgY2FzZSAneC1jcDEyNTUnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTUnXG4gICAgY2FzZSAnY3AxMjU2JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTYnOlxuICAgIGNhc2UgJ3gtY3AxMjU2JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU2J1xuICAgIGNhc2UgJ2NwMTI1Nyc6XG4gICAgY2FzZSAnd2luZG93cy0xMjU3JzpcbiAgICBjYXNlICd4LWNwMTI1Nyc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NydcbiAgICBjYXNlICdjcDEyNTgnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1OCc6XG4gICAgY2FzZSAneC1jcDEyNTgnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTgnXG4gICAgY2FzZSAneC1tYWMtY3lyaWxsaWMnOlxuICAgIGNhc2UgJ3gtbWFjLXVrcmFpbmlhbic6XG4gICAgICByZXR1cm4gJ3gtbWFjLWN5cmlsbGljJ1xuICAgIGNhc2UgJ2NoaW5lc2UnOlxuICAgIGNhc2UgJ2NzZ2IyMzEyJzpcbiAgICBjYXNlICdjc2lzbzU4Z2IyMzEyODAnOlxuICAgIGNhc2UgJ2diMjMxMic6XG4gICAgY2FzZSAnZ2JfMjMxMic6XG4gICAgY2FzZSAnZ2JfMjMxMi04MCc6XG4gICAgY2FzZSAnZ2JrJzpcbiAgICBjYXNlICdpc28taXItNTgnOlxuICAgIGNhc2UgJ3gtZ2JrJzpcbiAgICAgIHJldHVybiAnR0JLJ1xuICAgIGNhc2UgJ2diMTgwMzAnOlxuICAgICAgcmV0dXJuICdnYjE4MDMwJ1xuICAgIGNhc2UgJ2JpZzUnOlxuICAgIGNhc2UgJ2JpZzUtaGtzY3MnOlxuICAgIGNhc2UgJ2NuLWJpZzUnOlxuICAgIGNhc2UgJ2NzYmlnNSc6XG4gICAgY2FzZSAneC14LWJpZzUnOlxuICAgICAgcmV0dXJuICdCaWc1J1xuICAgIGNhc2UgJ2NzZXVjcGtkZm10amFwYW5lc2UnOlxuICAgIGNhc2UgJ2V1Yy1qcCc6XG4gICAgY2FzZSAneC1ldWMtanAnOlxuICAgICAgcmV0dXJuICdFVUMtSlAnXG4gICAgY2FzZSAnY3Npc28yMDIyanAnOlxuICAgIGNhc2UgJ2lzby0yMDIyLWpwJzpcbiAgICAgIHJldHVybiAnSVNPLTIwMjItSlAnXG4gICAgY2FzZSAnY3NzaGlmdGppcyc6XG4gICAgY2FzZSAnbXM5MzInOlxuICAgIGNhc2UgJ21zX2thbmppJzpcbiAgICBjYXNlICdzaGlmdC1qaXMnOlxuICAgIGNhc2UgJ3NoaWZ0X2ppcyc6XG4gICAgY2FzZSAnc2ppcyc6XG4gICAgY2FzZSAnd2luZG93cy0zMWonOlxuICAgIGNhc2UgJ3gtc2ppcyc6XG4gICAgICByZXR1cm4gJ1NoaWZ0X0pJUydcbiAgICBjYXNlICdjc2V1Y2tyJzpcbiAgICBjYXNlICdjc2tzYzU2MDExOTg3JzpcbiAgICBjYXNlICdldWMta3InOlxuICAgIGNhc2UgJ2lzby1pci0xNDknOlxuICAgIGNhc2UgJ2tvcmVhbic6XG4gICAgY2FzZSAna3NfY181NjAxLTE5ODcnOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg5JzpcbiAgICBjYXNlICdrc2M1NjAxJzpcbiAgICBjYXNlICdrc2NfNTYwMSc6XG4gICAgY2FzZSAnd2luZG93cy05NDknOlxuICAgICAgcmV0dXJuICdFVUMtS1InXG4gICAgY2FzZSAnY3Npc28yMDIya3InOlxuICAgIGNhc2UgJ2h6LWdiLTIzMTInOlxuICAgIGNhc2UgJ2lzby0yMDIyLWNuJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbi1leHQnOlxuICAgIGNhc2UgJ2lzby0yMDIyLWtyJzpcbiAgICBjYXNlICdyZXBsYWNlbWVudCc6XG4gICAgICByZXR1cm4gJ3JlcGxhY2VtZW50J1xuICAgIGNhc2UgJ3VuaWNvZGVmZmZlJzpcbiAgICBjYXNlICd1dGYtMTZiZSc6XG4gICAgICByZXR1cm4gJ1VURi0xNkJFJ1xuICAgIGNhc2UgJ2NzdW5pY29kZSc6XG4gICAgY2FzZSAnaXNvLTEwNjQ2LXVjcy0yJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndW5pY29kZSc6XG4gICAgY2FzZSAndW5pY29kZWZlZmYnOlxuICAgIGNhc2UgJ3V0Zi0xNic6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZMRSdcbiAgICBjYXNlICd4LXVzZXItZGVmaW5lZCc6XG4gICAgICByZXR1cm4gJ3gtdXNlci1kZWZpbmVkJ1xuICAgIGRlZmF1bHQ6IHJldHVybiAnZmFpbHVyZSdcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0RW5jb2Rpbmdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/fileapi/util.js\")\nconst {\n  kState,\n  kError,\n  kResult,\n  kEvents,\n  kAborted\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\n\nclass FileReader extends EventTarget {\n  constructor () {\n    super()\n\n    this[kState] = 'empty'\n    this[kResult] = null\n    this[kError] = null\n    this[kEvents] = {\n      loadend: null,\n      error: null,\n      abort: null,\n      load: null,\n      progress: null,\n      loadstart: null\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */\n  readAsArrayBuffer (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsArrayBuffer')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsArrayBuffer(blob) method, when invoked,\n    // must initiate a read operation for blob with ArrayBuffer.\n    readOperation(this, blob, 'ArrayBuffer')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */\n  readAsBinaryString (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsBinaryString')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsBinaryString(blob) method, when invoked,\n    // must initiate a read operation for blob with BinaryString.\n    readOperation(this, blob, 'BinaryString')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */\n  readAsText (blob, encoding = undefined) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsText')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    if (encoding !== undefined) {\n      encoding = webidl.converters.DOMString(encoding, 'FileReader.readAsText', 'encoding')\n    }\n\n    // The readAsText(blob, encoding) method, when invoked,\n    // must initiate a read operation for blob with Text and encoding.\n    readOperation(this, blob, 'Text', encoding)\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */\n  readAsDataURL (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsDataURL')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsDataURL(blob) method, when invoked, must\n    // initiate a read operation for blob with DataURL.\n    readOperation(this, blob, 'DataURL')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */\n  abort () {\n    // 1. If this's state is \"empty\" or if this's state is\n    //    \"done\" set this's result to null and terminate\n    //    this algorithm.\n    if (this[kState] === 'empty' || this[kState] === 'done') {\n      this[kResult] = null\n      return\n    }\n\n    // 2. If this's state is \"loading\" set this's state to\n    //    \"done\" and set this's result to null.\n    if (this[kState] === 'loading') {\n      this[kState] = 'done'\n      this[kResult] = null\n    }\n\n    // 3. If there are any tasks from this on the file reading\n    //    task source in an affiliated task queue, then remove\n    //    those tasks from that task queue.\n    this[kAborted] = true\n\n    // 4. Terminate the algorithm for the read method being processed.\n    // TODO\n\n    // 5. Fire a progress event called abort at this.\n    fireAProgressEvent('abort', this)\n\n    // 6. If this's state is not \"loading\", fire a progress\n    //    event called loadend at this.\n    if (this[kState] !== 'loading') {\n      fireAProgressEvent('loadend', this)\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */\n  get readyState () {\n    webidl.brandCheck(this, FileReader)\n\n    switch (this[kState]) {\n      case 'empty': return this.EMPTY\n      case 'loading': return this.LOADING\n      case 'done': return this.DONE\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */\n  get result () {\n    webidl.brandCheck(this, FileReader)\n\n    // The result attribute’s getter, when invoked, must return\n    // this's result.\n    return this[kResult]\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */\n  get error () {\n    webidl.brandCheck(this, FileReader)\n\n    // The error attribute’s getter, when invoked, must return\n    // this's error.\n    return this[kError]\n  }\n\n  get onloadend () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadend\n  }\n\n  set onloadend (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadend) {\n      this.removeEventListener('loadend', this[kEvents].loadend)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadend = fn\n      this.addEventListener('loadend', fn)\n    } else {\n      this[kEvents].loadend = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].error) {\n      this.removeEventListener('error', this[kEvents].error)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this[kEvents].error = null\n    }\n  }\n\n  get onloadstart () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadstart\n  }\n\n  set onloadstart (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadstart) {\n      this.removeEventListener('loadstart', this[kEvents].loadstart)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadstart = fn\n      this.addEventListener('loadstart', fn)\n    } else {\n      this[kEvents].loadstart = null\n    }\n  }\n\n  get onprogress () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].progress\n  }\n\n  set onprogress (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].progress) {\n      this.removeEventListener('progress', this[kEvents].progress)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].progress = fn\n      this.addEventListener('progress', fn)\n    } else {\n      this[kEvents].progress = null\n    }\n  }\n\n  get onload () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].load\n  }\n\n  set onload (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].load) {\n      this.removeEventListener('load', this[kEvents].load)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].load = fn\n      this.addEventListener('load', fn)\n    } else {\n      this[kEvents].load = null\n    }\n  }\n\n  get onabort () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].abort\n  }\n\n  set onabort (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].abort) {\n      this.removeEventListener('abort', this[kEvents].abort)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].abort = fn\n      this.addEventListener('abort', fn)\n    } else {\n      this[kEvents].abort = null\n    }\n  }\n}\n\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2\n\nObject.defineProperties(FileReader.prototype, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors,\n  readAsArrayBuffer: kEnumerableProperty,\n  readAsBinaryString: kEnumerableProperty,\n  readAsText: kEnumerableProperty,\n  readAsDataURL: kEnumerableProperty,\n  abort: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  result: kEnumerableProperty,\n  error: kEnumerableProperty,\n  onloadstart: kEnumerableProperty,\n  onprogress: kEnumerableProperty,\n  onload: kEnumerableProperty,\n  onabort: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onloadend: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FileReader',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(FileReader, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors\n})\n\nmodule.exports = {\n  FileReader\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseUVBQVc7QUFDdkIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDNUMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZUFBZTs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLGVBQWU7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxcZmlsZXJlYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0V2ZW50cyxcbiAga0Fib3J0ZWRcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5cbmNsYXNzIEZpbGVSZWFkZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSAnZW1wdHknXG4gICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICB0aGlzW2tFcnJvcl0gPSBudWxsXG4gICAgdGhpc1trRXZlbnRzXSA9IHtcbiAgICAgIGxvYWRlbmQ6IG51bGwsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIGFib3J0OiBudWxsLFxuICAgICAgbG9hZDogbnVsbCxcbiAgICAgIHByb2dyZXNzOiBudWxsLFxuICAgICAgbG9hZHN0YXJ0OiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1yZWFkQXNBcnJheUJ1ZmZlclxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzQXJyYXlCdWZmZXIgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnRmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcicpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIC8vIFRoZSByZWFkQXNBcnJheUJ1ZmZlcihibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBBcnJheUJ1ZmZlci5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdBcnJheUJ1ZmZlcicpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jcmVhZEFzQmluYXJ5U3RyaW5nXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqL1xuICByZWFkQXNCaW5hcnlTdHJpbmcgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnRmlsZVJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcnKVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzQmluYXJ5U3RyaW5nKGJsb2IpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIEJpbmFyeVN0cmluZy5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdCaW5hcnlTdHJpbmcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRBc0RhdGFUZXh0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdcbiAgICovXG4gIHJlYWRBc1RleHQgKGJsb2IsIGVuY29kaW5nID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0ZpbGVSZWFkZXIucmVhZEFzVGV4dCcpXG5cbiAgICBibG9iID0gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihibG9iLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmNvZGluZyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyhlbmNvZGluZywgJ0ZpbGVSZWFkZXIucmVhZEFzVGV4dCcsICdlbmNvZGluZycpXG4gICAgfVxuXG4gICAgLy8gVGhlIHJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpIG1ldGhvZCwgd2hlbiBpbnZva2VkLFxuICAgIC8vIG11c3QgaW5pdGlhdGUgYSByZWFkIG9wZXJhdGlvbiBmb3IgYmxvYiB3aXRoIFRleHQgYW5kIGVuY29kaW5nLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ1RleHQnLCBlbmNvZGluZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tcmVhZEFzRGF0YVVSTFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzRGF0YVVSTCAoYmxvYikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwnKVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzRGF0YVVSTChibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCwgbXVzdFxuICAgIC8vIGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBEYXRhVVJMLlxuICAgIHJlYWRPcGVyYXRpb24odGhpcywgYmxvYiwgJ0RhdGFVUkwnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2Rmbi1hYm9ydFxuICAgKi9cbiAgYWJvcnQgKCkge1xuICAgIC8vIDEuIElmIHRoaXMncyBzdGF0ZSBpcyBcImVtcHR5XCIgb3IgaWYgdGhpcydzIHN0YXRlIGlzXG4gICAgLy8gICAgXCJkb25lXCIgc2V0IHRoaXMncyByZXN1bHQgdG8gbnVsbCBhbmQgdGVybWluYXRlXG4gICAgLy8gICAgdGhpcyBhbGdvcml0aG0uXG4gICAgaWYgKHRoaXNba1N0YXRlXSA9PT0gJ2VtcHR5JyB8fCB0aGlzW2tTdGF0ZV0gPT09ICdkb25lJykge1xuICAgICAgdGhpc1trUmVzdWx0XSA9IG51bGxcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXMncyBzdGF0ZSBpcyBcImxvYWRpbmdcIiBzZXQgdGhpcydzIHN0YXRlIHRvXG4gICAgLy8gICAgXCJkb25lXCIgYW5kIHNldCB0aGlzJ3MgcmVzdWx0IHRvIG51bGwuXG4gICAgaWYgKHRoaXNba1N0YXRlXSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSAnZG9uZSdcbiAgICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGFueSB0YXNrcyBmcm9tIHRoaXMgb24gdGhlIGZpbGUgcmVhZGluZ1xuICAgIC8vICAgIHRhc2sgc291cmNlIGluIGFuIGFmZmlsaWF0ZWQgdGFzayBxdWV1ZSwgdGhlbiByZW1vdmVcbiAgICAvLyAgICB0aG9zZSB0YXNrcyBmcm9tIHRoYXQgdGFzayBxdWV1ZS5cbiAgICB0aGlzW2tBYm9ydGVkXSA9IHRydWVcblxuICAgIC8vIDQuIFRlcm1pbmF0ZSB0aGUgYWxnb3JpdGhtIGZvciB0aGUgcmVhZCBtZXRob2QgYmVpbmcgcHJvY2Vzc2VkLlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDUuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgYWJvcnQgYXQgdGhpcy5cbiAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Fib3J0JywgdGhpcylcblxuICAgIC8vIDYuIElmIHRoaXMncyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IHRoaXMuXG4gICAgaWYgKHRoaXNba1N0YXRlXSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1yZWFkeXN0YXRlXG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHN3aXRjaCAodGhpc1trU3RhdGVdKSB7XG4gICAgICBjYXNlICdlbXB0eSc6IHJldHVybiB0aGlzLkVNUFRZXG4gICAgICBjYXNlICdsb2FkaW5nJzogcmV0dXJuIHRoaXMuTE9BRElOR1xuICAgICAgY2FzZSAnZG9uZSc6IHJldHVybiB0aGlzLkRPTkVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItcmVzdWx0XG4gICAqL1xuICBnZXQgcmVzdWx0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgLy8gVGhlIHJlc3VsdCBhdHRyaWJ1dGXigJlzIGdldHRlciwgd2hlbiBpbnZva2VkLCBtdXN0IHJldHVyblxuICAgIC8vIHRoaXMncyByZXN1bHQuXG4gICAgcmV0dXJuIHRoaXNba1Jlc3VsdF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1lcnJvclxuICAgKi9cbiAgZ2V0IGVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgLy8gVGhlIGVycm9yIGF0dHJpYnV0ZeKAmXMgZ2V0dGVyLCB3aGVuIGludm9rZWQsIG11c3QgcmV0dXJuXG4gICAgLy8gdGhpcydzIGVycm9yLlxuICAgIHJldHVybiB0aGlzW2tFcnJvcl1cbiAgfVxuXG4gIGdldCBvbmxvYWRlbmQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2FkZW5kXG4gIH1cblxuICBzZXQgb25sb2FkZW5kIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2FkZW5kKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCB0aGlzW2tFdmVudHNdLmxvYWRlbmQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkZW5kID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRlbmQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpc1trRXZlbnRzXS5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25sb2Fkc3RhcnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2Fkc3RhcnRcbiAgfVxuXG4gIHNldCBvbmxvYWRzdGFydCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0KSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0ID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbnByb2dyZXNzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3NcbiAgfVxuXG4gIHNldCBvbnByb2dyZXNzIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5wcm9ncmVzcykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5wcm9ncmVzcyA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubG9hZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmxvYWRcbiAgfVxuXG4gIHNldCBvbmxvYWQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXNba0V2ZW50c10ubG9hZClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25hYm9ydCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLmFib3J0XG4gIH1cblxuICBzZXQgb25hYm9ydCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10uYWJvcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzW2tFdmVudHNdLmFib3J0KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10uYWJvcnQgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmFib3J0ID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZW1wdHlcbkZpbGVSZWFkZXIuRU1QVFkgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5FTVBUWSA9IDBcbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1sb2FkaW5nXG5GaWxlUmVhZGVyLkxPQURJTkcgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5MT0FESU5HID0gMVxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWRvbmVcbkZpbGVSZWFkZXIuRE9ORSA9IEZpbGVSZWFkZXIucHJvdG90eXBlLkRPTkUgPSAyXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZpbGVSZWFkZXIucHJvdG90eXBlLCB7XG4gIEVNUFRZOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBMT0FESU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBET05FOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkQXNBcnJheUJ1ZmZlcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzQmluYXJ5U3RyaW5nOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkQXNEYXRhVVJMOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhYm9ydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVzdWx0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2Fkc3RhcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ucHJvZ3Jlc3M6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25hYm9ydDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25sb2FkZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRmlsZVJlYWRlcicsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWxlUmVhZGVyLCB7XG4gIEVNUFRZOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBMT0FESU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBET05FOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRmlsZVJlYWRlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/filereader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\nconst kState = Symbol('ProgressEvent state')\n\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */\nclass ProgressEvent extends Event {\n  constructor (type, eventInitDict = {}) {\n    type = webidl.converters.DOMString(type, 'ProgressEvent constructor', 'type')\n    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {})\n\n    super(type, eventInitDict)\n\n    this[kState] = {\n      lengthComputable: eventInitDict.lengthComputable,\n      loaded: eventInitDict.loaded,\n      total: eventInitDict.total\n    }\n  }\n\n  get lengthComputable () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].lengthComputable\n  }\n\n  get loaded () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].loaded\n  }\n\n  get total () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].total\n  }\n}\n\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n  {\n    key: 'lengthComputable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'loaded',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'total',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n])\n\nmodule.exports = {\n  ProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsNEVBQWlCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDJFQUEyRTs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmaWxlYXBpXFxwcm9ncmVzc2V2ZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcblxuY29uc3Qga1N0YXRlID0gU3ltYm9sKCdQcm9ncmVzc0V2ZW50IHN0YXRlJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy8jcHJvZ3Jlc3NldmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBjb25zdHJ1Y3RvciAodHlwZSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCAnUHJvZ3Jlc3NFdmVudCBjb25zdHJ1Y3RvcicsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBsZW5ndGhDb21wdXRhYmxlOiBldmVudEluaXREaWN0Lmxlbmd0aENvbXB1dGFibGUsXG4gICAgICBsb2FkZWQ6IGV2ZW50SW5pdERpY3QubG9hZGVkLFxuICAgICAgdG90YWw6IGV2ZW50SW5pdERpY3QudG90YWxcbiAgICB9XG4gIH1cblxuICBnZXQgbGVuZ3RoQ29tcHV0YWJsZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubGVuZ3RoQ29tcHV0YWJsZVxuICB9XG5cbiAgZ2V0IGxvYWRlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUHJvZ3Jlc3NFdmVudClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ubG9hZGVkXG4gIH1cblxuICBnZXQgdG90YWwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnRvdGFsXG4gIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuUHJvZ3Jlc3NFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdsZW5ndGhDb21wdXRhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnbG9hZGVkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3RvdGFsJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQcm9ncmVzc0V2ZW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kState: Symbol('FileReader state'),\n  kResult: Symbol('FileReader result'),\n  kError: Symbol('FileReader error'),\n  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),\n  kEvents: Symbol('FileReader events'),\n  kAborted: Symbol('FileReader aborted')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZpbGVhcGlcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrU3RhdGU6IFN5bWJvbCgnRmlsZVJlYWRlciBzdGF0ZScpLFxuICBrUmVzdWx0OiBTeW1ib2woJ0ZpbGVSZWFkZXIgcmVzdWx0JyksXG4gIGtFcnJvcjogU3ltYm9sKCdGaWxlUmVhZGVyIGVycm9yJyksXG4gIGtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkOiBTeW1ib2woJ0ZpbGVSZWFkZXIgbGFzdCBwcm9ncmVzcyBldmVudCBmaXJlZCB0aW1lc3RhbXAnKSxcbiAga0V2ZW50czogU3ltYm9sKCdGaWxlUmVhZGVyIGV2ZW50cycpLFxuICBrQWJvcnRlZDogU3ltYm9sKCdGaWxlUmVhZGVyIGFib3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/fileapi/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/fileapi/symbols.js\")\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(ssr)/./node_modules/undici/lib/web/fileapi/progressevent.js\")\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/undici/lib/web/fileapi/encoding.js\")\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst { btoa } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from type’s parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlFQUFXO0FBQ3ZCLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDbkQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQywyRUFBWTtBQUM1QyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3pFLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjtBQUNsRCxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUV0QyxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBrU3RhdGUsXG4gIGtFcnJvcixcbiAga1Jlc3VsdCxcbiAga0Fib3J0ZWQsXG4gIGtMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgUHJvZ3Jlc3NFdmVudCB9ID0gcmVxdWlyZSgnLi9wcm9ncmVzc2V2ZW50JylcbmNvbnN0IHsgZ2V0RW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKVxuY29uc3QgeyBzZXJpYWxpemVBTWltZVR5cGUsIHBhcnNlTUlNRVR5cGUgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2RhdGEtdXJsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJylcbmNvbnN0IHsgYnRvYSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRPcGVyYXRpb25cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSBmclxuICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nTmFtZVxuICovXG5mdW5jdGlvbiByZWFkT3BlcmF0aW9uIChmciwgYmxvYiwgdHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIElmIGZy4oCZcyBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhyb3cgYW4gSW52YWxpZFN0YXRlRXJyb3JcbiAgLy8gICAgRE9NRXhjZXB0aW9uLlxuICBpZiAoZnJba1N0YXRlXSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBzdGF0ZScsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gIH1cblxuICAvLyAyLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwibG9hZGluZ1wiLlxuICBmcltrU3RhdGVdID0gJ2xvYWRpbmcnXG5cbiAgLy8gMy4gU2V0IGZy4oCZcyByZXN1bHQgdG8gbnVsbC5cbiAgZnJba1Jlc3VsdF0gPSBudWxsXG5cbiAgLy8gNC4gU2V0IGZy4oCZcyBlcnJvciB0byBudWxsLlxuICBmcltrRXJyb3JdID0gbnVsbFxuXG4gIC8vIDUuIExldCBzdHJlYW0gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGdldCBzdHJlYW0gb24gYmxvYi5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbS93ZWInKS5SZWFkYWJsZVN0cmVhbX0gKi9cbiAgY29uc3Qgc3RyZWFtID0gYmxvYi5zdHJlYW0oKVxuXG4gIC8vIDYuIExldCByZWFkZXIgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIGEgcmVhZGVyIGZyb20gc3RyZWFtLlxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAvLyA3LiBMZXQgYnl0ZXMgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5W119ICovXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICAvLyA4LiBMZXQgY2h1bmtQcm9taXNlIGJlIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhIGNodW5rIGZyb21cbiAgLy8gICAgc3RyZWFtIHdpdGggcmVhZGVyLlxuICBsZXQgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuXG4gIC8vIDkuIExldCBpc0ZpcnN0Q2h1bmsgYmUgdHJ1ZS5cbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWVcblxuICAvLyAxMC4gSW4gcGFyYWxsZWwsIHdoaWxlIHRydWU6XG4gIC8vIE5vdGU6IFwiSW4gcGFyYWxsZWxcIiBqdXN0IG1lYW5zIG5vbi1ibG9ja2luZ1xuICAvLyBOb3RlIDI6IHJlYWRPcGVyYXRpb24gaXRzZWxmIGNhbm5vdCBiZSBhc3luYyBhcyBkb3VibGVcbiAgLy8gcmVhZGluZyB0aGUgYm9keSB3b3VsZCB0aGVuIHJlamVjdCB0aGUgcHJvbWlzZSwgaW5zdGVhZFxuICAvLyBvZiB0aHJvd2luZyBhbiBlcnJvci5cbiAgOyhhc3luYyAoKSA9PiB7XG4gICAgd2hpbGUgKCFmcltrQWJvcnRlZF0pIHtcbiAgICAgIC8vIDEuIFdhaXQgZm9yIGNodW5rUHJvbWlzZSB0byBiZSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBjaHVua1Byb21pc2VcblxuICAgICAgICAvLyAyLiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkLCBhbmQgaXNGaXJzdENodW5rIGlzXG4gICAgICAgIC8vICAgIHRydWUsIHF1ZXVlIGEgdGFzayB0byBmaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkXG4gICAgICAgIC8vICAgIGxvYWRzdGFydCBhdCBmci5cbiAgICAgICAgaWYgKGlzRmlyc3RDaHVuayAmJiAhZnJba0Fib3J0ZWRdKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2Fkc3RhcnQnLCBmcilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gU2V0IGlzRmlyc3RDaHVuayB0byBmYWxzZS5cbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2VcblxuICAgICAgICAvLyA0LiBJZiBjaHVua1Byb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gb2JqZWN0IHdob3NlXG4gICAgICAgIC8vICAgIGRvbmUgcHJvcGVydHkgaXMgZmFsc2UgYW5kIHdob3NlIHZhbHVlIHByb3BlcnR5IGlzXG4gICAgICAgIC8vICAgIGEgVWludDhBcnJheSBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcbiAgICAgICAgaWYgKCFkb25lICYmIHR5cGVzLmlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyAxLiBMZXQgYnMgYmUgdGhlIGJ5dGUgc2VxdWVuY2UgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICAgICAgLy8gICAgVWludDhBcnJheSBvYmplY3QuXG5cbiAgICAgICAgICAvLyAyLiBBcHBlbmQgYnMgdG8gYnl0ZXMuXG4gICAgICAgICAgYnl0ZXMucHVzaCh2YWx1ZSlcblxuICAgICAgICAgIC8vIDMuIElmIHJvdWdobHkgNTBtcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGVzZSBzdGVwc1xuICAgICAgICAgIC8vICAgIHdlcmUgbGFzdCBpbnZva2VkLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhXG4gICAgICAgICAgLy8gICAgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIHByb2dyZXNzIGF0IGZyLlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA+PSA1MFxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgIWZyW2tBYm9ydGVkXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZnJba0xhc3RQcm9ncmVzc0V2ZW50RmlyZWRdID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgZnIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuIFNldCBjaHVua1Byb21pc2UgdG8gdGhlIHJlc3VsdCBvZiByZWFkaW5nIGFcbiAgICAgICAgICAvLyAgICBjaHVuayBmcm9tIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgICAgICAgICBjaHVua1Byb21pc2UgPSByZWFkZXIucmVhZCgpXG4gICAgICAgIH0gZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuXG4gICAgICAgICAgLy8gICAgb2JqZWN0IHdob3NlIGRvbmUgcHJvcGVydHkgaXMgdHJ1ZSwgcXVldWUgYSB0YXNrXG4gICAgICAgICAgLy8gICAgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHMgYW5kIGFib3J0IHRoaXMgYWxnb3JpdGhtOlxuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgICBmcltrU3RhdGVdID0gJ2RvbmUnXG5cbiAgICAgICAgICAgIC8vIDIuIExldCByZXN1bHQgYmUgdGhlIHJlc3VsdCBvZiBwYWNrYWdlIGRhdGEgZ2l2ZW5cbiAgICAgICAgICAgIC8vICAgIGJ5dGVzLCB0eXBlLCBibG9i4oCZcyB0eXBlLCBhbmQgZW5jb2RpbmdOYW1lLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFja2FnZURhdGEoYnl0ZXMsIHR5cGUsIGJsb2IudHlwZSwgZW5jb2RpbmdOYW1lKVxuXG4gICAgICAgICAgICAgIC8vIDQuIEVsc2U6XG5cbiAgICAgICAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyByZXN1bHQgdG8gcmVzdWx0LlxuICAgICAgICAgICAgICBmcltrUmVzdWx0XSA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgIC8vIDIuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgbG9hZCBhdCB0aGUgZnIuXG4gICAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZCcsIGZyKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gMy4gSWYgcGFja2FnZSBkYXRhIHRocmV3IGFuIGV4Y2VwdGlvbiBlcnJvcjpcblxuICAgICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIGVycm9yIHRvIGVycm9yLlxuICAgICAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2Vycm9yJywgZnIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDUuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWRlbmQnLCBmcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4gT3RoZXJ3aXNlLCBpZiBjaHVua1Byb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCBhblxuICAgICAgICAvLyAgICBlcnJvciBlcnJvciwgcXVldWUgYSB0YXNrIHRvIHJ1biB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vICAgIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgc3RhdGUgdG8gXCJkb25lXCIuXG4gICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgLy8gMi4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICBmcltrRXJyb3JdID0gZXJyb3JcblxuICAgICAgICAgIC8vIDMuIEZpcmUgYSBwcm9ncmVzcyBldmVudCBjYWxsZWQgZXJyb3IgYXQgZnIuXG4gICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuXG4gICAgICAgICAgLy8gNC4gSWYgZnLigJlzIHN0YXRlIGlzIG5vdCBcImxvYWRpbmdcIiwgZmlyZSBhIHByb2dyZXNzXG4gICAgICAgICAgLy8gICAgZXZlbnQgY2FsbGVkIGxvYWRlbmQgYXQgZnIuXG4gICAgICAgICAgaWYgKGZyW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9KSgpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZmlyZS1hLXByb2dyZXNzLWV2ZW50XG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ldmVudC1maXJlXG4gKiBAcGFyYW0ge3N0cmluZ30gZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ZpbGVyZWFkZXInKS5GaWxlUmVhZGVyfSByZWFkZXJcbiAqL1xuZnVuY3Rpb24gZmlyZUFQcm9ncmVzc0V2ZW50IChlLCByZWFkZXIpIHtcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgZG9lcyBub3QgYnViYmxlLiBlLmJ1YmJsZXMgbXVzdCBiZSBmYWxzZVxuICAvLyBUaGUgcHJvZ3Jlc3MgZXZlbnQgZSBpcyBOT1QgY2FuY2VsYWJsZS4gZS5jYW5jZWxhYmxlIG11c3QgYmUgZmFsc2VcbiAgY29uc3QgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudChlLCB7XG4gICAgYnViYmxlczogZmFsc2UsXG4gICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgfSlcblxuICByZWFkZXIuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNibG9iLXBhY2thZ2UtZGF0YVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBtaW1lVHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcGFja2FnZURhdGEgKGJ5dGVzLCB0eXBlLCBtaW1lVHlwZSwgZW5jb2RpbmdOYW1lKSB7XG4gIC8vIDEuIEEgQmxvYiBoYXMgYW4gYXNzb2NpYXRlZCBwYWNrYWdlIGRhdGEgYWxnb3JpdGhtLCBnaXZlblxuICAvLyAgICBieXRlcywgYSB0eXBlLCBhIG9wdGlvbmFsIG1pbWVUeXBlLCBhbmQgYSBvcHRpb25hbFxuICAvLyAgICBlbmNvZGluZ05hbWUsIHdoaWNoIHN3aXRjaGVzIG9uIHR5cGUgYW5kIHJ1bnMgdGhlXG4gIC8vICAgIGFzc29jaWF0ZWQgc3RlcHM6XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnRGF0YVVSTCc6IHtcbiAgICAgIC8vIDEuIFJldHVybiBieXRlcyBhcyBhIERhdGFVUkwgW1JGQzIzOTddIHN1YmplY3QgdG9cbiAgICAgIC8vICAgIHRoZSBjb25zaWRlcmF0aW9ucyBiZWxvdzpcbiAgICAgIC8vICAqIFVzZSBtaW1lVHlwZSBhcyBwYXJ0IG9mIHRoZSBEYXRhIFVSTCBpZiBpdCBpc1xuICAgICAgLy8gICAgYXZhaWxhYmxlIGluIGtlZXBpbmcgd2l0aCB0aGUgRGF0YSBVUkxcbiAgICAgIC8vICAgIHNwZWNpZmljYXRpb24gW1JGQzIzOTddLlxuICAgICAgLy8gICogSWYgbWltZVR5cGUgaXMgbm90IGF2YWlsYWJsZSByZXR1cm4gYSBEYXRhIFVSTFxuICAgICAgLy8gICAgd2l0aG91dCBhIG1lZGlhLXR5cGUuIFtSRkMyMzk3XS5cblxuICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyMzk3I3NlY3Rpb24tM1xuICAgICAgLy8gZGF0YXVybCAgICA6PSBcImRhdGE6XCIgWyBtZWRpYXR5cGUgXSBbIFwiO2Jhc2U2NFwiIF0gXCIsXCIgZGF0YVxuICAgICAgLy8gbWVkaWF0eXBlICA6PSBbIHR5cGUgXCIvXCIgc3VidHlwZSBdICooIFwiO1wiIHBhcmFtZXRlciApXG4gICAgICAvLyBkYXRhICAgICAgIDo9ICp1cmxjaGFyXG4gICAgICAvLyBwYXJhbWV0ZXIgIDo9IGF0dHJpYnV0ZSBcIj1cIiB2YWx1ZVxuICAgICAgbGV0IGRhdGFVUkwgPSAnZGF0YTonXG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpXG5cbiAgICAgIGlmIChwYXJzZWQgIT09ICdmYWlsdXJlJykge1xuICAgICAgICBkYXRhVVJMICs9IHNlcmlhbGl6ZUFNaW1lVHlwZShwYXJzZWQpXG4gICAgICB9XG5cbiAgICAgIGRhdGFVUkwgKz0gJztiYXNlNjQsJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIud3JpdGUoY2h1bmspKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9IGJ0b2EoZGVjb2Rlci5lbmQoKSlcblxuICAgICAgcmV0dXJuIGRhdGFVUkxcbiAgICB9XG4gICAgY2FzZSAnVGV4dCc6IHtcbiAgICAgIC8vIDEuIExldCBlbmNvZGluZyBiZSBmYWlsdXJlXG4gICAgICBsZXQgZW5jb2RpbmcgPSAnZmFpbHVyZSdcblxuICAgICAgLy8gMi4gSWYgdGhlIGVuY29kaW5nTmFtZSBpcyBwcmVzZW50LCBzZXQgZW5jb2RpbmcgdG8gdGhlXG4gICAgICAvLyAgICByZXN1bHQgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIGVuY29kaW5nTmFtZS5cbiAgICAgIGlmIChlbmNvZGluZ05hbWUpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhlbmNvZGluZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIGFuZCBtaW1lVHlwZSBpcyBwcmVzZW50OlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScgJiYgbWltZVR5cGUpIHtcbiAgICAgICAgLy8gMS4gTGV0IHR5cGUgYmUgdGhlIHJlc3VsdCBvZiBwYXJzZSBhIE1JTUUgdHlwZVxuICAgICAgICAvLyAgICBnaXZlbiBtaW1lVHlwZS5cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpXG5cbiAgICAgICAgLy8gMi4gSWYgdHlwZSBpcyBub3QgZmFpbHVyZSwgc2V0IGVuY29kaW5nIHRvIHRoZSByZXN1bHRcbiAgICAgICAgLy8gICAgb2YgZ2V0dGluZyBhbiBlbmNvZGluZyBmcm9tIHR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdLlxuICAgICAgICBpZiAodHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyh0eXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0JykpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgZW5jb2RpbmcgaXMgZmFpbHVyZSwgdGhlbiBzZXQgZW5jb2RpbmcgdG8gVVRGLTguXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdmYWlsdXJlJykge1xuICAgICAgICBlbmNvZGluZyA9ICdVVEYtOCdcbiAgICAgIH1cblxuICAgICAgLy8gNS4gRGVjb2RlIGJ5dGVzIHVzaW5nIGZhbGxiYWNrIGVuY29kaW5nIGVuY29kaW5nLCBhbmRcbiAgICAgIC8vICAgIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAgcmV0dXJuIGRlY29kZShieXRlcywgZW5jb2RpbmcpXG4gICAgfVxuICAgIGNhc2UgJ0FycmF5QnVmZmVyJzoge1xuICAgICAgLy8gUmV0dXJuIGEgbmV3IEFycmF5QnVmZmVyIHdob3NlIGNvbnRlbnRzIGFyZSBieXRlcy5cbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoYnl0ZXMpXG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZS5idWZmZXJcbiAgICB9XG4gICAgY2FzZSAnQmluYXJ5U3RyaW5nJzoge1xuICAgICAgLy8gUmV0dXJuIGJ5dGVzIGFzIGEgYmluYXJ5IHN0cmluZywgaW4gd2hpY2ggZXZlcnkgYnl0ZVxuICAgICAgLy8gIGlzIHJlcHJlc2VudGVkIGJ5IGEgY29kZSB1bml0IG9mIGVxdWFsIHZhbHVlIFswLi4yNTVdLlxuICAgICAgbGV0IGJpbmFyeVN0cmluZyA9ICcnXG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcignbGF0aW4xJylcblxuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBieXRlcykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gZGVjb2Rlci53cml0ZShjaHVuaylcbiAgICAgIH1cblxuICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIuZW5kKClcblxuICAgICAgcmV0dXJuIGJpbmFyeVN0cmluZ1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2RlY29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5W119IGlvUXVldWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiBkZWNvZGUgKGlvUXVldWUsIGVuY29kaW5nKSB7XG4gIGNvbnN0IGJ5dGVzID0gY29tYmluZUJ5dGVTZXF1ZW5jZXMoaW9RdWV1ZSlcblxuICAvLyAxLiBMZXQgQk9NRW5jb2RpbmcgYmUgdGhlIHJlc3VsdCBvZiBCT00gc25pZmZpbmcgaW9RdWV1ZS5cbiAgY29uc3QgQk9NRW5jb2RpbmcgPSBCT01TbmlmZmluZyhieXRlcylcblxuICBsZXQgc2xpY2UgPSAwXG5cbiAgLy8gMi4gSWYgQk9NRW5jb2RpbmcgaXMgbm9uLW51bGw6XG4gIGlmIChCT01FbmNvZGluZyAhPT0gbnVsbCkge1xuICAgIC8vIDEuIFNldCBlbmNvZGluZyB0byBCT01FbmNvZGluZy5cbiAgICBlbmNvZGluZyA9IEJPTUVuY29kaW5nXG5cbiAgICAvLyAyLiBSZWFkIHRocmVlIGJ5dGVzIGZyb20gaW9RdWV1ZSwgaWYgQk9NRW5jb2RpbmcgaXNcbiAgICAvLyAgICBVVEYtODsgb3RoZXJ3aXNlIHJlYWQgdHdvIGJ5dGVzLlxuICAgIC8vICAgIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgIHNsaWNlID0gQk9NRW5jb2RpbmcgPT09ICdVVEYtOCcgPyAzIDogMlxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgZW5jb2RpbmfigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuXG4gIGNvbnN0IHNsaWNlZCA9IGJ5dGVzLnNsaWNlKHNsaWNlKVxuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKS5kZWNvZGUoc2xpY2VkKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI2JvbS1zbmlmZlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpb1F1ZXVlXG4gKi9cbmZ1bmN0aW9uIEJPTVNuaWZmaW5nIChpb1F1ZXVlKSB7XG4gIC8vIDEuIExldCBCT00gYmUgdGhlIHJlc3VsdCBvZiBwZWVraW5nIDMgYnl0ZXMgZnJvbSBpb1F1ZXVlLFxuICAvLyAgICBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuICBjb25zdCBbYSwgYiwgY10gPSBpb1F1ZXVlXG5cbiAgLy8gMi4gRm9yIGVhY2ggb2YgdGhlIHJvd3MgaW4gdGhlIHRhYmxlIGJlbG93LCBzdGFydGluZyB3aXRoXG4gIC8vICAgIHRoZSBmaXJzdCBvbmUgYW5kIGdvaW5nIGRvd24sIGlmIEJPTSBzdGFydHMgd2l0aCB0aGVcbiAgLy8gICAgYnl0ZXMgZ2l2ZW4gaW4gdGhlIGZpcnN0IGNvbHVtbiwgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGVuY29kaW5nIGdpdmVuIGluIHRoZSBjZWxsIGluIHRoZSBzZWNvbmQgY29sdW1uIG9mIHRoYXRcbiAgLy8gICAgcm93LiBPdGhlcndpc2UsIHJldHVybiBudWxsLlxuICBpZiAoYSA9PT0gMHhFRiAmJiBiID09PSAweEJCICYmIGMgPT09IDB4QkYpIHtcbiAgICByZXR1cm4gJ1VURi04J1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkUgJiYgYiA9PT0gMHhGRikge1xuICAgIHJldHVybiAnVVRGLTE2QkUnXG4gIH0gZWxzZSBpZiAoYSA9PT0gMHhGRiAmJiBiID09PSAweEZFKSB7XG4gICAgcmV0dXJuICdVVEYtMTZMRSdcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5W119IHNlcXVlbmNlc1xuICovXG5mdW5jdGlvbiBjb21iaW5lQnl0ZVNlcXVlbmNlcyAoc2VxdWVuY2VzKSB7XG4gIGNvbnN0IHNpemUgPSBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGEgKyBiLmJ5dGVMZW5ndGhcbiAgfSwgMClcblxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIHJldHVybiBzZXF1ZW5jZXMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgYS5zZXQoYiwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBiLmJ5dGVMZW5ndGhcbiAgICByZXR1cm4gYVxuICB9LCBuZXcgVWludDhBcnJheShzaXplKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHJlYWRPcGVyYXRpb24sXG4gIGZpcmVBUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/fileapi/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose,\n  kResponse\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(ssr)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(ssr)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(ssr)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\")\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response, extensions)\n    }\n  })\n\n  return controller\n}\n\nfunction closeWebSocketConnection (ws, code, reason, reasonByteLength) {\n  if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n  } else if (!isEstablished(ws)) {\n    // If the WebSocket connection is not yet established\n    // Fail the WebSocket connection and set this's ready state\n    // to CLOSING (2).\n    failWebsocketConnection(ws, 'Connection was closed before it was established.')\n    ws[kReadyState] = states.CLOSING\n  } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n    // If the WebSocket closing handshake has not yet been started\n    // Start the WebSocket closing handshake and set this's ready\n    // state to CLOSING (2).\n    // - If neither code nor reason is present, the WebSocket Close\n    //   message must not have a body.\n    // - If code is present, then the status code to use in the\n    //   WebSocket Close message must be the integer given by code.\n    // - If reason is also present, then reasonBytes must be\n    //   provided in the Close message after the status code.\n\n    ws[kSentClose] = sentCloseFrameState.PROCESSING\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    if (code !== undefined && reason === undefined) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== undefined && reason !== undefined) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = ws[kResponse].socket\n\n    socket.write(frame.createFrame(opcodes.CLOSE))\n\n    ws[kSentClose] = sentCloseFrameState.SENT\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    ws[kReadyState] = states.CLOSING\n  } else {\n    // Otherwise\n    // Set this's ready state to CLOSING (2).\n    ws[kReadyState] = states.CLOSING\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n  const { [kResponse]: response } = ws\n\n  response.socket.off('data', onSocketData)\n  response.socket.off('close', onSocketClose)\n  response.socket.off('error', onSocketError)\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result && !result.error) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kReceivedClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  // TODO: process.nextTick\n  fireEvent('close', ws, (type, init) => new CloseEvent(type, init), {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQ3ZCLFFBQVEsMEZBQTBGLEVBQUUsbUJBQU8sQ0FBQyxxRUFBUTtBQUNwSCxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQ3pDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzdDLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDOUQsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUzs7QUFFaEQsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNoQztBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlDQUFpQztBQUM1QyxXQUFXLDJEQUEyRDtBQUN0RSxXQUFXLHdEQUF3RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsZUFBZSx5QkFBeUI7QUFDeEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmLFVBQVUsd0JBQXdCOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFVBQVUsS0FBSzs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxjb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHVpZCwgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBlbXB0eUJ1ZmZlciwgb3Bjb2RlcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrUmVhZHlTdGF0ZSxcbiAga1NlbnRDbG9zZSxcbiAga0J5dGVQYXJzZXIsXG4gIGtSZWNlaXZlZENsb3NlLFxuICBrUmVzcG9uc2Vcbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBmaXJlRXZlbnQsIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLCBpc0Nsb3NpbmcsIGlzQ2xvc2VkLCBpc0VzdGFibGlzaGVkLCBwYXJzZUV4dGVuc2lvbnMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHsgQ2xvc2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBtYWtlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IEhlYWRlcnMsIGdldEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9oZWFkZXJzJylcbmNvbnN0IHsgZ2V0RGVjb2RlU3BsaXQgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG59IGNhdGNoIHtcblxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC13ZWJzb2NrZXQtZXN0YWJsaXNoXG4gKiBAcGFyYW0ge1VSTH0gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0geyhyZXNwb25zZTogYW55LCBleHRlbnNpb25zOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZH0gb25Fc3RhYmxpc2hcbiAqIEBwYXJhbSB7UGFydGlhbDxpbXBvcnQoJy4uLy4uL3R5cGVzL3dlYnNvY2tldCcpLldlYlNvY2tldEluaXQ+fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24gKHVybCwgcHJvdG9jb2xzLCBjbGllbnQsIHdzLCBvbkVzdGFibGlzaCwgb3B0aW9ucykge1xuICAvLyAxLiBMZXQgcmVxdWVzdFVSTCBiZSBhIGNvcHkgb2YgdXJsLCB3aXRoIGl0cyBzY2hlbWUgc2V0IHRvIFwiaHR0cFwiLCBpZiB1cmzigJlzXG4gIC8vICAgIHNjaGVtZSBpcyBcIndzXCIsIGFuZCB0byBcImh0dHBzXCIgb3RoZXJ3aXNlLlxuICBjb25zdCByZXF1ZXN0VVJMID0gdXJsXG5cbiAgcmVxdWVzdFVSTC5wcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gJ3dzOicgPyAnaHR0cDonIDogJ2h0dHBzOidcblxuICAvLyAyLiBMZXQgcmVxdWVzdCBiZSBhIG5ldyByZXF1ZXN0LCB3aG9zZSBVUkwgaXMgcmVxdWVzdFVSTCwgY2xpZW50IGlzIGNsaWVudCxcbiAgLy8gICAgc2VydmljZS13b3JrZXJzIG1vZGUgaXMgXCJub25lXCIsIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgbW9kZSBpc1xuICAvLyAgICBcIndlYnNvY2tldFwiLCBjcmVkZW50aWFscyBtb2RlIGlzIFwiaW5jbHVkZVwiLCBjYWNoZSBtb2RlIGlzIFwibm8tc3RvcmVcIiAsXG4gIC8vICAgIGFuZCByZWRpcmVjdCBtb2RlIGlzIFwiZXJyb3JcIi5cbiAgY29uc3QgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICB1cmxMaXN0OiBbcmVxdWVzdFVSTF0sXG4gICAgY2xpZW50LFxuICAgIHNlcnZpY2VXb3JrZXJzOiAnbm9uZScsXG4gICAgcmVmZXJyZXI6ICduby1yZWZlcnJlcicsXG4gICAgbW9kZTogJ3dlYnNvY2tldCcsXG4gICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICBjYWNoZTogJ25vLXN0b3JlJyxcbiAgICByZWRpcmVjdDogJ2Vycm9yJ1xuICB9KVxuXG4gIC8vIE5vdGU6IHVuZGljaSBleHRlbnNpb24sIGFsbG93IHNldHRpbmcgY3VzdG9tIGhlYWRlcnMuXG4gIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycykpXG5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0ID0gaGVhZGVyc0xpc3RcbiAgfVxuXG4gIC8vIDMuIEFwcGVuZCAoYFVwZ3JhZGVgLCBgd2Vic29ja2V0YCkgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDQuIEFwcGVuZCAoYENvbm5lY3Rpb25gLCBgVXBncmFkZWApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyBOb3RlOiBib3RoIG9mIHRoZXNlIGFyZSBoYW5kbGVkIGJ5IHVuZGljaSBjdXJyZW50bHkuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvNjhjMjY5YzQxNDRjNDQ2ZjNmMTIyMDk1MTMzOGRhZWY0YTZiNWVjNC9saWIvY2xpZW50LmpzI0wxMzk3XG5cbiAgLy8gNS4gTGV0IGtleVZhbHVlIGJlIGEgbm9uY2UgY29uc2lzdGluZyBvZiBhIHJhbmRvbWx5IHNlbGVjdGVkXG4gIC8vICAgIDE2LWJ5dGUgdmFsdWUgdGhhdCBoYXMgYmVlbiBmb3JnaXZpbmctYmFzZTY0LWVuY29kZWQgYW5kXG4gIC8vICAgIGlzb21vcnBoaWMgZW5jb2RlZC5cbiAgY29uc3Qga2V5VmFsdWUgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4gIC8vIDYuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtS2V5YCwga2V5VmFsdWUpIHRvIHJlcXVlc3TigJlzXG4gIC8vICAgIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1rZXknLCBrZXlWYWx1ZSlcblxuICAvLyA3LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LVZlcnNpb25gLCBgMTNgKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbicsICcxMycpXG5cbiAgLy8gOC4gRm9yIGVhY2ggcHJvdG9jb2wgaW4gcHJvdG9jb2xzLCBjb21iaW5lXG4gIC8vICAgIChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAsIHByb3RvY29sKSBpbiByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gICAgbGlzdC5cbiAgZm9yIChjb25zdCBwcm90b2NvbCBvZiBwcm90b2NvbHMpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1wcm90b2NvbCcsIHByb3RvY29sKVxuICB9XG5cbiAgLy8gOS4gTGV0IHBlcm1lc3NhZ2VEZWZsYXRlIGJlIGEgdXNlci1hZ2VudCBkZWZpbmVkXG4gIC8vICAgIFwicGVybWVzc2FnZS1kZWZsYXRlXCIgZXh0ZW5zaW9uIGhlYWRlciB2YWx1ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvY2U3ODIzNGY1ZTY1M2E1ZDM5MTY4MTNmZjk5MGYwNTM1MTAyMjdiYy9uZXR3ZXJrL3Byb3RvY29sL3dlYnNvY2tldC9XZWJTb2NrZXRDaGFubmVsLmNwcCNMMjY3M1xuICBjb25zdCBwZXJtZXNzYWdlRGVmbGF0ZSA9ICdwZXJtZXNzYWdlLWRlZmxhdGU7IGNsaWVudF9tYXhfd2luZG93X2JpdHMnXG5cbiAgLy8gMTAuIEFwcGVuZCAoYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AsIHBlcm1lc3NhZ2VEZWZsYXRlKSB0b1xuICAvLyAgICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnLCBwZXJtZXNzYWdlRGVmbGF0ZSlcblxuICAvLyAxMS4gRmV0Y2ggcmVxdWVzdCB3aXRoIHVzZVBhcmFsbGVsUXVldWUgc2V0IHRvIHRydWUsIGFuZFxuICAvLyAgICAgcHJvY2Vzc1Jlc3BvbnNlIGdpdmVuIHJlc3BvbnNlIGJlaW5nIHRoZXNlIHN0ZXBzOlxuICBjb25zdCBjb250cm9sbGVyID0gZmV0Y2hpbmcoe1xuICAgIHJlcXVlc3QsXG4gICAgdXNlUGFyYWxsZWxRdWV1ZTogdHJ1ZSxcbiAgICBkaXNwYXRjaGVyOiBvcHRpb25zLmRpc3BhdGNoZXIsXG4gICAgcHJvY2Vzc1Jlc3BvbnNlIChyZXNwb25zZSkge1xuICAgICAgLy8gMS4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yIG9yIGl0cyBzdGF0dXMgaXMgbm90IDEwMSxcbiAgICAgIC8vICAgIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICdlcnJvcicgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSAxMDEpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBuZXR3b3JrIGVycm9yIG9yIG5vbi0xMDEgc3RhdHVzIGNvZGUuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHByb3RvY29scyBpcyBub3QgdGhlIGVtcHR5IGxpc3QgYW5kIGV4dHJhY3RpbmcgaGVhZGVyXG4gICAgICAvLyAgICBsaXN0IHZhbHVlcyBnaXZlbiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgYW5kIHJlc3BvbnNl4oCZc1xuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgcmVzdWx0cyBpbiBudWxsLCBmYWlsdXJlLCBvciB0aGUgZW1wdHkgYnl0ZVxuICAgICAgLy8gICAgc2VxdWVuY2UsIHRoZW4gZmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gMCAmJiAhcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LVByb3RvY29sJykpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggc2VudCBwcm90b2NvbHMuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEZvbGxvdyB0aGUgcmVxdWlyZW1lbnRzIHN0YXRlZCBzdGVwIDIgdG8gc3RlcCA2LCBpbmNsdXNpdmUsXG4gICAgICAvLyAgICBvZiB0aGUgbGFzdCBzZXQgb2Ygc3RlcHMgaW4gc2VjdGlvbiA0LjEgb2YgVGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgUHJvdG9jb2wgdG8gdmFsaWRhdGUgcmVzcG9uc2UuIFRoaXMgZWl0aGVyIHJlc3VsdHMgaW4gZmFpbFxuICAgICAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9yIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgICAgLy8gICAgZXN0YWJsaXNoZWQuXG5cbiAgICAgIC8vIDIuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhbiB8VXBncmFkZXwgaGVhZGVyIGZpZWxkIG9yIHRoZSB8VXBncmFkZXxcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IGFuIEFTQ0lJIGNhc2UtXG4gICAgICAvLyAgICBpbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwid2Vic29ja2V0XCIsIHRoZSBjbGllbnQgTVVTVFxuICAgICAgLy8gICAgX0ZhaWwgdGhlIFdlYlNvY2tldCBDb25uZWN0aW9uXy5cbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1VwZ3JhZGUnKT8udG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgVXBncmFkZSBoZWFkZXIgdG8gXCJ3ZWJzb2NrZXRcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfENvbm5lY3Rpb258IGhlYWRlciBmaWVsZCBvciB0aGVcbiAgICAgIC8vICAgIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgZG9lc24ndCBjb250YWluIGEgdG9rZW4gdGhhdCBpcyBhblxuICAgICAgLy8gICAgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgdGhlIHZhbHVlIFwiVXBncmFkZVwiLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdDb25uZWN0aW9uJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd1cGdyYWRlJykge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1NlcnZlciBkaWQgbm90IHNldCBDb25uZWN0aW9uIGhlYWRlciB0byBcInVwZ3JhZGVcIi4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gSWYgdGhlIHJlc3BvbnNlIGxhY2tzIGEgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBoZWFkZXIgZmllbGQgb3JcbiAgICAgIC8vICAgIHRoZSB8U2VjLVdlYlNvY2tldC1BY2NlcHR8IGNvbnRhaW5zIGEgdmFsdWUgb3RoZXIgdGhhbiB0aGVcbiAgICAgIC8vICAgIGJhc2U2NC1lbmNvZGVkIFNIQS0xIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSB8U2VjLVdlYlNvY2tldC1cbiAgICAgIC8vICAgIEtleXwgKGFzIGEgc3RyaW5nLCBub3QgYmFzZTY0LWRlY29kZWQpIHdpdGggdGhlIHN0cmluZyBcIjI1OEVBRkE1LVxuICAgICAgLy8gICAgRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExXCIgYnV0IGlnbm9yaW5nIGFueSBsZWFkaW5nIGFuZFxuICAgICAgLy8gICAgdHJhaWxpbmcgd2hpdGVzcGFjZSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjV1NBY2NlcHQgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0JylcbiAgICAgIGNvbnN0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGtleVZhbHVlICsgdWlkKS5kaWdlc3QoJ2Jhc2U2NCcpXG4gICAgICBpZiAoc2VjV1NBY2NlcHQgIT09IGRpZ2VzdCkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ0luY29ycmVjdCBoYXNoIHJlY2VpdmVkIGluIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlci4nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc3wgaGVhZGVyXG4gICAgICAvLyAgICBmaWVsZCBhbmQgdGhpcyBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB1c2Ugb2YgYW4gZXh0ZW5zaW9uXG4gICAgICAvLyAgICB0aGF0IHdhcyBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhc1xuICAgICAgLy8gICAgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50XG4gICAgICAvLyAgICBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uICAoVGhlIHBhcnNpbmcgb2YgdGhpc1xuICAgICAgLy8gICAgaGVhZGVyIGZpZWxkIHRvIGRldGVybWluZSB3aGljaCBleHRlbnNpb25zIGFyZSByZXF1ZXN0ZWQgaXNcbiAgICAgIC8vICAgIGRpc2N1c3NlZCBpbiBTZWN0aW9uIDkuMS4pXG4gICAgICBjb25zdCBzZWNFeHRlbnNpb24gPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucycpXG4gICAgICBsZXQgZXh0ZW5zaW9uc1xuXG4gICAgICBpZiAoc2VjRXh0ZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZUV4dGVuc2lvbnMoc2VjRXh0ZW5zaW9uKVxuXG4gICAgICAgIGlmICghZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGRvZXMgbm90IG1hdGNoLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNi4gSWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGEgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGhlYWRlciBmaWVsZFxuICAgICAgLy8gICAgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGEgc3VicHJvdG9jb2wgdGhhdCB3YXNcbiAgICAgIC8vICAgIG5vdCBwcmVzZW50IGluIHRoZSBjbGllbnQncyBoYW5kc2hha2UgKHRoZSBzZXJ2ZXIgaGFzIGluZGljYXRlZCBhXG4gICAgICAvLyAgICBzdWJwcm90b2NvbCBub3QgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQpLCB0aGUgY2xpZW50IE1VU1QgX0ZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBjb25zdCBzZWNQcm90b2NvbCA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpXG5cbiAgICAgIGlmIChzZWNQcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0UHJvdG9jb2xzID0gZ2V0RGVjb2RlU3BsaXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCByZXF1ZXN0LmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIFRoZSBjbGllbnQgY2FuIHJlcXVlc3QgdGhhdCB0aGUgc2VydmVyIHVzZSBhIHNwZWNpZmljIHN1YnByb3RvY29sIGJ5XG4gICAgICAgIC8vIGluY2x1ZGluZyB0aGUgfFNlYy1XZWJTb2NrZXQtUHJvdG9jb2x8IGZpZWxkIGluIGl0cyBoYW5kc2hha2UuICBJZiBpdFxuICAgICAgICAvLyBpcyBzcGVjaWZpZWQsIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gaW5jbHVkZSB0aGUgc2FtZSBmaWVsZCBhbmQgb25lIG9mXG4gICAgICAgIC8vIHRoZSBzZWxlY3RlZCBzdWJwcm90b2NvbCB2YWx1ZXMgaW4gaXRzIHJlc3BvbnNlIGZvciB0aGUgY29ubmVjdGlvbiB0b1xuICAgICAgICAvLyBiZSBlc3RhYmxpc2hlZC5cbiAgICAgICAgaWYgKCFyZXF1ZXN0UHJvdG9jb2xzLmluY2x1ZGVzKHNlY1Byb3RvY29sKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUHJvdG9jb2wgd2FzIG5vdCBzZXQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdkYXRhJywgb25Tb2NrZXREYXRhKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gICAgICByZXNwb25zZS5zb2NrZXQub24oJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcblxuICAgICAgaWYgKGNoYW5uZWxzLm9wZW4uaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgY2hhbm5lbHMub3Blbi5wdWJsaXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5zb2NrZXQuYWRkcmVzcygpLFxuICAgICAgICAgIHByb3RvY29sOiBzZWNQcm90b2NvbCxcbiAgICAgICAgICBleHRlbnNpb25zOiBzZWNFeHRlbnNpb25cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb25Fc3RhYmxpc2gocmVzcG9uc2UsIGV4dGVuc2lvbnMpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBjb250cm9sbGVyXG59XG5cbmZ1bmN0aW9uIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiAod3MsIGNvZGUsIHJlYXNvbiwgcmVhc29uQnl0ZUxlbmd0aCkge1xuICBpZiAoaXNDbG9zaW5nKHdzKSB8fCBpc0Nsb3NlZCh3cykpIHtcbiAgICAvLyBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ0xPU0lORyAoMikgb3IgQ0xPU0VEICgzKVxuICAgIC8vIERvIG5vdGhpbmcuXG4gIH0gZWxzZSBpZiAoIWlzRXN0YWJsaXNoZWQod3MpKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgZXN0YWJsaXNoZWRcbiAgICAvLyBGYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBhbmQgc2V0IHRoaXMncyByZWFkeSBzdGF0ZVxuICAgIC8vIHRvIENMT1NJTkcgKDIpLlxuICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSBpdCB3YXMgZXN0YWJsaXNoZWQuJylcbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2UgaWYgKHdzW2tTZW50Q2xvc2VdID09PSBzZW50Q2xvc2VGcmFtZVN0YXRlLk5PVF9TRU5UKSB7XG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBiZWVuIHN0YXJ0ZWRcbiAgICAvLyBTdGFydCB0aGUgV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIGFuZCBzZXQgdGhpcydzIHJlYWR5XG4gICAgLy8gc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgLy8gLSBJZiBuZWl0aGVyIGNvZGUgbm9yIHJlYXNvbiBpcyBwcmVzZW50LCB0aGUgV2ViU29ja2V0IENsb3NlXG4gICAgLy8gICBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuICAgIC8vIC0gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgLy8gICBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgLy8gLSBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAvLyAgIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cblxuICAgIHdzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5QUk9DRVNTSU5HXG5cbiAgICBjb25zdCBmcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoKVxuXG4gICAgLy8gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vIG1lc3NhZ2UgbXVzdCBub3QgaGF2ZSBhIGJvZHkuXG5cbiAgICAvLyBJZiBjb2RlIGlzIHByZXNlbnQsIHRoZW4gdGhlIHN0YXR1cyBjb2RlIHRvIHVzZSBpbiB0aGVcbiAgICAvLyBXZWJTb2NrZXQgQ2xvc2UgbWVzc2FnZSBtdXN0IGJlIHRoZSBpbnRlZ2VyIGdpdmVuIGJ5IGNvZGUuXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmIHJlYXNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiByZWFzb24gaXMgYWxzbyBwcmVzZW50LCB0aGVuIHJlYXNvbkJ5dGVzIG11c3QgYmVcbiAgICAgIC8vIHByb3ZpZGVkIGluIHRoZSBDbG9zZSBtZXNzYWdlIGFmdGVyIHRoZSBzdGF0dXMgY29kZS5cbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgcmVhc29uQnl0ZUxlbmd0aClcbiAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZVVJbnQxNkJFKGNvZGUsIDApXG4gICAgICAvLyB0aGUgYm9keSBNQVkgY29udGFpbiBVVEYtOC1lbmNvZGVkIGRhdGEgd2l0aCB2YWx1ZSAvcmVhc29uL1xuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlKHJlYXNvbiwgMiwgJ3V0Zi04JylcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUuZnJhbWVEYXRhID0gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnc3RyZWFtJykuRHVwbGV4fSAqL1xuICAgIGNvbnN0IHNvY2tldCA9IHdzW2tSZXNwb25zZV0uc29ja2V0XG5cbiAgICBzb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSkpXG5cbiAgICB3c1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVFxuXG4gICAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZVxuICAgIC8vIFNldCB0aGlzJ3MgcmVhZHkgc3RhdGUgdG8gQ0xPU0lORyAoMikuXG4gICAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVua1xuICovXG5mdW5jdGlvbiBvblNvY2tldERhdGEgKGNodW5rKSB7XG4gIGlmICghdGhpcy53c1trQnl0ZVBhcnNlcl0ud3JpdGUoY2h1bmspKSB7XG4gICAgdGhpcy5wYXVzZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS40XG4gKi9cbmZ1bmN0aW9uIG9uU29ja2V0Q2xvc2UgKCkge1xuICBjb25zdCB7IHdzIH0gPSB0aGlzXG4gIGNvbnN0IHsgW2tSZXNwb25zZV06IHJlc3BvbnNlIH0gPSB3c1xuXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2RhdGEnLCBvblNvY2tldERhdGEpXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2Nsb3NlJywgb25Tb2NrZXRDbG9zZSlcbiAgcmVzcG9uc2Uuc29ja2V0Lm9mZignZXJyb3InLCBvblNvY2tldEVycm9yKVxuXG4gIC8vIElmIHRoZSBUQ1AgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGFmdGVyIHRoZVxuICAvLyBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2Ugd2FzIGNvbXBsZXRlZCwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gIC8vIGlzIHNhaWQgdG8gaGF2ZSBiZWVuIGNsb3NlZCBfY2xlYW5seV8uXG4gIGNvbnN0IHdhc0NsZWFuID0gd3Nba1NlbnRDbG9zZV0gPT09IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCAmJiB3c1trUmVjZWl2ZWRDbG9zZV1cblxuICBsZXQgY29kZSA9IDEwMDVcbiAgbGV0IHJlYXNvbiA9ICcnXG5cbiAgY29uc3QgcmVzdWx0ID0gd3Nba0J5dGVQYXJzZXJdLmNsb3NpbmdJbmZvXG5cbiAgaWYgKHJlc3VsdCAmJiAhcmVzdWx0LmVycm9yKSB7XG4gICAgY29kZSA9IHJlc3VsdC5jb2RlID8/IDEwMDVcbiAgICByZWFzb24gPSByZXN1bHQucmVhc29uXG4gIH0gZWxzZSBpZiAoIXdzW2tSZWNlaXZlZENsb3NlXSkge1xuICAgIC8vIElmIF9UaGUgV2ViU29ja2V0XG4gICAgLy8gQ29ubmVjdGlvbiBpcyBDbG9zZWRfIGFuZCBubyBDbG9zZSBjb250cm9sIGZyYW1lIHdhcyByZWNlaXZlZCBieSB0aGVcbiAgICAvLyBlbmRwb2ludCAoc3VjaCBhcyBjb3VsZCBvY2N1ciBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY29ubmVjdGlvblxuICAgIC8vIGlzIGxvc3QpLCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzIGNvbnNpZGVyZWQgdG8gYmVcbiAgICAvLyAxMDA2LlxuICAgIGNvZGUgPSAxMDA2XG4gIH1cblxuICAvLyAxLiBDaGFuZ2UgdGhlIHJlYWR5IHN0YXRlIHRvIENMT1NFRCAoMykuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TRURcblxuICAvLyAyLiBJZiB0aGUgdXNlciBhZ2VudCB3YXMgcmVxdWlyZWQgdG8gZmFpbCB0aGUgV2ViU29ja2V0XG4gIC8vICAgIGNvbm5lY3Rpb24sIG9yIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gIC8vICAgIGFmdGVyIGJlaW5nIGZsYWdnZWQgYXMgZnVsbCwgZmlyZSBhbiBldmVudCBuYW1lZCBlcnJvclxuICAvLyAgICBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgY2xvc2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsXG4gIC8vICAgIHVzaW5nIENsb3NlRXZlbnQsIHdpdGggdGhlIHdhc0NsZWFuIGF0dHJpYnV0ZVxuICAvLyAgICBpbml0aWFsaXplZCB0byB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIGNsb3NlZCBjbGVhbmx5XG4gIC8vICAgIGFuZCBmYWxzZSBvdGhlcndpc2UsIHRoZSBjb2RlIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0b1xuICAvLyAgICB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2UgY29kZSwgYW5kIHRoZSByZWFzb25cbiAgLy8gICAgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgVVRGLThcbiAgLy8gICAgZGVjb2RlIHdpdGhvdXQgQk9NIHRvIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZVxuICAvLyAgICByZWFzb24uXG4gIC8vIFRPRE86IHByb2Nlc3MubmV4dFRpY2tcbiAgZmlyZUV2ZW50KCdjbG9zZScsIHdzLCAodHlwZSwgaW5pdCkgPT4gbmV3IENsb3NlRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICB3YXNDbGVhbiwgY29kZSwgcmVhc29uXG4gIH0pXG5cbiAgaWYgKGNoYW5uZWxzLmNsb3NlLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuY2xvc2UucHVibGlzaCh7XG4gICAgICB3ZWJzb2NrZXQ6IHdzLFxuICAgICAgY29kZSxcbiAgICAgIHJlYXNvblxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gb25Tb2NrZXRFcnJvciAoZXJyb3IpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuXG4gIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG5cbiAgaWYgKGNoYW5uZWxzLnNvY2tldEVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgY2hhbm5lbHMuc29ja2V0RXJyb3IucHVibGlzaChlcnJvcilcbiAgfVxuXG4gIHRoaXMuZGVzdHJveSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uLFxuICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb25cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\nconst sentCloseFrameState = {\n  NOT_SENT: 0,\n  PROCESSING: 1,\n  SENT: 2\n}\n\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\nconst sendHints = {\n  string: 1,\n  typedArray: 2,\n  arrayBuffer: 3,\n  blob: 4\n}\n\nmodule.exports = {\n  uid,\n  sentCloseFrameState,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer,\n  sendHints\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBUaGlzIGlzIGEgR2xvYmFsbHkgVW5pcXVlIElkZW50aWZpZXIgdW5pcXVlIHVzZWRcbi8vIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGVuZHBvaW50IGFjY2VwdHMgd2Vic29ja2V0XG4vLyBjb25uZWN0aW9ucy5cbi8vIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tMS4zXG5jb25zdCB1aWQgPSAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJ1xuXG4vKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi9cbmNvbnN0IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIENPTk5FQ1RJTkc6IDAsXG4gIE9QRU46IDEsXG4gIENMT1NJTkc6IDIsXG4gIENMT1NFRDogM1xufVxuXG5jb25zdCBzZW50Q2xvc2VGcmFtZVN0YXRlID0ge1xuICBOT1RfU0VOVDogMCxcbiAgUFJPQ0VTU0lORzogMSxcbiAgU0VOVDogMlxufVxuXG5jb25zdCBvcGNvZGVzID0ge1xuICBDT05USU5VQVRJT046IDB4MCxcbiAgVEVYVDogMHgxLFxuICBCSU5BUlk6IDB4MixcbiAgQ0xPU0U6IDB4OCxcbiAgUElORzogMHg5LFxuICBQT05HOiAweEFcbn1cblxuY29uc3QgbWF4VW5zaWduZWQxNkJpdCA9IDIgKiogMTYgLSAxIC8vIDY1NTM1XG5cbmNvbnN0IHBhcnNlclN0YXRlcyA9IHtcbiAgSU5GTzogMCxcbiAgUEFZTE9BRExFTkdUSF8xNjogMixcbiAgUEFZTE9BRExFTkdUSF82NDogMyxcbiAgUkVBRF9EQVRBOiA0XG59XG5cbmNvbnN0IGVtcHR5QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG5cbmNvbnN0IHNlbmRIaW50cyA9IHtcbiAgc3RyaW5nOiAxLFxuICB0eXBlZEFycmF5OiAyLFxuICBhcnJheUJ1ZmZlcjogMyxcbiAgYmxvYjogNFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdWlkLFxuICBzZW50Q2xvc2VGcmFtZVN0YXRlLFxuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBzdGF0ZXMsXG4gIG9wY29kZXMsXG4gIG1heFVuc2lnbmVkMTZCaXQsXG4gIHBhcnNlclN0YXRlcyxcbiAgZW1wdHlCdWZmZXIsXG4gIHNlbmRIaW50c1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(ssr)/./node_modules/undici/lib/core/symbols.js\")\nconst { MessagePort } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\")\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    if (type === kConstruct) {\n      super(arguments[1], arguments[2])\n      return\n    }\n\n    const prefix = 'MessageEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict')\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent')\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n\n  static createFastMessageEvent (type, init) {\n    const messageEvent = new MessageEvent(kConstruct, type, init)\n    messageEvent.#eventInit = init\n    messageEvent.#eventInit.data ??= null\n    messageEvent.#eventInit.origin ??= ''\n    messageEvent.#eventInit.lastEventId ??= ''\n    messageEvent.#eventInit.source ??= null\n    messageEvent.#eventInit.ports ??= []\n    return messageEvent\n  }\n}\n\nconst { createFastMessageEvent } = MessageEvent\ndelete MessageEvent.createFastMessageEvent\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    const prefix = 'CloseEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    const prefix = 'ErrorEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    super(type, eventInitDict)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: () => null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: () => null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    defaultValue: () => new Array(0)\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent,\n  createFastMessageEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsZ0RBQXFCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcZXZlbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgTWVzc2FnZVBvcnQgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCNtZXNzYWdlZXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIGlmICh0eXBlID09PSBrQ29uc3RydWN0KSB7XG4gICAgICBzdXBlcihhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeCA9ICdNZXNzYWdlRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICB0eXBlID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKHR5cGUsIHByZWZpeCwgJ3R5cGUnKVxuICAgIGV2ZW50SW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0KGV2ZW50SW5pdERpY3QsIHByZWZpeCwgJ2V2ZW50SW5pdERpY3QnKVxuXG4gICAgc3VwZXIodHlwZSwgZXZlbnRJbml0RGljdClcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCBkYXRhICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmRhdGFcbiAgfVxuXG4gIGdldCBvcmlnaW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQub3JpZ2luXG4gIH1cblxuICBnZXQgbGFzdEV2ZW50SWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGFzdEV2ZW50SWRcbiAgfVxuXG4gIGdldCBzb3VyY2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuc291cmNlXG4gIH1cblxuICBnZXQgcG9ydHMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIGlmICghT2JqZWN0LmlzRnJvemVuKHRoaXMuI2V2ZW50SW5pdC5wb3J0cykpIHtcbiAgICAgIE9iamVjdC5mcmVlemUodGhpcy4jZXZlbnRJbml0LnBvcnRzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucG9ydHNcbiAgfVxuXG4gIGluaXRNZXNzYWdlRXZlbnQgKFxuICAgIHR5cGUsXG4gICAgYnViYmxlcyA9IGZhbHNlLFxuICAgIGNhbmNlbGFibGUgPSBmYWxzZSxcbiAgICBkYXRhID0gbnVsbCxcbiAgICBvcmlnaW4gPSAnJyxcbiAgICBsYXN0RXZlbnRJZCA9ICcnLFxuICAgIHNvdXJjZSA9IG51bGwsXG4gICAgcG9ydHMgPSBbXVxuICApIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdNZXNzYWdlRXZlbnQuaW5pdE1lc3NhZ2VFdmVudCcpXG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VFdmVudCh0eXBlLCB7XG4gICAgICBidWJibGVzLCBjYW5jZWxhYmxlLCBkYXRhLCBvcmlnaW4sIGxhc3RFdmVudElkLCBzb3VyY2UsIHBvcnRzXG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50ICh0eXBlLCBpbml0KSB7XG4gICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChrQ29uc3RydWN0LCB0eXBlLCBpbml0KVxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0ID0gaW5pdFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LmRhdGEgPz89IG51bGxcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5vcmlnaW4gPz89ICcnXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQubGFzdEV2ZW50SWQgPz89ICcnXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQuc291cmNlID8/PSBudWxsXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQucG9ydHMgPz89IFtdXG4gICAgcmV0dXJuIG1lc3NhZ2VFdmVudFxuICB9XG59XG5cbmNvbnN0IHsgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gTWVzc2FnZUV2ZW50XG5kZWxldGUgTWVzc2FnZUV2ZW50LmNyZWF0ZUZhc3RNZXNzYWdlRXZlbnRcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1jbG9zZWV2ZW50LWludGVyZmFjZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIGNvbnN0IHByZWZpeCA9ICdDbG9zZUV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQoZXZlbnRJbml0RGljdClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgd2FzQ2xlYW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENsb3NlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0Lndhc0NsZWFuXG4gIH1cblxuICBnZXQgY29kZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29kZVxuICB9XG5cbiAgZ2V0IHJlYXNvbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucmVhc29uXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3RoZS1lcnJvcmV2ZW50LWludGVyZmFjZVxuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgI2V2ZW50SW5pdFxuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBldmVudEluaXREaWN0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ0Vycm9yRXZlbnQgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQoZXZlbnRJbml0RGljdCA/PyB7fSlcblxuICAgIHRoaXMuI2V2ZW50SW5pdCA9IGV2ZW50SW5pdERpY3RcbiAgfVxuXG4gIGdldCBtZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5tZXNzYWdlXG4gIH1cblxuICBnZXQgZmlsZW5hbWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmZpbGVuYW1lXG4gIH1cblxuICBnZXQgbGluZW5vICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5saW5lbm9cbiAgfVxuXG4gIGdldCBjb2xubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuY29sbm9cbiAgfVxuXG4gIGdldCBlcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuZXJyb3JcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhNZXNzYWdlRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdNZXNzYWdlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBkYXRhOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcmlnaW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxhc3RFdmVudElkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzb3VyY2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHBvcnRzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbml0TWVzc2FnZUV2ZW50OiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDbG9zZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnQ2xvc2VFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIHJlYXNvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29kZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgd2FzQ2xlYW46IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVycm9yRXZlbnQucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdFcnJvckV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZmlsZW5hbWU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGxpbmVubzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY29sbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGVycm9yOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoTWVzc2FnZVBvcnQpXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxNZXNzYWdlUG9ydD4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnRcbilcblxuY29uc3QgZXZlbnRJbml0ID0gW1xuICB7XG4gICAga2V5OiAnYnViYmxlcycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NhbmNlbGFibGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjb21wb3NlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5NZXNzYWdlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICdkYXRhJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGtleTogJ29yaWdpbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnbGFzdEV2ZW50SWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ3NvdXJjZScsXG4gICAgLy8gTm9kZSBkb2Vzbid0IGltcGxlbWVudCBXaW5kb3dQcm94eSBvciBTZXJ2aWNlV29ya2VyLCBzbyB0aGUgb25seVxuICAgIC8vIHZhbGlkIHZhbHVlIGZvciBzb3VyY2UgaXMgYSBNZXNzYWdlUG9ydC5cbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5NZXNzYWdlUG9ydCksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdwb3J0cycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ3dhc0NsZWFuJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlYXNvbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9XG5dKVxuXG53ZWJpZGwuY29udmVydGVycy5FcnJvckV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnbWVzc2FnZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJ1xuICB9LFxuICB7XG4gICAga2V5OiAnZmlsZW5hbWUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xpbmVubycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gMFxuICB9LFxuICB7XG4gICAga2V5OiAnY29sbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2Vycm9yJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTWVzc2FnZUV2ZW50LFxuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\n\nconst BUFFER_SIZE = 16386\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEQ7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXGZyYW1lLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG1heFVuc2lnbmVkMTZCaXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgQlVGRkVSX1NJWkUgPSAxNjM4NlxuXG4vKiogQHR5cGUge2ltcG9ydCgnY3J5cHRvJyl9ICovXG5sZXQgY3J5cHRvXG5sZXQgYnVmZmVyID0gbnVsbFxubGV0IGJ1ZklkeCA9IEJVRkZFUl9TSVpFXG5cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbn0gY2F0Y2gge1xuICBjcnlwdG8gPSB7XG4gICAgLy8gbm90IGZ1bGwgY29tcGF0aWJpbGl0eSwgYnV0IG1pbmltdW0uXG4gICAgcmFuZG9tRmlsbFN5bmM6IGZ1bmN0aW9uIHJhbmRvbUZpbGxTeW5jIChidWZmZXIsIF9vZmZzZXQsIF9zaXplKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMjU1IHwgMFxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU1hc2sgKCkge1xuICBpZiAoYnVmSWR4ID09PSBCVUZGRVJfU0laRSkge1xuICAgIGJ1ZklkeCA9IDBcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoKGJ1ZmZlciA/Pz0gQnVmZmVyLmFsbG9jVW5zYWZlKEJVRkZFUl9TSVpFKSksIDAsIEJVRkZFUl9TSVpFKVxuICB9XG4gIHJldHVybiBbYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXSwgYnVmZmVyW2J1ZklkeCsrXV1cbn1cblxuY2xhc3MgV2Vic29ja2V0RnJhbWVTZW5kIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QnVmZmVyfHVuZGVmaW5lZH0gZGF0YVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRhdGEpIHtcbiAgICB0aGlzLmZyYW1lRGF0YSA9IGRhdGFcbiAgfVxuXG4gIGNyZWF0ZUZyYW1lIChvcGNvZGUpIHtcbiAgICBjb25zdCBmcmFtZURhdGEgPSB0aGlzLmZyYW1lRGF0YVxuICAgIGNvbnN0IG1hc2tLZXkgPSBnZW5lcmF0ZU1hc2soKVxuICAgIGNvbnN0IGJvZHlMZW5ndGggPSBmcmFtZURhdGE/LmJ5dGVMZW5ndGggPz8gMFxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBib2R5TGVuZ3RoIC8vIDAtMTI1XG4gICAgbGV0IG9mZnNldCA9IDZcblxuICAgIGlmIChib2R5TGVuZ3RoID4gbWF4VW5zaWduZWQxNkJpdCkge1xuICAgICAgb2Zmc2V0ICs9IDggLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCA4IGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3XG4gICAgfSBlbHNlIGlmIChib2R5TGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMiAvLyBwYXlsb2FkIGxlbmd0aCBpcyBuZXh0IDIgYnl0ZXNcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjZcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYm9keUxlbmd0aCArIG9mZnNldClcblxuICAgIC8vIENsZWFyIGZpcnN0IDIgYnl0ZXMsIGV2ZXJ5dGhpbmcgZWxzZSBpcyBvdmVyd3JpdHRlblxuICAgIGJ1ZmZlclswXSA9IGJ1ZmZlclsxXSA9IDBcbiAgICBidWZmZXJbMF0gfD0gMHg4MCAvLyBGSU5cbiAgICBidWZmZXJbMF0gPSAoYnVmZmVyWzBdICYgMHhGMCkgKyBvcGNvZGUgLy8gb3Bjb2RlXG5cbiAgICAvKiEgd3MuIE1JVCBMaWNlbnNlLiBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT4gKi9cbiAgICBidWZmZXJbb2Zmc2V0IC0gNF0gPSBtYXNrS2V5WzBdXG4gICAgYnVmZmVyW29mZnNldCAtIDNdID0gbWFza0tleVsxXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAyXSA9IG1hc2tLZXlbMl1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMV0gPSBtYXNrS2V5WzNdXG5cbiAgICBidWZmZXJbMV0gPSBwYXlsb2FkTGVuZ3RoXG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MTZCRShib2R5TGVuZ3RoLCAyKVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAvLyBDbGVhciBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aFxuICAgICAgYnVmZmVyWzJdID0gYnVmZmVyWzNdID0gMFxuICAgICAgYnVmZmVyLndyaXRlVUludEJFKGJvZHlMZW5ndGgsIDQsIDYpXG4gICAgfVxuXG4gICAgYnVmZmVyWzFdIHw9IDB4ODAgLy8gTUFTS1xuXG4gICAgLy8gbWFzayBib2R5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGZyYW1lRGF0YVtpXSBeIG1hc2tLZXlbaSAmIDNdXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJzb2NrZXRGcmFtZVNlbmRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\")\n\nconst tail = Buffer.from([0x00, 0x00, 0xff, 0xff])\nconst kBuffer = Symbol('kBuffer')\nconst kLength = Symbol('kLength')\n\nclass PerMessageDeflate {\n  /** @type {import('node:zlib').InflateRaw} */\n  #inflate\n\n  #options = {}\n\n  constructor (extensions) {\n    this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover')\n    this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits')\n  }\n\n  decompress (chunk, fin, callback) {\n    // An endpoint uses the following algorithm to decompress a message.\n    // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n    //     payload of the message.\n    // 2.  Decompress the resulting data using DEFLATE.\n\n    if (!this.#inflate) {\n      let windowBits = Z_DEFAULT_WINDOWBITS\n\n      if (this.#options.serverMaxWindowBits) { // empty values default to Z_DEFAULT_WINDOWBITS\n        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n          callback(new Error('Invalid server_max_window_bits'))\n          return\n        }\n\n        windowBits = Number.parseInt(this.#options.serverMaxWindowBits)\n      }\n\n      this.#inflate = createInflateRaw({ windowBits })\n      this.#inflate[kBuffer] = []\n      this.#inflate[kLength] = 0\n\n      this.#inflate.on('data', (data) => {\n        this.#inflate[kBuffer].push(data)\n        this.#inflate[kLength] += data.length\n      })\n\n      this.#inflate.on('error', (err) => {\n        this.#inflate = null\n        callback(err)\n      })\n    }\n\n    this.#inflate.write(chunk)\n    if (fin) {\n      this.#inflate.write(tail)\n    }\n\n    this.#inflate.flush(() => {\n      const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength])\n\n      this.#inflate[kBuffer].length = 0\n      this.#inflate[kLength] = 0\n\n      callback(null, full)\n    })\n  }\n}\n\nmodule.exports = { PerMessageDeflate }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDdEUsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFFQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxccGVybWVzc2FnZS1kZWZsYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGNyZWF0ZUluZmxhdGVSYXcsIFpfREVGQVVMVF9XSU5ET1dCSVRTIH0gPSByZXF1aXJlKCdub2RlOnpsaWInKVxuY29uc3QgeyBpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuY29uc3QgdGFpbCA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSlcbmNvbnN0IGtCdWZmZXIgPSBTeW1ib2woJ2tCdWZmZXInKVxuY29uc3Qga0xlbmd0aCA9IFN5bWJvbCgna0xlbmd0aCcpXG5cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6emxpYicpLkluZmxhdGVSYXd9ICovXG4gICNpbmZsYXRlXG5cbiAgI29wdGlvbnMgPSB7fVxuXG4gIGNvbnN0cnVjdG9yIChleHRlbnNpb25zKSB7XG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9IGV4dGVuc2lvbnMuaGFzKCdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcicpXG4gICAgdGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID0gZXh0ZW5zaW9ucy5nZXQoJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKVxuICB9XG5cbiAgZGVjb21wcmVzcyAoY2h1bmssIGZpbiwgY2FsbGJhY2spIHtcbiAgICAvLyBBbiBlbmRwb2ludCB1c2VzIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtIHRvIGRlY29tcHJlc3MgYSBtZXNzYWdlLlxuICAgIC8vIDEuICBBcHBlbmQgNCBvY3RldHMgb2YgMHgwMCAweDAwIDB4ZmYgMHhmZiB0byB0aGUgdGFpbCBlbmQgb2YgdGhlXG4gICAgLy8gICAgIHBheWxvYWQgb2YgdGhlIG1lc3NhZ2UuXG4gICAgLy8gMi4gIERlY29tcHJlc3MgdGhlIHJlc3VsdGluZyBkYXRhIHVzaW5nIERFRkxBVEUuXG5cbiAgICBpZiAoIXRoaXMuI2luZmxhdGUpIHtcbiAgICAgIGxldCB3aW5kb3dCaXRzID0gWl9ERUZBVUxUX1dJTkRPV0JJVFNcblxuICAgICAgaWYgKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykgeyAvLyBlbXB0eSB2YWx1ZXMgZGVmYXVsdCB0byBaX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICBpZiAoIWlzVmFsaWRDbGllbnRXaW5kb3dCaXRzKHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykpIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmVyX21heF93aW5kb3dfYml0cycpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93Qml0cyA9IE51bWJlci5wYXJzZUludCh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2luZmxhdGUgPSBjcmVhdGVJbmZsYXRlUmF3KHsgd2luZG93Qml0cyB9KVxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSA9IFtdXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICB0aGlzLiNpbmZsYXRlLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5wdXNoKGRhdGEpXG4gICAgICAgIHRoaXMuI2luZmxhdGVba0xlbmd0aF0gKz0gZGF0YS5sZW5ndGhcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuI2luZmxhdGUub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNpbmZsYXRlID0gbnVsbFxuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUud3JpdGUoY2h1bmspXG4gICAgaWYgKGZpbikge1xuICAgICAgdGhpcy4jaW5mbGF0ZS53cml0ZSh0YWlsKVxuICAgIH1cblxuICAgIHRoaXMuI2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZnVsbCA9IEJ1ZmZlci5jb25jYXQodGhpcy4jaW5mbGF0ZVtrQnVmZmVyXSwgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSlcblxuICAgICAgdGhpcy4jaW5mbGF0ZVtrQnVmZmVyXS5sZW5ndGggPSAwXG4gICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdID0gMFxuXG4gICAgICBjYWxsYmFjayhudWxsLCBmdWxsKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFBlck1lc3NhZ2VEZWZsYXRlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(ssr)/./node_modules/undici/lib/core/diagnostics.js\")\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(ssr)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\")\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  constructor (ws, extensions) {\n    super()\n\n    this.ws = ws\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.ws, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.ws, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.ws, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.ws, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.ws, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.#fragments.push(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              const fullMessage = Buffer.concat(this.#fragments)\n              websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage)\n              this.#fragments.length = 0\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length)\n                return\n              }\n\n              this.#fragments.push(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments))\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.#fragments.length = 0\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        closeWebSocketConnection(this.ws, code, reason, reason.length)\n        failWebsocketConnection(this.ws, reason)\n        return false\n      }\n\n      if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(\n          closeFrame.createFrame(opcodes.CLOSE),\n          (err) => {\n            if (!err) {\n              this.ws[kSentClose] = sentCloseFrameState.SENT\n            }\n          }\n        )\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.ws[kReadyState] = states.CLOSING\n      this.ws[kReceivedClose] = true\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.ws[kReceivedClose]) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          })\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        })\n      }\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRyxRQUFRLHFEQUFxRCxFQUFFLG1CQUFPLENBQUMsMkVBQVc7QUFDbEYsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDcEIsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHVFQUFTO0FBQ2hELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYztBQUMzRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsaUdBQXNCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsZ0NBQWdDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw2Q0FBNkMsTUFBTSxNQUFNO0FBQ3JKLHFHQUFxRyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZTtBQUNmOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLHdCQUF3Qjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHJlY2VpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IHBhcnNlclN0YXRlcywgb3Bjb2Rlcywgc3RhdGVzLCBlbXB0eUJ1ZmZlciwgc2VudENsb3NlRnJhbWVTdGF0ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrUmVhZHlTdGF0ZSwga1NlbnRDbG9zZSwga1Jlc3BvbnNlLCBrUmVjZWl2ZWRDbG9zZSB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZGlhZ25vc3RpY3MnKVxuY29uc3Qge1xuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZE9wY29kZSxcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc0NvbnRpbnVhdGlvbkZyYW1lXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcbmNvbnN0IHsgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBQZXJNZXNzYWdlRGVmbGF0ZSB9ID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKVxuXG4vLyBUaGlzIGNvZGUgd2FzIGluZmx1ZW5jZWQgYnkgd3MgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuLy8gQ29weXJpZ2h0IChjKSAyMDExIEVpbmFyIE90dG8gU3Rhbmd2aWsgPGVpbmFyb3NAZ21haWwuY29tPlxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFybm91dCBLYXplbWllciBhbmQgY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgTHVpZ2kgUGluY2EgYW5kIGNvbnRyaWJ1dG9yc1xuXG5jbGFzcyBCeXRlUGFyc2VyIGV4dGVuZHMgV3JpdGFibGUge1xuICAjYnVmZmVycyA9IFtdXG4gICNieXRlT2Zmc2V0ID0gMFxuICAjbG9vcCA9IGZhbHNlXG5cbiAgI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cblxuICAjaW5mbyA9IHt9XG4gICNmcmFnbWVudHMgPSBbXVxuXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgUGVyTWVzc2FnZURlZmxhdGU+fSAqL1xuICAjZXh0ZW5zaW9uc1xuXG4gIGNvbnN0cnVjdG9yICh3cywgZXh0ZW5zaW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMud3MgPSB3c1xuICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zID09IG51bGwgPyBuZXcgTWFwKCkgOiBleHRlbnNpb25zXG5cbiAgICBpZiAodGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICB0aGlzLiNleHRlbnNpb25zLnNldCgncGVybWVzc2FnZS1kZWZsYXRlJywgbmV3IFBlck1lc3NhZ2VEZWZsYXRlKGV4dGVuc2lvbnMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAgICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgKi9cbiAgX3dyaXRlIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLiNidWZmZXJzLnB1c2goY2h1bmspXG4gICAgdGhpcy4jYnl0ZU9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLiNsb29wID0gdHJ1ZVxuXG4gICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUnVucyB3aGVuZXZlciBhIG5ldyBjaHVuayBpcyByZWNlaXZlZC5cbiAgICogQ2FsbGJhY2sgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyBidWZmZXJpbmcsXG4gICAqIG9yIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGJ1ZmZlcmVkIHRvIHBhcnNlLlxuICAgKi9cbiAgcnVuIChjYWxsYmFjaykge1xuICAgIHdoaWxlICh0aGlzLiNsb29wKSB7XG4gICAgICBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5JTkZPKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBlbm91Z2ggYnl0ZXMgdG8gcGFyc2UgdGhlIHBheWxvYWQgbGVuZ3RoLCBldGMuXG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgMikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoMilcbiAgICAgICAgY29uc3QgZmluID0gKGJ1ZmZlclswXSAmIDB4ODApICE9PSAwXG4gICAgICAgIGNvbnN0IG9wY29kZSA9IGJ1ZmZlclswXSAmIDB4MEZcbiAgICAgICAgY29uc3QgbWFza2VkID0gKGJ1ZmZlclsxXSAmIDB4ODApID09PSAweDgwXG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnRlZCA9ICFmaW4gJiYgb3Bjb2RlICE9PSBvcGNvZGVzLkNPTlRJTlVBVElPTlxuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gYnVmZmVyWzFdICYgMHg3RlxuXG4gICAgICAgIGNvbnN0IHJzdjEgPSBidWZmZXJbMF0gJiAweDQwXG4gICAgICAgIGNvbnN0IHJzdjIgPSBidWZmZXJbMF0gJiAweDIwXG4gICAgICAgIGNvbnN0IHJzdjMgPSBidWZmZXJbMF0gJiAweDEwXG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkT3Bjb2RlKG9wY29kZSkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnSW52YWxpZCBvcGNvZGUgcmVjZWl2ZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFza2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ZyYW1lIGNhbm5vdCBiZSBtYXNrZWQnKVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBNVVNUIGJlIDAgdW5sZXNzIGFuIGV4dGVuc2lvbiBpcyBuZWdvdGlhdGVkIHRoYXQgZGVmaW5lcyBtZWFuaW5nc1xuICAgICAgICAvLyBmb3Igbm9uLXplcm8gdmFsdWVzLiAgSWYgYSBub256ZXJvIHZhbHVlIGlzIHJlY2VpdmVkIGFuZCBub25lIG9mXG4gICAgICAgIC8vIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnMgZGVmaW5lcyB0aGUgbWVhbmluZyBvZiBzdWNoIGEgbm9uemVyb1xuICAgICAgICAvLyB2YWx1ZSwgdGhlIHJlY2VpdmluZyBlbmRwb2ludCBNVVNUIF9GYWlsIHRoZSBXZWJTb2NrZXRcbiAgICAgICAgLy8gQ29ubmVjdGlvbl8uXG4gICAgICAgIC8vIFRoaXMgZG9jdW1lbnQgYWxsb2NhdGVzIHRoZSBSU1YxIGJpdCBvZiB0aGUgV2ViU29ja2V0IGhlYWRlciBmb3JcbiAgICAgICAgLy8gUE1DRXMgYW5kIGNhbGxzIHRoZSBiaXQgdGhlIFwiUGVyLU1lc3NhZ2UgQ29tcHJlc3NlZFwiIGJpdC4gIE9uIGFcbiAgICAgICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gd2hlcmUgYSBQTUNFIGlzIGluIHVzZSwgdGhpcyBiaXQgaW5kaWNhdGVzXG4gICAgICAgIC8vIHdoZXRoZXIgYSBtZXNzYWdlIGlzIGNvbXByZXNzZWQgb3Igbm90LlxuICAgICAgICBpZiAocnN2MSAhPT0gMCAmJiAhdGhpcy4jZXh0ZW5zaW9ucy5oYXMoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0V4cGVjdGVkIFJTVjEgdG8gYmUgY2xlYXIuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyc3YyICE9PSAwIHx8IHJzdjMgIT09IDApIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUlNWMSwgUlNWMiwgUlNWMyBtdXN0IGJlIGNsZWFyJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudGVkICYmICFpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgLy8gT25seSB0ZXh0IGFuZCBiaW5hcnkgZnJhbWVzIGNhbiBiZSBmcmFnbWVudGVkXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ludmFsaWQgZnJhbWUgdHlwZSB3YXMgZnJhZ21lbnRlZC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFyc2luZyBhIHRleHQvYmluYXJ5IGZyYW1lIGFuZCBkbyBub3QgcmVjZWl2ZSBlaXRoZXJcbiAgICAgICAgLy8gYSBjb250aW51YXRpb24gZnJhbWUgb3IgY2xvc2UgZnJhbWUsIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIGlmIChpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpICYmIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0V4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4jaW5mby5mcmFnbWVudGVkICYmIGZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAvLyBBIGZyYWdtZW50ZWQgZnJhbWUgY2FuJ3QgYmUgZnJhZ21lbnRlZCBpdHNlbGZcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnRnJhZ21lbnRlZCBmcmFtZSBleGNlZWRlZCAxMjUgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFwiQWxsIGNvbnRyb2wgZnJhbWVzIE1VU1QgaGF2ZSBhIHBheWxvYWQgbGVuZ3RoIG9mIDEyNSBieXRlcyBvciBsZXNzXG4gICAgICAgIC8vIGFuZCBNVVNUIE5PVCBiZSBmcmFnbWVudGVkLlwiXG4gICAgICAgIGlmICgocGF5bG9hZExlbmd0aCA+IDEyNSB8fCBmcmFnbWVudGVkKSAmJiBpc0NvbnRyb2xGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0NvbnRyb2wgZnJhbWUgZWl0aGVyIHRvbyBsYXJnZSBvciBmcmFnbWVudGVkJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbnRpbnVhdGlvbkZyYW1lKG9wY29kZSkgJiYgdGhpcy4jZnJhZ21lbnRzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy4jaW5mby5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1VuZXhwZWN0ZWQgY29udGludWF0aW9uIGZyYW1lJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkTGVuZ3RoIDw9IDEyNSkge1xuICAgICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IHBheWxvYWRMZW5ndGhcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzE2XG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLmJpbmFyeVR5cGUgPSBvcGNvZGVcbiAgICAgICAgICB0aGlzLiNpbmZvLmNvbXByZXNzZWQgPSByc3YxICE9PSAwXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNpbmZvLm9wY29kZSA9IG9wY29kZVxuICAgICAgICB0aGlzLiNpbmZvLm1hc2tlZCA9IG1hc2tlZFxuICAgICAgICB0aGlzLiNpbmZvLmZpbiA9IGZpblxuICAgICAgICB0aGlzLiNpbmZvLmZyYWdtZW50ZWQgPSBmcmFnbWVudGVkXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNikge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKVxuICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5SRUFEX0RBVEFcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jc3RhdGUgPT09IHBhcnNlclN0YXRlcy5QQVlMT0FETEVOR1RIXzY0KSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgOCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmNvbnN1bWUoOClcbiAgICAgICAgY29uc3QgdXBwZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDApXG5cbiAgICAgICAgLy8gMl4zMSBpcyB0aGUgbWF4aW11bSBieXRlcyBhbiBhcnJheWJ1ZmZlciBjYW4gY29udGFpblxuICAgICAgICAvLyBvbiAzMi1iaXQgc3lzdGVtcy4gQWx0aG91Z2gsIG9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzXG4gICAgICAgIC8vIDJeNTMtMSBieXRlcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRXJyb3JzL0ludmFsaWRfYXJyYXlfbGVuZ3RoXG4gICAgICAgIC8vIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOnY4L3NyYy9jb21tb24vZ2xvYmFscy5oO2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlO2Jwdj0xO2JwdD0xO2w9MTI3NVxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvb2JqZWN0cy9qcy1hcnJheS1idWZmZXIuaDtsPTM0O2RyYz0xOTQ2MjEyYWMwMTAwNjY4ZjE0ZWI5ZTI4NDNiZGQ4NDZlNTEwYTFlXG4gICAgICAgIGlmICh1cHBlciA+IDIgKiogMzEgLSAxKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JlY2VpdmVkIHBheWxvYWQgbGVuZ3RoID4gMl4zMSBieXRlcy4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSBidWZmZXIucmVhZFVJbnQzMkJFKDQpXG5cbiAgICAgICAgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoID0gKHVwcGVyIDw8IDgpICsgbG93ZXJcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBKSB7XG4gICAgICAgIGlmICh0aGlzLiNieXRlT2Zmc2V0IDwgdGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmNvbnN1bWUodGhpcy4jaW5mby5wYXlsb2FkTGVuZ3RoKVxuXG4gICAgICAgIGlmIChpc0NvbnRyb2xGcmFtZSh0aGlzLiNpbmZvLm9wY29kZSkpIHtcbiAgICAgICAgICB0aGlzLiNsb29wID0gdGhpcy5wYXJzZUNvbnRyb2xGcmFtZShib2R5KVxuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLnB1c2goYm9keSlcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGlzIG5vdCBmcmFnbWVudGVkLCBhIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnJhbWUgaXMgZnJhZ21lbnRlZCwgaXQgd2lsbCB0ZXJtaW5hdGUgd2l0aCBhIGZpbiBiaXQgc2V0XG4gICAgICAgICAgICAvLyBhbmQgYW4gb3Bjb2RlIG9mIDAgKGNvbnRpbnVhdGlvbiksIHRoZXJlZm9yZSB3ZSBoYW5kbGUgdGhhdCB3aGVuXG4gICAgICAgICAgICAvLyBwYXJzaW5nIGNvbnRpbnVhdGlvbiBmcmFtZXMsIG5vdCBoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmZyYWdtZW50ZWQgJiYgdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2ZyYWdtZW50cylcbiAgICAgICAgICAgICAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkKHRoaXMud3MsIHRoaXMuI2luZm8uYmluYXJ5VHlwZSwgZnVsbE1lc3NhZ2UpXG4gICAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLklORk9cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZXh0ZW5zaW9ucy5nZXQoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpLmRlY29tcHJlc3MoYm9keSwgdGhpcy4jaW5mby5maW4sIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcy53cywgMTAwNywgZXJyb3IubWVzc2FnZSwgZXJyb3IubWVzc2FnZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMucHVzaChkYXRhKVxuXG4gICAgICAgICAgICAgIGlmICghdGhpcy4jaW5mby5maW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCh0aGlzLndzLCB0aGlzLiNpbmZvLmJpbmFyeVR5cGUsIEJ1ZmZlci5jb25jYXQodGhpcy4jZnJhZ21lbnRzKSlcblxuICAgICAgICAgICAgICB0aGlzLiNsb29wID0gdHJ1ZVxuICAgICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy4jbG9vcCA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIG4gYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgQnVmZmVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gblxuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgY29uc3VtZSAobikge1xuICAgIGlmIChuID4gdGhpcy4jYnl0ZU9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsZWQgY29uc3VtZSgpIGJlZm9yZSBidWZmZXJzIHNhdGlhdGVkLicpXG4gICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICByZXR1cm4gZW1wdHlCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYnVmZmVyc1swXS5sZW5ndGggPT09IG4pIHtcbiAgICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gdGhpcy4jYnVmZmVyc1swXS5sZW5ndGhcbiAgICAgIHJldHVybiB0aGlzLiNidWZmZXJzLnNoaWZ0KClcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgd2hpbGUgKG9mZnNldCAhPT0gbikge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMuI2J1ZmZlcnNbMF1cbiAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBuZXh0XG5cbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPT09IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldCh0aGlzLiNidWZmZXJzLnNoaWZ0KCksIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gbikge1xuICAgICAgICBidWZmZXIuc2V0KG5leHQuc3ViYXJyYXkoMCwgbiAtIG9mZnNldCksIG9mZnNldClcbiAgICAgICAgdGhpcy4jYnVmZmVyc1swXSA9IG5leHQuc3ViYXJyYXkobiAtIG9mZnNldClcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBuZXh0Lmxlbmd0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2J5dGVPZmZzZXQgLT0gblxuXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgcGFyc2VDbG9zZUJvZHkgKGRhdGEpIHtcbiAgICBhc3NlcnQoZGF0YS5sZW5ndGggIT09IDEpXG5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgY29kZVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDIpIHtcbiAgICAgIC8vIF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gQ2xvc2UgQ29kZV8gaXNcbiAgICAgIC8vIGRlZmluZWQgYXMgdGhlIHN0YXR1cyBjb2RlIChTZWN0aW9uIDcuNCkgY29udGFpbmVkIGluIHRoZSBmaXJzdCBDbG9zZVxuICAgICAgLy8gY29udHJvbCBmcmFtZSByZWNlaXZlZCBieSB0aGUgYXBwbGljYXRpb25cbiAgICAgIGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKVxuICAgIH1cblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4geyBjb2RlOiAxMDAyLCByZWFzb246ICdJbnZhbGlkIHN0YXR1cyBjb2RlJywgZXJyb3I6IHRydWUgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTcuMS42XG4gICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovXG4gICAgbGV0IHJlYXNvbiA9IGRhdGEuc3ViYXJyYXkoMilcblxuICAgIC8vIFJlbW92ZSBCT01cbiAgICBpZiAocmVhc29uWzBdID09PSAweEVGICYmIHJlYXNvblsxXSA9PT0gMHhCQiAmJiByZWFzb25bMl0gPT09IDB4QkYpIHtcbiAgICAgIHJlYXNvbiA9IHJlYXNvbi5zdWJhcnJheSgzKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZWFzb24gPSB1dGY4RGVjb2RlKHJlYXNvbilcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB7IGNvZGU6IDEwMDcsIHJlYXNvbjogJ0ludmFsaWQgVVRGLTgnLCBlcnJvcjogdHJ1ZSB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29kZSwgcmVhc29uLCBlcnJvcjogZmFsc2UgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBjb250cm9sIGZyYW1lcy5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGJvZHlcbiAgICovXG4gIHBhcnNlQ29udHJvbEZyYW1lIChib2R5KSB7XG4gICAgY29uc3QgeyBvcGNvZGUsIHBheWxvYWRMZW5ndGggfSA9IHRoaXMuI2luZm9cblxuICAgIGlmIChvcGNvZGUgPT09IG9wY29kZXMuQ0xPU0UpIHtcbiAgICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBjbG9zZSBmcmFtZSB3aXRoIGEgMS1ieXRlIGJvZHkuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2luZm8uY2xvc2VJbmZvID0gdGhpcy5wYXJzZUNsb3NlQm9keShib2R5KVxuXG4gICAgICBpZiAodGhpcy4jaW5mby5jbG9zZUluZm8uZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBjb2RlLCByZWFzb24gfSA9IHRoaXMuI2luZm8uY2xvc2VJbmZvXG5cbiAgICAgICAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsIGNvZGUsIHJlYXNvbiwgcmVhc29uLmxlbmd0aClcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgcmVhc29uKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3Nba1NlbnRDbG9zZV0gIT09IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVCkge1xuICAgICAgICAvLyBJZiBhbiBlbmRwb2ludCByZWNlaXZlcyBhIENsb3NlIGZyYW1lIGFuZCBkaWQgbm90IHByZXZpb3VzbHkgc2VuZCBhXG4gICAgICAgIC8vIENsb3NlIGZyYW1lLCB0aGUgZW5kcG9pbnQgTVVTVCBzZW5kIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UuICAoV2hlblxuICAgICAgICAvLyBzZW5kaW5nIGEgQ2xvc2UgZnJhbWUgaW4gcmVzcG9uc2UsIHRoZSBlbmRwb2ludCB0eXBpY2FsbHkgZWNob3MgdGhlXG4gICAgICAgIC8vIHN0YXR1cyBjb2RlIGl0IHJlY2VpdmVkLilcbiAgICAgICAgbGV0IGJvZHkgPSBlbXB0eUJ1ZmZlclxuICAgICAgICBpZiAodGhpcy4jaW5mby5jbG9zZUluZm8uY29kZSkge1xuICAgICAgICAgIGJvZHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgICAgICAgICBib2R5LndyaXRlVUludDE2QkUodGhpcy4jaW5mby5jbG9zZUluZm8uY29kZSwgMClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZUZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQud3JpdGUoXG4gICAgICAgICAgY2xvc2VGcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLkNMT1NFKSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICB0aGlzLndzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5TRU5UXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgICAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICAgICAgdGhpcy53c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuICAgICAgdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0gPSB0cnVlXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAob3Bjb2RlID09PSBvcGNvZGVzLlBJTkcpIHtcbiAgICAgIC8vIFVwb24gcmVjZWlwdCBvZiBhIFBpbmcgZnJhbWUsIGFuIGVuZHBvaW50IE1VU1Qgc2VuZCBhIFBvbmcgZnJhbWUgaW5cbiAgICAgIC8vIHJlc3BvbnNlLCB1bmxlc3MgaXQgYWxyZWFkeSByZWNlaXZlZCBhIENsb3NlIGZyYW1lLlxuICAgICAgLy8gQSBQb25nIGZyYW1lIHNlbnQgaW4gcmVzcG9uc2UgdG8gYSBQaW5nIGZyYW1lIG11c3QgaGF2ZSBpZGVudGljYWxcbiAgICAgIC8vIFwiQXBwbGljYXRpb24gZGF0YVwiXG5cbiAgICAgIGlmICghdGhpcy53c1trUmVjZWl2ZWRDbG9zZV0pIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKGJvZHkpXG5cbiAgICAgICAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC53cml0ZShmcmFtZS5jcmVhdGVGcmFtZShvcGNvZGVzLlBPTkcpKVxuXG4gICAgICAgIGlmIChjaGFubmVscy5waW5nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgICAgY2hhbm5lbHMucGluZy5wdWJsaXNoKHtcbiAgICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wY29kZXMuUE9ORykge1xuICAgICAgLy8gQSBQb25nIGZyYW1lIE1BWSBiZSBzZW50IHVuc29saWNpdGVkLiAgVGhpcyBzZXJ2ZXMgYXMgYVxuICAgICAgLy8gdW5pZGlyZWN0aW9uYWwgaGVhcnRiZWF0LiAgQSByZXNwb25zZSB0byBhbiB1bnNvbGljaXRlZCBQb25nIGZyYW1lIGlzXG4gICAgICAvLyBub3QgZXhwZWN0ZWQuXG5cbiAgICAgIGlmIChjaGFubmVscy5wb25nLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLnBvbmcucHVibGlzaCh7XG4gICAgICAgICAgcGF5bG9hZDogYm9keVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBnZXQgY2xvc2luZ0luZm8gKCkge1xuICAgIHJldHVybiB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCeXRlUGFyc2VyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(ssr)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\n\n/** @type {typeof Uint8Array} */\nconst FastBuffer = Buffer[Symbol.species]\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      const frame = createFrame(item, hint)\n      if (!this.#running) {\n        // fast-path\n        this.#socket.write(frame, cb)\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.string:\n      return Buffer.from(data)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new FastBuffer(data)\n    case sendHints.typedArray:\n      return new FastBuffer(data.buffer, data.byteOffset, data.byteLength)\n  }\n}\n\nmodule.exports = { SendQueue }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLCtGQUE4Qjs7QUFFekQsV0FBVyxtQkFBbUI7QUFDOUI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcc2VuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IG9wY29kZXMsIHNlbmRIaW50cyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4uLy4uL2Rpc3BhdGNoZXIvZml4ZWQtcXVldWUnKVxuXG4vKiogQHR5cGUge3R5cGVvZiBVaW50OEFycmF5fSAqL1xuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc11cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZW5kUXVldWVOb2RlXG4gKiBAcHJvcGVydHkge1Byb21pc2U8dm9pZD4gfCBudWxsfSBwcm9taXNlXG4gKiBAcHJvcGVydHkgeygoLi4uYXJnczogYW55W10pID0+IGFueSl9IGNhbGxiYWNrXG4gKiBAcHJvcGVydHkge0J1ZmZlciB8IG51bGx9IGZyYW1lXG4gKi9cblxuY2xhc3MgU2VuZFF1ZXVlIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGaXhlZFF1ZXVlfVxuICAgKi9cbiAgI3F1ZXVlID0gbmV3IEZpeGVkUXVldWUoKVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gICNydW5uaW5nID0gZmFsc2VcblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpuZXQnKS5Tb2NrZXR9ICovXG4gICNzb2NrZXRcblxuICBjb25zdHJ1Y3RvciAoc29ja2V0KSB7XG4gICAgdGhpcy4jc29ja2V0ID0gc29ja2V0XG4gIH1cblxuICBhZGQgKGl0ZW0sIGNiLCBoaW50KSB7XG4gICAgaWYgKGhpbnQgIT09IHNlbmRIaW50cy5ibG9iKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IGNyZWF0ZUZyYW1lKGl0ZW0sIGhpbnQpXG4gICAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgICAgLy8gZmFzdC1wYXRoXG4gICAgICAgIHRoaXMuI3NvY2tldC53cml0ZShmcmFtZSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgcHJvbWlzZTogbnVsbCxcbiAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgICAgZnJhbWVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1NlbmRRdWV1ZU5vZGV9ICovXG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIHByb21pc2U6IGl0ZW0uYXJyYXlCdWZmZXIoKS50aGVuKChhYikgPT4ge1xuICAgICAgICBub2RlLnByb21pc2UgPSBudWxsXG4gICAgICAgIG5vZGUuZnJhbWUgPSBjcmVhdGVGcmFtZShhYiwgaGludClcbiAgICAgIH0pLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgZnJhbWU6IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLiNxdWV1ZS5wdXNoKG5vZGUpXG5cbiAgICBpZiAoIXRoaXMuI3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuI3J1bigpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3J1biAoKSB7XG4gICAgdGhpcy4jcnVubmluZyA9IHRydWVcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuI3F1ZXVlXG4gICAgd2hpbGUgKCFxdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICAvLyB3YWl0IHBlbmRpbmcgcHJvbWlzZVxuICAgICAgaWYgKG5vZGUucHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBub2RlLnByb21pc2VcbiAgICAgIH1cbiAgICAgIC8vIHdyaXRlXG4gICAgICB0aGlzLiNzb2NrZXQud3JpdGUobm9kZS5mcmFtZSwgbm9kZS5jYWxsYmFjaylcbiAgICAgIC8vIGNsZWFudXBcbiAgICAgIG5vZGUuY2FsbGJhY2sgPSBub2RlLmZyYW1lID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLiNydW5uaW5nID0gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFtZSAoZGF0YSwgaGludCkge1xuICByZXR1cm4gbmV3IFdlYnNvY2tldEZyYW1lU2VuZCh0b0J1ZmZlcihkYXRhLCBoaW50KSkuY3JlYXRlRnJhbWUoaGludCA9PT0gc2VuZEhpbnRzLnN0cmluZyA/IG9wY29kZXMuVEVYVCA6IG9wY29kZXMuQklOQVJZKVxufVxuXG5mdW5jdGlvbiB0b0J1ZmZlciAoZGF0YSwgaGludCkge1xuICBzd2l0Y2ggKGhpbnQpIHtcbiAgICBjYXNlIHNlbmRIaW50cy5zdHJpbmc6XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSlcbiAgICBjYXNlIHNlbmRIaW50cy5hcnJheUJ1ZmZlcjpcbiAgICBjYXNlIHNlbmRIaW50cy5ibG9iOlxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGRhdGEpXG4gICAgY2FzZSBzZW5kSGludHMudHlwZWRBcnJheTpcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFNlbmRRdWV1ZSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kWebSocketURL: Symbol('url'),\n  kReadyState: Symbol('ready state'),\n  kController: Symbol('controller'),\n  kResponse: Symbol('response'),\n  kBinaryType: Symbol('binary type'),\n  kSentClose: Symbol('sent close'),\n  kReceivedClose: Symbol('received close'),\n  kByteParser: Symbol('byte parser')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcTnltZXNcXERvY3VtZW50c1xcR2l0SHViXFxOZXh0LmpzLUZpcmVCYXNlXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtXZWJTb2NrZXRVUkw6IFN5bWJvbCgndXJsJyksXG4gIGtSZWFkeVN0YXRlOiBTeW1ib2woJ3JlYWR5IHN0YXRlJyksXG4gIGtDb250cm9sbGVyOiBTeW1ib2woJ2NvbnRyb2xsZXInKSxcbiAga1Jlc3BvbnNlOiBTeW1ib2woJ3Jlc3BvbnNlJyksXG4gIGtCaW5hcnlUeXBlOiBTeW1ib2woJ2JpbmFyeSB0eXBlJyksXG4gIGtTZW50Q2xvc2U6IFN5bWJvbCgnc2VudCBjbG9zZScpLFxuICBrUmVjZWl2ZWRDbG9zZTogU3ltYm9sKCdyZWNlaXZlZCBjbG9zZScpLFxuICBrQnl0ZVBhcnNlcjogU3ltYm9sKCdieXRlIHBhcnNlcicpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { ErrorEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isConnecting (ws) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return ws[kReadyState] === states.CONNECTING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = utf8Decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = toArrayBuffer(data)\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, createFastMessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    // TODO: process.nextTick\n    fireEvent('error', ws, (type, init) => new ErrorEvent(type, init), {\n      error: new Error(reason),\n      message: reason\n    })\n  }\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=')\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string'\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', { fatal: true }) : undefined\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */\nconst utf8Decode = hasIntl\n  ? fatalDecoder.decode.bind(fatalDecoder)\n  : function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxrRUFBa0UsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQy9GLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRCxRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMseUVBQVU7QUFDakUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN4QyxRQUFRLHlEQUF5RCxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1COztBQUU5Rjs7QUFFQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyx5REFBeUQ7QUFDcEUsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSx1R0FBdUc7QUFDdkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFVBQVUsbURBQW1EOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTs7QUFFdkU7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXE55bWVzXFxEb2N1bWVudHNcXEdpdEh1YlxcTmV4dC5qcy1GaXJlQmFzZVxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1JlYWR5U3RhdGUsIGtDb250cm9sbGVyLCBrUmVzcG9uc2UsIGtCaW5hcnlUeXBlLCBrV2ViU29ja2V0VVJMIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBzdGF0ZXMsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgRXJyb3JFdmVudCwgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gcmVxdWlyZSgnLi9ldmVudHMnKVxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IHsgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QsIHJlbW92ZUhUVFBXaGl0ZXNwYWNlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5cbi8qIGdsb2JhbHMgQmxvYiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nvbm5lY3RpbmcgKHdzKSB7XG4gIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgeWV0IGVzdGFibGlzaGVkLCBhbmQgdGhlIGNvbm5lY3Rpb25cbiAgLy8gaXMgbm90IHlldCBjbG9zZWQsIHRoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNUSU5HIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ09OTkVDVElOR1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VzdGFibGlzaGVkICh3cykge1xuICAvLyBJZiB0aGUgc2VydmVyJ3MgcmVzcG9uc2UgaXMgdmFsaWRhdGVkIGFzIHByb3ZpZGVkIGZvciBhYm92ZSwgaXQgaXNcbiAgLy8gc2FpZCB0aGF0IF9UaGUgV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgRXN0YWJsaXNoZWRfIGFuZCB0aGF0IHRoZVxuICAvLyBXZWJTb2NrZXQgQ29ubmVjdGlvbiBpcyBpbiB0aGUgT1BFTiBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLk9QRU5cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbG9zaW5nICh3cykge1xuICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgLy8gdGhhdCBfVGhlIFdlYlNvY2tldCBDbG9zaW5nIEhhbmRzaGFrZSBpcyBTdGFydGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5DTE9TSU5HXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2VkICh3cykge1xuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0VEXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHsoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBFdmVudD4pID0+IEV2ZW50fSBldmVudEZhY3RvcnlcbiAqIEBwYXJhbSB7RXZlbnRJbml0IHwgdW5kZWZpbmVkfSBldmVudEluaXREaWN0XG4gKi9cbmZ1bmN0aW9uIGZpcmVFdmVudCAoZSwgdGFyZ2V0LCBldmVudEZhY3RvcnkgPSAodHlwZSwgaW5pdCkgPT4gbmV3IEV2ZW50KHR5cGUsIGluaXQpLCBldmVudEluaXREaWN0ID0ge30pIHtcbiAgLy8gMS4gSWYgZXZlbnRDb25zdHJ1Y3RvciBpcyBub3QgZ2l2ZW4sIHRoZW4gbGV0IGV2ZW50Q29uc3RydWN0b3IgYmUgRXZlbnQuXG5cbiAgLy8gMi4gTGV0IGV2ZW50IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZXZlbnQgZ2l2ZW4gZXZlbnRDb25zdHJ1Y3RvcixcbiAgLy8gICAgaW4gdGhlIHJlbGV2YW50IHJlYWxtIG9mIHRhcmdldC5cbiAgLy8gMy4gSW5pdGlhbGl6ZSBldmVudOKAmXMgdHlwZSBhdHRyaWJ1dGUgdG8gZS5cbiAgY29uc3QgZXZlbnQgPSBldmVudEZhY3RvcnkoZSwgZXZlbnRJbml0RGljdClcblxuICAvLyA0LiBJbml0aWFsaXplIGFueSBvdGhlciBJREwgYXR0cmlidXRlcyBvZiBldmVudCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gIC8vICAgIGludm9jYXRpb24gb2YgdGhpcyBhbGdvcml0aG0uXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgZGlzcGF0Y2hpbmcgZXZlbnQgYXQgdGFyZ2V0LCB3aXRoIGxlZ2FjeSB0YXJnZXRcbiAgLy8gICAgb3ZlcnJpZGUgZmxhZyBzZXQgaWYgc2V0LlxuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBPcGNvZGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIGFwcGxpY2F0aW9uIGRhdGFcbiAqL1xuZnVuY3Rpb24gd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkICh3cywgdHlwZSwgZGF0YSkge1xuICAvLyAxLiBJZiByZWFkeSBzdGF0ZSBpcyBub3QgT1BFTiAoMSksIHRoZW4gcmV0dXJuLlxuICBpZiAod3Nba1JlYWR5U3RhdGVdICE9PSBzdGF0ZXMuT1BFTikge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gMi4gTGV0IGRhdGFGb3JFdmVudCBiZSBkZXRlcm1pbmVkIGJ5IHN3aXRjaGluZyBvbiB0eXBlIGFuZCBiaW5hcnkgdHlwZTpcbiAgbGV0IGRhdGFGb3JFdmVudFxuXG4gIGlmICh0eXBlID09PSBvcGNvZGVzLlRFWFQpIHtcbiAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIFRleHRcbiAgICAvLyAgICAgIGEgbmV3IERPTVN0cmluZyBjb250YWluaW5nIGRhdGFcbiAgICB0cnkge1xuICAgICAgZGF0YUZvckV2ZW50ID0gdXRmOERlY29kZShkYXRhKVxuICAgIH0gY2F0Y2gge1xuICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdSZWNlaXZlZCBpbnZhbGlkIFVURi04IGluIHRleHQgZnJhbWUuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBvcGNvZGVzLkJJTkFSWSkge1xuICAgIGlmICh3c1trQmluYXJ5VHlwZV0gPT09ICdibG9iJykge1xuICAgICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBCaW5hcnkgYW5kIGJpbmFyeSB0eXBlIGlzIFwiYmxvYlwiXG4gICAgICAvLyAgICAgIGEgbmV3IEJsb2Igb2JqZWN0LCBjcmVhdGVkIGluIHRoZSByZWxldmFudCBSZWFsbSBvZiB0aGUgV2ViU29ja2V0XG4gICAgICAvLyAgICAgIG9iamVjdCwgdGhhdCByZXByZXNlbnRzIGRhdGEgYXMgaXRzIHJhdyBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSBuZXcgQmxvYihbZGF0YV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImFycmF5YnVmZmVyXCJcbiAgICAgIC8vICAgICAgYSBuZXcgQXJyYXlCdWZmZXIgb2JqZWN0LCBjcmVhdGVkIGluIHRoZSByZWxldmFudCBSZWFsbSBvZiB0aGVcbiAgICAgIC8vICAgICAgV2ViU29ja2V0IG9iamVjdCwgd2hvc2UgY29udGVudHMgYXJlIGRhdGFcbiAgICAgIGRhdGFGb3JFdmVudCA9IHRvQXJyYXlCdWZmZXIoZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIG1lc3NhZ2UgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QsIHVzaW5nIE1lc3NhZ2VFdmVudCxcbiAgLy8gICAgd2l0aCB0aGUgb3JpZ2luIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byB0aGUgc2VyaWFsaXphdGlvbiBvZiB0aGUgV2ViU29ja2V0XG4gIC8vICAgIG9iamVjdOKAmXMgdXJsJ3Mgb3JpZ2luLCBhbmQgdGhlIGRhdGEgYXR0cmlidXRlIGluaXRpYWxpemVkIHRvIGRhdGFGb3JFdmVudC5cbiAgZmlyZUV2ZW50KCdtZXNzYWdlJywgd3MsIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQsIHtcbiAgICBvcmlnaW46IHdzW2tXZWJTb2NrZXRVUkxdLm9yaWdpbixcbiAgICBkYXRhOiBkYXRhRm9yRXZlbnRcbiAgfSlcbn1cblxuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlciAoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gYnVmZmVyLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXJcbiAgfVxuICByZXR1cm4gYnVmZmVyLmJ1ZmZlci5zbGljZShidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NVxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzI2MTZcbiAqIEBzZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzk4NDA3XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN1YnByb3RvY29sIChwcm90b2NvbCkge1xuICAvLyBJZiBwcmVzZW50LCB0aGlzIHZhbHVlIGluZGljYXRlcyBvbmVcbiAgLy8gb3IgbW9yZSBjb21tYS1zZXBhcmF0ZWQgc3VicHJvdG9jb2wgdGhlIGNsaWVudCB3aXNoZXMgdG8gc3BlYWssXG4gIC8vIG9yZGVyZWQgYnkgcHJlZmVyZW5jZS4gIFRoZSBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoaXMgdmFsdWVcbiAgLy8gTVVTVCBiZSBub24tZW1wdHkgc3RyaW5ncyB3aXRoIGNoYXJhY3RlcnMgaW4gdGhlIHJhbmdlIFUrMDAyMSB0b1xuICAvLyBVKzAwN0Ugbm90IGluY2x1ZGluZyBzZXBhcmF0b3IgY2hhcmFjdGVycyBhcyBkZWZpbmVkIGluXG4gIC8vIFtSRkMyNjE2XSBhbmQgTVVTVCBhbGwgYmUgdW5pcXVlIHN0cmluZ3MuXG4gIGlmIChwcm90b2NvbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdG9jb2wubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gcHJvdG9jb2wuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gQ1RMLCBjb250YWlucyBTUCAoMHgyMCkgYW5kIEhUICgweDA5KVxuICAgICAgY29kZSA+IDB4N0UgfHxcbiAgICAgIGNvZGUgPT09IDB4MjIgfHwgLy8gXCJcbiAgICAgIGNvZGUgPT09IDB4MjggfHwgLy8gKFxuICAgICAgY29kZSA9PT0gMHgyOSB8fCAvLyApXG4gICAgICBjb2RlID09PSAweDJDIHx8IC8vICxcbiAgICAgIGNvZGUgPT09IDB4MkYgfHwgLy8gL1xuICAgICAgY29kZSA9PT0gMHgzQSB8fCAvLyA6XG4gICAgICBjb2RlID09PSAweDNCIHx8IC8vIDtcbiAgICAgIGNvZGUgPT09IDB4M0MgfHwgLy8gPFxuICAgICAgY29kZSA9PT0gMHgzRCB8fCAvLyA9XG4gICAgICBjb2RlID09PSAweDNFIHx8IC8vID5cbiAgICAgIGNvZGUgPT09IDB4M0YgfHwgLy8gP1xuICAgICAgY29kZSA9PT0gMHg0MCB8fCAvLyBAXG4gICAgICBjb2RlID09PSAweDVCIHx8IC8vIFtcbiAgICAgIGNvZGUgPT09IDB4NUMgfHwgLy8gXFxcbiAgICAgIGNvZGUgPT09IDB4NUQgfHwgLy8gXVxuICAgICAgY29kZSA9PT0gMHg3QiB8fCAvLyB7XG4gICAgICBjb2RlID09PSAweDdEIC8vIH1cbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LTRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlIChjb2RlKSB7XG4gIGlmIChjb2RlID49IDEwMDAgJiYgY29kZSA8IDEwMTUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY29kZSAhPT0gMTAwNCAmJiAvLyByZXNlcnZlZFxuICAgICAgY29kZSAhPT0gMTAwNSAmJiAvLyBcIk1VU1QgTk9UIGJlIHNldCBhcyBhIHN0YXR1cyBjb2RlXCJcbiAgICAgIGNvZGUgIT09IDEwMDYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHJlYXNvblxuICovXG5mdW5jdGlvbiBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiAod3MsIHJlYXNvbikge1xuICBjb25zdCB7IFtrQ29udHJvbGxlcl06IGNvbnRyb2xsZXIsIFtrUmVzcG9uc2VdOiByZXNwb25zZSB9ID0gd3NcblxuICBjb250cm9sbGVyLmFib3J0KClcblxuICBpZiAocmVzcG9uc2U/LnNvY2tldCAmJiAhcmVzcG9uc2Uuc29ja2V0LmRlc3Ryb3llZCkge1xuICAgIHJlc3BvbnNlLnNvY2tldC5kZXN0cm95KClcbiAgfVxuXG4gIGlmIChyZWFzb24pIHtcbiAgICAvLyBUT0RPOiBwcm9jZXNzLm5leHRUaWNrXG4gICAgZmlyZUV2ZW50KCdlcnJvcicsIHdzLCAodHlwZSwgaW5pdCkgPT4gbmV3IEVycm9yRXZlbnQodHlwZSwgaW5pdCksIHtcbiAgICAgIGVycm9yOiBuZXcgRXJyb3IocmVhc29uKSxcbiAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuNVxuICogQHBhcmFtIHtudW1iZXJ9IG9wY29kZVxuICovXG5mdW5jdGlvbiBpc0NvbnRyb2xGcmFtZSAob3Bjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgb3Bjb2RlID09PSBvcGNvZGVzLkNMT1NFIHx8XG4gICAgb3Bjb2RlID09PSBvcGNvZGVzLlBJTkcgfHxcbiAgICBvcGNvZGUgPT09IG9wY29kZXMuUE9OR1xuICApXG59XG5cbmZ1bmN0aW9uIGlzQ29udGludWF0aW9uRnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gb3Bjb2RlID09PSBvcGNvZGVzLkNPTlRJTlVBVElPTlxufVxuXG5mdW5jdGlvbiBpc1RleHRCaW5hcnlGcmFtZSAob3Bjb2RlKSB7XG4gIHJldHVybiBvcGNvZGUgPT09IG9wY29kZXMuVEVYVCB8fCBvcGNvZGUgPT09IG9wY29kZXMuQklOQVJZXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRPcGNvZGUgKG9wY29kZSkge1xuICByZXR1cm4gaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSB8fCBpc0NvbnRpbnVhdGlvbkZyYW1lKG9wY29kZSkgfHwgaXNDb250cm9sRnJhbWUob3Bjb2RlKVxufVxuXG4vKipcbiAqIFBhcnNlcyBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uc1xuICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbi8vIFRPRE8oQFV6bG9wYWssIEBLaGFmcmFEZXYpOiBtYWtlIGNvbXBsaWFudCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbmZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9ucyAoZXh0ZW5zaW9ucykge1xuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICBjb25zdCBleHRlbnNpb25MaXN0ID0gbmV3IE1hcCgpXG5cbiAgd2hpbGUgKHBvc2l0aW9uLnBvc2l0aW9uIDwgZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYWlyID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoJzsnLCBleHRlbnNpb25zLCBwb3NpdGlvbilcbiAgICBjb25zdCBbbmFtZSwgdmFsdWUgPSAnJ10gPSBwYWlyLnNwbGl0KCc9JylcblxuICAgIGV4dGVuc2lvbkxpc3Quc2V0KFxuICAgICAgcmVtb3ZlSFRUUFdoaXRlc3BhY2UobmFtZSwgdHJ1ZSwgZmFsc2UpLFxuICAgICAgcmVtb3ZlSFRUUFdoaXRlc3BhY2UodmFsdWUsIGZhbHNlLCB0cnVlKVxuICAgIClcblxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgfVxuXG4gIHJldHVybiBleHRlbnNpb25MaXN0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzY5MiNzZWN0aW9uLTcuMS4yLjJcbiAqIEBkZXNjcmlwdGlvbiBcImNsaWVudC1tYXgtd2luZG93LWJpdHMgPSAxKkRJR0lUXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyAodmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGJ5dGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoYnl0ZSA8IDB4MzAgfHwgYnl0ZSA+IDB4MzkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaW50bC5odG1sI2RldGVjdGluZy1pbnRlcm5hdGlvbmFsaXphdGlvbi1zdXBwb3J0XG5jb25zdCBoYXNJbnRsID0gdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMuaWN1ID09PSAnc3RyaW5nJ1xuY29uc3QgZmF0YWxEZWNvZGVyID0gaGFzSW50bCA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pIDogdW5kZWZpbmVkXG5cbi8qKlxuICogQ29udmVydHMgYSBCdWZmZXIgdG8gdXRmLTgsIGV2ZW4gb24gcGxhdGZvcm1zIHdpdGhvdXQgaWN1LlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5jb25zdCB1dGY4RGVjb2RlID0gaGFzSW50bFxuICA/IGZhdGFsRGVjb2Rlci5kZWNvZGUuYmluZChmYXRhbERlY29kZXIpXG4gIDogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgIGlmIChpc1V0ZjgoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmLTgnKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHV0Zi04IHJlY2VpdmVkLicpXG4gIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQ29ubmVjdGluZyxcbiAgaXNFc3RhYmxpc2hlZCxcbiAgaXNDbG9zaW5nLFxuICBpc0Nsb3NlZCxcbiAgZmlyZUV2ZW50LFxuICBpc1ZhbGlkU3VicHJvdG9jb2wsXG4gIGlzVmFsaWRTdGF0dXNDb2RlLFxuICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbixcbiAgd2Vic29ja2V0TWVzc2FnZVJlY2VpdmVkLFxuICB1dGY4RGVjb2RlLFxuICBpc0NvbnRyb2xGcmFtZSxcbiAgaXNDb250aW51YXRpb25GcmFtZSxcbiAgaXNUZXh0QmluYXJ5RnJhbWUsXG4gIGlzVmFsaWRPcGNvZGUsXG4gIHBhcnNlRXh0ZW5zaW9ucyxcbiAgaXNWYWxpZENsaWVudFdpbmRvd0JpdHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(ssr)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(ssr)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(ssr)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(ssr)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../../core/util */ \"(ssr)/./node_modules/undici/lib/core/util.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(ssr)/./node_modules/undici/lib/global.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { ErrorEvent, CloseEvent } = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(ssr)/./node_modules/undici/lib/web/websocket/sender.js\")\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this,\n      (response, extensions) => this.#onConnectionEstablished(response, extensions),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    this[kSentClose] = sentCloseFrameState.NOT_SENT\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason, prefix, 'reason')\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    closeWebSocketConnection(this, code, reason, reasonByteLength)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const length = Buffer.byteLength(data)\n\n      this.#bufferedAmount += length\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= length\n      }, sendHints.string)\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this, parsedExtensions)\n    parser.on('drain', onParserDrain)\n    parser.on('error', onParserError.bind(this))\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => new Array(0)\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nfunction onParserDrain () {\n  this.ws[kResponse].socket.resume()\n}\n\nfunction onParserError (err) {\n  let message\n  let code\n\n  if (err instanceof CloseEvent) {\n    message = err.reason\n    code = err.code\n  } else {\n    message = err.message\n  }\n\n  fireEvent('error', this, () => new ErrorEvent('error', { error: err, message }))\n\n  closeWebSocketConnection(this, code)\n}\n\nmodule.exports = {\n  WebSocket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3JELFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTtBQUM3RCxRQUFRLG9FQUFvRSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFFQUFRO0FBQ3BCLFFBQVEseURBQXlELEVBQUUsbUJBQU8sQ0FBQyxpRkFBYztBQUN6RixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDZFQUFZO0FBQzNDLFFBQVEsa0NBQWtDLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDckUsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQ3RELFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckMsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQ3JELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsV0FBVztBQUN4Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUUsYUFBYTtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxXQUFXLGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSwyREFBMkQscUJBQXFCOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxOeW1lc1xcRG9jdW1lbnRzXFxHaXRIdWJcXE5leHQuanMtRmlyZUJhc2VcXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx3ZWJzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3V0aWwnKVxuY29uc3QgeyBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLCBzdGF0ZXMsIHNlbnRDbG9zZUZyYW1lU3RhdGUsIHNlbmRIaW50cyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBrV2ViU29ja2V0VVJMLFxuICBrUmVhZHlTdGF0ZSxcbiAga0NvbnRyb2xsZXIsXG4gIGtCaW5hcnlUeXBlLFxuICBrUmVzcG9uc2UsXG4gIGtTZW50Q2xvc2UsXG4gIGtCeXRlUGFyc2VyXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHtcbiAgaXNDb25uZWN0aW5nLFxuICBpc0VzdGFibGlzaGVkLFxuICBpc0Nsb3NpbmcsXG4gIGlzVmFsaWRTdWJwcm90b2NvbCxcbiAgZmlyZUV2ZW50XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbiwgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKVxuY29uc3QgeyBCeXRlUGFyc2VyIH0gPSByZXF1aXJlKCcuL3JlY2VpdmVyJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSwgaXNCbG9iTGlrZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZ2V0R2xvYmFsRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi4vLi4vZ2xvYmFsJylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IEVycm9yRXZlbnQsIENsb3NlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgU2VuZFF1ZXVlIH0gPSByZXF1aXJlKCcuL3NlbmRlcicpXG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1kZWZpbml0aW9uXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNldmVudHMgPSB7XG4gICAgb3BlbjogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBjbG9zZTogbnVsbCxcbiAgICBtZXNzYWdlOiBudWxsXG4gIH1cblxuICAjYnVmZmVyZWRBbW91bnQgPSAwXG4gICNwcm90b2NvbCA9ICcnXG4gICNleHRlbnNpb25zID0gJydcblxuICAvKiogQHR5cGUge1NlbmRRdWV1ZX0gKi9cbiAgI3NlbmRRdWV1ZVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwcm90b2NvbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHByb3RvY29scyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4gb3IgV2ViU29ja2V0SW5pdCddKHByb3RvY29scywgcHJlZml4LCAnb3B0aW9ucycpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsLCBwcmVmaXgsICd1cmwnKVxuICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2xzXG5cbiAgICAvLyAxLiBMZXQgYmFzZVVSTCBiZSB0aGlzJ3MgcmVsZXZhbnQgc2V0dGluZ3Mgb2JqZWN0J3MgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVUkwgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDEuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgVVJMIHBhcnNlciB0byB1cmwgd2l0aCBiYXNlVVJMLlxuICAgIGxldCB1cmxSZWNvcmRcblxuICAgIHRyeSB7XG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgYmFzZVVSTClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyAzLiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgXCJodHRwXCIsIHRoZW4gc2V0IHVybFJlY29yZOKAmXMgc2NoZW1lIHRvIFwid3NcIi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cDonKSB7XG4gICAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3M6J1xuICAgIH0gZWxzZSBpZiAodXJsUmVjb3JkLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgLy8gNS4gT3RoZXJ3aXNlLCBpZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBcImh0dHBzXCIsIHNldCB1cmxSZWNvcmTigJlzIHNjaGVtZSB0byBcIndzc1wiLlxuICAgICAgdXJsUmVjb3JkLnByb3RvY29sID0gJ3dzczonXG4gICAgfVxuXG4gICAgLy8gNi4gSWYgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgaXMgbm90IFwid3NcIiBvciBcIndzc1wiLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLnByb3RvY29sICE9PSAnd3M6JyAmJiB1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3c3M6Jykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgYEV4cGVjdGVkIGEgd3M6IG9yIHdzczogcHJvdG9jb2wsIGdvdCAke3VybFJlY29yZC5wcm90b2NvbH1gLFxuICAgICAgICAnU3ludGF4RXJyb3InXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gNy4gSWYgdXJsUmVjb3Jk4oCZcyBmcmFnbWVudCBpcyBub24tbnVsbCwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIlxuICAgIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAodXJsUmVjb3JkLmhhc2ggfHwgdXJsUmVjb3JkLmhyZWYuZW5kc1dpdGgoJyMnKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignR290IGZyYWdtZW50JywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA4LiBJZiBwcm90b2NvbHMgaXMgYSBzdHJpbmcsIHNldCBwcm90b2NvbHMgdG8gYSBzZXF1ZW5jZSBjb25zaXN0aW5nXG4gICAgLy8gICAgb2YganVzdCB0aGF0IHN0cmluZy5cbiAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdXG4gICAgfVxuXG4gICAgLy8gOS4gSWYgYW55IG9mIHRoZSB2YWx1ZXMgaW4gcHJvdG9jb2xzIG9jY3VyIG1vcmUgdGhhbiBvbmNlIG9yIG90aGVyd2lzZVxuICAgIC8vICAgIGZhaWwgdG8gbWF0Y2ggdGhlIHJlcXVpcmVtZW50cyBmb3IgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGUgdmFsdWVcbiAgICAvLyAgICBvZiBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgZmllbGRzIGFzIGRlZmluZWQgYnkgVGhlIFdlYlNvY2tldFxuICAgIC8vICAgIHByb3RvY29sLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCAhPT0gbmV3IFNldChwcm90b2NvbHMubWFwKHAgPT4gcC50b0xvd2VyQ2FzZSgpKSkuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICBpZiAocHJvdG9jb2xzLmxlbmd0aCA+IDAgJiYgIXByb3RvY29scy5ldmVyeShwID0+IGlzVmFsaWRTdWJwcm90b2NvbChwKSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCB2YWx1ZScsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMTAuIFNldCB0aGlzJ3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzW2tXZWJTb2NrZXRVUkxdID0gbmV3IFVSTCh1cmxSZWNvcmQuaHJlZilcblxuICAgIC8vIDExLiBMZXQgY2xpZW50IGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgY29uc3QgY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gMTIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6XG5cbiAgICAvLyAgICAxLiBFc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBnaXZlbiB1cmxSZWNvcmQsIHByb3RvY29scyxcbiAgICAvLyAgICAgICBhbmQgY2xpZW50LlxuICAgIHRoaXNba0NvbnRyb2xsZXJdID0gZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbihcbiAgICAgIHVybFJlY29yZCxcbiAgICAgIHByb3RvY29scyxcbiAgICAgIGNsaWVudCxcbiAgICAgIHRoaXMsXG4gICAgICAocmVzcG9uc2UsIGV4dGVuc2lvbnMpID0+IHRoaXMuI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkKHJlc3BvbnNlLCBleHRlbnNpb25zKSxcbiAgICAgIG9wdGlvbnNcbiAgICApXG5cbiAgICAvLyBFYWNoIFdlYlNvY2tldCBvYmplY3QgaGFzIGFuIGFzc29jaWF0ZWQgcmVhZHkgc3RhdGUsIHdoaWNoIGlzIGFcbiAgICAvLyBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29ubmVjdGlvbi4gSW5pdGlhbGx5IGl0IG11c3RcbiAgICAvLyBiZSBDT05ORUNUSU5HICgwKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IFdlYlNvY2tldC5DT05ORUNUSU5HXG5cbiAgICB0aGlzW2tTZW50Q2xvc2VdID0gc2VudENsb3NlRnJhbWVTdGF0ZS5OT1RfU0VOVFxuXG4gICAgLy8gVGhlIGV4dGVuc2lvbnMgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gVGhlIHByb3RvY29sIGF0dHJpYnV0ZSBtdXN0IGluaXRpYWxseSByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCBiaW5hcnkgdHlwZSwgd2hpY2ggaXMgYVxuICAgIC8vIEJpbmFyeVR5cGUuIEluaXRpYWxseSBpdCBtdXN0IGJlIFwiYmxvYlwiLlxuICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NlXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHJlYXNvblxuICAgKi9cbiAgY2xvc2UgKGNvZGUgPSB1bmRlZmluZWQsIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQuY2xvc2UnXG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2RlID0gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10oY29kZSwgcHJlZml4LCAnY29kZScsIHsgY2xhbXA6IHRydWUgfSlcbiAgICB9XG5cbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlYXNvbiA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhyZWFzb24sIHByZWZpeCwgJ3JlYXNvbicpXG4gICAgfVxuXG4gICAgLy8gMS4gSWYgY29kZSBpcyBwcmVzZW50LCBidXQgaXMgbmVpdGhlciBhbiBpbnRlZ2VyIGVxdWFsIHRvIDEwMDAgbm9yIGFuXG4gICAgLy8gICAgaW50ZWdlciBpbiB0aGUgcmFuZ2UgMzAwMCB0byA0OTk5LCBpbmNsdXNpdmUsIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvZGUgIT09IDEwMDAgJiYgKGNvZGUgPCAzMDAwIHx8IGNvZGUgPiA0OTk5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdpbnZhbGlkIGNvZGUnLCAnSW52YWxpZEFjY2Vzc0Vycm9yJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVhc29uQnl0ZUxlbmd0aCA9IDBcblxuICAgIC8vIDIuIElmIHJlYXNvbiBpcyBwcmVzZW50LCB0aGVuIHJ1biB0aGVzZSBzdWJzdGVwczpcbiAgICBpZiAocmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDEuIExldCByZWFzb25CeXRlcyBiZSB0aGUgcmVzdWx0IG9mIGVuY29kaW5nIHJlYXNvbi5cbiAgICAgIC8vIDIuIElmIHJlYXNvbkJ5dGVzIGlzIGxvbmdlciB0aGFuIDEyMyBieXRlcywgdGhlbiB0aHJvdyBhXG4gICAgICAvLyAgICBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgICAgcmVhc29uQnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHJlYXNvbilcblxuICAgICAgaWYgKHJlYXNvbkJ5dGVMZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBgUmVhc29uIG11c3QgYmUgbGVzcyB0aGFuIDEyMyBieXRlczsgcmVjZWl2ZWQgJHtyZWFzb25CeXRlTGVuZ3RofWAsXG4gICAgICAgICAgJ1N5bnRheEVycm9yJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUnVuIHRoZSBmaXJzdCBtYXRjaGluZyBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcywgY29kZSwgcmVhc29uLCByZWFzb25CeXRlTGVuZ3RoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1zZW5kXG4gICAqIEBwYXJhbSB7Tm9kZUpTLlR5cGVkQXJyYXl8QXJyYXlCdWZmZXJ8QmxvYnxzdHJpbmd9IGRhdGFcbiAgICovXG4gIHNlbmQgKGRhdGEpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnV2ViU29ja2V0LnNlbmQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBkYXRhID0gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEoZGF0YSwgcHJlZml4LCAnZGF0YScpXG5cbiAgICAvLyAxLiBJZiB0aGlzJ3MgcmVhZHkgc3RhdGUgaXMgQ09OTkVDVElORywgdGhlbiB0aHJvdyBhblxuICAgIC8vICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgaWYgKGlzQ29ubmVjdGluZyh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VudCBiZWZvcmUgY29ubmVjdGVkLicsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gMi4gUnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHMgZnJvbSB0aGUgZm9sbG93aW5nIGxpc3Q6XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNi4xXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNS4yXG5cbiAgICBpZiAoIWlzRXN0YWJsaXNoZWQodGhpcykgfHwgaXNDbG9zaW5nKHRoaXMpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiBkYXRhIGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgdGhlIGRhdGEgYXJndW1lbnRcbiAgICAgIC8vIHVzaW5nIGEgdGV4dCBmcmFtZSBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuXG4gICAgICAvLyBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2VcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhXG4gICAgICAvLyBzdHJpbmcgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZVxuICAgICAgLy8gdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0b1xuICAgICAgLy8gZXhwcmVzcyB0aGUgYXJndW1lbnQgYXMgVVRGLTguXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aFxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGxlbmd0aFxuICAgICAgfSwgc2VuZEhpbnRzLnN0cmluZylcbiAgICB9IGVsc2UgaWYgKHR5cGVzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcbiAgICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnQgbXVzdFxuICAgICAgLy8gc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiBkYXRhIHVzaW5nIGEgYmluYXJ5IGZyYW1lXG4gICAgICAvLyBvcGNvZGU7IGlmIHRoZSBkYXRhIGNhbm5vdCBiZSBzZW50LCBlLmcuIGJlY2F1c2UgaXQgd291bGQgbmVlZFxuICAgICAgLy8gdG8gYmUgYnVmZmVyZWQgYnV0IHRoZSBidWZmZXIgaXMgZnVsbCwgdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnXG4gICAgICAvLyB0aGUgV2ViU29ja2V0IGFzIGZ1bGwgYW5kIHRoZW4gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgLy8gVGhlIGRhdGEgdG8gYmUgc2VudCBpcyB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGJ1ZmZlciBkZXNjcmliZWRcbiAgICAgIC8vIGJ5IHRoZSBBcnJheUJ1ZmZlciBvYmplY3QuIEFueSBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYW5cbiAgICAgIC8vIEFycmF5QnVmZmVyIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3RcbiAgICAgIC8vIGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIC8vIEFycmF5QnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy5hcnJheUJ1ZmZlcilcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZVxuICAgICAgLy8gZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgc2VjdGlvbiBvZiB0aGUgYnVmZmVyXG4gICAgICAvLyBkZXNjcmliZWQgYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IGRhdGEgcmVmZXJlbmNlcy4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggdGhpcyBraW5kIG9mIGFyZ3VtZW50IHRoYXQgZG9lc1xuICAgICAgLy8gbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGVcbiAgICAgIC8vIGJ5IHRoZSBsZW5ndGggb2YgZGF0YeKAmXMgYnVmZmVyIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLmJ5dGVMZW5ndGhcbiAgICAgIH0sIHNlbmRIaW50cy50eXBlZEFycmF5KVxuICAgIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkIHRvXG4gICAgICAvLyBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWcgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIFRoZSBkYXRhXG4gICAgICAvLyB0byBiZSBzZW50IGlzIHRoZSByYXcgZGF0YSByZXByZXNlbnRlZCBieSB0aGUgQmxvYiBvYmplY3QuIEFueVxuICAgICAgLy8gaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGEgQmxvYiBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93XG4gICAgICAvLyBhbiBleGNlcHRpb24gbXVzdCBpbmNyZWFzZSB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBzaXplXG4gICAgICAvLyBvZiB0aGUgQmxvYiBvYmplY3TigJlzIHJhdyBkYXRhLCBpbiBieXRlcy5cblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gZGF0YS5zaXplXG4gICAgICB0aGlzLiNzZW5kUXVldWUuYWRkKGRhdGEsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gZGF0YS5zaXplXG4gICAgICB9LCBzZW5kSGludHMuYmxvYilcbiAgICB9XG4gIH1cblxuICBnZXQgcmVhZHlTdGF0ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHJlYWR5U3RhdGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHJlYWR5IHN0YXRlLlxuICAgIHJldHVybiB0aGlzW2tSZWFkeVN0YXRlXVxuICB9XG5cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jYnVmZmVyZWRBbW91bnRcbiAgfVxuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpcydzIHVybCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzW2tXZWJTb2NrZXRVUkxdKVxuICB9XG5cbiAgZ2V0IGV4dGVuc2lvbnMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNleHRlbnNpb25zXG4gIH1cblxuICBnZXQgcHJvdG9jb2wgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNwcm90b2NvbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmVycm9yXG4gIH1cblxuICBzZXQgb25lcnJvciAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmVycm9yKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy4jZXZlbnRzLmVycm9yKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5lcnJvciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25jbG9zZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5jbG9zZVxuICB9XG5cbiAgc2V0IG9uY2xvc2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5jbG9zZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuI2V2ZW50cy5jbG9zZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuY2xvc2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5tZXNzYWdlXG4gIH1cblxuICBzZXQgb25tZXNzYWdlIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMubWVzc2FnZSkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy4jZXZlbnRzLm1lc3NhZ2UpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBiaW5hcnlUeXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpc1trQmluYXJ5VHlwZV1cbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlICh0eXBlKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHR5cGUgIT09ICdibG9iJyAmJiB0eXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9ICdibG9iJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tCaW5hcnlUeXBlXSA9IHR5cGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICAgKi9cbiAgI29uQ29ubmVjdGlvbkVzdGFibGlzaGVkIChyZXNwb25zZSwgcGFyc2VkRXh0ZW5zaW9ucykge1xuICAgIC8vIHByb2Nlc3NSZXNwb25zZSBpcyBjYWxsZWQgd2hlbiB0aGUgXCJyZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIGluaXRpYWxpemVkLlwiXG4gICAgLy8gb25jZSB0aGlzIGhhcHBlbnMsIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5cbiAgICB0aGlzW2tSZXNwb25zZV0gPSByZXNwb25zZVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEJ5dGVQYXJzZXIodGhpcywgcGFyc2VkRXh0ZW5zaW9ucylcbiAgICBwYXJzZXIub24oJ2RyYWluJywgb25QYXJzZXJEcmFpbilcbiAgICBwYXJzZXIub24oJ2Vycm9yJywgb25QYXJzZXJFcnJvci5iaW5kKHRoaXMpKVxuXG4gICAgcmVzcG9uc2Uuc29ja2V0LndzID0gdGhpc1xuICAgIHRoaXNba0J5dGVQYXJzZXJdID0gcGFyc2VyXG5cbiAgICB0aGlzLiNzZW5kUXVldWUgPSBuZXcgU2VuZFF1ZXVlKHJlc3BvbnNlLnNvY2tldClcblxuICAgIC8vIDEuIENoYW5nZSB0aGUgcmVhZHkgc3RhdGUgdG8gT1BFTiAoMSkuXG4gICAgdGhpc1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuT1BFTlxuXG4gICAgLy8gMi4gQ2hhbmdlIHRoZSBleHRlbnNpb25zIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIGV4dGVuc2lvbnMgaW4gdXNlLCBpZlxuICAgIC8vICAgIGl0IGlzIG5vdCB0aGUgbnVsbCB2YWx1ZS5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi05LjFcbiAgICBjb25zdCBleHRlbnNpb25zID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnKVxuXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2V4dGVuc2lvbnMgPSBleHRlbnNpb25zXG4gICAgfVxuXG4gICAgLy8gMy4gQ2hhbmdlIHRoZSBwcm90b2NvbCBhdHRyaWJ1dGXigJlzIHZhbHVlIHRvIHRoZSBzdWJwcm90b2NvbCBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTEuOVxuICAgIGNvbnN0IHByb3RvY29sID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJylcblxuICAgIGlmIChwcm90b2NvbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jcHJvdG9jb2wgPSBwcm90b2NvbFxuICAgIH1cblxuICAgIC8vIDQuIEZpcmUgYW4gZXZlbnQgbmFtZWQgb3BlbiBhdCB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgICBmaXJlRXZlbnQoJ29wZW4nLCB0aGlzKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY29ubmVjdGluZ1xuV2ViU29ja2V0LkNPTk5FQ1RJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBzdGF0ZXMuQ09OTkVDVElOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1vcGVuXG5XZWJTb2NrZXQuT1BFTiA9IFdlYlNvY2tldC5wcm90b3R5cGUuT1BFTiA9IHN0YXRlcy5PUEVOXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LWNsb3NpbmdcbldlYlNvY2tldC5DTE9TSU5HID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TSU5HID0gc3RhdGVzLkNMT1NJTkdcbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VkXG5XZWJTb2NrZXQuQ0xPU0VEID0gV2ViU29ja2V0LnByb3RvdHlwZS5DTE9TRUQgPSBzdGF0ZXMuQ0xPU0VEXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgQ09OTkVDVElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgT1BFTjogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0lORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgQ0xPU0VEOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJ1ZmZlcmVkQW1vdW50OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm9wZW46IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNsb3NlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbm1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGJpbmFyeVR5cGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNlbmQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGV4dGVuc2lvbnM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHByb3RvY29sOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnV2ViU29ja2V0JyxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdlYlNvY2tldCwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnNcbn0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZ1xuKVxuXG53ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gVikge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG59XG5cbi8vIFRoaXMgaW1wbGVtZW50cyB0aGUgcHJvcG9zYWwgbWFkZSBpbiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3dlYnNvY2tldHMvaXNzdWVzLzQyXG53ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAncHJvdG9jb2xzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IEFycmF5KDApXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGdldEdsb2JhbERpc3BhdGNoZXIoKVxuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQpXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0J10gPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0SW5pdChWKVxuICB9XG5cbiAgcmV0dXJuIHsgcHJvdG9jb2xzOiB3ZWJpZGwuY29udmVydGVyc1snRE9NU3RyaW5nIG9yIHNlcXVlbmNlPERPTVN0cmluZz4nXShWKSB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldFNlbmREYXRhID0gZnVuY3Rpb24gKFYpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnKSB7XG4gICAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5CbG9iKFYsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoVikgfHwgdHlwZXMuaXNBcnJheUJ1ZmZlcihWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoVilcbn1cblxuZnVuY3Rpb24gb25QYXJzZXJEcmFpbiAoKSB7XG4gIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQucmVzdW1lKClcbn1cblxuZnVuY3Rpb24gb25QYXJzZXJFcnJvciAoZXJyKSB7XG4gIGxldCBtZXNzYWdlXG4gIGxldCBjb2RlXG5cbiAgaWYgKGVyciBpbnN0YW5jZW9mIENsb3NlRXZlbnQpIHtcbiAgICBtZXNzYWdlID0gZXJyLnJlYXNvblxuICAgIGNvZGUgPSBlcnIuY29kZVxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZVxuICB9XG5cbiAgZmlyZUV2ZW50KCdlcnJvcicsIHRoaXMsICgpID0+IG5ldyBFcnJvckV2ZW50KCdlcnJvcicsIHsgZXJyb3I6IGVyciwgbWVzc2FnZSB9KSlcblxuICBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24odGhpcywgY29kZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYlNvY2tldFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;